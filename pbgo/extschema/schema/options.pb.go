// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/options.proto

package schema

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf "github.com/golang/protobuf/protoc-gen-go/descriptor"

import strconv "strconv"

import strings "strings"
import reflect "reflect"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ReferenceType
//
// x-displayName: "Reference Type"
// MessageOptions related messages
type ReferenceType int32

const (
	// x-displayName "displayname"
	// This is the reference as defined in schema and stored in db
	FORWARD_REF ReferenceType = 0
	// x-displayName "displayname"
	// This is a runtime maintained mirror side of Forward Reference
	BACK_REF ReferenceType = 1
)

var ReferenceType_name = map[int32]string{
	0: "FORWARD_REF",
	1: "BACK_REF",
}
var ReferenceType_value = map[string]int32{
	"FORWARD_REF": 0,
	"BACK_REF":    1,
}

func (ReferenceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorOptions, []int{0} }

// KeyType
//
// x-displayName "keytype"
// Type of keys on an Object
type KeyType int32

const (
	// x-displayName "displayname"
	// Primary key is the default
	PRIMARY_KEY KeyType = 0
	// x-displayName "displayname"
	// Non unique secondary index
	SECONDARY_KEY KeyType = 1
	// x-displayName "displayname"
	// Unique secondary index
	SECONDARY_KEY_UNIQUE KeyType = 2
)

var KeyType_name = map[int32]string{
	0: "PRIMARY_KEY",
	1: "SECONDARY_KEY",
	2: "SECONDARY_KEY_UNIQUE",
}
var KeyType_value = map[string]int32{
	"PRIMARY_KEY":          0,
	"SECONDARY_KEY":        1,
	"SECONDARY_KEY_UNIQUE": 2,
}

func (KeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorOptions, []int{1} }

// MetricType
//
// x-displayName "displayname"
// Types of metrics
type MetricType int32

const (
	// x-displayName "displayname"
	// Invalid metric type
	UNSPECIFIED MetricType = 0
	// x-displayName "displayname"
	// Gauge metric type
	GAUGE MetricType = 1
	// x-displayName "displayname"
	// Counter metric type
	COUNTER MetricType = 2
	// x-displayName "displayname"
	// Histogram metric type
	HISTOGRAM MetricType = 3
	// x-displayName "displayname"
	// Summary metric type
	SUMMARY MetricType = 4
)

var MetricType_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "GAUGE",
	2: "COUNTER",
	3: "HISTOGRAM",
	4: "SUMMARY",
}
var MetricType_value = map[string]int32{
	"UNSPECIFIED": 0,
	"GAUGE":       1,
	"COUNTER":     2,
	"HISTOGRAM":   3,
	"SUMMARY":     4,
}

func (MetricType) EnumDescriptor() ([]byte, []int) { return fileDescriptorOptions, []int{2} }

// ServiceType
//
// x-displayName "displayname"
// Type of protobuf service on configuration or operational Object
type ServiceType int32

const (
	// x-displayName "displayname"
	// CUSTOM is DEPRECATED by CUSTOM_PUBLIC
	CUSTOM ServiceType = 0
	// x-displayName "displayname"
	// AUTO_CRUD is external private API for CRUD operations
	AUTO_CRUD ServiceType = 1
	// x-displayName "displayname"
	// AUTO_CRUD is external public API for CRUD operations
	AUTO_CRUD_PUBLIC ServiceType = 2
	// x-displayName "displayname"
	// CUSTOM_PUBLIC is external public API for custom operations
	CUSTOM_PUBLIC ServiceType = 3
	// x-displayName "displayname"
	// CUSTOM_PRIVATE is external private API for custom operations
	CUSTOM_PRIVATE ServiceType = 4
)

var ServiceType_name = map[int32]string{
	0: "CUSTOM",
	1: "AUTO_CRUD",
	2: "AUTO_CRUD_PUBLIC",
	3: "CUSTOM_PUBLIC",
	4: "CUSTOM_PRIVATE",
}
var ServiceType_value = map[string]int32{
	"CUSTOM":           0,
	"AUTO_CRUD":        1,
	"AUTO_CRUD_PUBLIC": 2,
	"CUSTOM_PUBLIC":    3,
	"CUSTOM_PRIVATE":   4,
}

func (ServiceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorOptions, []int{3} }

// Via
//
// x-displayName: "Via"
// This message option is used with On to specify the spans of a path
// leading from an object type (say virtual_network) to its dependent
// object types (say interface, route)
type Via struct {
	// type
	//
	// x-displayName: "Type"
	// dependency is on the remote object type
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// field_path
	//
	// x-displayName: "Field Path"
	// based on the specified field_path
	FieldPath string `protobuf:"bytes,2,opt,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	// ref_type
	//
	// x-displayName: "Reference Type"
	// whether the traversal is forward (reference field is defined in this
	// Object's definition) or reverse (reference field is defined in the
	// remote Object's definition)
	RefType ReferenceType `protobuf:"varint,3,opt,name=ref_type,json=refType,proto3,enum=ves.io.schema.ReferenceType" json:"ref_type,omitempty"`
}

func (m *Via) Reset()                    { *m = Via{} }
func (*Via) ProtoMessage()               {}
func (*Via) Descriptor() ([]byte, []int) { return fileDescriptorOptions, []int{0} }

func (m *Via) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Via) GetFieldPath() string {
	if m != nil {
		return m.FieldPath
	}
	return ""
}

func (m *Via) GetRefType() ReferenceType {
	if m != nil {
		return m.RefType
	}
	return FORWARD_REF
}

// On
//
// x-displayName: "On"
// This message option is used in Dependencies to indicate which other
// object types an object type is dependent upon for correct functioning.
type On struct {
	// type
	//
	// x-displayName: "Type"
	// This is the dependent object type which when updated we need to
	// react upon
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// via
	//
	// x-displayName: "Via"
	// This is the set of spans to walk to reach the dependent object type
	// specified by type
	Via []*Via `protobuf:"bytes,2,rep,name=via" json:"via,omitempty"`
}

func (m *On) Reset()                    { *m = On{} }
func (*On) ProtoMessage()               {}
func (*On) Descriptor() ([]byte, []int) { return fileDescriptorOptions, []int{1} }

func (m *On) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *On) GetVia() []*Via {
	if m != nil {
		return m.Via
	}
	return nil
}

// Dependencies
//
// x-displayName: "Dependencies"
// This message option is used to indicate an object-type is dependent
// (i.e. needs to be re-evaluated) based on updates to another object-type.
// For example a virtual_network object definition may use this option to
// indicate that notification has to be issued when an interface object
// undergoes change. This is specific to the daemon implementation and
// should be used on the 'Object' message definition at the service's repo
// schema directory.
type Dependencies struct {
	// on
	//
	// x-displayName: "On"
	// This encodes the set of dependent object types and paths leading to them
	On []*On `protobuf:"bytes,1,rep,name=on" json:"on,omitempty"`
}

func (m *Dependencies) Reset()                    { *m = Dependencies{} }
func (*Dependencies) ProtoMessage()               {}
func (*Dependencies) Descriptor() ([]byte, []int) { return fileDescriptorOptions, []int{2} }

func (m *Dependencies) GetOn() []*On {
	if m != nil {
		return m.On
	}
	return nil
}

// Key
//
// x-displayName "key"
// Shape of key
type Key struct {
	// Field path
	//
	// x-displayName "Field path"
	// Field Path
	FieldPath string `protobuf:"bytes,1,opt,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	// Key
	//
	// x-displayName "Key"
	// Key
	Type KeyType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.KeyType" json:"type,omitempty"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptorOptions, []int{3} }

func (m *Key) GetFieldPath() string {
	if m != nil {
		return m.FieldPath
	}
	return ""
}

func (m *Key) GetType() KeyType {
	if m != nil {
		return m.Type
	}
	return PRIMARY_KEY
}

// Keys
//
// x-displayName "keys"
// Shape of keys
type Keys struct {
	// list of Keys
	//
	// x-displayName "Keys"
	// Keys
	Keys []*Key `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *Keys) Reset()                    { *m = Keys{} }
func (*Keys) ProtoMessage()               {}
func (*Keys) Descriptor() ([]byte, []int) { return fileDescriptorOptions, []int{4} }

func (m *Keys) GetKeys() []*Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
type MetricDef struct {
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// name of the metric
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Human readable description of the metric
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Describes what type of metric this is.
	Type MetricType `protobuf:"varint,3,opt,name=type,proto3,enum=ves.io.schema.MetricType" json:"type,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Label configuration to use
	Labels []string `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Buckets to use for histogram
	Buckets []float64 `protobuf:"fixed64,5,rep,packed,name=buckets" json:"buckets,omitempty"`
}

func (m *MetricDef) Reset()                    { *m = MetricDef{} }
func (*MetricDef) ProtoMessage()               {}
func (*MetricDef) Descriptor() ([]byte, []int) { return fileDescriptorOptions, []int{5} }

func (m *MetricDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDef) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDef) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return UNSPECIFIED
}

func (m *MetricDef) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *MetricDef) GetBuckets() []float64 {
	if m != nil {
		return m.Buckets
	}
	return nil
}

var E_Dependencies = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*Dependencies)(nil),
	Field:         1000,
	Name:          "ves.io.schema.dependencies",
	Tag:           "bytes,1000,opt,name=dependencies",
	Filename:      "ves.io/schema/options.proto",
}

var E_MapsToMsg = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1001,
	Name:          "ves.io.schema.maps_to_msg",
	Tag:           "bytes,1001,opt,name=maps_to_msg,json=mapsToMsg",
	Filename:      "ves.io/schema/options.proto",
}

var E_MapsToSvc = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1003,
	Name:          "ves.io.schema.maps_to_svc",
	Tag:           "bytes,1003,opt,name=maps_to_svc,json=mapsToSvc",
	Filename:      "ves.io/schema/options.proto",
}

var E_Keys = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*Keys)(nil),
	Field:         1002,
	Name:          "ves.io.schema.keys",
	Tag:           "bytes,1002,opt,name=keys",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsMsgConfidential = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         1004,
	Name:          "ves.io.schema.is_msg_confidential",
	Tag:           "varint,1004,opt,name=is_msg_confidential,json=isMsgConfidential",
	Filename:      "ves.io/schema/options.proto",
}

var E_GetSpecNotCreateSpecSuperset = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         1005,
	Name:          "ves.io.schema.get_spec_not_create_spec_superset",
	Tag:           "varint,1005,opt,name=get_spec_not_create_spec_superset,json=getSpecNotCreateSpecSuperset",
	Filename:      "ves.io/schema/options.proto",
}

var E_DisplayOrder = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1006,
	Name:          "ves.io.schema.display_order",
	Tag:           "bytes,1006,opt,name=display_order,json=displayOrder",
	Filename:      "ves.io/schema/options.proto",
}

var E_GeneratePrivateApiMethods = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1007,
	Name:          "ves.io.schema.generate_private_api_methods",
	Tag:           "bytes,1007,opt,name=generate_private_api_methods,json=generatePrivateApiMethods",
	Filename:      "ves.io/schema/options.proto",
}

var E_InNamespaceTypes = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1008,
	Name:          "ves.io.schema.in_namespace_types",
	Tag:           "bytes,1008,opt,name=in_namespace_types,json=inNamespaceTypes",
	Filename:      "ves.io/schema/options.proto",
}

var E_GeneratePublicCrud = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FileOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         1000,
	Name:          "ves.io.schema.generate_public_crud",
	Tag:           "varint,1000,opt,name=generate_public_crud,json=generatePublicCrud",
	Filename:      "ves.io/schema/options.proto",
}

var E_GeneratePublicApiMethods = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FileOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1001,
	Name:          "ves.io.schema.generate_public_api_methods",
	Tag:           "bytes,1001,opt,name=generate_public_api_methods,json=generatePublicApiMethods",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsPkey = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2000,
	Name:          "ves.io.schema.is_pkey",
	Tag:           "varint,2000,opt,name=is_pkey,json=isPkey",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsSkeyUniq = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2001,
	Name:          "ves.io.schema.is_skey_uniq",
	Tag:           "varint,2001,opt,name=is_skey_uniq,json=isSkeyUniq",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsSkey = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2002,
	Name:          "ves.io.schema.is_skey",
	Tag:           "varint,2002,opt,name=is_skey,json=isSkey",
	Filename:      "ves.io/schema/options.proto",
}

var E_MapsToField = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         2003,
	Name:          "ves.io.schema.maps_to_field",
	Tag:           "bytes,2003,opt,name=maps_to_field,json=mapsToField",
	Filename:      "ves.io/schema/options.proto",
}

var E_Metric = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*MetricDef)(nil),
	Field:         2004,
	Name:          "ves.io.schema.metric",
	Tag:           "bytes,2004,opt,name=metric",
	Filename:      "ves.io/schema/options.proto",
}

var E_RefTo = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         2005,
	Name:          "ves.io.schema.ref_to",
	Tag:           "bytes,2005,opt,name=ref_to,json=refTo",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsRefSecondary = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2006,
	Name:          "ves.io.schema.is_ref_secondary",
	Tag:           "varint,2006,opt,name=is_ref_secondary,json=isRefSecondary",
	Filename:      "ves.io/schema/options.proto",
}

var E_LabelSelectorObjectKind = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         2007,
	Name:          "ves.io.schema.label_selector_object_kind",
	Tag:           "bytes,2007,opt,name=label_selector_object_kind,json=labelSelectorObjectKind",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsObject = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2008,
	Name:          "ves.io.schema.is_object",
	Tag:           "varint,2008,opt,name=is_object,json=isObject",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsFieldConfidential = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2009,
	Name:          "ves.io.schema.is_field_confidential",
	Tag:           "varint,2009,opt,name=is_field_confidential,json=isFieldConfidential",
	Filename:      "ves.io/schema/options.proto",
}

var E_GenerateSetter = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2010,
	Name:          "ves.io.schema.generate_setter",
	Tag:           "varint,2010,opt,name=generate_setter,json=generateSetter",
	Filename:      "ves.io/schema/options.proto",
}

var E_Internal = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2011,
	Name:          "ves.io.schema.internal",
	Tag:           "varint,2011,opt,name=internal",
	Filename:      "ves.io/schema/options.proto",
}

var E_ServiceType = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.ServiceOptions)(nil),
	ExtensionType: (*ServiceType)(nil),
	Field:         3000,
	Name:          "ves.io.schema.service_type",
	Tag:           "varint,3000,opt,name=service_type,json=serviceType,enum=ves.io.schema.ServiceType",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsSdro = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.ServiceOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         3001,
	Name:          "ves.io.schema.is_sdro",
	Tag:           "varint,3001,opt,name=is_sdro,json=isSdro",
	Filename:      "ves.io/schema/options.proto",
}

var E_ObjectType = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.ServiceOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         3002,
	Name:          "ves.io.schema.object_type",
	Tag:           "bytes,3002,opt,name=object_type,json=objectType",
	Filename:      "ves.io/schema/options.proto",
}

var E_HasStatus = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.ServiceOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         3003,
	Name:          "ves.io.schema.has_status",
	Tag:           "varint,3003,opt,name=has_status,json=hasStatus",
	Filename:      "ves.io/schema/options.proto",
}

var E_ObjectStatusType = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.ServiceOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         3004,
	Name:          "ves.io.schema.object_status_type",
	Tag:           "bytes,3004,opt,name=object_status_type,json=objectStatusType",
	Filename:      "ves.io/schema/options.proto",
}

var E_MapsToOneofField = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.OneofOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         4000,
	Name:          "ves.io.schema.maps_to_oneof_field",
	Tag:           "bytes,4000,opt,name=maps_to_oneof_field,json=mapsToOneofField",
	Filename:      "ves.io/schema/options.proto",
}

var E_InternalEnum = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.EnumValueOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2000,
	Name:          "ves.io.schema.internal_enum",
	Tag:           "varint,2000,opt,name=internal_enum,json=internalEnum",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsImmutable = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MethodOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         5001,
	Name:          "ves.io.schema.is_immutable",
	Tag:           "varint,5001,opt,name=is_immutable,json=isImmutable",
	Filename:      "ves.io/schema/options.proto",
}

func init() {
	proto.RegisterType((*Via)(nil), "ves.io.schema.Via")
	proto.RegisterType((*On)(nil), "ves.io.schema.On")
	proto.RegisterType((*Dependencies)(nil), "ves.io.schema.Dependencies")
	proto.RegisterType((*Key)(nil), "ves.io.schema.Key")
	proto.RegisterType((*Keys)(nil), "ves.io.schema.Keys")
	proto.RegisterType((*MetricDef)(nil), "ves.io.schema.MetricDef")
	proto.RegisterEnum("ves.io.schema.ReferenceType", ReferenceType_name, ReferenceType_value)
	proto.RegisterEnum("ves.io.schema.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("ves.io.schema.MetricType", MetricType_name, MetricType_value)
	proto.RegisterEnum("ves.io.schema.ServiceType", ServiceType_name, ServiceType_value)
	proto.RegisterExtension(E_Dependencies)
	proto.RegisterExtension(E_MapsToMsg)
	proto.RegisterExtension(E_MapsToSvc)
	proto.RegisterExtension(E_Keys)
	proto.RegisterExtension(E_IsMsgConfidential)
	proto.RegisterExtension(E_GetSpecNotCreateSpecSuperset)
	proto.RegisterExtension(E_DisplayOrder)
	proto.RegisterExtension(E_GeneratePrivateApiMethods)
	proto.RegisterExtension(E_InNamespaceTypes)
	proto.RegisterExtension(E_GeneratePublicCrud)
	proto.RegisterExtension(E_GeneratePublicApiMethods)
	proto.RegisterExtension(E_IsPkey)
	proto.RegisterExtension(E_IsSkeyUniq)
	proto.RegisterExtension(E_IsSkey)
	proto.RegisterExtension(E_MapsToField)
	proto.RegisterExtension(E_Metric)
	proto.RegisterExtension(E_RefTo)
	proto.RegisterExtension(E_IsRefSecondary)
	proto.RegisterExtension(E_LabelSelectorObjectKind)
	proto.RegisterExtension(E_IsObject)
	proto.RegisterExtension(E_IsFieldConfidential)
	proto.RegisterExtension(E_GenerateSetter)
	proto.RegisterExtension(E_Internal)
	proto.RegisterExtension(E_ServiceType)
	proto.RegisterExtension(E_IsSdro)
	proto.RegisterExtension(E_ObjectType)
	proto.RegisterExtension(E_HasStatus)
	proto.RegisterExtension(E_ObjectStatusType)
	proto.RegisterExtension(E_MapsToOneofField)
	proto.RegisterExtension(E_InternalEnum)
	proto.RegisterExtension(E_IsImmutable)
}
func (x ReferenceType) String() string {
	s, ok := ReferenceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x KeyType) String() string {
	s, ok := KeyType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MetricType) String() string {
	s, ok := MetricType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ServiceType) String() string {
	s, ok := ServiceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Via) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Via)
	if !ok {
		that2, ok := that.(Via)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.FieldPath != that1.FieldPath {
		return false
	}
	if this.RefType != that1.RefType {
		return false
	}
	return true
}
func (this *On) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*On)
	if !ok {
		that2, ok := that.(On)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Via) != len(that1.Via) {
		return false
	}
	for i := range this.Via {
		if !this.Via[i].Equal(that1.Via[i]) {
			return false
		}
	}
	return true
}
func (this *Dependencies) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Dependencies)
	if !ok {
		that2, ok := that.(Dependencies)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.On) != len(that1.On) {
		return false
	}
	for i := range this.On {
		if !this.On[i].Equal(that1.On[i]) {
			return false
		}
	}
	return true
}
func (this *Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Key)
	if !ok {
		that2, ok := that.(Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FieldPath != that1.FieldPath {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Keys) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Keys)
	if !ok {
		that2, ok := that.(Keys)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if !this.Keys[i].Equal(that1.Keys[i]) {
			return false
		}
	}
	return true
}
func (this *MetricDef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricDef)
	if !ok {
		that2, ok := that.(MetricDef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Buckets) != len(that1.Buckets) {
		return false
	}
	for i := range this.Buckets {
		if this.Buckets[i] != that1.Buckets[i] {
			return false
		}
	}
	return true
}
func (this *Via) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.Via{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "FieldPath: "+fmt.Sprintf("%#v", this.FieldPath)+",\n")
	s = append(s, "RefType: "+fmt.Sprintf("%#v", this.RefType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *On) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.On{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Via != nil {
		s = append(s, "Via: "+fmt.Sprintf("%#v", this.Via)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Dependencies) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.Dependencies{")
	if this.On != nil {
		s = append(s, "On: "+fmt.Sprintf("%#v", this.On)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Key{")
	s = append(s, "FieldPath: "+fmt.Sprintf("%#v", this.FieldPath)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Keys) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.Keys{")
	if this.Keys != nil {
		s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricDef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.MetricDef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	s = append(s, "Buckets: "+fmt.Sprintf("%#v", this.Buckets)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringOptions(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Via) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Via) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FieldPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOptions(dAtA, i, uint64(len(m.FieldPath)))
		i += copy(dAtA[i:], m.FieldPath)
	}
	if m.RefType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOptions(dAtA, i, uint64(m.RefType))
	}
	return i, nil
}

func (m *On) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *On) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Via) > 0 {
		for _, msg := range m.Via {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOptions(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Dependencies) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dependencies) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.On) > 0 {
		for _, msg := range m.On {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOptions(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Key) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Key) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOptions(dAtA, i, uint64(len(m.FieldPath)))
		i += copy(dAtA[i:], m.FieldPath)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOptions(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *Keys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keys) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOptions(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MetricDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOptions(dAtA, i, uint64(m.Type))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Buckets) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Buckets)*8))
		for _, num := range m.Buckets {
			f1 := math.Float64bits(float64(num))
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
			i += 8
		}
	}
	return i, nil
}

func encodeVarintOptions(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Via) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.FieldPath)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.RefType != 0 {
		n += 1 + sovOptions(uint64(m.RefType))
	}
	return n
}

func (m *On) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if len(m.Via) > 0 {
		for _, e := range m.Via {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	return n
}

func (m *Dependencies) Size() (n int) {
	var l int
	_ = l
	if len(m.On) > 0 {
		for _, e := range m.On {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	return n
}

func (m *Key) Size() (n int) {
	var l int
	_ = l
	l = len(m.FieldPath)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovOptions(uint64(m.Type))
	}
	return n
}

func (m *Keys) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	return n
}

func (m *MetricDef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovOptions(uint64(m.Type))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	if len(m.Buckets) > 0 {
		n += 1 + sovOptions(uint64(len(m.Buckets)*8)) + len(m.Buckets)*8
	}
	return n
}

func sovOptions(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOptions(x uint64) (n int) {
	return sovOptions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Via) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Via{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`FieldPath:` + fmt.Sprintf("%v", this.FieldPath) + `,`,
		`RefType:` + fmt.Sprintf("%v", this.RefType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *On) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&On{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Via:` + strings.Replace(fmt.Sprintf("%v", this.Via), "Via", "Via", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Dependencies) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Dependencies{`,
		`On:` + strings.Replace(fmt.Sprintf("%v", this.On), "On", "On", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Key{`,
		`FieldPath:` + fmt.Sprintf("%v", this.FieldPath) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Keys) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Keys{`,
		`Keys:` + strings.Replace(fmt.Sprintf("%v", this.Keys), "Key", "Key", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricDef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricDef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Labels:` + fmt.Sprintf("%v", this.Labels) + `,`,
		`Buckets:` + fmt.Sprintf("%v", this.Buckets) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringOptions(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Via) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Via: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Via: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefType", wireType)
			}
			m.RefType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefType |= (ReferenceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *On) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: On: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: On: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Via", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Via = append(m.Via, &Via{})
			if err := m.Via[len(m.Via)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dependencies) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dependencies: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dependencies: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field On", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.On = append(m.On, &On{})
			if err := m.On[len(m.On)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Key) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Key: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Key: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (KeyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &Key{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MetricType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Buckets = append(m.Buckets, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOptions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOptions
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Buckets = append(m.Buckets, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOptions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOptions
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOptions
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOptions(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOptions = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOptions   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/options.proto", fileDescriptorOptions) }

var fileDescriptorOptions = []byte{
	// 1446 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x97, 0xdd, 0x6e, 0xdb, 0x46,
	0x16, 0xc7, 0x45, 0xc9, 0xb1, 0xad, 0x23, 0x3b, 0x66, 0xe8, 0x6c, 0xac, 0x38, 0x5e, 0x45, 0x31,
	0x16, 0xbb, 0x86, 0x01, 0xcb, 0xd8, 0x2c, 0x16, 0xc1, 0x72, 0x81, 0xdd, 0xc8, 0xb2, 0xec, 0x08,
	0x5e, 0x59, 0x0a, 0x65, 0x79, 0x91, 0xb6, 0x00, 0x41, 0x91, 0x47, 0xf2, 0x54, 0x12, 0x87, 0xe1,
	0x90, 0x42, 0x75, 0xd7, 0xdb, 0xde, 0xf5, 0x11, 0x8a, 0x5e, 0xf5, 0x11, 0xfa, 0xf5, 0x00, 0xbd,
	0x4c, 0xbf, 0xd3, 0xf6, 0xa6, 0x51, 0x6f, 0xd2, 0xef, 0x3c, 0x42, 0xc1, 0x19, 0xd2, 0x96, 0x64,
	0xb7, 0xf4, 0x95, 0x38, 0x1f, 0xff, 0xdf, 0xfc, 0xcf, 0xcc, 0x9c, 0x33, 0x36, 0xdc, 0x1a, 0x20,
	0x2b, 0x10, 0xba, 0xcd, 0xcc, 0x13, 0xec, 0x1b, 0xdb, 0xd4, 0xf1, 0x08, 0xb5, 0x59, 0xc1, 0x71,
	0xa9, 0x47, 0x95, 0x45, 0x31, 0x58, 0x10, 0x83, 0xab, 0x5b, 0x1d, 0xe2, 0x9d, 0xf8, 0xad, 0x82,
	0x49, 0xfb, 0xdb, 0x1d, 0xda, 0xa1, 0xdb, 0x7c, 0x56, 0xcb, 0x6f, 0xf3, 0x16, 0x6f, 0xf0, 0x2f,
	0xa1, 0x5e, 0xcd, 0x77, 0x28, 0xed, 0xf4, 0xf0, 0x6c, 0x96, 0x85, 0xcc, 0x74, 0x89, 0xe3, 0x51,
	0x57, 0xcc, 0x58, 0x7f, 0x0c, 0xa9, 0x63, 0x62, 0x28, 0x0a, 0xcc, 0x78, 0x43, 0x07, 0xb3, 0x52,
	0x5e, 0xda, 0x48, 0x6b, 0xfc, 0x5b, 0xf9, 0x33, 0x40, 0x9b, 0x60, 0xcf, 0xd2, 0x1d, 0xc3, 0x3b,
	0xc9, 0x26, 0xf9, 0x48, 0x9a, 0xf7, 0xd4, 0x0d, 0xef, 0x44, 0xb9, 0x07, 0xf3, 0x2e, 0xb6, 0x75,
	0x2e, 0x4b, 0xe5, 0xa5, 0x8d, 0xab, 0x77, 0xd7, 0x0a, 0x13, 0x66, 0x0b, 0x1a, 0xb6, 0xd1, 0x45,
	0xdb, 0xc4, 0xa3, 0xa1, 0x83, 0xda, 0x9c, 0x8b, 0xed, 0xe0, 0x63, 0xfd, 0x3f, 0x90, 0xac, 0xd9,
	0x17, 0xae, 0xf8, 0x17, 0x48, 0x0d, 0x88, 0x91, 0x4d, 0xe6, 0x53, 0x1b, 0x99, 0xbb, 0xca, 0x14,
	0xed, 0x98, 0x18, 0x5a, 0x30, 0xbc, 0xfe, 0x77, 0x58, 0xd8, 0x45, 0x07, 0x6d, 0x0b, 0x6d, 0x93,
	0x20, 0x53, 0xee, 0x40, 0x92, 0xda, 0x59, 0x89, 0x8b, 0xae, 0x4d, 0x89, 0x6a, 0xb6, 0x96, 0xa4,
	0xf6, 0x7a, 0x1d, 0x52, 0x07, 0x38, 0x9c, 0x8a, 0x48, 0x9a, 0x8e, 0x68, 0x33, 0xb4, 0x94, 0xe4,
	0xd1, 0xdc, 0x98, 0x42, 0x1d, 0xe0, 0x90, 0xc7, 0xc1, 0xe7, 0xac, 0x17, 0x60, 0xe6, 0x00, 0x87,
	0x4c, 0xf9, 0x2b, 0xcc, 0x74, 0x71, 0xc8, 0xc2, 0xe5, 0x95, 0xf3, 0x1a, 0x8d, 0x8f, 0xaf, 0xbf,
	0x2d, 0x41, 0xba, 0x8a, 0x9e, 0x4b, 0xcc, 0x5d, 0x6c, 0x07, 0xc1, 0xdb, 0x46, 0xff, 0x34, 0xf8,
	0xe0, 0x5b, 0xc9, 0x43, 0x26, 0x3a, 0x1d, 0x42, 0xed, 0x70, 0xbf, 0xc7, 0xbb, 0x94, 0xad, 0xd0,
	0x9f, 0xd8, 0xed, 0x9b, 0x53, 0x6b, 0x09, 0xfa, 0x99, 0x45, 0xe5, 0x06, 0xcc, 0xf6, 0x8c, 0x16,
	0xf6, 0x58, 0x76, 0x26, 0x9f, 0xda, 0x48, 0x6b, 0x61, 0x4b, 0xc9, 0xc2, 0x5c, 0xcb, 0x37, 0xbb,
	0xe8, 0xb1, 0xec, 0x95, 0x7c, 0x6a, 0x43, 0xd2, 0xa2, 0xe6, 0x66, 0x01, 0x16, 0x27, 0xce, 0x4c,
	0x59, 0x82, 0xcc, 0x5e, 0x4d, 0xfb, 0x7f, 0x51, 0xdb, 0xd5, 0xb5, 0xf2, 0x9e, 0x9c, 0x50, 0x16,
	0x60, 0x7e, 0xa7, 0x58, 0x3a, 0xe0, 0x2d, 0x69, 0x73, 0x1f, 0xe6, 0xc2, 0x5d, 0x09, 0x66, 0xd6,
	0xb5, 0x4a, 0xb5, 0xa8, 0x3d, 0xd2, 0x0f, 0xca, 0x8f, 0xe4, 0x84, 0x72, 0x0d, 0x16, 0x1b, 0xe5,
	0x52, 0xed, 0x70, 0x37, 0xea, 0x92, 0x94, 0x2c, 0x5c, 0x9f, 0xe8, 0xd2, 0x9b, 0x87, 0x95, 0x87,
	0xcd, 0xb2, 0x9c, 0xdc, 0x7c, 0x08, 0x70, 0x66, 0x3f, 0x60, 0x35, 0x0f, 0x1b, 0xf5, 0x72, 0xa9,
	0xb2, 0x57, 0x29, 0xef, 0xca, 0x09, 0x25, 0x0d, 0x57, 0xf6, 0x8b, 0xcd, 0xfd, 0xb2, 0x2c, 0x29,
	0x19, 0x98, 0x2b, 0xd5, 0x9a, 0x87, 0x47, 0x65, 0x4d, 0x4e, 0x2a, 0x8b, 0x90, 0x7e, 0x50, 0x69,
	0x1c, 0xd5, 0xf6, 0xb5, 0x62, 0x55, 0x4e, 0x05, 0x63, 0x8d, 0x66, 0x35, 0xf0, 0x20, 0xcf, 0x6c,
	0x22, 0x64, 0x1a, 0xe8, 0x0e, 0x48, 0x18, 0x09, 0xc0, 0x6c, 0xa9, 0xd9, 0x38, 0xaa, 0x55, 0xe5,
	0x44, 0x20, 0x2b, 0x36, 0x8f, 0x6a, 0x7a, 0x49, 0x6b, 0xee, 0xca, 0x92, 0x72, 0x1d, 0xe4, 0xd3,
	0xa6, 0x5e, 0x6f, 0xee, 0xfc, 0xaf, 0x52, 0x92, 0x93, 0x81, 0x7f, 0x21, 0x88, 0xba, 0x52, 0x8a,
	0x02, 0x57, 0xa3, 0x2e, 0xad, 0x72, 0x5c, 0x3c, 0x2a, 0xcb, 0x33, 0xaa, 0x01, 0x0b, 0xd6, 0xf8,
	0x65, 0xbc, 0x5d, 0x10, 0x29, 0x57, 0x88, 0x52, 0xae, 0x50, 0x45, 0xc6, 0x8c, 0x0e, 0xd6, 0x44,
	0x5a, 0x67, 0x9f, 0xcf, 0xe5, 0xa5, 0x8d, 0xcc, 0xdd, 0x5b, 0x53, 0xa7, 0x37, 0x7e, 0xa3, 0xb5,
	0x09, 0xa4, 0x7a, 0x1f, 0x32, 0x7d, 0xc3, 0x61, 0xba, 0x47, 0xf5, 0x3e, 0xeb, 0xc4, 0xaf, 0xf0,
	0xfd, 0x9c, 0xb8, 0xd8, 0x81, 0xe8, 0x88, 0x56, 0x59, 0x67, 0x9c, 0xc0, 0x06, 0x66, 0x3c, 0xe1,
	0xc7, 0x09, 0x42, 0x63, 0x60, 0xaa, 0x15, 0x71, 0xcd, 0xe3, 0xa5, 0x3f, 0x88, 0xf0, 0x96, 0xcf,
	0x27, 0x02, 0x13, 0x99, 0xa0, 0xd6, 0x61, 0x99, 0xb0, 0x20, 0x12, 0xdd, 0xa4, 0x76, 0x9b, 0x58,
	0x68, 0x7b, 0xc4, 0xe8, 0xc5, 0x93, 0x7f, 0x0a, 0xc8, 0xf3, 0xda, 0x35, 0xc2, 0xaa, 0xac, 0x53,
	0x1a, 0x93, 0xaa, 0x04, 0xee, 0x74, 0xd0, 0xd3, 0x99, 0x83, 0xa6, 0x6e, 0x53, 0x4f, 0x37, 0x5d,
	0x34, 0x3c, 0x14, 0x6d, 0xe6, 0x3b, 0xe8, 0x32, 0xf4, 0xe2, 0xf9, 0x3f, 0x0b, 0xfe, 0x5a, 0x07,
	0xbd, 0x86, 0x83, 0xe6, 0x21, 0xf5, 0x4a, 0x9c, 0x13, 0x34, 0x1a, 0x21, 0x45, 0x2d, 0xc3, 0xa2,
	0x45, 0x98, 0xd3, 0x33, 0x86, 0x3a, 0x75, 0x2d, 0x74, 0xe3, 0xb1, 0xbf, 0x88, 0xbd, 0x5c, 0x08,
	0x65, 0xb5, 0x40, 0xa5, 0x1a, 0xb0, 0xd6, 0x41, 0x1b, 0xdd, 0xc0, 0xa6, 0xe3, 0x92, 0x41, 0xf0,
	0x6b, 0x38, 0x44, 0xef, 0xa3, 0x77, 0x42, 0xad, 0x4b, 0x6c, 0xf3, 0xaf, 0x82, 0x7a, 0x33, 0xa2,
	0xd4, 0x05, 0xa4, 0xe8, 0x90, 0xaa, 0x40, 0xa8, 0x87, 0xa0, 0x10, 0x5b, 0x0f, 0x2a, 0x0b, 0x73,
	0x0c, 0x13, 0x79, 0x9d, 0xbe, 0x04, 0xf8, 0x85, 0x00, 0xcb, 0xc4, 0x3e, 0x8c, 0xa4, 0x41, 0xfe,
	0x30, 0xb5, 0x06, 0xd7, 0xcf, 0x2c, 0xfb, 0xad, 0x1e, 0x31, 0x75, 0xd3, 0xf5, 0x2d, 0x65, 0xed,
	0x1c, 0x71, 0x8f, 0xf4, 0x26, 0x6f, 0xfb, 0xbc, 0xa6, 0x9c, 0xfa, 0xe4, 0xca, 0x92, 0xeb, 0x5b,
	0xea, 0x2b, 0x70, 0x6b, 0x1a, 0x38, 0xbe, 0x05, 0x7f, 0xcc, 0x0d, 0xef, 0x78, 0x76, 0x92, 0x3b,
	0x16, 0xfe, 0x3d, 0x98, 0x23, 0x4c, 0x77, 0xba, 0x41, 0xd5, 0xbf, 0x80, 0x84, 0x3d, 0x2b, 0x42,
	0x3d, 0x59, 0xe2, 0x16, 0x67, 0x09, 0xab, 0x77, 0x71, 0xa8, 0xde, 0x87, 0x05, 0xc2, 0x74, 0xd6,
	0xc5, 0xa1, 0xee, 0xdb, 0xe4, 0x71, 0x9c, 0xfa, 0x63, 0xa1, 0x06, 0xc2, 0x1a, 0x5d, 0x1c, 0x36,
	0x6d, 0xf2, 0x38, 0x5c, 0x9a, 0x5d, 0x62, 0xe9, 0x4f, 0x4e, 0x97, 0x0e, 0xc4, 0xea, 0x0e, 0x2c,
	0x46, 0x69, 0xca, 0x1f, 0xa5, 0x38, 0xf9, 0xa7, 0x4b, 0xe2, 0x8d, 0x10, 0x69, 0xca, 0x87, 0xd4,
	0x3a, 0xcc, 0xf6, 0x79, 0x25, 0x8d, 0x13, 0x7f, 0xb6, 0xc4, 0x13, 0x35, 0x7b, 0xe1, 0x2b, 0xb2,
	0x8b, 0x6d, 0x2d, 0xe4, 0xa8, 0xff, 0x84, 0x59, 0xfe, 0xce, 0xd3, 0x38, 0xe2, 0xe7, 0xc2, 0xce,
	0x95, 0xe0, 0x9d, 0xa7, 0xea, 0x03, 0x90, 0x09, 0xd3, 0x03, 0x25, 0x43, 0x93, 0xda, 0x96, 0xe1,
	0xc6, 0x6e, 0xc7, 0x17, 0x62, 0x3b, 0xae, 0x12, 0xa6, 0x61, 0xbb, 0x11, 0xa9, 0xd4, 0x97, 0x61,
	0x95, 0xbf, 0x5c, 0x3a, 0xc3, 0x1e, 0x9a, 0x1e, 0x75, 0x75, 0xda, 0x7a, 0x15, 0x4d, 0x4f, 0xef,
	0x12, 0x3b, 0x76, 0x8f, 0xbe, 0x14, 0xa6, 0x56, 0x38, 0xa1, 0x11, 0x02, 0x6a, 0x5c, 0x7f, 0x40,
	0x6c, 0x4b, 0xfd, 0x37, 0xa4, 0x09, 0x0b, 0x81, 0x71, 0xac, 0xa7, 0xc2, 0xdf, 0x3c, 0x61, 0x02,
	0xa0, 0x6a, 0xf0, 0x27, 0xc2, 0xc4, 0x59, 0x4d, 0x16, 0xb3, 0x18, 0xd0, 0x57, 0x02, 0xb4, 0x4c,
	0x18, 0xef, 0x9e, 0x28, 0x66, 0xfb, 0xb0, 0x74, 0x9a, 0x16, 0x0c, 0x3d, 0x0f, 0xdd, 0x38, 0xda,
	0xd7, 0xe1, 0xb6, 0x45, 0xb2, 0x06, 0x57, 0xa9, 0x2a, 0xcc, 0x13, 0xdb, 0x43, 0xd7, 0x8e, 0xf7,
	0xf3, 0x4d, 0x14, 0x58, 0x38, 0x5f, 0xd5, 0x61, 0x81, 0x89, 0xc7, 0x93, 0xd7, 0x8d, 0x0b, 0xca,
	0x46, 0xf8, 0xb6, 0x46, 0x84, 0x77, 0x57, 0xf8, 0xdf, 0x24, 0xab, 0x53, 0xb7, 0x69, 0xec, 0x05,
	0xd6, 0x32, 0xec, 0xac, 0xa1, 0xfe, 0x4b, 0xe4, 0x88, 0xe5, 0xd2, 0x78, 0xf6, 0x7b, 0x2b, 0xa7,
	0x59, 0x62, 0xb9, 0x54, 0x2d, 0x42, 0x26, 0x3c, 0xff, 0xcb, 0x59, 0x7b, 0x7f, 0x85, 0xdf, 0x00,
	0x10, 0x22, 0xbe, 0xfa, 0x7f, 0x01, 0x4e, 0x0c, 0xa6, 0x33, 0xcf, 0xf0, 0x7c, 0x16, 0x4f, 0xf8,
	0x40, 0x18, 0x48, 0x9f, 0x18, 0xac, 0xc1, 0x25, 0x41, 0x71, 0x0d, 0x3d, 0x08, 0xc6, 0x25, 0xad,
	0x7c, 0x28, 0xac, 0xc8, 0x42, 0x2b, 0x58, 0xdc, 0x50, 0x15, 0x96, 0xa3, 0xcc, 0xa7, 0x36, 0xd2,
	0xf6, 0xef, 0xe6, 0x7f, 0x2d, 0x18, 0x8d, 0x70, 0x6f, 0xdd, 0x16, 0x38, 0x91, 0xff, 0x7c, 0x48,
	0x14, 0x81, 0x7d, 0x58, 0x8c, 0x8e, 0x52, 0x47, 0xdb, 0xef, 0x2b, 0x77, 0xce, 0x81, 0xca, 0xb6,
	0xdf, 0x3f, 0x36, 0x7a, 0x3e, 0x4e, 0x95, 0xc1, 0x85, 0x48, 0x18, 0x4c, 0x50, 0x77, 0x78, 0x31,
	0x24, 0xfd, 0xbe, 0xef, 0x19, 0xad, 0x1e, 0x2a, 0xb9, 0x0b, 0x9e, 0x8f, 0xa0, 0xde, 0x46, 0x90,
	0x37, 0xfe, 0xc6, 0x21, 0x19, 0xc2, 0x2a, 0x91, 0x66, 0xc7, 0x7f, 0xf2, 0x2c, 0x97, 0x78, 0xfa,
	0x2c, 0x97, 0x78, 0xf1, 0x2c, 0x27, 0xbd, 0x3e, 0xca, 0x49, 0xef, 0x8c, 0x72, 0xd2, 0x47, 0xa3,
	0x9c, 0xf4, 0x64, 0x94, 0x93, 0x9e, 0x8e, 0x72, 0xd2, 0xb7, 0xa3, 0x9c, 0xf4, 0x7c, 0x94, 0x4b,
	0xbc, 0x18, 0xe5, 0xa4, 0x37, 0xbf, 0xcb, 0x25, 0x5e, 0x2a, 0x75, 0xa8, 0xd3, 0xed, 0x14, 0x06,
	0xb4, 0xe7, 0xa1, 0xeb, 0x1a, 0x05, 0x9f, 0x6d, 0xf3, 0x8f, 0x36, 0x75, 0xfb, 0x5b, 0x8e, 0x4b,
	0x07, 0xc4, 0x42, 0x77, 0x2b, 0x1a, 0xde, 0x76, 0x5a, 0x1d, 0xba, 0x8d, 0xaf, 0x79, 0xe1, 0xff,
	0x4f, 0xe2, 0xa7, 0x35, 0xcb, 0x2d, 0xfe, 0xe3, 0xb7, 0x00, 0x00, 0x00, 0xff, 0xff, 0x20, 0x32,
	0x35, 0x92, 0x5e, 0x0d, 0x00, 0x00,
}

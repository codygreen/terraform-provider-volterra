// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/types.proto

package schema

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf3 "github.com/gogo/protobuf/types"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// HttpMethod
//
// x-displayName: "HTTP Method"
// Specifies the HTTP method used to acess a resource.
type HttpMethod int32

const (
	// x-displayName: "ANY"
	// Any HTTP Method
	ANY HttpMethod = 0
	// x-displayName: "GET"
	// GET method
	GET HttpMethod = 1
	// x-displayName: "HEAD"
	// HEAD method
	HEAD HttpMethod = 2
	// x-displayName: "POST"
	// POST method
	POST HttpMethod = 3
	// x-displayName: "PUT"
	// PUT method
	PUT HttpMethod = 4
	// x-displayName: "DELETE"
	// DELETE method
	DELETE HttpMethod = 5
	// x-displayName: "CONNECT"
	// CONNECT method
	CONNECT HttpMethod = 6
	// x-displayName: "OPTIONS"
	// OPTIONS method
	OPTIONS HttpMethod = 7
	// x-displayName: "TRACE"
	// TRACE method
	TRACE HttpMethod = 8
	// x-displayName: "PATCH"
	// PATCH method
	PATCH HttpMethod = 9
)

var HttpMethod_name = map[int32]string{
	0: "ANY",
	1: "GET",
	2: "HEAD",
	3: "POST",
	4: "PUT",
	5: "DELETE",
	6: "CONNECT",
	7: "OPTIONS",
	8: "TRACE",
	9: "PATCH",
}
var HttpMethod_value = map[string]int32{
	"ANY":     0,
	"GET":     1,
	"HEAD":    2,
	"POST":    3,
	"PUT":     4,
	"DELETE":  5,
	"CONNECT": 6,
	"OPTIONS": 7,
	"TRACE":   8,
	"PATCH":   9,
}

func (HttpMethod) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// StatusPublishType
//
// x-displayName: "Publish"
// StatusPublishType is all possible publish operations on a StatusObject
type StatusPublishType int32

const (
	// Do not propagate this status to user. This could be because status is only informational
	STATUS_DO_NOT_PUBLISH StatusPublishType = 0
	// Propagate this status up to user as it might be actionable
	STATUS_PUBLISH StatusPublishType = 1
)

var StatusPublishType_name = map[int32]string{
	0: "STATUS_DO_NOT_PUBLISH",
	1: "STATUS_PUBLISH",
}
var StatusPublishType_value = map[string]int32{
	"STATUS_DO_NOT_PUBLISH": 0,
	"STATUS_PUBLISH":        1,
}

func (StatusPublishType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// SecretEncodingType
//
// x-displayName: "Secret Encoding"
// SecretEncodingType defines the encoding type of the secret before handled by the Secret Management Service.
type SecretEncodingType int32

const (
	// x-displayName: "None"
	// No Encoding
	EncodingNone SecretEncodingType = 0
	// Base64
	//
	// x-displayName: "Base64"
	// Base64 encoding
	EncodingBase64 SecretEncodingType = 1
)

var SecretEncodingType_name = map[int32]string{
	0: "EncodingNone",
	1: "EncodingBase64",
}
var SecretEncodingType_value = map[string]int32{
	"EncodingNone":   0,
	"EncodingBase64": 1,
}

func (SecretEncodingType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// URLSchemeType
//
// x-displayName: "URL Scheme"
// SchemeType is used to indicate URL scheme
type URLSchemeType int32

const (
	// x-displayName: "HTTP"
	// http:// scheme
	HTTP URLSchemeType = 0
	// x-displayName: "HTTPS"
	// https:// scheme
	HTTPS URLSchemeType = 1
)

var URLSchemeType_name = map[int32]string{
	0: "HTTP",
	1: "HTTPS",
}
var URLSchemeType_value = map[string]int32{
	"HTTP":  0,
	"HTTPS": 1,
}

func (URLSchemeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// TlsProtocol
//
// x-displayName: "TLS Protocol"
// TlsProtocol is enumeration of supported TLS versions
type TlsProtocol int32

const (
	// x-displayName: "Automatic"
	// Volterra will choose the optimal TLS version.
	TLS_AUTO TlsProtocol = 0
	// x-displayName: "TLSv1.0"
	// TLS 1.0
	TLSv1_0 TlsProtocol = 1
	// x-displayName: "TLSv1.1"
	// TLS 1.1
	TLSv1_1 TlsProtocol = 2
	// x-displayName: "TLSv1.2"
	// TLS 1.2
	TLSv1_2 TlsProtocol = 3
	// x-displayName: "TLSv1.3"
	// TLS 1.3
	TLSv1_3 TlsProtocol = 4
)

var TlsProtocol_name = map[int32]string{
	0: "TLS_AUTO",
	1: "TLSv1_0",
	2: "TLSv1_1",
	3: "TLSv1_2",
	4: "TLSv1_3",
}
var TlsProtocol_value = map[string]int32{
	"TLS_AUTO": 0,
	"TLSv1_0":  1,
	"TLSv1_1":  2,
	"TLSv1_2":  3,
	"TLSv1_3":  4,
}

func (TlsProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

// RoutingPriority
//
// x-displayName: "Routing Priority"
// Priority routing for each request.
// Different connection pools are used based on the priority selected for the request.
// Also, circuit-breaker configuration at destination cluster is chosen based on selected priority.
type RoutingPriority int32

const (
	// x-displayName: "Default"
	// Default routing mechanism
	DEFAULT RoutingPriority = 0
	// x-displayName: "High-Priority"
	// High-Priority routing mechanism
	HIGH RoutingPriority = 1
)

var RoutingPriority_name = map[int32]string{
	0: "DEFAULT",
	1: "HIGH",
}
var RoutingPriority_value = map[string]int32{
	"DEFAULT": 0,
	"HIGH":    1,
}

func (RoutingPriority) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

// DenominatorType
//
// x-displayName: "Denominator"
// Denominator used in fraction where sampling percentages are needed. example sampled requests
type DenominatorType int32

const (
	// x-displayName: "100"
	// Use hundred as denominator
	HUNDRED DenominatorType = 0
	// x-displayName: "10000"
	// Use ten thousand as denominator
	TEN_THOUSAND DenominatorType = 1
	// x-displayName: "1000000"
	// Use million as denominator
	MILLION DenominatorType = 2
)

var DenominatorType_name = map[int32]string{
	0: "HUNDRED",
	1: "TEN_THOUSAND",
	2: "MILLION",
}
var DenominatorType_value = map[string]int32{
	"HUNDRED":      0,
	"TEN_THOUSAND": 1,
	"MILLION":      2,
}

func (DenominatorType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

// DiscoveryType
//
// x-displayName: "Discovery Type"
// Specifies whether the discovery is from Kubernetes or Consul cluster
type DiscoveryType int32

const (
	// x-displayName: "INVALID"
	// Invalid Discovery mechanism
	INVALID_DISCOVERY DiscoveryType = 0
	// x-displayName: "Kubernetes"
	// Discover from Kubernetes cluster
	K8S DiscoveryType = 1
	// x-displayName: "HashiCorp Consul"
	// Discover from Consul service
	CONSUL DiscoveryType = 2
)

var DiscoveryType_name = map[int32]string{
	0: "INVALID_DISCOVERY",
	1: "K8S",
	2: "CONSUL",
}
var DiscoveryType_value = map[string]int32{
	"INVALID_DISCOVERY": 0,
	"K8S":               1,
	"CONSUL":            2,
}

func (DiscoveryType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

// WafModeType
//
// x-displayName: "WAF Mode"
// The mode of operation for Web Application Firewall
type WafModeType int32

const (
	// x-displayName: "Block"
	// Block on detection
	BLOCK WafModeType = 0
	// x-displayName: "Alert"
	// Only raise alert on detection
	ALERT_ONLY WafModeType = 1
)

var WafModeType_name = map[int32]string{
	0: "BLOCK",
	1: "ALERT_ONLY",
}
var WafModeType_value = map[string]int32{
	"BLOCK":      0,
	"ALERT_ONLY": 1,
}

func (WafModeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

// VipVrrpType
//
// x-displayName: "VRRP Virtual-IP"
// VRRP advertisement mode for VIP
type VipVrrpType int32

const (
	// x-displayName: "INVALID"
	// Invalid VRRP mode
	VIP_VRRP_INVALID VipVrrpType = 0
	// x-displayName: "Enable VRRP for VIP(s)"
	// VRRP advertisement enabled for virtual-ip
	VIP_VRRP_ENABLE VipVrrpType = 1
	// x-displayName: "Disable VRRP for VIP(s)"
	// VRRP advertisement disabled for virtual-ip
	VIP_VRRP_DISABLE VipVrrpType = 2
)

var VipVrrpType_name = map[int32]string{
	0: "VIP_VRRP_INVALID",
	1: "VIP_VRRP_ENABLE",
	2: "VIP_VRRP_DISABLE",
}
var VipVrrpType_value = map[string]int32{
	"VIP_VRRP_INVALID": 0,
	"VIP_VRRP_ENABLE":  1,
	"VIP_VRRP_DISABLE": 2,
}

func (VipVrrpType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

// Site to site tunnel type
//
// x-displayName: "Tunnel type"
// Tunnel encapsulation to be used between sites
type SiteToSiteTunnelType int32

const (
	// x-displayName: "IPSEC or SSL"
	// Site to site tunnel can operate in both ipsec and ssl
	// ipsec takes precedence over ssl
	SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL SiteToSiteTunnelType = 0
	// x-displayName: "IPSEC"
	// Site to site tunnel is of type ipsec
	SITE_TO_SITE_TUNNEL_IPSEC SiteToSiteTunnelType = 1
	// x-displayName: "SSL"
	// Site to site tunnel is of type ssl
	SITE_TO_SITE_TUNNEL_SSL SiteToSiteTunnelType = 2
)

var SiteToSiteTunnelType_name = map[int32]string{
	0: "SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL",
	1: "SITE_TO_SITE_TUNNEL_IPSEC",
	2: "SITE_TO_SITE_TUNNEL_SSL",
}
var SiteToSiteTunnelType_value = map[string]int32{
	"SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL": 0,
	"SITE_TO_SITE_TUNNEL_IPSEC":        1,
	"SITE_TO_SITE_TUNNEL_SSL":          2,
}

func (SiteToSiteTunnelType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

// SortOrder
//
// x-displayName: "Sort Order"
// Sort algorithm
type SortOrder int32

const (
	// x-displayName: "Descending Order"
	// Sort in descending order
	DESCENDING SortOrder = 0
	// x-displayName: "Ascending Order"
	// Sort in ascending order
	ASCENDING SortOrder = 1
)

var SortOrder_name = map[int32]string{
	0: "DESCENDING",
	1: "ASCENDING",
}
var SortOrder_value = map[string]int32{
	"DESCENDING": 0,
	"ASCENDING":  1,
}

func (SortOrder) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

// TunnelEncapsulationType
//
// x-displayName: "Tunnel Encapsulation Type"
// Type of tunnel encapsulation
type TunnelEncapsulationType int32

const (
	// x-displayName: "IPSEC PKI"
	// IPSEC using public key infrastructure
	IPSEC_PKI TunnelEncapsulationType = 0
	// x-displayName: "IPSEC PSK"
	// IPSEC using pre shared key
	IPSEC_PSK TunnelEncapsulationType = 1
	// x-displayName: "SSL"
	// SSL encapsulation
	SSL TunnelEncapsulationType = 2
	// x-displayName: "GRE"
	// GRE encapsulation
	GRE TunnelEncapsulationType = 3
)

var TunnelEncapsulationType_name = map[int32]string{
	0: "IPSEC_PKI",
	1: "IPSEC_PSK",
	2: "SSL",
	3: "GRE",
}
var TunnelEncapsulationType_value = map[string]int32{
	"IPSEC_PKI": 0,
	"IPSEC_PSK": 1,
	"SSL":       2,
	"GRE":       3,
}

func (TunnelEncapsulationType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

// TenantType
//
// x-displayName: "Tenant type"
// TenantType is the type of the customer
type TenantType int32

const (
	// x-displayName: "Unknown"
	// UNKNOWN indicates the field not being set
	UNKNOWN TenantType = 0
	// x-displayName: "Freemium"
	// FREEMIUM are customer that don't have their domain
	FREEMIUM TenantType = 1
	// x-displayName: "Enterprise"
	// ENTERPRiISE customer have their domain
	ENTERPRISE TenantType = 2
)

var TenantType_name = map[int32]string{
	0: "UNKNOWN",
	1: "FREEMIUM",
	2: "ENTERPRISE",
}
var TenantType_value = map[string]int32{
	"UNKNOWN":    0,
	"FREEMIUM":   1,
	"ENTERPRISE": 2,
}

func (TenantType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

// TaxExemptionType
//
// x-displayName: "Tax Exemption"
// TaxExemptionType holds possible tax exemption option.
type TaxExemptionType int32

const (
	// x-displayName: "Unknown"
	// UNKNOWN indicates the field not being set
	TAX_UNKNOWN TaxExemptionType = 0
	// x-displayName: "Regular"
	// TAX_REGULAR indicates customers that are required to pay taxes
	TAX_REGULAR TaxExemptionType = 1
	// x-displayName: "Unverified"
	// TAX_EXEMPT indicates customers exempt from paying taxes - their status needs to be verified once signup is completed.
	TAX_EXEMPT_UNVERIFIED TaxExemptionType = 2
	// x-displayName: "Verified"
	// TAX_EXEMPT indicates customers exempt from paying taxes - their status has been verified and the customer is not being taxed by us.
	TAX_EXEMPT_VERIFIED TaxExemptionType = 3
	// x-displayName: "Verification Failed"
	// TAX_EXEMPT_VERIFICATION_FAILED indicates customers that the tax exempt verification process failed - they can contact Volterra to get more details
	TAX_EXEMPT_VERIFICATION_FAILED TaxExemptionType = 4
	// x-displayName: "Verification Pending"
	// TAX_EXEMPT_VERIFICATION_PENDING indicates customers that the tax exempt verification process is ongoing
	TAX_EXEMPT_VERIFICATION_PENDING TaxExemptionType = 5
)

var TaxExemptionType_name = map[int32]string{
	0: "TAX_UNKNOWN",
	1: "TAX_REGULAR",
	2: "TAX_EXEMPT_UNVERIFIED",
	3: "TAX_EXEMPT_VERIFIED",
	4: "TAX_EXEMPT_VERIFICATION_FAILED",
	5: "TAX_EXEMPT_VERIFICATION_PENDING",
}
var TaxExemptionType_value = map[string]int32{
	"TAX_UNKNOWN":                     0,
	"TAX_REGULAR":                     1,
	"TAX_EXEMPT_UNVERIFIED":           2,
	"TAX_EXEMPT_VERIFIED":             3,
	"TAX_EXEMPT_VERIFICATION_FAILED":  4,
	"TAX_EXEMPT_VERIFICATION_PENDING": 5,
}

func (TaxExemptionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

// PlanType
//
// x-displayName: "Plan Type"
// PlanType is the type of billing plan for the customer
type PlanType int32

const (
	// x-displayName: "Free"
	FREE PlanType = 0
	// x-displayName: "Individual"
	INDIVIDUAL PlanType = 1
	// x-displayName: "Team"
	TEAM PlanType = 2
	// x-displayName: "Organization"
	ORGANIZATION PlanType = 3
	// x-displayName: "Unspecified"
	PLAN_TYPE_UNSPECIFIED PlanType = 4
)

var PlanType_name = map[int32]string{
	0: "FREE",
	1: "INDIVIDUAL",
	2: "TEAM",
	3: "ORGANIZATION",
	4: "PLAN_TYPE_UNSPECIFIED",
}
var PlanType_value = map[string]int32{
	"FREE":                  0,
	"INDIVIDUAL":            1,
	"TEAM":                  2,
	"ORGANIZATION":          3,
	"PLAN_TYPE_UNSPECIFIED": 4,
}

func (PlanType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

// Metric Label Operator
//
// x-displayName: "Metric Label Operator"
// The operator to use when filtering metrics based on label values.
type MetricLabelOp int32

const (
	// x-displayName: "Equal To"
	EQ MetricLabelOp = 0
	// x-displayName: "Not Equal To"
	NEQ MetricLabelOp = 1
)

var MetricLabelOp_name = map[int32]string{
	0: "EQ",
	1: "NEQ",
}
var MetricLabelOp_value = map[string]int32{
	"EQ":  0,
	"NEQ": 1,
}

func (MetricLabelOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

// Route Attribute
//
// x-displayName: "Route Attribute"
// Defines attributes associated with route
type RouteAttrType int32

const (
	// x-displayName: "None"
	// Ignore attribute
	ROUTE_ATTR_NO_OP RouteAttrType = 0
	// x-displayName: "Advertise"
	// Advertise route in all supported routing protocols
	ROUTE_ATTR_ADVERTISE RouteAttrType = 1
	// x-displayName: "Install Host OS"
	// Add route into host OS - route in host OS will point to interface corresponding to the
	// virtual network. Host OS must have an interface in the virtual network.
	ROUTE_ATTR_INSTALL_HOST RouteAttrType = 2
	// x-displayName: "Install Forwarding"
	// Use the route for forwarding decision - adds route into data plane
	// modules with configured next-hop
	ROUTE_ATTR_INSTALL_FORWARDING RouteAttrType = 3
	// x-displayName: "Merge Route"
	// Merge Route if they already exist
	ROUTE_ATTR_MERGE_ONLY RouteAttrType = 4
)

var RouteAttrType_name = map[int32]string{
	0: "ROUTE_ATTR_NO_OP",
	1: "ROUTE_ATTR_ADVERTISE",
	2: "ROUTE_ATTR_INSTALL_HOST",
	3: "ROUTE_ATTR_INSTALL_FORWARDING",
	4: "ROUTE_ATTR_MERGE_ONLY",
}
var RouteAttrType_value = map[string]int32{
	"ROUTE_ATTR_NO_OP":              0,
	"ROUTE_ATTR_ADVERTISE":          1,
	"ROUTE_ATTR_INSTALL_HOST":       2,
	"ROUTE_ATTR_INSTALL_FORWARDING": 3,
	"ROUTE_ATTR_MERGE_ONLY":         4,
}

func (RouteAttrType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

// Nexthop Types
//
// x-displayName: "Nexthop Types"
// Defines types of next-hop
type NextHopTypes int32

const (
	// x-displayName: "Default Gateway"
	// Use default gateway on the local interface as gateway for route.
	// Assumes there is only one local interface on the virtual network.
	NEXT_HOP_DEFAULT_GATEWAY NextHopTypes = 0
	// x-displayName: "User Configured"
	// Use the specified address as nexthop
	NEXT_HOP_USE_CONFIGURED NextHopTypes = 1
	// x-displayName: "Network Interface"
	// Use the network interface as nexthop
	NEXT_HOP_NETWORK_INTERFACE NextHopTypes = 2
	// x-displayName: "Discard"
	// Discard nexthop, used when attr type is Advertise
	NEXT_HOP_DISCARD NextHopTypes = 3
	// x-displayName: "SNAT to Public"
	// Used in VoltADN private virtual network.
	NEXT_HOP_SNAT_TO_PUBLIC NextHopTypes = 4
)

var NextHopTypes_name = map[int32]string{
	0: "NEXT_HOP_DEFAULT_GATEWAY",
	1: "NEXT_HOP_USE_CONFIGURED",
	2: "NEXT_HOP_NETWORK_INTERFACE",
	3: "NEXT_HOP_DISCARD",
	4: "NEXT_HOP_SNAT_TO_PUBLIC",
}
var NextHopTypes_value = map[string]int32{
	"NEXT_HOP_DEFAULT_GATEWAY":   0,
	"NEXT_HOP_USE_CONFIGURED":    1,
	"NEXT_HOP_NETWORK_INTERFACE": 2,
	"NEXT_HOP_DISCARD":           3,
	"NEXT_HOP_SNAT_TO_PUBLIC":    4,
}

func (NextHopTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

// Empty
//
// x-displayName: "Empty"
// This can be used for messages where no values are needed
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// ObjectRefType
//
// x-displayName: "Object reference"
// This type establishes a 'direct reference' from one object(the referrer) to another(the referred).
// Such a reference is in form of tenant/namespace/name for public API and Uid for private API
// This type of reference is called direct because the relation is explicit and concrete (as opposed
// to selector reference which builds a group based on labels of selectee objects)
type ObjectRefType struct {
	// kind
	//
	// x-displayName: "Kind"
	// x-example: "virtual_site"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then kind will hold the referred object's kind (e.g. "route")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then uid will hold the referred object's(e.g. route's) uid.
	Uid string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// tenant
	//
	// x-displayName: "Tenant"
	// x-example: "acmecorp"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then tenant will hold the referred object's(e.g. route's) tenant.
	Tenant string `protobuf:"bytes,3,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then namespace will hold the referred object's(e.g. route's) namespace.
	Namespace string `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "contactus-route"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then name will hold the referred object's(e.g. route's) name.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ObjectRefType) Reset()                    { *m = ObjectRefType{} }
func (*ObjectRefType) ProtoMessage()               {}
func (*ObjectRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *ObjectRefType) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ObjectRefType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ObjectRefType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *ObjectRefType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectRefType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// LabelSelectorType
//
// x-displayName: "Label Selector"
// This type can be used to establish a 'selector reference' from one object(called selector) to
// a set of other objects(called selectees) based on the value of expresssions.
// A label selector is a label query over a set of resources. An empty label selector matches all objects.
// A null label selector matches no objects. Label selector is immutable.
// expressions is a list of strings of label selection expression.
// Each string has "," seperated values which are "AND" and all strings are logically "OR".
// BNF for expression string
// <selector-syntax>         ::= <requirement> | <requirement> "," <selector-syntax>
// <requirement>             ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ]
// <set-based-restriction>   ::= "" | <inclusion-exclusion> <value-set>
// <inclusion-exclusion>     ::= <inclusion> | <exclusion>
// <exclusion>               ::= "notin"
// <inclusion>               ::= "in"
// <value-set>               ::= "(" <values> ")"
// <values>                  ::= VALUE | VALUE "," <values>
// <exact-match-restriction> ::= ["="|"=="|"!="] VALUE
type LabelSelectorType struct {
	// expressions
	//
	// x-displayName: "Selector Expression"
	// x-required
	// x-example: "region in (us-west1, us-west2),tier in (staging)"
	// expressions contains the kubernetes style label expression for selections.
	Expressions []string `protobuf:"bytes,1,rep,name=expressions" json:"expressions,omitempty"`
}

func (m *LabelSelectorType) Reset()                    { *m = LabelSelectorType{} }
func (*LabelSelectorType) ProtoMessage()               {}
func (*LabelSelectorType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *LabelSelectorType) GetExpressions() []string {
	if m != nil {
		return m.Expressions
	}
	return nil
}

// LabelMatcherType
//
// x-displayName: "Label Matcher"
// A label matcher specifies a list of label keys whose values need to match for
// source/client and destination/server. Note that the actual label values are not
// specified and do not matter. This allows an ability to scope grouping by the
// label key name.
type LabelMatcherType struct {
	// keys
	//
	// x-displayName: "Keys"
	// x-example: "['environment', 'location', 'deployment']"
	// The list of label key names that have to match
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *LabelMatcherType) Reset()                    { *m = LabelMatcherType{} }
func (*LabelMatcherType) ProtoMessage()               {}
func (*LabelMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *LabelMatcherType) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// ConditionType
//
// x-displayName: "Status Condition"
// Conditions are used in the object status to describe the current state of the
// object, e.g. Ready, Succeeded, etc.
type ConditionType struct {
	// type
	//
	// x-displayName: "Type"
	// x-example: "Operational"
	// Type of the condition
	// "Validation" represents validation user given configuration object
	// "Operational" represents operational status of a given configuration object
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// status
	//
	// x-displayName: "Status"
	// x-example: "Failed"
	// Status of the condition
	// "Success" Validtion has succeded. Requested operation was successful.
	// "Failed"  Validation has failed.
	// "Incomplete" Validation of configuration has failed due to missing configuration.
	// "Installed" Validation has passed and configuration has been installed in data path or K8s
	// "Down" Configuration is operationally down. e.g. down interface
	// "Disabled" Configuration is administratively disabled i.e. ObjectMetaType.Disable = true.
	// "NotApplicable" Configuration is not applicable e.g. tenant service_policy_set(s) in system namespace are not applicable on REs
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// reason
	//
	// x-displayName: "Reason"
	// x-example: "value"
	// x-reason: "Insufficient memory in data plane"
	// A human readable string explaining the reason for reaching this condition
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// last_update_time
	//
	// x-displayName: "Last Updated"
	// Last time the condition was updated
	LastUpdateTime *google_protobuf3.Timestamp `protobuf:"bytes,5,opt,name=last_update_time,json=lastUpdateTime" json:"last_update_time,omitempty"`
	// hostname
	//
	// x-displayName: "Hostname"
	// Hostname of the instance of the site that sent the status
	Hostname string `protobuf:"bytes,6,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// service name
	//
	// x-displayName: "Service Name"
	// Name of the service that sent the status
	ServiceName string `protobuf:"bytes,7,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
}

func (m *ConditionType) Reset()                    { *m = ConditionType{} }
func (*ConditionType) ProtoMessage()               {}
func (*ConditionType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *ConditionType) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ConditionType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ConditionType) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ConditionType) GetLastUpdateTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.LastUpdateTime
	}
	return nil
}

func (m *ConditionType) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *ConditionType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

// StatusType
//
// x-displayName: "Status"
// Status is a return value for calls that don't return other objects.
type StatusType struct {
	// status
	//
	// x-displayName: "Status"
	// x-example: "value"
	// Status of the operation.
	// One of: "Success" or "Failure".
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// reason
	//
	// x-displayName: "Reason"
	// x-example: "value"
	// A human-readable description of why this operation is in the
	// "Failure" status. If this value is empty there
	// is no information available.
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// code
	//
	// x-displayName: "Code"
	// x-example: "0"
	// Suggested HTTP return code for this status, 0 if not set.
	Code int32 `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *StatusType) Reset()                    { *m = StatusType{} }
func (*StatusType) ProtoMessage()               {}
func (*StatusType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *StatusType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *StatusType) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *StatusType) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// InitializerType
//
// x-displayName: "Initializer"
// Initializer is information about an initializer that has not yet completed.
type InitializerType struct {
	// name
	//
	// x-displayName: "Name"
	// name of the service that is responsible for initializing this object.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *InitializerType) Reset()                    { *m = InitializerType{} }
func (*InitializerType) ProtoMessage()               {}
func (*InitializerType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *InitializerType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// InitializersType
//
// x-displayName: "Initializers"
// Initializers tracks the progress of initialization of a configuration object
type InitializersType struct {
	// pending
	//
	// x-displayName: "Pending"
	// Pending is a list of initializers that must execute in order before this object is initialized.
	// When the last pending initializer is removed, and no failing result is set, the initializers
	// struct will be set to nil and the object is considered as initialized and visible to all
	// clients.
	Pending []*InitializerType `protobuf:"bytes,1,rep,name=pending" json:"pending,omitempty"`
	// result
	//
	// x-displayName: "Result"
	// If result is set with the Failure field, the object will be persisted to storage and then deleted,
	// ensuring that other clients can observe the deletion.
	Result *StatusType `protobuf:"bytes,2,opt,name=result" json:"result,omitempty"`
}

func (m *InitializersType) Reset()                    { *m = InitializersType{} }
func (*InitializersType) ProtoMessage()               {}
func (*InitializersType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *InitializersType) GetPending() []*InitializerType {
	if m != nil {
		return m.Pending
	}
	return nil
}

func (m *InitializersType) GetResult() *StatusType {
	if m != nil {
		return m.Result
	}
	return nil
}

// StatusMetaType
//
// x-displayName: "Metadata"
// StatusMetaType is metadata that all status must have.
type StatusMetaType struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for a StatusObject.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// creator_class
	//
	// x-displayName: "Creator Class"
	// x-example: "ver.re1.int.ves.io"
	// Class of creator which created this StatusObject. This will be service's DNS FQDN.
	// This will be set by the system based on client certificate information.
	CreatorClass string `protobuf:"bytes,2,opt,name=creator_class,json=creatorClass,proto3" json:"creator_class,omitempty"`
	// creator_id
	//
	// x-displayName: "Creator ID"
	// x-example: "ver-instance-1"
	// ID of creator which created this StatusObject. This will be a concrete identifier for service (e.g.
	// identifying the environment also). This will be set by the system based on client certificate
	// information
	CreatorId string `protobuf:"bytes,3,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// status_id
	//
	// x-displayName: "Status ID"
	// status_id is a field used by the generator to distinguish (if necessary) between two status
	// objects for the same config object from the same site and same service and potentially same
	// daemon(creator-id)
	StatusId string `protobuf:"bytes,4,opt,name=status_id,json=statusId,proto3" json:"status_id,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// creation_timestamp is when the status object was created. It is used to find/tie-break
	// for latest status object from same origin
	CreationTimestamp *google_protobuf3.Timestamp `protobuf:"bytes,5,opt,name=creation_timestamp,json=creationTimestamp" json:"creation_timestamp,omitempty"`
	// publish
	//
	// x-displayName: "Publish"
	// Decides wether this status object will be propagated to user.
	Publish StatusPublishType `protobuf:"varint,6,opt,name=publish,proto3,enum=ves.io.schema.StatusPublishType" json:"publish,omitempty"`
}

func (m *StatusMetaType) Reset()                    { *m = StatusMetaType{} }
func (*StatusMetaType) ProtoMessage()               {}
func (*StatusMetaType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *StatusMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *StatusMetaType) GetCreatorClass() string {
	if m != nil {
		return m.CreatorClass
	}
	return ""
}

func (m *StatusMetaType) GetCreatorId() string {
	if m != nil {
		return m.CreatorId
	}
	return ""
}

func (m *StatusMetaType) GetStatusId() string {
	if m != nil {
		return m.StatusId
	}
	return ""
}

func (m *StatusMetaType) GetCreationTimestamp() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *StatusMetaType) GetPublish() StatusPublishType {
	if m != nil {
		return m.Publish
	}
	return STATUS_DO_NOT_PUBLISH
}

// ObjectMetaType
//
// x-displayName: "Metadata"
// ObjectMetaType is metadata(common attributes) of an object that all configuration objects will have.
// The information in this type can be specified by user during create and replace APIs.
type ObjectMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// This is the name of configuration object. It has to be unique within the namespace.
	// It can only be specified during create API and cannot be changed during replace API.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. Object create will fail if
	// provided by the client and the value exists in the system. Typically generated by the
	// server on successful creation of an object and is not allowed to change once populated.
	// Shadowed by SystemObjectMeta's uid field.
	Uid string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// x-example: "value"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotations"
	// x-example: "value"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,5,rep,name=annotations" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectMetaType) Reset()                    { *m = ObjectMetaType{} }
func (*ObjectMetaType) ProtoMessage()               {}
func (*ObjectMetaType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *ObjectMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ObjectMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ListMetaType
//
// x-displayName: "List Metadata"
// ListMetaType is metadata that all lists must have.
type ListMetaType struct {
	// resource_version
	//
	// x-displayName: "Resource Version"
	// x-example: "181255"
	// An opaque value that represents the revision of the store at the time the list API is
	// performed. It can be used in subsequent watch API to receive all changes after the list
	// API, or in a replace API to make the replace conditional on the object still being at
	// that revision
	ResourceVersion string `protobuf:"bytes,1,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
}

func (m *ListMetaType) Reset()                    { *m = ListMetaType{} }
func (*ListMetaType) ProtoMessage()               {}
func (*ListMetaType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *ListMetaType) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

// ObjectGetMetaType
//
// x-displayName: "Get Metadata"
// ObjectGetMetaType is metadata that can be specified in Get/Create response of an object.
type ObjectGetMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// The configuration object will be created with name. It has to be unique within the namespace.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// x-example: "value"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotation"
	// x-example: "value"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,5,rep,name=annotations" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectGetMetaType) Reset()                    { *m = ObjectGetMetaType{} }
func (*ObjectGetMetaType) ProtoMessage()               {}
func (*ObjectGetMetaType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *ObjectGetMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectGetMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectGetMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectGetMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectGetMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectGetMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ObjectCreateMetaType
//
// x-displayName: "Create Metadata"
// ObjectCreateMetaType is metadata that can be specified in Create request of an object.
type ObjectCreateMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// The configuration object will be created with name. It has to be unique within the namespace.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotation"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,5,rep,name=annotations" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectCreateMetaType) Reset()                    { *m = ObjectCreateMetaType{} }
func (*ObjectCreateMetaType) ProtoMessage()               {}
func (*ObjectCreateMetaType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

func (m *ObjectCreateMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectCreateMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectCreateMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectCreateMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectCreateMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectCreateMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ObjectReplaceMetaType
//
// x-displayName: "Replace Metadata"
// ObjectReplaceMetaType is metadata that can be specified in Replace request of an object.
type ObjectReplaceMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// The configuration object to be replaced will be looked up by name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotations"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,4,rep,name=annotations" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,6,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectReplaceMetaType) Reset()                    { *m = ObjectReplaceMetaType{} }
func (*ObjectReplaceMetaType) ProtoMessage()               {}
func (*ObjectReplaceMetaType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *ObjectReplaceMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectReplaceMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectReplaceMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectReplaceMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectReplaceMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectReplaceMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// MessageMetaType
//
// x-displayName: "Message Metadata"
// MessageMetaType is metadata (common attributes) of a message that only certain messages
// have. This information is propagated to the metadata of a child object that gets created
// from the containing message during view processing.
// The information in this type can be specified by user during create and replace APIs.
type MessageMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// This is the name of the message.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object that corresponds to the containing message.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will administratively disable the object that corresponds to the containing message.
	Disable bool `protobuf:"varint,3,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *MessageMetaType) Reset()                    { *m = MessageMetaType{} }
func (*MessageMetaType) ProtoMessage()               {}
func (*MessageMetaType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *MessageMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MessageMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MessageMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ViewRefType
//
// x-displayName: "View Reference"
// ViewRefType represents a reference to a view
type ViewRefType struct {
	// kind
	//
	// x-displayName: "Kind"
	// x-example: "http_proxy"
	// Kind of the view object
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// uid
	//
	// x-displayName: "UID"
	// x-example: "f3744323-1adf-4aaa-a5dc-0707c1d1bd82"
	// UID of the view object
	Uid string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then namespace will hold the referred object's(e.g. route's) namespace.
	Namespace string `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "contactus-route"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then name will hold the referred object's(e.g. route's) name.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ViewRefType) Reset()                    { *m = ViewRefType{} }
func (*ViewRefType) ProtoMessage()               {}
func (*ViewRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *ViewRefType) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ViewRefType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ViewRefType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ViewRefType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// KubeRefType
//
// x-displayName: "Kubernetes Reference"
// KubeRefType represents a reference to a Kubernetes (K8s) object
type KubeRefType struct {
	// kind
	//
	// x-displayName: "Kind"
	// x-example: "Deployment"
	// Kind of the kubernetes object
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// Namespace of the kubernetes object
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "adservice"
	// Name of the kubernetes object
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *KubeRefType) Reset()                    { *m = KubeRefType{} }
func (*KubeRefType) ProtoMessage()               {}
func (*KubeRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

func (m *KubeRefType) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *KubeRefType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *KubeRefType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// SystemObjectMetaType
//
// x-displayName: "System Metadata"
// SystemObjectMetaType is metadata generated or populated by the system for all persisted objects and
// cannot be updated directly by users.
type SystemObjectMetaType struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. It is generated by
	// the server on successful creation of an object and is not allowed to change on Replace
	// API. The value of is taken from uid field of ObjectMetaType, if provided.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp *google_protobuf3.Timestamp `protobuf:"bytes,3,opt,name=creation_timestamp,json=creationTimestamp" json:"creation_timestamp,omitempty"`
	// deletion_timestamp
	//
	// x-displayName: "Deletion Timestamp"
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	DeletionTimestamp *google_protobuf3.Timestamp `protobuf:"bytes,4,opt,name=deletion_timestamp,json=deletionTimestamp" json:"deletion_timestamp,omitempty"`
	// modification_timestamp
	//
	// x-displayName: "Modification Timestamp"
	// ModificationTimestamp is a timestamp representing the server time when this object was
	// last modified.
	ModificationTimestamp *google_protobuf3.Timestamp `protobuf:"bytes,5,opt,name=modification_timestamp,json=modificationTimestamp" json:"modification_timestamp,omitempty"`
	// initializers
	//
	// x-displayName: "Initializers"
	// An initializer is a controller which enforces some system invariant at object creation time.
	// This field is a list of initializers that have not yet acted on this object. If nil or empty,
	// this object has been completely initialized. Otherwise, the object is considered uninitialized
	// and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to
	// observe uninitialized objects.
	//
	// When an object is created, the system will populate this list with the current set of initializers.
	// Only privileged users may set or modify this list. Once it is empty, it may not be modified further
	// by any user.
	Initializers *InitializersType `protobuf:"bytes,6,opt,name=initializers" json:"initializers,omitempty"`
	// finalizers
	//
	// x-displayName: "Finalizers"
	// x-example: "value"
	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	Finalizers []string `protobuf:"bytes,7,rep,name=finalizers" json:"finalizers,omitempty"`
	// tenant
	//
	// x-displayName: "Tenant"
	// x-example: "acmecorp"
	// Tenant to which this configuration object belongs to. The value for this is found from
	// presented credentials.
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// creator_class
	//
	// x-displayName: "Creator Class"
	// x-example: "value"
	// A value identifying the class of the user or service which created this configuration object.
	CreatorClass string `protobuf:"bytes,9,opt,name=creator_class,json=creatorClass,proto3" json:"creator_class,omitempty"`
	// creator_id
	//
	// x-displayName: "Creator ID"
	// x-example: "value"
	// A value identifying the exact user or service that created this configuration object
	CreatorId string `protobuf:"bytes,10,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// creator_cookie
	//
	// x-displayName: "Creator Cookie"
	// x-example: "value"
	// This can used by the creator of the object for later audit for e.g. by storing the
	// version identifying information of the object so at future it can be determined if
	// version present at remote end is current or stale.
	CreatorCookie string `protobuf:"bytes,14,opt,name=creator_cookie,json=creatorCookie,proto3" json:"creator_cookie,omitempty"`
	// trace_info
	//
	// x-displayName: "Trace Info"
	// x-example: "value"
	// trace_info holds information(<trace-id>:<span-id>:<parent-span-id>) of the request doing
	// the object modification. This can be used on the watch side to create subsequent spans.
	// This information can be used to co-relate activities across services (modulo state compression)
	// for a synchronous API.
	TraceInfo string `protobuf:"bytes,11,opt,name=trace_info,json=traceInfo,proto3" json:"trace_info,omitempty"`
	// object_index
	//
	// x-displayName: "Object Index"
	// x-example: "0"
	// Unique index for the object. Some objects need a unique integer index to be allocated
	// for each object type. This field will be populated for all objects that need it and will
	// be zero otherwise.
	ObjectIndex uint32 `protobuf:"varint,12,opt,name=object_index,json=objectIndex,proto3" json:"object_index,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace Reference"
	// The namespace this object belongs to. This is populated by the service based on the
	// metadata.namespace field when an object is created.
	Namespace []*ObjectRefType `protobuf:"bytes,13,rep,name=namespace" json:"namespace,omitempty"`
	// owner_view
	//
	// x-displayName: "Owner View"
	// Reference to the view object that owns this object.
	// If there is no view owner, this field will be nil.
	// If not nil, this object can only be edited/deleted through the view
	OwnerView *ViewRefType `protobuf:"bytes,15,opt,name=owner_view,json=ownerView" json:"owner_view,omitempty"`
}

func (m *SystemObjectMetaType) Reset()                    { *m = SystemObjectMetaType{} }
func (*SystemObjectMetaType) ProtoMessage()               {}
func (*SystemObjectMetaType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

func (m *SystemObjectMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreationTimestamp() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *SystemObjectMetaType) GetDeletionTimestamp() *google_protobuf3.Timestamp {
	if m != nil {
		return m.DeletionTimestamp
	}
	return nil
}

func (m *SystemObjectMetaType) GetModificationTimestamp() *google_protobuf3.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *SystemObjectMetaType) GetInitializers() *InitializersType {
	if m != nil {
		return m.Initializers
	}
	return nil
}

func (m *SystemObjectMetaType) GetFinalizers() []string {
	if m != nil {
		return m.Finalizers
	}
	return nil
}

func (m *SystemObjectMetaType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreatorClass() string {
	if m != nil {
		return m.CreatorClass
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreatorId() string {
	if m != nil {
		return m.CreatorId
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreatorCookie() string {
	if m != nil {
		return m.CreatorCookie
	}
	return ""
}

func (m *SystemObjectMetaType) GetTraceInfo() string {
	if m != nil {
		return m.TraceInfo
	}
	return ""
}

func (m *SystemObjectMetaType) GetObjectIndex() uint32 {
	if m != nil {
		return m.ObjectIndex
	}
	return 0
}

func (m *SystemObjectMetaType) GetNamespace() []*ObjectRefType {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *SystemObjectMetaType) GetOwnerView() *ViewRefType {
	if m != nil {
		return m.OwnerView
	}
	return nil
}

// SystemObjectGetMetaType
//
// x-displayName: "System Metadata"
// SystemObjectGetMetaType is metadata generated or populated by the system for all persisted objects and
// cannot be updated directly by users.
type SystemObjectGetMetaType struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. It is generated by
	// the server on successful creation of an object and is not allowed to change on Replace
	// API. The value of is taken from uid field of ObjectMetaType, if provided.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp *google_protobuf3.Timestamp `protobuf:"bytes,3,opt,name=creation_timestamp,json=creationTimestamp" json:"creation_timestamp,omitempty"`
	// deletion_timestamp
	//
	// x-displayName: "Deletion Timestamp"
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	DeletionTimestamp *google_protobuf3.Timestamp `protobuf:"bytes,4,opt,name=deletion_timestamp,json=deletionTimestamp" json:"deletion_timestamp,omitempty"`
	// modification_timestamp
	//
	// x-displayName: "Modification Timestamp"
	// ModificationTimestamp is a timestamp representing the server time when this object was
	// last modified.
	ModificationTimestamp *google_protobuf3.Timestamp `protobuf:"bytes,5,opt,name=modification_timestamp,json=modificationTimestamp" json:"modification_timestamp,omitempty"`
	// initializers
	//
	// x-displayName: "Initializers"
	// An initializer is a controller which enforces some system invariant at object creation time.
	// This field is a list of initializers that have not yet acted on this object. If nil or empty,
	// this object has been completely initialized. Otherwise, the object is considered uninitialized
	// and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to
	// observe uninitialized objects.
	//
	// When an object is created, the system will populate this list with the current set of initializers.
	// Only privileged users may set or modify this list. Once it is empty, it may not be modified further
	// by any user.
	Initializers *InitializersType `protobuf:"bytes,6,opt,name=initializers" json:"initializers,omitempty"`
	// finalizers
	//
	// x-displayName: "Finalizers"
	// x-example: "value"
	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	Finalizers []string `protobuf:"bytes,7,rep,name=finalizers" json:"finalizers,omitempty"`
	// tenant
	//
	// x-displayName: "Tenant"
	// x-example: "acmecorp"
	// Tenant to which this configuration object belongs to. The value for this is found from
	// presented credentials.
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// creator_class
	//
	// x-displayName: "Creator Class"
	// x-example: "prism"
	// A value identifying the class of the user or service which created this configuration object.
	CreatorClass string `protobuf:"bytes,9,opt,name=creator_class,json=creatorClass,proto3" json:"creator_class,omitempty"`
	// creator_id
	//
	// x-displayName: "Creator ID"
	// x-example: "admin@acmecorp.com"
	// A value identifying the exact user or service that created this configuration object
	CreatorId string `protobuf:"bytes,10,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// object_index
	//
	// x-displayName: "Object Index"
	// x-example: "0"
	// Unique index for the object. Some objects need a unique integer index to be allocated
	// for each object type. This field will be populated for all objects that need it and will
	// be zero otherwise.
	ObjectIndex uint32 `protobuf:"varint,12,opt,name=object_index,json=objectIndex,proto3" json:"object_index,omitempty"`
	// owner_view
	//
	// x-displayName: "Owner View"
	// Reference to the view object that owns this object.
	// If there is no view owner, this field will be nil.
	// If not nil, this object can only be edited/deleted through the view
	OwnerView *ViewRefType `protobuf:"bytes,15,opt,name=owner_view,json=ownerView" json:"owner_view,omitempty"`
}

func (m *SystemObjectGetMetaType) Reset()                    { *m = SystemObjectGetMetaType{} }
func (*SystemObjectGetMetaType) ProtoMessage()               {}
func (*SystemObjectGetMetaType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

func (m *SystemObjectGetMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetCreationTimestamp() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetDeletionTimestamp() *google_protobuf3.Timestamp {
	if m != nil {
		return m.DeletionTimestamp
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetModificationTimestamp() *google_protobuf3.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetInitializers() *InitializersType {
	if m != nil {
		return m.Initializers
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetFinalizers() []string {
	if m != nil {
		return m.Finalizers
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetCreatorClass() string {
	if m != nil {
		return m.CreatorClass
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetCreatorId() string {
	if m != nil {
		return m.CreatorId
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetObjectIndex() uint32 {
	if m != nil {
		return m.ObjectIndex
	}
	return 0
}

func (m *SystemObjectGetMetaType) GetOwnerView() *ViewRefType {
	if m != nil {
		return m.OwnerView
	}
	return nil
}

// AuthnTypeBasicAuth
//
// x-displayName: "BasicAuth Authentication Parameters"
// AuthnTypeBasicAuth is used for using basic_auth mode of HTTP authentication
type AuthnTypeBasicAuth struct {
	// username
	//
	// x-displayName: "Username"
	// The username to encode in Basic Auth scheme
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// password
	//
	// x-displayName: "Password"
	// Volterra Secret. The password to encode in Basic Auth scheme
	Password *SecretType `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *AuthnTypeBasicAuth) Reset()                    { *m = AuthnTypeBasicAuth{} }
func (*AuthnTypeBasicAuth) ProtoMessage()               {}
func (*AuthnTypeBasicAuth) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

func (m *AuthnTypeBasicAuth) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AuthnTypeBasicAuth) GetPassword() *SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

// AuthnTypeHeaders
//
// x-displayName: "Authentication Headers"
// AuthnTypeHeaders is used for setting headers for authentication
type AuthnTypeHeaders struct {
	// headers
	//
	// x-displayName: "Headers"
	// The set of authentication headers to pass in HTTP request
	Headers map[string]*SecretType `protobuf:"bytes,1,rep,name=headers" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AuthnTypeHeaders) Reset()                    { *m = AuthnTypeHeaders{} }
func (*AuthnTypeHeaders) ProtoMessage()               {}
func (*AuthnTypeHeaders) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20} }

func (m *AuthnTypeHeaders) GetHeaders() map[string]*SecretType {
	if m != nil {
		return m.Headers
	}
	return nil
}

// AuthnTypeQueryParams
//
// x-displayName: "Authentication QueryParams"
// AuthnTypeQueryParams is used for setting query_params for authentication
type AuthnTypeQueryParams struct {
	// query_params
	//
	// x-displayName: "Query Parameters"
	// The set of authentication parameters to be passed as query parameters
	QueryParams map[string]*SecretType `protobuf:"bytes,1,rep,name=query_params,json=queryParams" json:"query_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AuthnTypeQueryParams) Reset()                    { *m = AuthnTypeQueryParams{} }
func (*AuthnTypeQueryParams) ProtoMessage()               {}
func (*AuthnTypeQueryParams) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{21} }

func (m *AuthnTypeQueryParams) GetQueryParams() map[string]*SecretType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

// BlindfoldSecretInfoType
//
// x-displayName: "Blindfold Secret"
// BlindfoldSecretInfoType specifies information about the Secret managed by Volterra Secret Management
type BlindfoldSecretInfoType struct {
	// Decryption Provider
	//
	// x-displayName: "Decryption Provider"
	// Name of the Secret Management Access object that contains information about the backend Secret Management service.
	DecryptionProvider string `protobuf:"bytes,1,opt,name=decryption_provider,json=decryptionProvider,proto3" json:"decryption_provider,omitempty"`
	// Store Provider
	//
	// x-displayName: "Store Provider"
	// Name of the Secret Management Access object that contains information about the store to get encrypted bytes
	// This field needs to be provided only if the url scheme is not string:///
	StoreProvider string `protobuf:"bytes,2,opt,name=store_provider,json=storeProvider,proto3" json:"store_provider,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// x-required
	// x-example: "string:///U2VjcmV0SW5mb3JtYXRpb24="
	// Location is the uri_ref. It could be in url format for string:///
	// Or it could be a path if the store provider is an http/https location
	Location string `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *BlindfoldSecretInfoType) Reset()                    { *m = BlindfoldSecretInfoType{} }
func (*BlindfoldSecretInfoType) ProtoMessage()               {}
func (*BlindfoldSecretInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{22} }

func (m *BlindfoldSecretInfoType) GetDecryptionProvider() string {
	if m != nil {
		return m.DecryptionProvider
	}
	return ""
}

func (m *BlindfoldSecretInfoType) GetStoreProvider() string {
	if m != nil {
		return m.StoreProvider
	}
	return ""
}

func (m *BlindfoldSecretInfoType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

// VaultSecretInfoType
//
// x-displayName: "Vault Secret"
// VaultSecretInfoType specifies information about the Secret managed by Hashicorp Vault.
type VaultSecretInfoType struct {
	// Provider
	//
	// x-displayName: "Provider"
	// x-required
	// x-example: "vault-vh-provider"
	// Name of the Secret Management Access object that contains information about the backend Vault.
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// x-required
	// x-example: "v1/data/vhost_key"
	// Path to secret in Vault.
	Location string `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	// Key
	//
	// x-displayName: "Key"
	// x-example: "key_pem"
	// Key of the individual secret. Vault Secrets are stored as key-value pair.
	// If user is only interested in one value from the map, this field should be set to the corresponding key.
	// If not provided entire secret will be returned.
	Key string `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// Version
	//
	// x-displayName: "Version"
	// x-example: "1"
	// Version of the secret to be fetched. As vault secrets are versioned, user can specify this field to fetch specific version.
	// If not provided latest version will be returned.
	Version uint32 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// secret_encoding
	//
	// x-displayName: "Secret Encoding"
	// This field defines the encoding type of the secret BEFORE the secret is put into Hashicorp Vault.
	SecretEncoding SecretEncodingType `protobuf:"varint,5,opt,name=secret_encoding,json=secretEncoding,proto3,enum=ves.io.schema.SecretEncodingType" json:"secret_encoding,omitempty"`
}

func (m *VaultSecretInfoType) Reset()                    { *m = VaultSecretInfoType{} }
func (*VaultSecretInfoType) ProtoMessage()               {}
func (*VaultSecretInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{23} }

func (m *VaultSecretInfoType) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *VaultSecretInfoType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *VaultSecretInfoType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *VaultSecretInfoType) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *VaultSecretInfoType) GetSecretEncoding() SecretEncodingType {
	if m != nil {
		return m.SecretEncoding
	}
	return EncodingNone
}

// ClearSecretInfoType
//
// x-displayName: "In-Clear Secret"
// ClearSecretInfoType specifies information about the Secret that is not encrypted.
type ClearSecretInfoType struct {
	// Provider
	//
	// x-displayName: "Provider"
	// x-example: "box-provider"
	// Name of the Secret Management Access object that contains information about the store to get encrypted bytes
	// This field needs to be provided only if the url scheme is not string:///
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	// URL
	//
	// x-displayName: "URL"
	// x-required
	// x-example: "string:///U2VjcmV0SW5mb3JtYXRpb24="
	// URL of the secret. Currently supported URL schemes is string:///.
	// For string:/// scheme, Secret needs to be encoded Base64 format.
	// When asked for this secret, caller will get Secret bytes after Base64 decoding.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *ClearSecretInfoType) Reset()                    { *m = ClearSecretInfoType{} }
func (*ClearSecretInfoType) ProtoMessage()               {}
func (*ClearSecretInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{24} }

func (m *ClearSecretInfoType) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *ClearSecretInfoType) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// WingmanSecretInfoType
//
// x-displayName: "Wingman Secret"
// WingmanSecretInfoType specifies the handle to the wingman secret
type WingmanSecretInfoType struct {
	// Name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "ChargeBack-API-Key"
	// Name of the secret.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *WingmanSecretInfoType) Reset()                    { *m = WingmanSecretInfoType{} }
func (*WingmanSecretInfoType) ProtoMessage()               {}
func (*WingmanSecretInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{25} }

func (m *WingmanSecretInfoType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// SecretType
//
// x-displayName: "Secret"
// SecretType is used in an object to indicate a sensitive/confidential field
type SecretType struct {
	// SecretInfoOneof
	//
	// x-displayName: "Secret Info"
	// x-required
	// Secret can be one of the following types -
	// * Blindfold Secret - Secret is managed by Volterra Secret Management System
	// * Clear Secret - Secret is not encrypted
	//
	// Types that are valid to be assigned to SecretInfoOneof:
	//	*SecretType_BlindfoldSecretInfo
	//	*SecretType_VaultSecretInfo
	//	*SecretType_ClearSecretInfo
	//	*SecretType_WingmanSecretInfo
	SecretInfoOneof isSecretType_SecretInfoOneof `protobuf_oneof:"secret_info_oneof"`
	// Blindfold Secret Internal
	//
	// x-displayName: "Blindfold Secret Internal"
	// Blindfold Secret Internal is used for the putting re-encrypted blindfold secret
	BlindfoldSecretInfoInternal *BlindfoldSecretInfoType `protobuf:"bytes,10,opt,name=blindfold_secret_info_internal,json=blindfoldSecretInfoInternal" json:"blindfold_secret_info_internal,omitempty"`
	// secret_encoding_type
	//
	// x-displayName: "Secret Encoding"
	// This field defines the encoding type of the secret BEFORE the secret is given to any Secret Management System.
	// this will be set if the secret is encoded and not plaintext BEFORE it is encrypted and put it in SecretType.
	// Note - Do NOT set this field for Clear Secret with string:/// scheme.
	// e.g. if a secret is base64 encoded and then put into vault.
	SecretEncodingType SecretEncodingType `protobuf:"varint,8,opt,name=secret_encoding_type,json=secretEncodingType,proto3,enum=ves.io.schema.SecretEncodingType" json:"secret_encoding_type,omitempty"`
}

func (m *SecretType) Reset()                    { *m = SecretType{} }
func (*SecretType) ProtoMessage()               {}
func (*SecretType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{26} }

type isSecretType_SecretInfoOneof interface {
	isSecretType_SecretInfoOneof()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SecretType_BlindfoldSecretInfo struct {
	BlindfoldSecretInfo *BlindfoldSecretInfoType `protobuf:"bytes,4,opt,name=blindfold_secret_info,json=blindfoldSecretInfo,oneof"`
}
type SecretType_VaultSecretInfo struct {
	VaultSecretInfo *VaultSecretInfoType `protobuf:"bytes,5,opt,name=vault_secret_info,json=vaultSecretInfo,oneof"`
}
type SecretType_ClearSecretInfo struct {
	ClearSecretInfo *ClearSecretInfoType `protobuf:"bytes,6,opt,name=clear_secret_info,json=clearSecretInfo,oneof"`
}
type SecretType_WingmanSecretInfo struct {
	WingmanSecretInfo *WingmanSecretInfoType `protobuf:"bytes,7,opt,name=wingman_secret_info,json=wingmanSecretInfo,oneof"`
}

func (*SecretType_BlindfoldSecretInfo) isSecretType_SecretInfoOneof() {}
func (*SecretType_VaultSecretInfo) isSecretType_SecretInfoOneof()     {}
func (*SecretType_ClearSecretInfo) isSecretType_SecretInfoOneof()     {}
func (*SecretType_WingmanSecretInfo) isSecretType_SecretInfoOneof()   {}

func (m *SecretType) GetSecretInfoOneof() isSecretType_SecretInfoOneof {
	if m != nil {
		return m.SecretInfoOneof
	}
	return nil
}

func (m *SecretType) GetBlindfoldSecretInfo() *BlindfoldSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_BlindfoldSecretInfo); ok {
		return x.BlindfoldSecretInfo
	}
	return nil
}

func (m *SecretType) GetVaultSecretInfo() *VaultSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_VaultSecretInfo); ok {
		return x.VaultSecretInfo
	}
	return nil
}

func (m *SecretType) GetClearSecretInfo() *ClearSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_ClearSecretInfo); ok {
		return x.ClearSecretInfo
	}
	return nil
}

func (m *SecretType) GetWingmanSecretInfo() *WingmanSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_WingmanSecretInfo); ok {
		return x.WingmanSecretInfo
	}
	return nil
}

func (m *SecretType) GetBlindfoldSecretInfoInternal() *BlindfoldSecretInfoType {
	if m != nil {
		return m.BlindfoldSecretInfoInternal
	}
	return nil
}

func (m *SecretType) GetSecretEncodingType() SecretEncodingType {
	if m != nil {
		return m.SecretEncodingType
	}
	return EncodingNone
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SecretType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SecretType_OneofMarshaler, _SecretType_OneofUnmarshaler, _SecretType_OneofSizer, []interface{}{
		(*SecretType_BlindfoldSecretInfo)(nil),
		(*SecretType_VaultSecretInfo)(nil),
		(*SecretType_ClearSecretInfo)(nil),
		(*SecretType_WingmanSecretInfo)(nil),
	}
}

func _SecretType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SecretType)
	// secret_info_oneof
	switch x := m.SecretInfoOneof.(type) {
	case *SecretType_BlindfoldSecretInfo:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BlindfoldSecretInfo); err != nil {
			return err
		}
	case *SecretType_VaultSecretInfo:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VaultSecretInfo); err != nil {
			return err
		}
	case *SecretType_ClearSecretInfo:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClearSecretInfo); err != nil {
			return err
		}
	case *SecretType_WingmanSecretInfo:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WingmanSecretInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SecretType.SecretInfoOneof has unexpected type %T", x)
	}
	return nil
}

func _SecretType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SecretType)
	switch tag {
	case 4: // secret_info_oneof.blindfold_secret_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BlindfoldSecretInfoType)
		err := b.DecodeMessage(msg)
		m.SecretInfoOneof = &SecretType_BlindfoldSecretInfo{msg}
		return true, err
	case 5: // secret_info_oneof.vault_secret_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VaultSecretInfoType)
		err := b.DecodeMessage(msg)
		m.SecretInfoOneof = &SecretType_VaultSecretInfo{msg}
		return true, err
	case 6: // secret_info_oneof.clear_secret_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClearSecretInfoType)
		err := b.DecodeMessage(msg)
		m.SecretInfoOneof = &SecretType_ClearSecretInfo{msg}
		return true, err
	case 7: // secret_info_oneof.wingman_secret_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WingmanSecretInfoType)
		err := b.DecodeMessage(msg)
		m.SecretInfoOneof = &SecretType_WingmanSecretInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SecretType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SecretType)
	// secret_info_oneof
	switch x := m.SecretInfoOneof.(type) {
	case *SecretType_BlindfoldSecretInfo:
		s := proto.Size(x.BlindfoldSecretInfo)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecretType_VaultSecretInfo:
		s := proto.Size(x.VaultSecretInfo)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecretType_ClearSecretInfo:
		s := proto.Size(x.ClearSecretInfo)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecretType_WingmanSecretInfo:
		s := proto.Size(x.WingmanSecretInfo)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// NetworkRefType
//
// x-displayName: "Network Reference"
// This specifies a direct reference to a network configuration object
type NetworkRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A virtual network direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref" json:"ref,omitempty"`
}

func (m *NetworkRefType) Reset()                    { *m = NetworkRefType{} }
func (*NetworkRefType) ProtoMessage()               {}
func (*NetworkRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{27} }

func (m *NetworkRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// SiteRefType
//
// x-displayName: "Site Reference"
// This specifies a direct reference to a site configuration object
type SiteRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A site direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref" json:"ref,omitempty"`
	// network_type
	//
	// x-displayName: "Network Type"
	// The type of network on the referred site
	NetworkType VirtualNetworkType `protobuf:"varint,2,opt,name=network_type,json=networkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"network_type,omitempty"`
}

func (m *SiteRefType) Reset()                    { *m = SiteRefType{} }
func (*SiteRefType) ProtoMessage()               {}
func (*SiteRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{28} }

func (m *SiteRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *SiteRefType) GetNetworkType() VirtualNetworkType {
	if m != nil {
		return m.NetworkType
	}
	return VIRTUAL_NETWORK_SITE_LOCAL
}

// IpPrefixSetRefType
//
// x-displayName: "IP Prefix Set Reference"
// A list of references to ip_prefix_set objects.
type IpPrefixSetRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A list of references to ip_prefix_set objects.
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref" json:"ref,omitempty"`
}

func (m *IpPrefixSetRefType) Reset()                    { *m = IpPrefixSetRefType{} }
func (*IpPrefixSetRefType) ProtoMessage()               {}
func (*IpPrefixSetRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{29} }

func (m *IpPrefixSetRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// VSiteRefType
//
// x-displayName: "Virtual Site"
// A reference to virtual_site object
type VSiteRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A virtual_site direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref" json:"ref,omitempty"`
	// network_type
	//
	// x-displayName: "Network Type"
	// The type of network on the referred virtual_site
	NetworkType VirtualNetworkType `protobuf:"varint,2,opt,name=network_type,json=networkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"network_type,omitempty"`
}

func (m *VSiteRefType) Reset()                    { *m = VSiteRefType{} }
func (*VSiteRefType) ProtoMessage()               {}
func (*VSiteRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{30} }

func (m *VSiteRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *VSiteRefType) GetNetworkType() VirtualNetworkType {
	if m != nil {
		return m.NetworkType
	}
	return VIRTUAL_NETWORK_SITE_LOCAL
}

// PolicerRefType
//
// x-displayName: "Policer Reference"
// Reference to policer object
type PolicerRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A policer direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref" json:"ref,omitempty"`
}

func (m *PolicerRefType) Reset()                    { *m = PolicerRefType{} }
func (*PolicerRefType) ProtoMessage()               {}
func (*PolicerRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{31} }

func (m *PolicerRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// ProtocolPolicerRefType
//
// x-displayName: "Protocol Policer Reference"
// Reference to policer object
type ProtocolPolicerRefType struct {
	// ref
	//
	// x-displayName: "Protocol policer Reference"
	// Reference to protocol policer object
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref" json:"ref,omitempty"`
}

func (m *ProtocolPolicerRefType) Reset()                    { *m = ProtocolPolicerRefType{} }
func (*ProtocolPolicerRefType) ProtoMessage()               {}
func (*ProtocolPolicerRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{32} }

func (m *ProtocolPolicerRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// NetworkSiteRefSelector
//
// x-displayName: "Network or Site Reference"
// NetworkSiteRefSelector defines a union of reference to site or reference to virtual_network  or reference to virtual_site
// It is used to determine virtual network using following rules
//  * Direct reference to virtual_network object
//  * Site local network when refering to site object
//  * All site local networks for sites selected by refering to virtual_site object
type NetworkSiteRefSelector struct {
	// ref_or_selector
	//
	// x-displayName: "Virtual-Site or Site or Network"
	// One of following
	//
	// Types that are valid to be assigned to RefOrSelector:
	//	*NetworkSiteRefSelector_VirtualNetwork
	//	*NetworkSiteRefSelector_Site
	//	*NetworkSiteRefSelector_VirtualSite
	RefOrSelector isNetworkSiteRefSelector_RefOrSelector `protobuf_oneof:"ref_or_selector"`
}

func (m *NetworkSiteRefSelector) Reset()                    { *m = NetworkSiteRefSelector{} }
func (*NetworkSiteRefSelector) ProtoMessage()               {}
func (*NetworkSiteRefSelector) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{33} }

type isNetworkSiteRefSelector_RefOrSelector interface {
	isNetworkSiteRefSelector_RefOrSelector()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NetworkSiteRefSelector_VirtualNetwork struct {
	VirtualNetwork *NetworkRefType `protobuf:"bytes,1,opt,name=virtual_network,json=virtualNetwork,oneof"`
}
type NetworkSiteRefSelector_Site struct {
	Site *SiteRefType `protobuf:"bytes,2,opt,name=site,oneof"`
}
type NetworkSiteRefSelector_VirtualSite struct {
	VirtualSite *VSiteRefType `protobuf:"bytes,3,opt,name=virtual_site,json=virtualSite,oneof"`
}

func (*NetworkSiteRefSelector_VirtualNetwork) isNetworkSiteRefSelector_RefOrSelector() {}
func (*NetworkSiteRefSelector_Site) isNetworkSiteRefSelector_RefOrSelector()           {}
func (*NetworkSiteRefSelector_VirtualSite) isNetworkSiteRefSelector_RefOrSelector()    {}

func (m *NetworkSiteRefSelector) GetRefOrSelector() isNetworkSiteRefSelector_RefOrSelector {
	if m != nil {
		return m.RefOrSelector
	}
	return nil
}

func (m *NetworkSiteRefSelector) GetVirtualNetwork() *NetworkRefType {
	if x, ok := m.GetRefOrSelector().(*NetworkSiteRefSelector_VirtualNetwork); ok {
		return x.VirtualNetwork
	}
	return nil
}

func (m *NetworkSiteRefSelector) GetSite() *SiteRefType {
	if x, ok := m.GetRefOrSelector().(*NetworkSiteRefSelector_Site); ok {
		return x.Site
	}
	return nil
}

func (m *NetworkSiteRefSelector) GetVirtualSite() *VSiteRefType {
	if x, ok := m.GetRefOrSelector().(*NetworkSiteRefSelector_VirtualSite); ok {
		return x.VirtualSite
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NetworkSiteRefSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NetworkSiteRefSelector_OneofMarshaler, _NetworkSiteRefSelector_OneofUnmarshaler, _NetworkSiteRefSelector_OneofSizer, []interface{}{
		(*NetworkSiteRefSelector_VirtualNetwork)(nil),
		(*NetworkSiteRefSelector_Site)(nil),
		(*NetworkSiteRefSelector_VirtualSite)(nil),
	}
}

func _NetworkSiteRefSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NetworkSiteRefSelector)
	// ref_or_selector
	switch x := m.RefOrSelector.(type) {
	case *NetworkSiteRefSelector_VirtualNetwork:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualNetwork); err != nil {
			return err
		}
	case *NetworkSiteRefSelector_Site:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Site); err != nil {
			return err
		}
	case *NetworkSiteRefSelector_VirtualSite:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualSite); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NetworkSiteRefSelector.RefOrSelector has unexpected type %T", x)
	}
	return nil
}

func _NetworkSiteRefSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NetworkSiteRefSelector)
	switch tag {
	case 1: // ref_or_selector.virtual_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NetworkRefType)
		err := b.DecodeMessage(msg)
		m.RefOrSelector = &NetworkSiteRefSelector_VirtualNetwork{msg}
		return true, err
	case 2: // ref_or_selector.site
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SiteRefType)
		err := b.DecodeMessage(msg)
		m.RefOrSelector = &NetworkSiteRefSelector_Site{msg}
		return true, err
	case 3: // ref_or_selector.virtual_site
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VSiteRefType)
		err := b.DecodeMessage(msg)
		m.RefOrSelector = &NetworkSiteRefSelector_VirtualSite{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NetworkSiteRefSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NetworkSiteRefSelector)
	// ref_or_selector
	switch x := m.RefOrSelector.(type) {
	case *NetworkSiteRefSelector_VirtualNetwork:
		s := proto.Size(x.VirtualNetwork)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NetworkSiteRefSelector_Site:
		s := proto.Size(x.Site)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NetworkSiteRefSelector_VirtualSite:
		s := proto.Size(x.VirtualSite)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SiteVirtualSiteRefSelector
//
// x-displayName: "Site or Virtual Site Reference"
// VirtualSiteSiteRefSelector defines a union of reference to site  or reference to virtual_site
// It used to refer site or a group of sites indicated by virtual site.
type SiteVirtualSiteRefSelector struct {
	// ref_or_selector
	//
	// x-displayName: "Direct/Selector Reference"
	// One of following
	//
	// Types that are valid to be assigned to RefOrSelector:
	//	*SiteVirtualSiteRefSelector_Site
	//	*SiteVirtualSiteRefSelector_VirtualSite
	RefOrSelector isSiteVirtualSiteRefSelector_RefOrSelector `protobuf_oneof:"ref_or_selector"`
}

func (m *SiteVirtualSiteRefSelector) Reset()                    { *m = SiteVirtualSiteRefSelector{} }
func (*SiteVirtualSiteRefSelector) ProtoMessage()               {}
func (*SiteVirtualSiteRefSelector) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{34} }

type isSiteVirtualSiteRefSelector_RefOrSelector interface {
	isSiteVirtualSiteRefSelector_RefOrSelector()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteVirtualSiteRefSelector_Site struct {
	Site *SiteRefType `protobuf:"bytes,2,opt,name=site,oneof"`
}
type SiteVirtualSiteRefSelector_VirtualSite struct {
	VirtualSite *VSiteRefType `protobuf:"bytes,3,opt,name=virtual_site,json=virtualSite,oneof"`
}

func (*SiteVirtualSiteRefSelector_Site) isSiteVirtualSiteRefSelector_RefOrSelector()        {}
func (*SiteVirtualSiteRefSelector_VirtualSite) isSiteVirtualSiteRefSelector_RefOrSelector() {}

func (m *SiteVirtualSiteRefSelector) GetRefOrSelector() isSiteVirtualSiteRefSelector_RefOrSelector {
	if m != nil {
		return m.RefOrSelector
	}
	return nil
}

func (m *SiteVirtualSiteRefSelector) GetSite() *SiteRefType {
	if x, ok := m.GetRefOrSelector().(*SiteVirtualSiteRefSelector_Site); ok {
		return x.Site
	}
	return nil
}

func (m *SiteVirtualSiteRefSelector) GetVirtualSite() *VSiteRefType {
	if x, ok := m.GetRefOrSelector().(*SiteVirtualSiteRefSelector_VirtualSite); ok {
		return x.VirtualSite
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SiteVirtualSiteRefSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SiteVirtualSiteRefSelector_OneofMarshaler, _SiteVirtualSiteRefSelector_OneofUnmarshaler, _SiteVirtualSiteRefSelector_OneofSizer, []interface{}{
		(*SiteVirtualSiteRefSelector_Site)(nil),
		(*SiteVirtualSiteRefSelector_VirtualSite)(nil),
	}
}

func _SiteVirtualSiteRefSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SiteVirtualSiteRefSelector)
	// ref_or_selector
	switch x := m.RefOrSelector.(type) {
	case *SiteVirtualSiteRefSelector_Site:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Site); err != nil {
			return err
		}
	case *SiteVirtualSiteRefSelector_VirtualSite:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualSite); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SiteVirtualSiteRefSelector.RefOrSelector has unexpected type %T", x)
	}
	return nil
}

func _SiteVirtualSiteRefSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SiteVirtualSiteRefSelector)
	switch tag {
	case 2: // ref_or_selector.site
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SiteRefType)
		err := b.DecodeMessage(msg)
		m.RefOrSelector = &SiteVirtualSiteRefSelector_Site{msg}
		return true, err
	case 3: // ref_or_selector.virtual_site
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VSiteRefType)
		err := b.DecodeMessage(msg)
		m.RefOrSelector = &SiteVirtualSiteRefSelector_VirtualSite{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SiteVirtualSiteRefSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SiteVirtualSiteRefSelector)
	// ref_or_selector
	switch x := m.RefOrSelector.(type) {
	case *SiteVirtualSiteRefSelector_Site:
		s := proto.Size(x.Site)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SiteVirtualSiteRefSelector_VirtualSite:
		s := proto.Size(x.VirtualSite)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// HeaderManipulationOptionType
//
// x-displayName: "Header Manipulation Option"
// HTTP header is a key-value pair.
// The name acts as key of HTTP header
// The value acts as the data/value of HTTP header
// Example HTTP header
//     Host: user.volterra.com
// In the above example, Host is the name or key of HTTP header
// In the above example, user.volterra.com is the value of HTTP header
type HeaderManipulationOptionType struct {
	// name
	//
	// x-displayName: "Name"
	// x-required
	// Name of the HTTP header.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// value
	//
	// x-displayName: "Value"
	// x-required
	// Value of the HTTP header.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// append
	//
	// x-displayName: "Append"
	// Should the value be appended? If true, the value is appended to existing values.
	// Default value is do not append
	Append bool `protobuf:"varint,3,opt,name=append,proto3" json:"append,omitempty"`
}

func (m *HeaderManipulationOptionType) Reset()      { *m = HeaderManipulationOptionType{} }
func (*HeaderManipulationOptionType) ProtoMessage() {}
func (*HeaderManipulationOptionType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{35}
}

func (m *HeaderManipulationOptionType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderManipulationOptionType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *HeaderManipulationOptionType) GetAppend() bool {
	if m != nil {
		return m.Append
	}
	return false
}

// TlsValidationParamsType
//
// x-displayName: "TLS Certificate Validation Parameters"
// This includes URL for a trust store, whether SAN verification is required
// and list of Subject Alt Names for verification
type TlsValidationParamsType struct {
	// trusted_ca_url
	//
	// x-displayName: "Trusted CA"
	// The URL for a trust store
	TrustedCaUrl string `protobuf:"bytes,1,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"`
	// skip_hostname_verification
	//
	// x-displayName: "Skip verification of hostname"
	// When True, skip verification of hostname i.e. CN/Subject Alt Name of certificate
	// is not matched to the connecting hostname
	SkipHostnameVerification bool `protobuf:"varint,2,opt,name=skip_hostname_verification,json=skipHostnameVerification,proto3" json:"skip_hostname_verification,omitempty"`
	// verify_subject_alt_names
	//
	// x-displayName: "List of SANs for matching"
	// List of acceptable Subject Alt Names/CN in the peer's certificate.
	// When skip_hostname_verification is false and verify_subject_alt_names is empty,
	// the hostname of the peer will be used for matching against SAN/CN of peer's certificate
	VerifySubjectAltNames []string `protobuf:"bytes,3,rep,name=verify_subject_alt_names,json=verifySubjectAltNames" json:"verify_subject_alt_names,omitempty"`
	// use_volterra_trusted_ca_url
	//
	// x-displayName: "Use Volterra trusted CA list for verification of hostname"
	// Ignore the trusted CA URL and use the volterra trusted CA URL from the global config for verification.
	UseVolterraTrustedCaUrl bool `protobuf:"varint,4,opt,name=use_volterra_trusted_ca_url,json=useVolterraTrustedCaUrl,proto3" json:"use_volterra_trusted_ca_url,omitempty"`
}

func (m *TlsValidationParamsType) Reset()                    { *m = TlsValidationParamsType{} }
func (*TlsValidationParamsType) ProtoMessage()               {}
func (*TlsValidationParamsType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{36} }

func (m *TlsValidationParamsType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

func (m *TlsValidationParamsType) GetSkipHostnameVerification() bool {
	if m != nil {
		return m.SkipHostnameVerification
	}
	return false
}

func (m *TlsValidationParamsType) GetVerifySubjectAltNames() []string {
	if m != nil {
		return m.VerifySubjectAltNames
	}
	return nil
}

func (m *TlsValidationParamsType) GetUseVolterraTrustedCaUrl() bool {
	if m != nil {
		return m.UseVolterraTrustedCaUrl
	}
	return false
}

// TlsCertificateType
//
// x-displayName: "TLS Certificate"
// Handle to fetch certificate and key
type TlsCertificateType struct {
	// certificate_url
	//
	// x-displayName: "Certificate URL"
	// x-required
	// TLS certificate.
	// Certificate or certificate chain in PEM format including the PEM headers.
	CertificateUrl string `protobuf:"bytes,1,opt,name=certificate_url,json=certificateUrl,proto3" json:"certificate_url,omitempty"`
	// private_key
	//
	// x-displayName: "Private Key"
	// x-required
	// TLS Private Key data in unencrypted PEM format including the PEM headers. The data may be optionally secured using BlindFold. TLS key has to match the accompanying certificate.
	PrivateKey *SecretType `protobuf:"bytes,4,opt,name=private_key,json=privateKey" json:"private_key,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// Description for the certificate
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *TlsCertificateType) Reset()                    { *m = TlsCertificateType{} }
func (*TlsCertificateType) ProtoMessage()               {}
func (*TlsCertificateType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{37} }

func (m *TlsCertificateType) GetCertificateUrl() string {
	if m != nil {
		return m.CertificateUrl
	}
	return ""
}

func (m *TlsCertificateType) GetPrivateKey() *SecretType {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *TlsCertificateType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// TlsParamsType
//
// x-displayName: "TLS Parameters"
// Information of different aspects for TLS authentication related to ciphers,
// certificates and trust store
type TlsParamsType struct {
	// minimum_protocol_version
	//
	// x-displayName: "Minimum TLS Version"
	// Minimum TLS protocol version.
	MinimumProtocolVersion TlsProtocol `protobuf:"varint,1,opt,name=minimum_protocol_version,json=minimumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"minimum_protocol_version,omitempty"`
	// maximum_protocol_version
	//
	// x-displayName: "Maximum TLS Version"
	// Maximum TLS protocol version.
	MaximumProtocolVersion TlsProtocol `protobuf:"varint,2,opt,name=maximum_protocol_version,json=maximumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"maximum_protocol_version,omitempty"`
	// cipher_suites
	//
	// x-displayName: "Cipher Suites"
	// The following list specifies the supported cipher suite
	//   TLS_AES_128_GCM_SHA256
	//   TLS_AES_256_GCM_SHA384
	//   TLS_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
	//   TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
	//   TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
	//   TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	//   TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
	//   TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
	//   TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
	//   TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
	//   TLS_RSA_WITH_AES_128_CBC_SHA
	//   TLS_RSA_WITH_AES_128_GCM_SHA256
	//   TLS_RSA_WITH_AES_256_CBC_SHA
	//   TLS_RSA_WITH_AES_256_GCM_SHA384
	//
	// If not specified, the default list:
	//   TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
	//   TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
	//   TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
	//   TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	// will be used.
	CipherSuites []string `protobuf:"bytes,3,rep,name=cipher_suites,json=cipherSuites" json:"cipher_suites,omitempty"`
	// tls_certificates
	//
	// x-displayName: "TLS Certificates"
	// Set of TLS certificates
	TlsCertificates []*TlsCertificateType `protobuf:"bytes,4,rep,name=tls_certificates,json=tlsCertificates" json:"tls_certificates,omitempty"`
	// trusted_ca_url
	//
	// x-displayName: "Trusted CA"
	// The URL or value for trusted CA certificates
	// Certificates in PEM format including the PEM headers.
	TrustedCaUrl string `protobuf:"bytes,5,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"`
	// validation_params
	//
	// x-displayName: "Trusted CA Validation params"
	// This includes URL for a trust store, whether SAN verification is required
	// and list of Subject Alt Names for verification
	ValidationParams *TlsValidationParamsType `protobuf:"bytes,7,opt,name=validation_params,json=validationParams" json:"validation_params,omitempty"`
}

func (m *TlsParamsType) Reset()                    { *m = TlsParamsType{} }
func (*TlsParamsType) ProtoMessage()               {}
func (*TlsParamsType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{38} }

func (m *TlsParamsType) GetMinimumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MinimumProtocolVersion
	}
	return TLS_AUTO
}

func (m *TlsParamsType) GetMaximumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MaximumProtocolVersion
	}
	return TLS_AUTO
}

func (m *TlsParamsType) GetCipherSuites() []string {
	if m != nil {
		return m.CipherSuites
	}
	return nil
}

func (m *TlsParamsType) GetTlsCertificates() []*TlsCertificateType {
	if m != nil {
		return m.TlsCertificates
	}
	return nil
}

func (m *TlsParamsType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

func (m *TlsParamsType) GetValidationParams() *TlsValidationParamsType {
	if m != nil {
		return m.ValidationParams
	}
	return nil
}

// UpstreamTlsParamsType
//
// x-displayName: "Upstream TLS Parameters"
// TLS configuration for upstream connections
type UpstreamTlsParamsType struct {
	// common_params
	//
	// x-displayName: "Common Parameters"
	// Common TLS parameters used in both upstream and downstream connections
	CommonParams *TlsParamsType `protobuf:"bytes,1,opt,name=common_params,json=commonParams" json:"common_params,omitempty"`
	// sni choice
	//
	// x-displayName: "SNI Selection"
	// x-required
	// SNI to be used while connecting to upstream service.
	//
	// Types that are valid to be assigned to SniChoice:
	//	*UpstreamTlsParamsType_Sni
	//	*UpstreamTlsParamsType_UseHostHeaderAsSni
	//	*UpstreamTlsParamsType_DisableSni
	SniChoice isUpstreamTlsParamsType_SniChoice `protobuf_oneof:"sni_choice"`
}

func (m *UpstreamTlsParamsType) Reset()                    { *m = UpstreamTlsParamsType{} }
func (*UpstreamTlsParamsType) ProtoMessage()               {}
func (*UpstreamTlsParamsType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{39} }

type isUpstreamTlsParamsType_SniChoice interface {
	isUpstreamTlsParamsType_SniChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type UpstreamTlsParamsType_Sni struct {
	Sni string `protobuf:"bytes,2,opt,name=sni,proto3,oneof"`
}
type UpstreamTlsParamsType_UseHostHeaderAsSni struct {
	UseHostHeaderAsSni *Empty `protobuf:"bytes,3,opt,name=use_host_header_as_sni,json=useHostHeaderAsSni,oneof"`
}
type UpstreamTlsParamsType_DisableSni struct {
	DisableSni *Empty `protobuf:"bytes,4,opt,name=disable_sni,json=disableSni,oneof"`
}

func (*UpstreamTlsParamsType_Sni) isUpstreamTlsParamsType_SniChoice()                {}
func (*UpstreamTlsParamsType_UseHostHeaderAsSni) isUpstreamTlsParamsType_SniChoice() {}
func (*UpstreamTlsParamsType_DisableSni) isUpstreamTlsParamsType_SniChoice()         {}

func (m *UpstreamTlsParamsType) GetSniChoice() isUpstreamTlsParamsType_SniChoice {
	if m != nil {
		return m.SniChoice
	}
	return nil
}

func (m *UpstreamTlsParamsType) GetCommonParams() *TlsParamsType {
	if m != nil {
		return m.CommonParams
	}
	return nil
}

func (m *UpstreamTlsParamsType) GetSni() string {
	if x, ok := m.GetSniChoice().(*UpstreamTlsParamsType_Sni); ok {
		return x.Sni
	}
	return ""
}

func (m *UpstreamTlsParamsType) GetUseHostHeaderAsSni() *Empty {
	if x, ok := m.GetSniChoice().(*UpstreamTlsParamsType_UseHostHeaderAsSni); ok {
		return x.UseHostHeaderAsSni
	}
	return nil
}

func (m *UpstreamTlsParamsType) GetDisableSni() *Empty {
	if x, ok := m.GetSniChoice().(*UpstreamTlsParamsType_DisableSni); ok {
		return x.DisableSni
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UpstreamTlsParamsType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UpstreamTlsParamsType_OneofMarshaler, _UpstreamTlsParamsType_OneofUnmarshaler, _UpstreamTlsParamsType_OneofSizer, []interface{}{
		(*UpstreamTlsParamsType_Sni)(nil),
		(*UpstreamTlsParamsType_UseHostHeaderAsSni)(nil),
		(*UpstreamTlsParamsType_DisableSni)(nil),
	}
}

func _UpstreamTlsParamsType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UpstreamTlsParamsType)
	// sni_choice
	switch x := m.SniChoice.(type) {
	case *UpstreamTlsParamsType_Sni:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Sni)
	case *UpstreamTlsParamsType_UseHostHeaderAsSni:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UseHostHeaderAsSni); err != nil {
			return err
		}
	case *UpstreamTlsParamsType_DisableSni:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DisableSni); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("UpstreamTlsParamsType.SniChoice has unexpected type %T", x)
	}
	return nil
}

func _UpstreamTlsParamsType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UpstreamTlsParamsType)
	switch tag {
	case 2: // sni_choice.sni
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.SniChoice = &UpstreamTlsParamsType_Sni{x}
		return true, err
	case 3: // sni_choice.use_host_header_as_sni
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.SniChoice = &UpstreamTlsParamsType_UseHostHeaderAsSni{msg}
		return true, err
	case 4: // sni_choice.disable_sni
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.SniChoice = &UpstreamTlsParamsType_DisableSni{msg}
		return true, err
	default:
		return false, nil
	}
}

func _UpstreamTlsParamsType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UpstreamTlsParamsType)
	// sni_choice
	switch x := m.SniChoice.(type) {
	case *UpstreamTlsParamsType_Sni:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Sni)))
		n += len(x.Sni)
	case *UpstreamTlsParamsType_UseHostHeaderAsSni:
		s := proto.Size(x.UseHostHeaderAsSni)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UpstreamTlsParamsType_DisableSni:
		s := proto.Size(x.DisableSni)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DownstreamTlsParamsType
//
// x-displayName: "Downstream TLS Parameters"
// TLS configuration for downstream connections
type DownstreamTlsParamsType struct {
	// common_params
	//
	// x-displayName: "Common Parameters"
	// Common TLS parameters used in both upstream and downstream connections
	CommonParams *TlsParamsType `protobuf:"bytes,1,opt,name=common_params,json=commonParams" json:"common_params,omitempty"`
	// require_client_certificate
	//
	// x-displayName: "Require Client Certificate(enable mTLS)"
	// If true, Volterra will reject connections without a valid client
	// certificate.
	RequireClientCertificate bool `protobuf:"varint,4,opt,name=require_client_certificate,json=requireClientCertificate,proto3" json:"require_client_certificate,omitempty"`
}

func (m *DownstreamTlsParamsType) Reset()                    { *m = DownstreamTlsParamsType{} }
func (*DownstreamTlsParamsType) ProtoMessage()               {}
func (*DownstreamTlsParamsType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{40} }

func (m *DownstreamTlsParamsType) GetCommonParams() *TlsParamsType {
	if m != nil {
		return m.CommonParams
	}
	return nil
}

func (m *DownstreamTlsParamsType) GetRequireClientCertificate() bool {
	if m != nil {
		return m.RequireClientCertificate
	}
	return false
}

// Domains
//
// x-displayName: "Domains"
// Domains names
type DomainType struct {
	//  Domain choice
	//
	// x-displayName: "Enter Domain"
	// x-required
	// Method to specify domain part in SNI for TLS connections
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*DomainType_ExactValue
	//	*DomainType_SuffixValue
	//	*DomainType_RegexValue
	DomainChoice isDomainType_DomainChoice `protobuf_oneof:"domain_choice"`
}

func (m *DomainType) Reset()                    { *m = DomainType{} }
func (*DomainType) ProtoMessage()               {}
func (*DomainType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{41} }

type isDomainType_DomainChoice interface {
	isDomainType_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DomainType_ExactValue struct {
	ExactValue string `protobuf:"bytes,1,opt,name=exact_value,json=exactValue,proto3,oneof"`
}
type DomainType_SuffixValue struct {
	SuffixValue string `protobuf:"bytes,2,opt,name=suffix_value,json=suffixValue,proto3,oneof"`
}
type DomainType_RegexValue struct {
	RegexValue string `protobuf:"bytes,3,opt,name=regex_value,json=regexValue,proto3,oneof"`
}

func (*DomainType_ExactValue) isDomainType_DomainChoice()  {}
func (*DomainType_SuffixValue) isDomainType_DomainChoice() {}
func (*DomainType_RegexValue) isDomainType_DomainChoice()  {}

func (m *DomainType) GetDomainChoice() isDomainType_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *DomainType) GetExactValue() string {
	if x, ok := m.GetDomainChoice().(*DomainType_ExactValue); ok {
		return x.ExactValue
	}
	return ""
}

func (m *DomainType) GetSuffixValue() string {
	if x, ok := m.GetDomainChoice().(*DomainType_SuffixValue); ok {
		return x.SuffixValue
	}
	return ""
}

func (m *DomainType) GetRegexValue() string {
	if x, ok := m.GetDomainChoice().(*DomainType_RegexValue); ok {
		return x.RegexValue
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DomainType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DomainType_OneofMarshaler, _DomainType_OneofUnmarshaler, _DomainType_OneofSizer, []interface{}{
		(*DomainType_ExactValue)(nil),
		(*DomainType_SuffixValue)(nil),
		(*DomainType_RegexValue)(nil),
	}
}

func _DomainType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DomainType)
	// domain_choice
	switch x := m.DomainChoice.(type) {
	case *DomainType_ExactValue:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ExactValue)
	case *DomainType_SuffixValue:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.SuffixValue)
	case *DomainType_RegexValue:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.RegexValue)
	case nil:
	default:
		return fmt.Errorf("DomainType.DomainChoice has unexpected type %T", x)
	}
	return nil
}

func _DomainType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DomainType)
	switch tag {
	case 1: // domain_choice.exact_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DomainChoice = &DomainType_ExactValue{x}
		return true, err
	case 2: // domain_choice.suffix_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DomainChoice = &DomainType_SuffixValue{x}
		return true, err
	case 3: // domain_choice.regex_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DomainChoice = &DomainType_RegexValue{x}
		return true, err
	default:
		return false, nil
	}
}

func _DomainType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DomainType)
	// domain_choice
	switch x := m.DomainChoice.(type) {
	case *DomainType_ExactValue:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ExactValue)))
		n += len(x.ExactValue)
	case *DomainType_SuffixValue:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SuffixValue)))
		n += len(x.SuffixValue)
	case *DomainType_RegexValue:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.RegexValue)))
		n += len(x.RegexValue)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// L4 Dest Type
//
// x-displayName: "L4 Destination"
// L4 Destination consisting of IPv4 Prefixes and TCP Port Range
type L4DestType struct {
	// prefixes
	//
	// x-displayName: "IPv4 Prefixes"
	// x-required
	// Destination IPv4 prefixes.
	Prefixes []string `protobuf:"bytes,1,rep,name=prefixes" json:"prefixes,omitempty"`
	// port_ranges
	//
	// x-displayName: "Port Ranges"
	// x-example: "80,443,8080-8191,9080"
	// A string containing a comma separated list of port ranges.
	// Each port range consists of a single port or two ports separated by "-".
	PortRanges string `protobuf:"bytes,2,opt,name=port_ranges,json=portRanges,proto3" json:"port_ranges,omitempty"`
}

func (m *L4DestType) Reset()                    { *m = L4DestType{} }
func (*L4DestType) ProtoMessage()               {}
func (*L4DestType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{42} }

func (m *L4DestType) GetPrefixes() []string {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

func (m *L4DestType) GetPortRanges() string {
	if m != nil {
		return m.PortRanges
	}
	return ""
}

// TlsInterceptionRule
//
// x-displayName: "TLS Interception Rule"
// x-required
// Rule to enable or disable TLS interception based on domain match
type TlsInterceptionRule struct {
	// Domain Match
	//
	// x-displayName: "Match Domain"
	// x-required
	// Domain value or regular expression to match
	DomainMatch *DomainType `protobuf:"bytes,1,opt,name=domain_match,json=domainMatch" json:"domain_match,omitempty"`
	// Enable/Disable Interception
	//
	// x-displayName: "Enable/Disable Interception"
	// x-required
	// Enable or disable interception for the domain
	//
	// Types that are valid to be assigned to EnableDisableChoice:
	//	*TlsInterceptionRule_DisableInterception
	//	*TlsInterceptionRule_EnableInterception
	EnableDisableChoice isTlsInterceptionRule_EnableDisableChoice `protobuf_oneof:"enable_disable_choice"`
}

func (m *TlsInterceptionRule) Reset()                    { *m = TlsInterceptionRule{} }
func (*TlsInterceptionRule) ProtoMessage()               {}
func (*TlsInterceptionRule) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{43} }

type isTlsInterceptionRule_EnableDisableChoice interface {
	isTlsInterceptionRule_EnableDisableChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TlsInterceptionRule_DisableInterception struct {
	DisableInterception *Empty `protobuf:"bytes,3,opt,name=disable_interception,json=disableInterception,oneof"`
}
type TlsInterceptionRule_EnableInterception struct {
	EnableInterception *Empty `protobuf:"bytes,4,opt,name=enable_interception,json=enableInterception,oneof"`
}

func (*TlsInterceptionRule_DisableInterception) isTlsInterceptionRule_EnableDisableChoice() {}
func (*TlsInterceptionRule_EnableInterception) isTlsInterceptionRule_EnableDisableChoice()  {}

func (m *TlsInterceptionRule) GetEnableDisableChoice() isTlsInterceptionRule_EnableDisableChoice {
	if m != nil {
		return m.EnableDisableChoice
	}
	return nil
}

func (m *TlsInterceptionRule) GetDomainMatch() *DomainType {
	if m != nil {
		return m.DomainMatch
	}
	return nil
}

func (m *TlsInterceptionRule) GetDisableInterception() *Empty {
	if x, ok := m.GetEnableDisableChoice().(*TlsInterceptionRule_DisableInterception); ok {
		return x.DisableInterception
	}
	return nil
}

func (m *TlsInterceptionRule) GetEnableInterception() *Empty {
	if x, ok := m.GetEnableDisableChoice().(*TlsInterceptionRule_EnableInterception); ok {
		return x.EnableInterception
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TlsInterceptionRule) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TlsInterceptionRule_OneofMarshaler, _TlsInterceptionRule_OneofUnmarshaler, _TlsInterceptionRule_OneofSizer, []interface{}{
		(*TlsInterceptionRule_DisableInterception)(nil),
		(*TlsInterceptionRule_EnableInterception)(nil),
	}
}

func _TlsInterceptionRule_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TlsInterceptionRule)
	// enable_disable_choice
	switch x := m.EnableDisableChoice.(type) {
	case *TlsInterceptionRule_DisableInterception:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DisableInterception); err != nil {
			return err
		}
	case *TlsInterceptionRule_EnableInterception:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableInterception); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TlsInterceptionRule.EnableDisableChoice has unexpected type %T", x)
	}
	return nil
}

func _TlsInterceptionRule_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TlsInterceptionRule)
	switch tag {
	case 3: // enable_disable_choice.disable_interception
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.EnableDisableChoice = &TlsInterceptionRule_DisableInterception{msg}
		return true, err
	case 4: // enable_disable_choice.enable_interception
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.EnableDisableChoice = &TlsInterceptionRule_EnableInterception{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TlsInterceptionRule_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TlsInterceptionRule)
	// enable_disable_choice
	switch x := m.EnableDisableChoice.(type) {
	case *TlsInterceptionRule_DisableInterception:
		s := proto.Size(x.DisableInterception)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TlsInterceptionRule_EnableInterception:
		s := proto.Size(x.EnableInterception)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TlsInterceptionPolicy
//
// x-displayName: "TLS Interception Policy"
// Policy to enable or disable TLS interception.
type TlsInterceptionPolicy struct {
	// Interception Rules
	//
	// x-displayName: "TLS Interception Rules"
	// x-required
	// List of ordered rules to enable or disable for TLS interception
	InterceptionRules []*TlsInterceptionRule `protobuf:"bytes,1,rep,name=interception_rules,json=interceptionRules" json:"interception_rules,omitempty"`
}

func (m *TlsInterceptionPolicy) Reset()                    { *m = TlsInterceptionPolicy{} }
func (*TlsInterceptionPolicy) ProtoMessage()               {}
func (*TlsInterceptionPolicy) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{44} }

func (m *TlsInterceptionPolicy) GetInterceptionRules() []*TlsInterceptionRule {
	if m != nil {
		return m.InterceptionRules
	}
	return nil
}

// TlsInterceptionType
//
// x-displayName: "Configuration for TLS interception"
// Configuration to enable TLS interception
type TlsInterceptionType struct {
	// Interception Policy
	//
	// x-displayName: "Interception Policy"
	// x-required
	// Interception policy choice - enable for all domains or custom policies
	//
	// Types that are valid to be assigned to InterceptionPolicyChoice:
	//	*TlsInterceptionType_EnableForAllDomains
	//	*TlsInterceptionType_Policy
	InterceptionPolicyChoice isTlsInterceptionType_InterceptionPolicyChoice `protobuf_oneof:"interception_policy_choice"`
	// Signing Certificate
	//
	// x-displayName: "Select Signing Certificate"
	// x-required
	// Certificate used to generate intermediate certificate for interception
	//
	// Types that are valid to be assigned to SigningCertChoice:
	//	*TlsInterceptionType_CustomCertificate
	//	*TlsInterceptionType_VolterraCertificate
	SigningCertChoice isTlsInterceptionType_SigningCertChoice `protobuf_oneof:"signing_cert_choice"`
	// Trusted CA List
	//
	// x-displayName: "Select Trusted CA List"
	// x-required
	// Select Trusted CA list for upstream connection
	//
	// Types that are valid to be assigned to TrustedCaChoice:
	//	*TlsInterceptionType_TrustedCaUrl
	//	*TlsInterceptionType_VolterraTrustedCa
	TrustedCaChoice isTlsInterceptionType_TrustedCaChoice `protobuf_oneof:"trusted_ca_choice"`
}

func (m *TlsInterceptionType) Reset()                    { *m = TlsInterceptionType{} }
func (*TlsInterceptionType) ProtoMessage()               {}
func (*TlsInterceptionType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{45} }

type isTlsInterceptionType_InterceptionPolicyChoice interface {
	isTlsInterceptionType_InterceptionPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTlsInterceptionType_SigningCertChoice interface {
	isTlsInterceptionType_SigningCertChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTlsInterceptionType_TrustedCaChoice interface {
	isTlsInterceptionType_TrustedCaChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TlsInterceptionType_EnableForAllDomains struct {
	EnableForAllDomains *Empty `protobuf:"bytes,9,opt,name=enable_for_all_domains,json=enableForAllDomains,oneof"`
}
type TlsInterceptionType_Policy struct {
	Policy *TlsInterceptionPolicy `protobuf:"bytes,1,opt,name=policy,oneof"`
}
type TlsInterceptionType_CustomCertificate struct {
	CustomCertificate *TlsCertificateType `protobuf:"bytes,3,opt,name=custom_certificate,json=customCertificate,oneof"`
}
type TlsInterceptionType_VolterraCertificate struct {
	VolterraCertificate *Empty `protobuf:"bytes,4,opt,name=volterra_certificate,json=volterraCertificate,oneof"`
}
type TlsInterceptionType_TrustedCaUrl struct {
	TrustedCaUrl string `protobuf:"bytes,6,opt,name=trusted_ca_url,json=trustedCaUrl,proto3,oneof"`
}
type TlsInterceptionType_VolterraTrustedCa struct {
	VolterraTrustedCa *Empty `protobuf:"bytes,7,opt,name=volterra_trusted_ca,json=volterraTrustedCa,oneof"`
}

func (*TlsInterceptionType_EnableForAllDomains) isTlsInterceptionType_InterceptionPolicyChoice() {}
func (*TlsInterceptionType_Policy) isTlsInterceptionType_InterceptionPolicyChoice()              {}
func (*TlsInterceptionType_CustomCertificate) isTlsInterceptionType_SigningCertChoice()          {}
func (*TlsInterceptionType_VolterraCertificate) isTlsInterceptionType_SigningCertChoice()        {}
func (*TlsInterceptionType_TrustedCaUrl) isTlsInterceptionType_TrustedCaChoice()                 {}
func (*TlsInterceptionType_VolterraTrustedCa) isTlsInterceptionType_TrustedCaChoice()            {}

func (m *TlsInterceptionType) GetInterceptionPolicyChoice() isTlsInterceptionType_InterceptionPolicyChoice {
	if m != nil {
		return m.InterceptionPolicyChoice
	}
	return nil
}
func (m *TlsInterceptionType) GetSigningCertChoice() isTlsInterceptionType_SigningCertChoice {
	if m != nil {
		return m.SigningCertChoice
	}
	return nil
}
func (m *TlsInterceptionType) GetTrustedCaChoice() isTlsInterceptionType_TrustedCaChoice {
	if m != nil {
		return m.TrustedCaChoice
	}
	return nil
}

func (m *TlsInterceptionType) GetEnableForAllDomains() *Empty {
	if x, ok := m.GetInterceptionPolicyChoice().(*TlsInterceptionType_EnableForAllDomains); ok {
		return x.EnableForAllDomains
	}
	return nil
}

func (m *TlsInterceptionType) GetPolicy() *TlsInterceptionPolicy {
	if x, ok := m.GetInterceptionPolicyChoice().(*TlsInterceptionType_Policy); ok {
		return x.Policy
	}
	return nil
}

func (m *TlsInterceptionType) GetCustomCertificate() *TlsCertificateType {
	if x, ok := m.GetSigningCertChoice().(*TlsInterceptionType_CustomCertificate); ok {
		return x.CustomCertificate
	}
	return nil
}

func (m *TlsInterceptionType) GetVolterraCertificate() *Empty {
	if x, ok := m.GetSigningCertChoice().(*TlsInterceptionType_VolterraCertificate); ok {
		return x.VolterraCertificate
	}
	return nil
}

func (m *TlsInterceptionType) GetTrustedCaUrl() string {
	if x, ok := m.GetTrustedCaChoice().(*TlsInterceptionType_TrustedCaUrl); ok {
		return x.TrustedCaUrl
	}
	return ""
}

func (m *TlsInterceptionType) GetVolterraTrustedCa() *Empty {
	if x, ok := m.GetTrustedCaChoice().(*TlsInterceptionType_VolterraTrustedCa); ok {
		return x.VolterraTrustedCa
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TlsInterceptionType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TlsInterceptionType_OneofMarshaler, _TlsInterceptionType_OneofUnmarshaler, _TlsInterceptionType_OneofSizer, []interface{}{
		(*TlsInterceptionType_EnableForAllDomains)(nil),
		(*TlsInterceptionType_Policy)(nil),
		(*TlsInterceptionType_CustomCertificate)(nil),
		(*TlsInterceptionType_VolterraCertificate)(nil),
		(*TlsInterceptionType_TrustedCaUrl)(nil),
		(*TlsInterceptionType_VolterraTrustedCa)(nil),
	}
}

func _TlsInterceptionType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TlsInterceptionType)
	// interception_policy_choice
	switch x := m.InterceptionPolicyChoice.(type) {
	case *TlsInterceptionType_EnableForAllDomains:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableForAllDomains); err != nil {
			return err
		}
	case *TlsInterceptionType_Policy:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Policy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TlsInterceptionType.InterceptionPolicyChoice has unexpected type %T", x)
	}
	// signing_cert_choice
	switch x := m.SigningCertChoice.(type) {
	case *TlsInterceptionType_CustomCertificate:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomCertificate); err != nil {
			return err
		}
	case *TlsInterceptionType_VolterraCertificate:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VolterraCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TlsInterceptionType.SigningCertChoice has unexpected type %T", x)
	}
	// trusted_ca_choice
	switch x := m.TrustedCaChoice.(type) {
	case *TlsInterceptionType_TrustedCaUrl:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.TrustedCaUrl)
	case *TlsInterceptionType_VolterraTrustedCa:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VolterraTrustedCa); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TlsInterceptionType.TrustedCaChoice has unexpected type %T", x)
	}
	return nil
}

func _TlsInterceptionType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TlsInterceptionType)
	switch tag {
	case 9: // interception_policy_choice.enable_for_all_domains
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.InterceptionPolicyChoice = &TlsInterceptionType_EnableForAllDomains{msg}
		return true, err
	case 1: // interception_policy_choice.policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsInterceptionPolicy)
		err := b.DecodeMessage(msg)
		m.InterceptionPolicyChoice = &TlsInterceptionType_Policy{msg}
		return true, err
	case 3: // signing_cert_choice.custom_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsCertificateType)
		err := b.DecodeMessage(msg)
		m.SigningCertChoice = &TlsInterceptionType_CustomCertificate{msg}
		return true, err
	case 4: // signing_cert_choice.volterra_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.SigningCertChoice = &TlsInterceptionType_VolterraCertificate{msg}
		return true, err
	case 6: // trusted_ca_choice.trusted_ca_url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.TrustedCaChoice = &TlsInterceptionType_TrustedCaUrl{x}
		return true, err
	case 7: // trusted_ca_choice.volterra_trusted_ca
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.TrustedCaChoice = &TlsInterceptionType_VolterraTrustedCa{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TlsInterceptionType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TlsInterceptionType)
	// interception_policy_choice
	switch x := m.InterceptionPolicyChoice.(type) {
	case *TlsInterceptionType_EnableForAllDomains:
		s := proto.Size(x.EnableForAllDomains)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TlsInterceptionType_Policy:
		s := proto.Size(x.Policy)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// signing_cert_choice
	switch x := m.SigningCertChoice.(type) {
	case *TlsInterceptionType_CustomCertificate:
		s := proto.Size(x.CustomCertificate)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TlsInterceptionType_VolterraCertificate:
		s := proto.Size(x.VolterraCertificate)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// trusted_ca_choice
	switch x := m.TrustedCaChoice.(type) {
	case *TlsInterceptionType_TrustedCaUrl:
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.TrustedCaUrl)))
		n += len(x.TrustedCaUrl)
	case *TlsInterceptionType_VolterraTrustedCa:
		s := proto.Size(x.VolterraTrustedCa)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FractionalPercent
//
// x-displayName: "Fractional Percent"
// Fraction used where sampling percentages are needed. example sampled requests
type FractionalPercent struct {
	// numerator
	//
	// x-displayName: "Numerator"
	// x-required
	// x-example: "5"
	// sampled parts per denominator. If denominator was 10000, then value of 5 will be 5 in 10000
	Numerator uint32 `protobuf:"varint,1,opt,name=numerator,proto3" json:"numerator,omitempty"`
	// denominator
	//
	// x-displayName: "Denominator"
	// x-required
	// Samples per denominator. numerator part per 100 or 10000 ro 1000000
	Denominator DenominatorType `protobuf:"varint,2,opt,name=denominator,proto3,enum=ves.io.schema.DenominatorType" json:"denominator,omitempty"`
}

func (m *FractionalPercent) Reset()                    { *m = FractionalPercent{} }
func (*FractionalPercent) ProtoMessage()               {}
func (*FractionalPercent) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{46} }

func (m *FractionalPercent) GetNumerator() uint32 {
	if m != nil {
		return m.Numerator
	}
	return 0
}

func (m *FractionalPercent) GetDenominator() DenominatorType {
	if m != nil {
		return m.Denominator
	}
	return HUNDRED
}

// BufferConfigType
//
// x-displayName: "Buffer Configuration"
// Some upstream applications are not capable of handling streamed data. This config
// enables buffering the entire request before sending to upstream application. We can
// specify the maximum buffer size and buffer interval with this config.
//
// Buffering can be enabled and disabled at VirtualHost and Route levels
// Route level buffer configuration takes precedence.
type BufferConfigType struct {
	// disable
	//
	// x-displayName: "Disable"
	// Disable buffering for a particular route. This is useful when virtual-host
	// has buffering, but we need to disable it on a specific route.
	// The value of this field is ignored for virtual-host
	Disabled bool `protobuf:"varint,1,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// max_request_bytes
	//
	// x-displayName: "Max Request Bytes"
	// x-example: "2048"
	// The maximum request size that the filter will buffer before the connection
	// manager will stop buffering and return a RequestEntityTooLarge (413) response.
	MaxRequestBytes uint32 `protobuf:"varint,2,opt,name=max_request_bytes,json=maxRequestBytes,proto3" json:"max_request_bytes,omitempty"`
	// max_request_time
	//
	// x-displayName: "Max Request Time"
	// x-example: "30"
	// The maximum number of seconds that the filter will wait for a complete
	// request before returning a RequestTimeout (408) response
	MaxRequestTime uint32 `protobuf:"varint,3,opt,name=max_request_time,json=maxRequestTime,proto3" json:"max_request_time,omitempty"`
}

func (m *BufferConfigType) Reset()                    { *m = BufferConfigType{} }
func (*BufferConfigType) ProtoMessage()               {}
func (*BufferConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{47} }

func (m *BufferConfigType) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *BufferConfigType) GetMaxRequestBytes() uint32 {
	if m != nil {
		return m.MaxRequestBytes
	}
	return 0
}

func (m *BufferConfigType) GetMaxRequestTime() uint32 {
	if m != nil {
		return m.MaxRequestTime
	}
	return 0
}

// CorsPolicy
//
// x-displayName: "CORS Policy"
// Cross-Origin Resource Sharing requests configuration specified at Virtual-host or
// Route level. Route level configuration takes precedence.
//
// An example of an Cross origin HTTP request
//     GET /resources/public-data/ HTTP/1.1
//     Host: bar.other
//     User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
//     Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
//     Accept-Language: en-us,en;q=0.5
//     Accept-Encoding: gzip,deflate
//     Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
//     Connection: keep-alive
//     Referrer: http://foo.example/examples/access-control/simpleXSInvocation.html
//     Origin: http://foo.example
//
//
//     HTTP/1.1 200 OK
//     Date: Mon, 01 Dec 2008 00:23:53 GMT
//     Server: Apache/2.0.61
//     Access-Control-Allow-Origin: *
//     Keep-Alive: timeout=2, max=100
//     Connection: Keep-Alive
//     Transfer-Encoding: chunked
//     Content-Type: application/xml
//
// An example for cross origin HTTP OPTIONS request with Access-Control-Request-* header
//
//     OPTIONS /resources/post-here/ HTTP/1.1
//     Host: bar.other
//     User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
//     Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
//     Accept-Language: en-us,en;q=0.5
//     Accept-Encoding: gzip,deflate
//     Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
//     Connection: keep-alive
//     Origin: http://foo.example
//     Access-Control-Request-Method: POST
//     Access-Control-Request-Headers: X-PINGOTHER, Content-Type
//
//
//     HTTP/1.1 204 No Content
//     Date: Mon, 01 Dec 2008 01:15:39 GMT
//     Server: Apache/2.0.61 (Unix)
//     Access-Control-Allow-Origin: http://foo.example
//     Access-Control-Allow-Methods: POST, GET, OPTIONS
//     Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
//     Access-Control-Max-Age: 86400
//     Vary: Accept-Encoding, Origin
//     Keep-Alive: timeout=2, max=100
//     Connection: Keep-Alive
type CorsPolicy struct {
	// disabled
	//
	// x-displayName: "Disabled"
	// Disable the CorsPolicy for a particular route. This is useful when
	// virtual-host has CorsPolicy, but we need to disable it on a specific route.
	// The value of this field is ignored for virtual-host
	Disabled bool `protobuf:"varint,1,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// allow_origin
	//
	// x-displayName: "Allow Origin"
	// Specifies the origins that will be allowed to do CORS requests.
	// An origin is allowed if either allow_origin or allow_origin_regex match
	AllowOrigin []string `protobuf:"bytes,2,rep,name=allow_origin,json=allowOrigin" json:"allow_origin,omitempty"`
	// allow_origin_regex
	//
	// x-displayName: "Allow Origin Regex"
	// Specifies regex patterns that match allowed origins.
	// An origin is allowed if either allow_origin or allow_origin_regex match
	AllowOriginRegex []string `protobuf:"bytes,3,rep,name=allow_origin_regex,json=allowOriginRegex" json:"allow_origin_regex,omitempty"`
	// allow_methods
	//
	// x-displayName: "Allow Methods"
	// Specifies the content for the access-control-allow-methods header
	AllowMethods string `protobuf:"bytes,4,opt,name=allow_methods,json=allowMethods,proto3" json:"allow_methods,omitempty"`
	// allow_headers
	//
	// x-displayName: "Allow Headers"
	// Specifies the content for the access-control-allow-headers header
	AllowHeaders string `protobuf:"bytes,5,opt,name=allow_headers,json=allowHeaders,proto3" json:"allow_headers,omitempty"`
	// expose_headers
	//
	// x-displayName: "Expose Headers"
	// Specifies the content for the access-control-expose-headers header
	ExposeHeaders string `protobuf:"bytes,6,opt,name=expose_headers,json=exposeHeaders,proto3" json:"expose_headers,omitempty"`
	// max_age
	//
	// x-displayName: "Max Age"
	// Specifies the content for the access-control-max-age header
	MaxAge string `protobuf:"bytes,7,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
	// maximum_age
	//
	// x-displayName: "Maximum Age"
	// Specifies the content for the access-control-max-age header in seconds.
	// This indicates the maximum number of seconds the results can be cached
	// A value of -1 will disable caching.
	// Maximum permitted value is 86400 seconds (24 hours)
	MaximumAge int32 `protobuf:"varint,9,opt,name=maximum_age,json=maximumAge,proto3" json:"maximum_age,omitempty"`
	// allow_credentials
	//
	// x-displayName: "Allow Credentials"
	// Specifies whether the resource allows credentials
	AllowCredentials bool `protobuf:"varint,8,opt,name=allow_credentials,json=allowCredentials,proto3" json:"allow_credentials,omitempty"`
}

func (m *CorsPolicy) Reset()                    { *m = CorsPolicy{} }
func (*CorsPolicy) ProtoMessage()               {}
func (*CorsPolicy) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{48} }

func (m *CorsPolicy) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *CorsPolicy) GetAllowOrigin() []string {
	if m != nil {
		return m.AllowOrigin
	}
	return nil
}

func (m *CorsPolicy) GetAllowOriginRegex() []string {
	if m != nil {
		return m.AllowOriginRegex
	}
	return nil
}

func (m *CorsPolicy) GetAllowMethods() string {
	if m != nil {
		return m.AllowMethods
	}
	return ""
}

func (m *CorsPolicy) GetAllowHeaders() string {
	if m != nil {
		return m.AllowHeaders
	}
	return ""
}

func (m *CorsPolicy) GetExposeHeaders() string {
	if m != nil {
		return m.ExposeHeaders
	}
	return ""
}

func (m *CorsPolicy) GetMaxAge() string {
	if m != nil {
		return m.MaxAge
	}
	return ""
}

func (m *CorsPolicy) GetMaximumAge() int32 {
	if m != nil {
		return m.MaximumAge
	}
	return 0
}

func (m *CorsPolicy) GetAllowCredentials() bool {
	if m != nil {
		return m.AllowCredentials
	}
	return false
}

// PathMatcherType
//
// x-displayName: "Path to Match"
// Path match of the URI can be either be, Prefix match or exact match or regular expression match
type PathMatcherType struct {
	// path_match
	//
	// x-displayName: "Path Match"
	// A specification of path match
	//
	// Types that are valid to be assigned to PathMatch:
	//	*PathMatcherType_Prefix
	//	*PathMatcherType_Path
	//	*PathMatcherType_Regex
	PathMatch isPathMatcherType_PathMatch `protobuf_oneof:"path_match"`
}

func (m *PathMatcherType) Reset()                    { *m = PathMatcherType{} }
func (*PathMatcherType) ProtoMessage()               {}
func (*PathMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{49} }

type isPathMatcherType_PathMatch interface {
	isPathMatcherType_PathMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PathMatcherType_Prefix struct {
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3,oneof"`
}
type PathMatcherType_Path struct {
	Path string `protobuf:"bytes,2,opt,name=path,proto3,oneof"`
}
type PathMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof"`
}

func (*PathMatcherType_Prefix) isPathMatcherType_PathMatch() {}
func (*PathMatcherType_Path) isPathMatcherType_PathMatch()   {}
func (*PathMatcherType_Regex) isPathMatcherType_PathMatch()  {}

func (m *PathMatcherType) GetPathMatch() isPathMatcherType_PathMatch {
	if m != nil {
		return m.PathMatch
	}
	return nil
}

func (m *PathMatcherType) GetPrefix() string {
	if x, ok := m.GetPathMatch().(*PathMatcherType_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *PathMatcherType) GetPath() string {
	if x, ok := m.GetPathMatch().(*PathMatcherType_Path); ok {
		return x.Path
	}
	return ""
}

func (m *PathMatcherType) GetRegex() string {
	if x, ok := m.GetPathMatch().(*PathMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PathMatcherType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PathMatcherType_OneofMarshaler, _PathMatcherType_OneofUnmarshaler, _PathMatcherType_OneofSizer, []interface{}{
		(*PathMatcherType_Prefix)(nil),
		(*PathMatcherType_Path)(nil),
		(*PathMatcherType_Regex)(nil),
	}
}

func _PathMatcherType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PathMatcherType)
	// path_match
	switch x := m.PathMatch.(type) {
	case *PathMatcherType_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Prefix)
	case *PathMatcherType_Path:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Path)
	case *PathMatcherType_Regex:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Regex)
	case nil:
	default:
		return fmt.Errorf("PathMatcherType.PathMatch has unexpected type %T", x)
	}
	return nil
}

func _PathMatcherType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PathMatcherType)
	switch tag {
	case 1: // path_match.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathMatch = &PathMatcherType_Prefix{x}
		return true, err
	case 2: // path_match.path
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathMatch = &PathMatcherType_Path{x}
		return true, err
	case 3: // path_match.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathMatch = &PathMatcherType_Regex{x}
		return true, err
	default:
		return false, nil
	}
}

func _PathMatcherType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PathMatcherType)
	// path_match
	switch x := m.PathMatch.(type) {
	case *PathMatcherType_Prefix:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case *PathMatcherType_Path:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Path)))
		n += len(x.Path)
	case *PathMatcherType_Regex:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// HeaderMatcherType
//
// x-displayName: "Header to Match"
// Header match is done using the name of the header and its value.
// The value match is done using one of the following
//     regex match on value
//     exact match of value
//     presence of header
//
// Header Match can also be inverse of above, which be used to check
//     missing header or
//     non-matching value
type HeaderMatcherType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "Content-Type"
	// Name of the header
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// value_match
	//
	// x-displayName: "Value"
	// The variants of matching a header value
	//
	// Types that are valid to be assigned to ValueMatch:
	//	*HeaderMatcherType_Exact
	//	*HeaderMatcherType_Regex
	//	*HeaderMatcherType_Presence
	ValueMatch isHeaderMatcherType_ValueMatch `protobuf_oneof:"value_match"`
	// invert_match
	//
	// x-displayName: "NOT of match"
	// Invert the result of the match to detect missing header or non-matching value
	InvertMatch bool `protobuf:"varint,5,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
}

func (m *HeaderMatcherType) Reset()                    { *m = HeaderMatcherType{} }
func (*HeaderMatcherType) ProtoMessage()               {}
func (*HeaderMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{50} }

type isHeaderMatcherType_ValueMatch interface {
	isHeaderMatcherType_ValueMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcherType_Exact struct {
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof"`
}
type HeaderMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof"`
}
type HeaderMatcherType_Presence struct {
	Presence bool `protobuf:"varint,4,opt,name=presence,proto3,oneof"`
}

func (*HeaderMatcherType_Exact) isHeaderMatcherType_ValueMatch()    {}
func (*HeaderMatcherType_Regex) isHeaderMatcherType_ValueMatch()    {}
func (*HeaderMatcherType_Presence) isHeaderMatcherType_ValueMatch() {}

func (m *HeaderMatcherType) GetValueMatch() isHeaderMatcherType_ValueMatch {
	if m != nil {
		return m.ValueMatch
	}
	return nil
}

func (m *HeaderMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcherType) GetExact() string {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *HeaderMatcherType) GetRegex() string {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

func (m *HeaderMatcherType) GetPresence() bool {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *HeaderMatcherType) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HeaderMatcherType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HeaderMatcherType_OneofMarshaler, _HeaderMatcherType_OneofUnmarshaler, _HeaderMatcherType_OneofSizer, []interface{}{
		(*HeaderMatcherType_Exact)(nil),
		(*HeaderMatcherType_Regex)(nil),
		(*HeaderMatcherType_Presence)(nil),
	}
}

func _HeaderMatcherType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HeaderMatcherType)
	// value_match
	switch x := m.ValueMatch.(type) {
	case *HeaderMatcherType_Exact:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Exact)
	case *HeaderMatcherType_Regex:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Regex)
	case *HeaderMatcherType_Presence:
		t := uint64(0)
		if x.Presence {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("HeaderMatcherType.ValueMatch has unexpected type %T", x)
	}
	return nil
}

func _HeaderMatcherType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HeaderMatcherType)
	switch tag {
	case 2: // value_match.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ValueMatch = &HeaderMatcherType_Exact{x}
		return true, err
	case 3: // value_match.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ValueMatch = &HeaderMatcherType_Regex{x}
		return true, err
	case 4: // value_match.presence
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ValueMatch = &HeaderMatcherType_Presence{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _HeaderMatcherType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HeaderMatcherType)
	// value_match
	switch x := m.ValueMatch.(type) {
	case *HeaderMatcherType_Exact:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *HeaderMatcherType_Regex:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case *HeaderMatcherType_Presence:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// QueryParameterMatcherType
//
// x-displayName: "Query Parameter to Match"
// Query parameter match can be either regex match on value or exact match of value for given key
// An example for HTTP request with query parameter https://gitlab.com/dashboard/issues?assignee_username=xxyyxx
type QueryParameterMatcherType struct {
	// key
	//
	// x-displayName: "Key"
	// x-example: "assignee_username"
	// Query parameter key
	// In the above example, assignee_username is the key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// value_match
	//
	// x-displayName: "Value"
	// Query parameter value regex match or exact match
	// In the above example, xxyyxx is the value for the matching key
	//
	// Types that are valid to be assigned to ValueMatch:
	//	*QueryParameterMatcherType_Exact
	//	*QueryParameterMatcherType_Regex
	ValueMatch isQueryParameterMatcherType_ValueMatch `protobuf_oneof:"value_match"`
}

func (m *QueryParameterMatcherType) Reset()                    { *m = QueryParameterMatcherType{} }
func (*QueryParameterMatcherType) ProtoMessage()               {}
func (*QueryParameterMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{51} }

type isQueryParameterMatcherType_ValueMatch interface {
	isQueryParameterMatcherType_ValueMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryParameterMatcherType_Exact struct {
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof"`
}
type QueryParameterMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof"`
}

func (*QueryParameterMatcherType_Exact) isQueryParameterMatcherType_ValueMatch() {}
func (*QueryParameterMatcherType_Regex) isQueryParameterMatcherType_ValueMatch() {}

func (m *QueryParameterMatcherType) GetValueMatch() isQueryParameterMatcherType_ValueMatch {
	if m != nil {
		return m.ValueMatch
	}
	return nil
}

func (m *QueryParameterMatcherType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *QueryParameterMatcherType) GetExact() string {
	if x, ok := m.GetValueMatch().(*QueryParameterMatcherType_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *QueryParameterMatcherType) GetRegex() string {
	if x, ok := m.GetValueMatch().(*QueryParameterMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueryParameterMatcherType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueryParameterMatcherType_OneofMarshaler, _QueryParameterMatcherType_OneofUnmarshaler, _QueryParameterMatcherType_OneofSizer, []interface{}{
		(*QueryParameterMatcherType_Exact)(nil),
		(*QueryParameterMatcherType_Regex)(nil),
	}
}

func _QueryParameterMatcherType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueryParameterMatcherType)
	// value_match
	switch x := m.ValueMatch.(type) {
	case *QueryParameterMatcherType_Exact:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Exact)
	case *QueryParameterMatcherType_Regex:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Regex)
	case nil:
	default:
		return fmt.Errorf("QueryParameterMatcherType.ValueMatch has unexpected type %T", x)
	}
	return nil
}

func _QueryParameterMatcherType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueryParameterMatcherType)
	switch tag {
	case 2: // value_match.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ValueMatch = &QueryParameterMatcherType_Exact{x}
		return true, err
	case 3: // value_match.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ValueMatch = &QueryParameterMatcherType_Regex{x}
		return true, err
	default:
		return false, nil
	}
}

func _QueryParameterMatcherType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueryParameterMatcherType)
	// value_match
	switch x := m.ValueMatch.(type) {
	case *QueryParameterMatcherType_Exact:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *QueryParameterMatcherType_Regex:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RouteMatch
//
// x-displayName: "Match"
// Route Match can be specified to match four things
// 1. In case of HTTP "path" specifies URI part URL (path excluding hostname) in request.
// 2. List of headers  to match in incoming request.
// 3. Query parameters (key, value) in the request. (Not the Query expression)
// 4. HTTP method
type RouteMatch struct {
	// path
	//
	// x-displayName: "Path"
	// URI path of route
	Path *PathMatcherType `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// headers
	//
	// x-displayName: "Headers"
	// List of (key, value) headers
	Headers []*HeaderMatcherType `protobuf:"bytes,2,rep,name=headers" json:"headers,omitempty"`
	// query_params
	//
	// x-displayName: "Query Parameters"
	// List of (key, value) query parameters
	QueryParams []*QueryParameterMatcherType `protobuf:"bytes,3,rep,name=query_params,json=queryParams" json:"query_params,omitempty"`
	// http_method
	//
	// x-displayName: "HTTP Method"
	// The name of the HTTP Method (GET, PUT, POST, etc)
	HttpMethod HttpMethod `protobuf:"varint,4,opt,name=http_method,json=httpMethod,proto3,enum=ves.io.schema.HttpMethod" json:"http_method,omitempty"`
}

func (m *RouteMatch) Reset()                    { *m = RouteMatch{} }
func (*RouteMatch) ProtoMessage()               {}
func (*RouteMatch) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{52} }

func (m *RouteMatch) GetPath() *PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *RouteMatch) GetHeaders() []*HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *RouteMatch) GetQueryParams() []*QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *RouteMatch) GetHttpMethod() HttpMethod {
	if m != nil {
		return m.HttpMethod
	}
	return ANY
}

// WafRefType
//
// x-displayName: "WAF Reference"
// A reference to the WAF configuration object
type WafRefType struct {
	// waf
	//
	// x-displayName: "WAF"
	// A direct reference to web application firewall configuration object
	Waf []*ObjectRefType `protobuf:"bytes,1,rep,name=waf" json:"waf,omitempty"`
}

func (m *WafRefType) Reset()                    { *m = WafRefType{} }
func (*WafRefType) ProtoMessage()               {}
func (*WafRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{53} }

func (m *WafRefType) GetWaf() []*ObjectRefType {
	if m != nil {
		return m.Waf
	}
	return nil
}

// WafRulesRefType
//
// x-displayName: "WAF Rules Reference"
// A list of references to the waf_rules configuration objects
type WafRulesRefType struct {
	// waf_rules
	//
	// x-displayName: "WAF Rules"
	// References to a set of WAF Rules configuration object
	WafRules []*ObjectRefType `protobuf:"bytes,1,rep,name=waf_rules,json=wafRules" json:"waf_rules,omitempty"`
}

func (m *WafRulesRefType) Reset()                    { *m = WafRulesRefType{} }
func (*WafRulesRefType) ProtoMessage()               {}
func (*WafRulesRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{54} }

func (m *WafRulesRefType) GetWafRules() []*ObjectRefType {
	if m != nil {
		return m.WafRules
	}
	return nil
}

// WafType
//
// x-displayName: "WAF Instance"
// WAF instance will be pointing to either Waf object (high level) or waf_rules Object
type WafType struct {
	// WAF config
	//
	// x-displayName: "WAF Config"
	// The variants of direct reference of WAF
	//
	// Types that are valid to be assigned to RefType:
	//	*WafType_Waf
	//	*WafType_WafRules
	RefType isWafType_RefType `protobuf_oneof:"ref_type"`
}

func (m *WafType) Reset()                    { *m = WafType{} }
func (*WafType) ProtoMessage()               {}
func (*WafType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{55} }

type isWafType_RefType interface {
	isWafType_RefType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WafType_Waf struct {
	Waf *WafRefType `protobuf:"bytes,1,opt,name=waf,oneof"`
}
type WafType_WafRules struct {
	WafRules *WafRulesRefType `protobuf:"bytes,2,opt,name=waf_rules,json=wafRules,oneof"`
}

func (*WafType_Waf) isWafType_RefType()      {}
func (*WafType_WafRules) isWafType_RefType() {}

func (m *WafType) GetRefType() isWafType_RefType {
	if m != nil {
		return m.RefType
	}
	return nil
}

func (m *WafType) GetWaf() *WafRefType {
	if x, ok := m.GetRefType().(*WafType_Waf); ok {
		return x.Waf
	}
	return nil
}

func (m *WafType) GetWafRules() *WafRulesRefType {
	if x, ok := m.GetRefType().(*WafType_WafRules); ok {
		return x.WafRules
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WafType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WafType_OneofMarshaler, _WafType_OneofUnmarshaler, _WafType_OneofSizer, []interface{}{
		(*WafType_Waf)(nil),
		(*WafType_WafRules)(nil),
	}
}

func _WafType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WafType)
	// ref_type
	switch x := m.RefType.(type) {
	case *WafType_Waf:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Waf); err != nil {
			return err
		}
	case *WafType_WafRules:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WafRules); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("WafType.RefType has unexpected type %T", x)
	}
	return nil
}

func _WafType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WafType)
	switch tag {
	case 1: // ref_type.waf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WafRefType)
		err := b.DecodeMessage(msg)
		m.RefType = &WafType_Waf{msg}
		return true, err
	case 2: // ref_type.waf_rules
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WafRulesRefType)
		err := b.DecodeMessage(msg)
		m.RefType = &WafType_WafRules{msg}
		return true, err
	default:
		return false, nil
	}
}

func _WafType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WafType)
	// ref_type
	switch x := m.RefType.(type) {
	case *WafType_Waf:
		s := proto.Size(x.Waf)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WafType_WafRules:
		s := proto.Size(x.WafRules)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AppRoleAuthInfoType
//
// x-displayName: "Vault AppRole Authentication Parameters"
// AppRoleAuthInfoType contains parameters for AppRole authentication in Hashicorp Vault
type AppRoleAuthInfoType struct {
	// role-id
	//
	// x-displayName: "Role ID"
	// role-id to be used for authentication
	RoleId string `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	// secret-id
	//
	// x-displayName: "Secret ID"
	// Volterra Secret. Secret-id to be used for authentication. secret-id has to be long lived.
	SecretId *SecretType `protobuf:"bytes,2,opt,name=secret_id,json=secretId" json:"secret_id,omitempty"`
}

func (m *AppRoleAuthInfoType) Reset()                    { *m = AppRoleAuthInfoType{} }
func (*AppRoleAuthInfoType) ProtoMessage()               {}
func (*AppRoleAuthInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{56} }

func (m *AppRoleAuthInfoType) GetRoleId() string {
	if m != nil {
		return m.RoleId
	}
	return ""
}

func (m *AppRoleAuthInfoType) GetSecretId() *SecretType {
	if m != nil {
		return m.SecretId
	}
	return nil
}

// VaultAuthTypeInfo
//
// x-displayName: "Vault Authentication Parameters"
// Authentication parameters for Hashicorp Vault hosts
type VaultAuthInfoType struct {
	// Authentication Parameters
	//
	// x-displayName: "Authentication Parameters"
	// Different authentication parameters for authentication to Hashicorp Vault backend. Currently supported methods are -
	// * AppRole authentication - Authentication using AppRole method
	// * Token authentication - Authentication using Token
	//
	// Types that are valid to be assigned to AuthParams:
	//	*VaultAuthInfoType_AppRoleAuth
	//	*VaultAuthInfoType_Token
	AuthParams isVaultAuthInfoType_AuthParams `protobuf_oneof:"auth_params"`
}

func (m *VaultAuthInfoType) Reset()                    { *m = VaultAuthInfoType{} }
func (*VaultAuthInfoType) ProtoMessage()               {}
func (*VaultAuthInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{57} }

type isVaultAuthInfoType_AuthParams interface {
	isVaultAuthInfoType_AuthParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VaultAuthInfoType_AppRoleAuth struct {
	AppRoleAuth *AppRoleAuthInfoType `protobuf:"bytes,1,opt,name=app_role_auth,json=appRoleAuth,oneof"`
}
type VaultAuthInfoType_Token struct {
	Token *SecretType `protobuf:"bytes,2,opt,name=token,oneof"`
}

func (*VaultAuthInfoType_AppRoleAuth) isVaultAuthInfoType_AuthParams() {}
func (*VaultAuthInfoType_Token) isVaultAuthInfoType_AuthParams()       {}

func (m *VaultAuthInfoType) GetAuthParams() isVaultAuthInfoType_AuthParams {
	if m != nil {
		return m.AuthParams
	}
	return nil
}

func (m *VaultAuthInfoType) GetAppRoleAuth() *AppRoleAuthInfoType {
	if x, ok := m.GetAuthParams().(*VaultAuthInfoType_AppRoleAuth); ok {
		return x.AppRoleAuth
	}
	return nil
}

func (m *VaultAuthInfoType) GetToken() *SecretType {
	if x, ok := m.GetAuthParams().(*VaultAuthInfoType_Token); ok {
		return x.Token
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VaultAuthInfoType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VaultAuthInfoType_OneofMarshaler, _VaultAuthInfoType_OneofUnmarshaler, _VaultAuthInfoType_OneofSizer, []interface{}{
		(*VaultAuthInfoType_AppRoleAuth)(nil),
		(*VaultAuthInfoType_Token)(nil),
	}
}

func _VaultAuthInfoType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VaultAuthInfoType)
	// auth_params
	switch x := m.AuthParams.(type) {
	case *VaultAuthInfoType_AppRoleAuth:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AppRoleAuth); err != nil {
			return err
		}
	case *VaultAuthInfoType_Token:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Token); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VaultAuthInfoType.AuthParams has unexpected type %T", x)
	}
	return nil
}

func _VaultAuthInfoType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VaultAuthInfoType)
	switch tag {
	case 1: // auth_params.app_role_auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppRoleAuthInfoType)
		err := b.DecodeMessage(msg)
		m.AuthParams = &VaultAuthInfoType_AppRoleAuth{msg}
		return true, err
	case 2: // auth_params.token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SecretType)
		err := b.DecodeMessage(msg)
		m.AuthParams = &VaultAuthInfoType_Token{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VaultAuthInfoType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VaultAuthInfoType)
	// auth_params
	switch x := m.AuthParams.(type) {
	case *VaultAuthInfoType_AppRoleAuth:
		s := proto.Size(x.AppRoleAuth)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VaultAuthInfoType_Token:
		s := proto.Size(x.Token)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RestAuthInfoType
//
// x-displayName: "Rest Authentication Parameters"
// Authentication parameters for REST based hosts
type RestAuthInfoType struct {
	// Authentication Parameters
	//
	// x-displayName: "Authentication Parameters"
	// Different authentication parameters for authenticating to REST backend, Currently supported are -
	// BasicAuth - Authentication using basic auth
	// Authentication Headers - Authentication using Headers
	// Authentication QueryParams - Authentication using QueryParams
	//
	// Types that are valid to be assigned to AuthParams:
	//	*RestAuthInfoType_BasicAuth
	//	*RestAuthInfoType_HeadersAuth
	//	*RestAuthInfoType_QueryParamsAuth
	AuthParams isRestAuthInfoType_AuthParams `protobuf_oneof:"auth_params"`
}

func (m *RestAuthInfoType) Reset()                    { *m = RestAuthInfoType{} }
func (*RestAuthInfoType) ProtoMessage()               {}
func (*RestAuthInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{58} }

type isRestAuthInfoType_AuthParams interface {
	isRestAuthInfoType_AuthParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RestAuthInfoType_BasicAuth struct {
	BasicAuth *AuthnTypeBasicAuth `protobuf:"bytes,1,opt,name=basic_auth,json=basicAuth,oneof"`
}
type RestAuthInfoType_HeadersAuth struct {
	HeadersAuth *AuthnTypeHeaders `protobuf:"bytes,2,opt,name=headers_auth,json=headersAuth,oneof"`
}
type RestAuthInfoType_QueryParamsAuth struct {
	QueryParamsAuth *AuthnTypeQueryParams `protobuf:"bytes,3,opt,name=query_params_auth,json=queryParamsAuth,oneof"`
}

func (*RestAuthInfoType_BasicAuth) isRestAuthInfoType_AuthParams()       {}
func (*RestAuthInfoType_HeadersAuth) isRestAuthInfoType_AuthParams()     {}
func (*RestAuthInfoType_QueryParamsAuth) isRestAuthInfoType_AuthParams() {}

func (m *RestAuthInfoType) GetAuthParams() isRestAuthInfoType_AuthParams {
	if m != nil {
		return m.AuthParams
	}
	return nil
}

func (m *RestAuthInfoType) GetBasicAuth() *AuthnTypeBasicAuth {
	if x, ok := m.GetAuthParams().(*RestAuthInfoType_BasicAuth); ok {
		return x.BasicAuth
	}
	return nil
}

func (m *RestAuthInfoType) GetHeadersAuth() *AuthnTypeHeaders {
	if x, ok := m.GetAuthParams().(*RestAuthInfoType_HeadersAuth); ok {
		return x.HeadersAuth
	}
	return nil
}

func (m *RestAuthInfoType) GetQueryParamsAuth() *AuthnTypeQueryParams {
	if x, ok := m.GetAuthParams().(*RestAuthInfoType_QueryParamsAuth); ok {
		return x.QueryParamsAuth
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RestAuthInfoType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RestAuthInfoType_OneofMarshaler, _RestAuthInfoType_OneofUnmarshaler, _RestAuthInfoType_OneofSizer, []interface{}{
		(*RestAuthInfoType_BasicAuth)(nil),
		(*RestAuthInfoType_HeadersAuth)(nil),
		(*RestAuthInfoType_QueryParamsAuth)(nil),
	}
}

func _RestAuthInfoType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RestAuthInfoType)
	// auth_params
	switch x := m.AuthParams.(type) {
	case *RestAuthInfoType_BasicAuth:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BasicAuth); err != nil {
			return err
		}
	case *RestAuthInfoType_HeadersAuth:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HeadersAuth); err != nil {
			return err
		}
	case *RestAuthInfoType_QueryParamsAuth:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.QueryParamsAuth); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RestAuthInfoType.AuthParams has unexpected type %T", x)
	}
	return nil
}

func _RestAuthInfoType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RestAuthInfoType)
	switch tag {
	case 1: // auth_params.basic_auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AuthnTypeBasicAuth)
		err := b.DecodeMessage(msg)
		m.AuthParams = &RestAuthInfoType_BasicAuth{msg}
		return true, err
	case 2: // auth_params.headers_auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AuthnTypeHeaders)
		err := b.DecodeMessage(msg)
		m.AuthParams = &RestAuthInfoType_HeadersAuth{msg}
		return true, err
	case 3: // auth_params.query_params_auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AuthnTypeQueryParams)
		err := b.DecodeMessage(msg)
		m.AuthParams = &RestAuthInfoType_QueryParamsAuth{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RestAuthInfoType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RestAuthInfoType)
	// auth_params
	switch x := m.AuthParams.(type) {
	case *RestAuthInfoType_BasicAuth:
		s := proto.Size(x.BasicAuth)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RestAuthInfoType_HeadersAuth:
		s := proto.Size(x.HeadersAuth)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RestAuthInfoType_QueryParamsAuth:
		s := proto.Size(x.QueryParamsAuth)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// HostAccessInfoType
//
// x-displayName: "Host Access Information"
// HostAccessInfoType contains the information about how to connect to the remote host.
type HostAccessInfoType struct {
	// scheme
	//
	// x-displayName: "URL Scheme"
	// URL scheme to use for connection
	Scheme URLSchemeType `protobuf:"varint,1,opt,name=scheme,proto3,enum=ves.io.schema.URLSchemeType" json:"scheme,omitempty"`
	// server_endpoint
	//
	// x-displayName: "Server Endpoint and Port"
	// x-required
	// x-example: "webserver:443"
	// endpoint to connect to, in host:port format
	ServerEndpoint string `protobuf:"bytes,2,opt,name=server_endpoint,json=serverEndpoint,proto3" json:"server_endpoint,omitempty"`
	// tls_config
	//
	// x-displayName: "TLS Configuration"
	// TLS configuration for the connection
	TlsConfig *UpstreamTlsParamsType `protobuf:"bytes,4,opt,name=tls_config,json=tlsConfig" json:"tls_config,omitempty"`
	// Authentication Parameters
	//
	// x-displayName: "Authentication Parameters"
	// Different Methods for Authenticating to the remote host. Currently supported are -
	// * Rest Authentication - This is used if the remote host is REST server
	// * Vault Authentication - This is used if the remote host is a Hashicorp Vault server
	//
	// Types that are valid to be assigned to AuthParams:
	//	*HostAccessInfoType_RestAuthInfo
	//	*HostAccessInfoType_VaultAuthInfo
	AuthParams isHostAccessInfoType_AuthParams `protobuf_oneof:"auth_params"`
}

func (m *HostAccessInfoType) Reset()                    { *m = HostAccessInfoType{} }
func (*HostAccessInfoType) ProtoMessage()               {}
func (*HostAccessInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{59} }

type isHostAccessInfoType_AuthParams interface {
	isHostAccessInfoType_AuthParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HostAccessInfoType_RestAuthInfo struct {
	RestAuthInfo *RestAuthInfoType `protobuf:"bytes,5,opt,name=rest_auth_info,json=restAuthInfo,oneof"`
}
type HostAccessInfoType_VaultAuthInfo struct {
	VaultAuthInfo *VaultAuthInfoType `protobuf:"bytes,6,opt,name=vault_auth_info,json=vaultAuthInfo,oneof"`
}

func (*HostAccessInfoType_RestAuthInfo) isHostAccessInfoType_AuthParams()  {}
func (*HostAccessInfoType_VaultAuthInfo) isHostAccessInfoType_AuthParams() {}

func (m *HostAccessInfoType) GetAuthParams() isHostAccessInfoType_AuthParams {
	if m != nil {
		return m.AuthParams
	}
	return nil
}

func (m *HostAccessInfoType) GetScheme() URLSchemeType {
	if m != nil {
		return m.Scheme
	}
	return HTTP
}

func (m *HostAccessInfoType) GetServerEndpoint() string {
	if m != nil {
		return m.ServerEndpoint
	}
	return ""
}

func (m *HostAccessInfoType) GetTlsConfig() *UpstreamTlsParamsType {
	if m != nil {
		return m.TlsConfig
	}
	return nil
}

func (m *HostAccessInfoType) GetRestAuthInfo() *RestAuthInfoType {
	if x, ok := m.GetAuthParams().(*HostAccessInfoType_RestAuthInfo); ok {
		return x.RestAuthInfo
	}
	return nil
}

func (m *HostAccessInfoType) GetVaultAuthInfo() *VaultAuthInfoType {
	if x, ok := m.GetAuthParams().(*HostAccessInfoType_VaultAuthInfo); ok {
		return x.VaultAuthInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HostAccessInfoType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HostAccessInfoType_OneofMarshaler, _HostAccessInfoType_OneofUnmarshaler, _HostAccessInfoType_OneofSizer, []interface{}{
		(*HostAccessInfoType_RestAuthInfo)(nil),
		(*HostAccessInfoType_VaultAuthInfo)(nil),
	}
}

func _HostAccessInfoType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HostAccessInfoType)
	// auth_params
	switch x := m.AuthParams.(type) {
	case *HostAccessInfoType_RestAuthInfo:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RestAuthInfo); err != nil {
			return err
		}
	case *HostAccessInfoType_VaultAuthInfo:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VaultAuthInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HostAccessInfoType.AuthParams has unexpected type %T", x)
	}
	return nil
}

func _HostAccessInfoType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HostAccessInfoType)
	switch tag {
	case 5: // auth_params.rest_auth_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestAuthInfoType)
		err := b.DecodeMessage(msg)
		m.AuthParams = &HostAccessInfoType_RestAuthInfo{msg}
		return true, err
	case 6: // auth_params.vault_auth_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VaultAuthInfoType)
		err := b.DecodeMessage(msg)
		m.AuthParams = &HostAccessInfoType_VaultAuthInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HostAccessInfoType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HostAccessInfoType)
	// auth_params
	switch x := m.AuthParams.(type) {
	case *HostAccessInfoType_RestAuthInfo:
		s := proto.Size(x.RestAuthInfo)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HostAccessInfoType_VaultAuthInfo:
		s := proto.Size(x.VaultAuthInfo)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// VaultAccessInfoType
//
// x-displayName: "Vault Access Information"
// VaultAccessInfoType contains information about how to connect to Hashicorp vault.
type VaultAccessInfoType struct {
	// vault_addr
	//
	// x-displayName: "Vault Address"
	// vault_address defines the address of the vault in <host:port> format
	VaultAddr string `protobuf:"bytes,1,opt,name=vault_addr,json=vaultAddr,proto3" json:"vault_addr,omitempty"`
	// vault_ca_url
	//
	// x-displayName: "Vault CA URL"
	// vault_ca_url contains the CA to trust for remote vault
	VaultCaUrl string `protobuf:"bytes,2,opt,name=vault_ca_url,json=vaultCaUrl,proto3" json:"vault_ca_url,omitempty"`
	// Types that are valid to be assigned to AuthnChoice:
	//	*VaultAccessInfoType_AppRoleAuth
	//	*VaultAccessInfoType_Token
	AuthnChoice isVaultAccessInfoType_AuthnChoice `protobuf_oneof:"authn_choice"`
}

func (m *VaultAccessInfoType) Reset()                    { *m = VaultAccessInfoType{} }
func (*VaultAccessInfoType) ProtoMessage()               {}
func (*VaultAccessInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{60} }

type isVaultAccessInfoType_AuthnChoice interface {
	isVaultAccessInfoType_AuthnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VaultAccessInfoType_AppRoleAuth struct {
	AppRoleAuth *AppRoleAuthInfoType `protobuf:"bytes,3,opt,name=app_role_auth,json=appRoleAuth,oneof"`
}
type VaultAccessInfoType_Token struct {
	Token *SecretType `protobuf:"bytes,4,opt,name=token,oneof"`
}

func (*VaultAccessInfoType_AppRoleAuth) isVaultAccessInfoType_AuthnChoice() {}
func (*VaultAccessInfoType_Token) isVaultAccessInfoType_AuthnChoice()       {}

func (m *VaultAccessInfoType) GetAuthnChoice() isVaultAccessInfoType_AuthnChoice {
	if m != nil {
		return m.AuthnChoice
	}
	return nil
}

func (m *VaultAccessInfoType) GetVaultAddr() string {
	if m != nil {
		return m.VaultAddr
	}
	return ""
}

func (m *VaultAccessInfoType) GetVaultCaUrl() string {
	if m != nil {
		return m.VaultCaUrl
	}
	return ""
}

func (m *VaultAccessInfoType) GetAppRoleAuth() *AppRoleAuthInfoType {
	if x, ok := m.GetAuthnChoice().(*VaultAccessInfoType_AppRoleAuth); ok {
		return x.AppRoleAuth
	}
	return nil
}

func (m *VaultAccessInfoType) GetToken() *SecretType {
	if x, ok := m.GetAuthnChoice().(*VaultAccessInfoType_Token); ok {
		return x.Token
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VaultAccessInfoType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VaultAccessInfoType_OneofMarshaler, _VaultAccessInfoType_OneofUnmarshaler, _VaultAccessInfoType_OneofSizer, []interface{}{
		(*VaultAccessInfoType_AppRoleAuth)(nil),
		(*VaultAccessInfoType_Token)(nil),
	}
}

func _VaultAccessInfoType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VaultAccessInfoType)
	// authn_choice
	switch x := m.AuthnChoice.(type) {
	case *VaultAccessInfoType_AppRoleAuth:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AppRoleAuth); err != nil {
			return err
		}
	case *VaultAccessInfoType_Token:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Token); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VaultAccessInfoType.AuthnChoice has unexpected type %T", x)
	}
	return nil
}

func _VaultAccessInfoType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VaultAccessInfoType)
	switch tag {
	case 3: // authn_choice.app_role_auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppRoleAuthInfoType)
		err := b.DecodeMessage(msg)
		m.AuthnChoice = &VaultAccessInfoType_AppRoleAuth{msg}
		return true, err
	case 4: // authn_choice.token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SecretType)
		err := b.DecodeMessage(msg)
		m.AuthnChoice = &VaultAccessInfoType_Token{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VaultAccessInfoType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VaultAccessInfoType)
	// authn_choice
	switch x := m.AuthnChoice.(type) {
	case *VaultAccessInfoType_AppRoleAuth:
		s := proto.Size(x.AppRoleAuth)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VaultAccessInfoType_Token:
		s := proto.Size(x.Token)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// VaultSecretType
//
// x-displayName: "Vault Secret"
// VaultSecretType contains the information about a secret stored in Hashicorp vault
type VaultSecretType struct {
	// Types that are valid to be assigned to AccessChoice:
	//	*VaultSecretType_VaultAccessInfo
	//	*VaultSecretType_ProviderName
	AccessChoice isVaultSecretType_AccessChoice `protobuf_oneof:"access_choice"`
	// secret_path
	//
	// x-displayName: "Secret Path"
	// secret_path provider, or can give access information inline.
	SecretPath string `protobuf:"bytes,3,opt,name=secret_path,json=secretPath,proto3" json:"secret_path,omitempty"`
	// secret_sub_path
	//
	// x-displayName: "Secret SubPath"
	// secret_sub_path contains the subPath of the secret in Hashicorp vault.
	SecretSubPath string `protobuf:"bytes,4,opt,name=secret_sub_path,json=secretSubPath,proto3" json:"secret_sub_path,omitempty"`
	// secret_version
	//
	// x-displayName: "Secret Version"
	// secret_version contains the version of the secret to be fetched from Hashicorp vault.
	SecretVersion string `protobuf:"bytes,5,opt,name=secret_version,json=secretVersion,proto3" json:"secret_version,omitempty"`
}

func (m *VaultSecretType) Reset()                    { *m = VaultSecretType{} }
func (*VaultSecretType) ProtoMessage()               {}
func (*VaultSecretType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{61} }

type isVaultSecretType_AccessChoice interface {
	isVaultSecretType_AccessChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VaultSecretType_VaultAccessInfo struct {
	VaultAccessInfo *VaultAccessInfoType `protobuf:"bytes,1,opt,name=vault_access_info,json=vaultAccessInfo,oneof"`
}
type VaultSecretType_ProviderName struct {
	ProviderName string `protobuf:"bytes,2,opt,name=provider_name,json=providerName,proto3,oneof"`
}

func (*VaultSecretType_VaultAccessInfo) isVaultSecretType_AccessChoice() {}
func (*VaultSecretType_ProviderName) isVaultSecretType_AccessChoice()    {}

func (m *VaultSecretType) GetAccessChoice() isVaultSecretType_AccessChoice {
	if m != nil {
		return m.AccessChoice
	}
	return nil
}

func (m *VaultSecretType) GetVaultAccessInfo() *VaultAccessInfoType {
	if x, ok := m.GetAccessChoice().(*VaultSecretType_VaultAccessInfo); ok {
		return x.VaultAccessInfo
	}
	return nil
}

func (m *VaultSecretType) GetProviderName() string {
	if x, ok := m.GetAccessChoice().(*VaultSecretType_ProviderName); ok {
		return x.ProviderName
	}
	return ""
}

func (m *VaultSecretType) GetSecretPath() string {
	if m != nil {
		return m.SecretPath
	}
	return ""
}

func (m *VaultSecretType) GetSecretSubPath() string {
	if m != nil {
		return m.SecretSubPath
	}
	return ""
}

func (m *VaultSecretType) GetSecretVersion() string {
	if m != nil {
		return m.SecretVersion
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VaultSecretType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VaultSecretType_OneofMarshaler, _VaultSecretType_OneofUnmarshaler, _VaultSecretType_OneofSizer, []interface{}{
		(*VaultSecretType_VaultAccessInfo)(nil),
		(*VaultSecretType_ProviderName)(nil),
	}
}

func _VaultSecretType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VaultSecretType)
	// access_choice
	switch x := m.AccessChoice.(type) {
	case *VaultSecretType_VaultAccessInfo:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VaultAccessInfo); err != nil {
			return err
		}
	case *VaultSecretType_ProviderName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ProviderName)
	case nil:
	default:
		return fmt.Errorf("VaultSecretType.AccessChoice has unexpected type %T", x)
	}
	return nil
}

func _VaultSecretType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VaultSecretType)
	switch tag {
	case 1: // access_choice.vault_access_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VaultAccessInfoType)
		err := b.DecodeMessage(msg)
		m.AccessChoice = &VaultSecretType_VaultAccessInfo{msg}
		return true, err
	case 2: // access_choice.provider_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AccessChoice = &VaultSecretType_ProviderName{x}
		return true, err
	default:
		return false, nil
	}
}

func _VaultSecretType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VaultSecretType)
	// access_choice
	switch x := m.AccessChoice.(type) {
	case *VaultSecretType_VaultAccessInfo:
		s := proto.Size(x.VaultAccessInfo)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VaultSecretType_ProviderName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ProviderName)))
		n += len(x.ProviderName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// VolterraSecretType
//
// x-displayName: "Volterra Secret"
// VolterraSecretType contains the information about secret distributed by volterra.
type VolterraSecretType struct {
	// Types that are valid to be assigned to SecretTypeChoice:
	//	*VolterraSecretType_BlindfoldSecretInfo
	//	*VolterraSecretType_VaultSecretInfo
	SecretTypeChoice isVolterraSecretType_SecretTypeChoice `protobuf_oneof:"secret_type_choice"`
}

func (m *VolterraSecretType) Reset()                    { *m = VolterraSecretType{} }
func (*VolterraSecretType) ProtoMessage()               {}
func (*VolterraSecretType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{62} }

type isVolterraSecretType_SecretTypeChoice interface {
	isVolterraSecretType_SecretTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VolterraSecretType_BlindfoldSecretInfo struct {
	BlindfoldSecretInfo *BlindfoldSecretInfoType `protobuf:"bytes,1,opt,name=blindfold_secret_info,json=blindfoldSecretInfo,oneof"`
}
type VolterraSecretType_VaultSecretInfo struct {
	VaultSecretInfo *VaultAccessInfoType `protobuf:"bytes,2,opt,name=vault_secret_info,json=vaultSecretInfo,oneof"`
}

func (*VolterraSecretType_BlindfoldSecretInfo) isVolterraSecretType_SecretTypeChoice() {}
func (*VolterraSecretType_VaultSecretInfo) isVolterraSecretType_SecretTypeChoice()     {}

func (m *VolterraSecretType) GetSecretTypeChoice() isVolterraSecretType_SecretTypeChoice {
	if m != nil {
		return m.SecretTypeChoice
	}
	return nil
}

func (m *VolterraSecretType) GetBlindfoldSecretInfo() *BlindfoldSecretInfoType {
	if x, ok := m.GetSecretTypeChoice().(*VolterraSecretType_BlindfoldSecretInfo); ok {
		return x.BlindfoldSecretInfo
	}
	return nil
}

func (m *VolterraSecretType) GetVaultSecretInfo() *VaultAccessInfoType {
	if x, ok := m.GetSecretTypeChoice().(*VolterraSecretType_VaultSecretInfo); ok {
		return x.VaultSecretInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VolterraSecretType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VolterraSecretType_OneofMarshaler, _VolterraSecretType_OneofUnmarshaler, _VolterraSecretType_OneofSizer, []interface{}{
		(*VolterraSecretType_BlindfoldSecretInfo)(nil),
		(*VolterraSecretType_VaultSecretInfo)(nil),
	}
}

func _VolterraSecretType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VolterraSecretType)
	// secret_type_choice
	switch x := m.SecretTypeChoice.(type) {
	case *VolterraSecretType_BlindfoldSecretInfo:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BlindfoldSecretInfo); err != nil {
			return err
		}
	case *VolterraSecretType_VaultSecretInfo:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VaultSecretInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VolterraSecretType.SecretTypeChoice has unexpected type %T", x)
	}
	return nil
}

func _VolterraSecretType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VolterraSecretType)
	switch tag {
	case 1: // secret_type_choice.blindfold_secret_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BlindfoldSecretInfoType)
		err := b.DecodeMessage(msg)
		m.SecretTypeChoice = &VolterraSecretType_BlindfoldSecretInfo{msg}
		return true, err
	case 2: // secret_type_choice.vault_secret_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VaultAccessInfoType)
		err := b.DecodeMessage(msg)
		m.SecretTypeChoice = &VolterraSecretType_VaultSecretInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VolterraSecretType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VolterraSecretType)
	// secret_type_choice
	switch x := m.SecretTypeChoice.(type) {
	case *VolterraSecretType_BlindfoldSecretInfo:
		s := proto.Size(x.BlindfoldSecretInfo)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VolterraSecretType_VaultSecretInfo:
		s := proto.Size(x.VaultSecretInfo)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// PortValueType
//
// x-displayName: "Port Value Type"
// PortValueType specifies the port value
// Can be any or a specified port
type PortValueType struct {
	// port_value_type_choice
	//
	// x-displayName: "Port Value Type"
	// Match criteria for port
	//
	// Types that are valid to be assigned to PortValueTypeChoice:
	//	*PortValueType_All
	//	*PortValueType_UserDefined
	//	*PortValueType_Dns
	PortValueTypeChoice isPortValueType_PortValueTypeChoice `protobuf_oneof:"port_value_type_choice"`
}

func (m *PortValueType) Reset()                    { *m = PortValueType{} }
func (*PortValueType) ProtoMessage()               {}
func (*PortValueType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{63} }

type isPortValueType_PortValueTypeChoice interface {
	isPortValueType_PortValueTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PortValueType_All struct {
	All *Empty `protobuf:"bytes,1,opt,name=all,oneof"`
}
type PortValueType_UserDefined struct {
	UserDefined uint32 `protobuf:"varint,2,opt,name=user_defined,json=userDefined,proto3,oneof"`
}
type PortValueType_Dns struct {
	Dns *Empty `protobuf:"bytes,3,opt,name=dns,oneof"`
}

func (*PortValueType_All) isPortValueType_PortValueTypeChoice()         {}
func (*PortValueType_UserDefined) isPortValueType_PortValueTypeChoice() {}
func (*PortValueType_Dns) isPortValueType_PortValueTypeChoice()         {}

func (m *PortValueType) GetPortValueTypeChoice() isPortValueType_PortValueTypeChoice {
	if m != nil {
		return m.PortValueTypeChoice
	}
	return nil
}

func (m *PortValueType) GetAll() *Empty {
	if x, ok := m.GetPortValueTypeChoice().(*PortValueType_All); ok {
		return x.All
	}
	return nil
}

func (m *PortValueType) GetUserDefined() uint32 {
	if x, ok := m.GetPortValueTypeChoice().(*PortValueType_UserDefined); ok {
		return x.UserDefined
	}
	return 0
}

func (m *PortValueType) GetDns() *Empty {
	if x, ok := m.GetPortValueTypeChoice().(*PortValueType_Dns); ok {
		return x.Dns
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PortValueType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PortValueType_OneofMarshaler, _PortValueType_OneofUnmarshaler, _PortValueType_OneofSizer, []interface{}{
		(*PortValueType_All)(nil),
		(*PortValueType_UserDefined)(nil),
		(*PortValueType_Dns)(nil),
	}
}

func _PortValueType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PortValueType)
	// port_value_type_choice
	switch x := m.PortValueTypeChoice.(type) {
	case *PortValueType_All:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.All); err != nil {
			return err
		}
	case *PortValueType_UserDefined:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.UserDefined))
	case *PortValueType_Dns:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dns); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PortValueType.PortValueTypeChoice has unexpected type %T", x)
	}
	return nil
}

func _PortValueType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PortValueType)
	switch tag {
	case 1: // port_value_type_choice.all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.PortValueTypeChoice = &PortValueType_All{msg}
		return true, err
	case 2: // port_value_type_choice.user_defined
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PortValueTypeChoice = &PortValueType_UserDefined{uint32(x)}
		return true, err
	case 3: // port_value_type_choice.dns
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.PortValueTypeChoice = &PortValueType_Dns{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PortValueType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PortValueType)
	// port_value_type_choice
	switch x := m.PortValueTypeChoice.(type) {
	case *PortValueType_All:
		s := proto.Size(x.All)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PortValueType_UserDefined:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.UserDefined))
	case *PortValueType_Dns:
		s := proto.Size(x.Dns)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// VirtualNetworkReferenceType
//
// x-displayName: "Virtual Network Reference Type"
// Carries the reference to virtual network
type VirtualNetworkReferenceType struct {
	// Virtual Network Reference
	//
	// x-displayName: "Virtual Network Reference"
	// Reference to virtual network
	Refs []*ObjectRefType `protobuf:"bytes,1,rep,name=refs" json:"refs,omitempty"`
}

func (m *VirtualNetworkReferenceType) Reset()      { *m = VirtualNetworkReferenceType{} }
func (*VirtualNetworkReferenceType) ProtoMessage() {}
func (*VirtualNetworkReferenceType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{64}
}

func (m *VirtualNetworkReferenceType) GetRefs() []*ObjectRefType {
	if m != nil {
		return m.Refs
	}
	return nil
}

// VirtualNetworkSelectorType
//
// x-displayName: "Virtual Network Type"
// Different types of virtual networks understood by the system
type VirtualNetworkSelectorType struct {
	// vn_type_choice
	//
	// x-displayName: "Virtual Network"
	// Different types of virtual networks understood by the system
	//
	// Types that are valid to be assigned to VnTypeChoice:
	//	*VirtualNetworkSelectorType_SiteLocal
	//	*VirtualNetworkSelectorType_SiteLocalInside
	//	*VirtualNetworkSelectorType_Public
	VnTypeChoice isVirtualNetworkSelectorType_VnTypeChoice `protobuf_oneof:"vn_type_choice"`
}

func (m *VirtualNetworkSelectorType) Reset()                    { *m = VirtualNetworkSelectorType{} }
func (*VirtualNetworkSelectorType) ProtoMessage()               {}
func (*VirtualNetworkSelectorType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{65} }

type isVirtualNetworkSelectorType_VnTypeChoice interface {
	isVirtualNetworkSelectorType_VnTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VirtualNetworkSelectorType_SiteLocal struct {
	SiteLocal *Empty `protobuf:"bytes,1,opt,name=site_local,json=siteLocal,oneof"`
}
type VirtualNetworkSelectorType_SiteLocalInside struct {
	SiteLocalInside *Empty `protobuf:"bytes,2,opt,name=site_local_inside,json=siteLocalInside,oneof"`
}
type VirtualNetworkSelectorType_Public struct {
	Public *Empty `protobuf:"bytes,4,opt,name=public,oneof"`
}

func (*VirtualNetworkSelectorType_SiteLocal) isVirtualNetworkSelectorType_VnTypeChoice()       {}
func (*VirtualNetworkSelectorType_SiteLocalInside) isVirtualNetworkSelectorType_VnTypeChoice() {}
func (*VirtualNetworkSelectorType_Public) isVirtualNetworkSelectorType_VnTypeChoice()          {}

func (m *VirtualNetworkSelectorType) GetVnTypeChoice() isVirtualNetworkSelectorType_VnTypeChoice {
	if m != nil {
		return m.VnTypeChoice
	}
	return nil
}

func (m *VirtualNetworkSelectorType) GetSiteLocal() *Empty {
	if x, ok := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_SiteLocal); ok {
		return x.SiteLocal
	}
	return nil
}

func (m *VirtualNetworkSelectorType) GetSiteLocalInside() *Empty {
	if x, ok := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_SiteLocalInside); ok {
		return x.SiteLocalInside
	}
	return nil
}

func (m *VirtualNetworkSelectorType) GetPublic() *Empty {
	if x, ok := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_Public); ok {
		return x.Public
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VirtualNetworkSelectorType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VirtualNetworkSelectorType_OneofMarshaler, _VirtualNetworkSelectorType_OneofUnmarshaler, _VirtualNetworkSelectorType_OneofSizer, []interface{}{
		(*VirtualNetworkSelectorType_SiteLocal)(nil),
		(*VirtualNetworkSelectorType_SiteLocalInside)(nil),
		(*VirtualNetworkSelectorType_Public)(nil),
	}
}

func _VirtualNetworkSelectorType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VirtualNetworkSelectorType)
	// vn_type_choice
	switch x := m.VnTypeChoice.(type) {
	case *VirtualNetworkSelectorType_SiteLocal:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SiteLocal); err != nil {
			return err
		}
	case *VirtualNetworkSelectorType_SiteLocalInside:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SiteLocalInside); err != nil {
			return err
		}
	case *VirtualNetworkSelectorType_Public:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Public); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VirtualNetworkSelectorType.VnTypeChoice has unexpected type %T", x)
	}
	return nil
}

func _VirtualNetworkSelectorType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VirtualNetworkSelectorType)
	switch tag {
	case 1: // vn_type_choice.site_local
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.VnTypeChoice = &VirtualNetworkSelectorType_SiteLocal{msg}
		return true, err
	case 2: // vn_type_choice.site_local_inside
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.VnTypeChoice = &VirtualNetworkSelectorType_SiteLocalInside{msg}
		return true, err
	case 4: // vn_type_choice.public
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.VnTypeChoice = &VirtualNetworkSelectorType_Public{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VirtualNetworkSelectorType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VirtualNetworkSelectorType)
	// vn_type_choice
	switch x := m.VnTypeChoice.(type) {
	case *VirtualNetworkSelectorType_SiteLocal:
		s := proto.Size(x.SiteLocal)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VirtualNetworkSelectorType_SiteLocalInside:
		s := proto.Size(x.SiteLocalInside)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VirtualNetworkSelectorType_Public:
		s := proto.Size(x.Public)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RetryBackOff
//
// x-displayName: "Retry BackOff interval"
// Specifies parameters that control retry back off.
type RetryBackOff struct {
	// base_interval
	//
	// x-displayName: "base retry interval"
	// x-example: 5
	// Specifies the base interval between retries in milliseconds
	BaseInterval uint32 `protobuf:"varint,1,opt,name=base_interval,json=baseInterval,proto3" json:"base_interval,omitempty"`
	// max_interval
	//
	// x-displayName: "maximum retry interval"
	// x-example: 60
	// Specifies the maximum interval between retries in milliseconds.
	// This parameter is optional, but must be greater than or equal
	// to the base_interval if set. The default is 10 times the base_interval.
	MaxInterval uint32 `protobuf:"varint,2,opt,name=max_interval,json=maxInterval,proto3" json:"max_interval,omitempty"`
}

func (m *RetryBackOff) Reset()                    { *m = RetryBackOff{} }
func (*RetryBackOff) ProtoMessage()               {}
func (*RetryBackOff) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{66} }

func (m *RetryBackOff) GetBaseInterval() uint32 {
	if m != nil {
		return m.BaseInterval
	}
	return 0
}

func (m *RetryBackOff) GetMaxInterval() uint32 {
	if m != nil {
		return m.MaxInterval
	}
	return 0
}

// RetryPolicyType
//
// x-displayName: "Retry Policy"
// Retry policy configuration for route destination.
type RetryPolicyType struct {
	// retry_on
	//
	// x-displayName: "Retry On"
	// x-example: "5xx"
	// Specifies the conditions under which retry takes place.
	// Retries can be on different types of condition depending on application requirements.
	// For example, network failure, all 5xx response codes, idempotent 4xx response codes, etc
	//
	// The possible values are
	//
	// "5xx"             : Retry will be done if the upstream server responds with any 5xx response code,
	//                     or does not respond at all (disconnect/reset/read timeout).
	//
	// "gateway-error"   : Retry will be done only if the upstream server responds with 502, 503 or
	//                     504 responses (Included in 5xx)
	//
	// "connect-failure" : Retry will be done if the request fails because of a connection failure to the
	//                     upstream server (connect timeout, etc.). (Included in 5xx)
	//
	// "refused-stream"  : Retry is done if the upstream server resets the stream with a REFUSED_STREAM
	//                     error code (Included in 5xx)
	//
	// "retriable-4xx"   : Retry is done if the upstream server responds with a retriable 4xx response code.
	//                     The only response code in this category is HTTP CONFLICT (409)
	//
	// "retriable-status-codes" :  Retry is done if the upstream server responds with any response code
	//                             matching one defined in retriable_status_codes field
	RetryOn string `protobuf:"bytes,1,opt,name=retry_on,json=retryOn,proto3" json:"retry_on,omitempty"`
	// num_retries
	//
	// x-displayName: "Number of Retries"
	// x-example: 3
	// Specifies the allowed number of retries. Defaults to 1.
	// Retries can be done any number of times. An exponential back-off algorithm
	// is used between each retry
	NumRetries uint32 `protobuf:"varint,2,opt,name=num_retries,json=numRetries,proto3" json:"num_retries,omitempty"`
	// per_try_timeout
	//
	// x-displayName: "Per Try Timeout"
	// x-example: 1000
	// Specifies a non-zero timeout per retry attempt. In milliseconds
	PerTryTimeout uint32 `protobuf:"varint,3,opt,name=per_try_timeout,json=perTryTimeout,proto3" json:"per_try_timeout,omitempty"`
	// Retriable status Code
	//
	// x-displayName: "Status Code to Retry"
	// x-example: 403
	// HTTP status codes that should trigger a retry in addition to those specified by retry_on.
	RetriableStatusCodes []uint32 `protobuf:"varint,4,rep,packed,name=retriable_status_codes,json=retriableStatusCodes" json:"retriable_status_codes,omitempty"`
	// Retry BackOff
	//
	// x-displayName: "Retry BackOff interval"
	// Specifies parameters that control retry back off.
	// This parameter is optional, in which case the default base
	// interval is 25 milliseconds. The default maximum interval is
	// 10 times the base interval
	BackOff *RetryBackOff `protobuf:"bytes,5,opt,name=back_off,json=backOff" json:"back_off,omitempty"`
}

func (m *RetryPolicyType) Reset()                    { *m = RetryPolicyType{} }
func (*RetryPolicyType) ProtoMessage()               {}
func (*RetryPolicyType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{67} }

func (m *RetryPolicyType) GetRetryOn() string {
	if m != nil {
		return m.RetryOn
	}
	return ""
}

func (m *RetryPolicyType) GetNumRetries() uint32 {
	if m != nil {
		return m.NumRetries
	}
	return 0
}

func (m *RetryPolicyType) GetPerTryTimeout() uint32 {
	if m != nil {
		return m.PerTryTimeout
	}
	return 0
}

func (m *RetryPolicyType) GetRetriableStatusCodes() []uint32 {
	if m != nil {
		return m.RetriableStatusCodes
	}
	return nil
}

func (m *RetryPolicyType) GetBackOff() *RetryBackOff {
	if m != nil {
		return m.BackOff
	}
	return nil
}

// Metric Value
//
// x-displayName: "Metric Value"
// Metric data contains timestamp and the value.
type MetricValue struct {
	// Timestamp
	//
	// x-displayName: "Timestamp"
	// x-example: "1570007981"
	// timestamp
	Timestamp float64 `protobuf:"fixed64,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Value
	//
	// x-displayName: "Value"
	// x-example: "15"
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MetricValue) Reset()                    { *m = MetricValue{} }
func (*MetricValue) ProtoMessage()               {}
func (*MetricValue) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{68} }

func (m *MetricValue) GetTimestamp() float64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MetricValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Nexthop
//
// x-displayName: "Nexthop"
// Identifies the next-hop for a route
type NextHopType struct {
	// Type
	//
	// x-displayName: "Type"
	// Identifies the type of next-hop
	Type NextHopTypes `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.NextHopTypes" json:"type,omitempty"`
	// Nexthop Address
	//
	// x-displayName: "Address"
	// Nexthop address when type is "Use-Configured"
	NexthopAddress *IpAddressType `protobuf:"bytes,2,opt,name=nexthop_address,json=nexthopAddress" json:"nexthop_address,omitempty"`
	// Network Interface
	//
	// x-displayName: "Network Interface"
	// Nexthop is network interface when type is "Network-Interface"
	Interface []*ObjectRefType `protobuf:"bytes,3,rep,name=interface" json:"interface,omitempty"`
}

func (m *NextHopType) Reset()                    { *m = NextHopType{} }
func (*NextHopType) ProtoMessage()               {}
func (*NextHopType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{69} }

func (m *NextHopType) GetType() NextHopTypes {
	if m != nil {
		return m.Type
	}
	return NEXT_HOP_DEFAULT_GATEWAY
}

func (m *NextHopType) GetNexthopAddress() *IpAddressType {
	if m != nil {
		return m.NexthopAddress
	}
	return nil
}

func (m *NextHopType) GetInterface() []*ObjectRefType {
	if m != nil {
		return m.Interface
	}
	return nil
}

// Static Route
//
// x-displayName: "Static Route"
// Defines a static route, configuring a list of prefixes and a next-hop to be used for them
type StaticRouteType struct {
	// Attributes
	//
	// x-displayName: "Attributes"
	// List of route attributes associated with the static route
	Attrs []RouteAttrType `protobuf:"varint,1,rep,packed,name=attrs,enum=ves.io.schema.RouteAttrType" json:"attrs,omitempty"`
	// Subnets
	//
	// x-displayName: "Subnets"
	// List of route prefixes
	Subnets []*IpSubnetType `protobuf:"bytes,2,rep,name=subnets" json:"subnets,omitempty"`
	// Nexthop
	//
	// x-displayName: "Nexthop"
	// Nexthop for the route
	Nexthop *NextHopType `protobuf:"bytes,10,opt,name=nexthop" json:"nexthop,omitempty"`
	// Static Route labels
	//
	// x-displayName: "Static Route Labels"
	// Add Labels for this Static Route, these labels can be used in network policy
	Labels map[string]string `protobuf:"bytes,11,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *StaticRouteType) Reset()                    { *m = StaticRouteType{} }
func (*StaticRouteType) ProtoMessage()               {}
func (*StaticRouteType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{70} }

func (m *StaticRouteType) GetAttrs() []RouteAttrType {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *StaticRouteType) GetSubnets() []*IpSubnetType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *StaticRouteType) GetNexthop() *NextHopType {
	if m != nil {
		return m.Nexthop
	}
	return nil
}

func (m *StaticRouteType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// ForwardProxyConfigType
//
// x-displayName: "Forward Proxy Configuration"
// Fine tune forward proxy behavior
//
// Few configurations allowed are
//
//   White listed ports and ip prefixes:
//     Forward proxy does application protocol detection and server name(SNI) detection by peeking into
//     the traffic on the incoming downstream connection. Few protocols doesn't have client sending
//     the first data. In such cases, protocol and SNI detection fails. This configuration allows,
//     skipping protocol and SNI detection for whitelisted ip-prefix-list and ports
//   connection_timeout:
//     The timeout for new network connections to upstream server.
//   max_connect_attempts:
//     Maximum number of attempts made to make new network connection to upstream server.
//
type ForwardProxyConfigType struct {
	// IP prefix list
	//
	// x-displayName: "IP Prefixes to Skip Protocol Parsing"
	// x-example: "['10.2.1.0/24', '192.168.8.0/29', '10.7.64.160/27']"
	// Traffic to these destination ip prefixes is not subjected to protocol parsing
	// Example "tmate" server ip
	WhiteListedPrefixes []string `protobuf:"bytes,1,rep,name=white_listed_prefixes,json=whiteListedPrefixes" json:"white_listed_prefixes,omitempty"`
	// Port list
	//
	// x-displayName: "TCP Ports to Skip Protocol Parsing"
	// x-example: [22, 9400]
	// Traffic to these destination TCP ports is not subjected to protocol parsing
	// Example "tmate" server port
	WhiteListedPorts []uint32 `protobuf:"varint,2,rep,packed,name=white_listed_ports,json=whiteListedPorts" json:"white_listed_ports,omitempty"`
	// max_connect_attempts
	//
	// x-displayName: "Number of connect attempts"
	// x-example: 3
	// Specifies the allowed number of retries on connect failure to upstream server. Defaults to 1.
	MaxConnectAttempts uint32 `protobuf:"varint,3,opt,name=max_connect_attempts,json=maxConnectAttempts,proto3" json:"max_connect_attempts,omitempty"`
	// connection_timeout
	//
	// x-displayName: "Connection Timeout"
	// x-example: "4000"
	// The timeout for new network connections to upstream server.
	// This is specified in milliseconds. The default value is 2000 (2 seconds)
	ConnectionTimeout uint32 `protobuf:"varint,4,opt,name=connection_timeout,json=connectionTimeout,proto3" json:"connection_timeout,omitempty"`
	// TLS Interception choice
	//
	// x-displayName: "Enable TLS Interception"
	// TLS interception is enabled for HTTPS connections
	// This configuration is applicable only when ForwardProxy and DynamicReverseProxy is enabled on the network connector
	//
	// Types that are valid to be assigned to TlsInterceptionChoice:
	//	*ForwardProxyConfigType_NoInterception
	//	*ForwardProxyConfigType_TlsIntercept
	TlsInterceptionChoice isForwardProxyConfigType_TlsInterceptionChoice `protobuf_oneof:"tls_interception_choice"`
}

func (m *ForwardProxyConfigType) Reset()                    { *m = ForwardProxyConfigType{} }
func (*ForwardProxyConfigType) ProtoMessage()               {}
func (*ForwardProxyConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{71} }

type isForwardProxyConfigType_TlsInterceptionChoice interface {
	isForwardProxyConfigType_TlsInterceptionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ForwardProxyConfigType_NoInterception struct {
	NoInterception *Empty `protobuf:"bytes,6,opt,name=no_interception,json=noInterception,oneof"`
}
type ForwardProxyConfigType_TlsIntercept struct {
	TlsIntercept *TlsInterceptionType `protobuf:"bytes,7,opt,name=tls_intercept,json=tlsIntercept,oneof"`
}

func (*ForwardProxyConfigType_NoInterception) isForwardProxyConfigType_TlsInterceptionChoice() {}
func (*ForwardProxyConfigType_TlsIntercept) isForwardProxyConfigType_TlsInterceptionChoice()   {}

func (m *ForwardProxyConfigType) GetTlsInterceptionChoice() isForwardProxyConfigType_TlsInterceptionChoice {
	if m != nil {
		return m.TlsInterceptionChoice
	}
	return nil
}

func (m *ForwardProxyConfigType) GetWhiteListedPrefixes() []string {
	if m != nil {
		return m.WhiteListedPrefixes
	}
	return nil
}

func (m *ForwardProxyConfigType) GetWhiteListedPorts() []uint32 {
	if m != nil {
		return m.WhiteListedPorts
	}
	return nil
}

func (m *ForwardProxyConfigType) GetMaxConnectAttempts() uint32 {
	if m != nil {
		return m.MaxConnectAttempts
	}
	return 0
}

func (m *ForwardProxyConfigType) GetConnectionTimeout() uint32 {
	if m != nil {
		return m.ConnectionTimeout
	}
	return 0
}

func (m *ForwardProxyConfigType) GetNoInterception() *Empty {
	if x, ok := m.GetTlsInterceptionChoice().(*ForwardProxyConfigType_NoInterception); ok {
		return x.NoInterception
	}
	return nil
}

func (m *ForwardProxyConfigType) GetTlsIntercept() *TlsInterceptionType {
	if x, ok := m.GetTlsInterceptionChoice().(*ForwardProxyConfigType_TlsIntercept); ok {
		return x.TlsIntercept
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ForwardProxyConfigType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ForwardProxyConfigType_OneofMarshaler, _ForwardProxyConfigType_OneofUnmarshaler, _ForwardProxyConfigType_OneofSizer, []interface{}{
		(*ForwardProxyConfigType_NoInterception)(nil),
		(*ForwardProxyConfigType_TlsIntercept)(nil),
	}
}

func _ForwardProxyConfigType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ForwardProxyConfigType)
	// tls_interception_choice
	switch x := m.TlsInterceptionChoice.(type) {
	case *ForwardProxyConfigType_NoInterception:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoInterception); err != nil {
			return err
		}
	case *ForwardProxyConfigType_TlsIntercept:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TlsIntercept); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ForwardProxyConfigType.TlsInterceptionChoice has unexpected type %T", x)
	}
	return nil
}

func _ForwardProxyConfigType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ForwardProxyConfigType)
	switch tag {
	case 6: // tls_interception_choice.no_interception
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.TlsInterceptionChoice = &ForwardProxyConfigType_NoInterception{msg}
		return true, err
	case 7: // tls_interception_choice.tls_intercept
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsInterceptionType)
		err := b.DecodeMessage(msg)
		m.TlsInterceptionChoice = &ForwardProxyConfigType_TlsIntercept{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ForwardProxyConfigType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ForwardProxyConfigType)
	// tls_interception_choice
	switch x := m.TlsInterceptionChoice.(type) {
	case *ForwardProxyConfigType_NoInterception:
		s := proto.Size(x.NoInterception)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ForwardProxyConfigType_TlsIntercept:
		s := proto.Size(x.TlsIntercept)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Host Identifier
//
// x-displayName: "Host Identifier"
// Host Identifier identifies a host, either by its DNS name (hostname) or by its IP address.
type HostIdentifier struct {
	// hostname_or_ip
	//
	// x-displayName: "Hostname/IP"
	// One of following
	//
	// Types that are valid to be assigned to HostnameOrIp:
	//	*HostIdentifier_Ip
	//	*HostIdentifier_Hostname
	HostnameOrIp isHostIdentifier_HostnameOrIp `protobuf_oneof:"hostname_or_ip"`
}

func (m *HostIdentifier) Reset()                    { *m = HostIdentifier{} }
func (*HostIdentifier) ProtoMessage()               {}
func (*HostIdentifier) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{72} }

type isHostIdentifier_HostnameOrIp interface {
	isHostIdentifier_HostnameOrIp()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HostIdentifier_Ip struct {
	Ip string `protobuf:"bytes,1,opt,name=ip,proto3,oneof"`
}
type HostIdentifier_Hostname struct {
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3,oneof"`
}

func (*HostIdentifier_Ip) isHostIdentifier_HostnameOrIp()       {}
func (*HostIdentifier_Hostname) isHostIdentifier_HostnameOrIp() {}

func (m *HostIdentifier) GetHostnameOrIp() isHostIdentifier_HostnameOrIp {
	if m != nil {
		return m.HostnameOrIp
	}
	return nil
}

func (m *HostIdentifier) GetIp() string {
	if x, ok := m.GetHostnameOrIp().(*HostIdentifier_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *HostIdentifier) GetHostname() string {
	if x, ok := m.GetHostnameOrIp().(*HostIdentifier_Hostname); ok {
		return x.Hostname
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HostIdentifier) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HostIdentifier_OneofMarshaler, _HostIdentifier_OneofUnmarshaler, _HostIdentifier_OneofSizer, []interface{}{
		(*HostIdentifier_Ip)(nil),
		(*HostIdentifier_Hostname)(nil),
	}
}

func _HostIdentifier_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HostIdentifier)
	// hostname_or_ip
	switch x := m.HostnameOrIp.(type) {
	case *HostIdentifier_Ip:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Ip)
	case *HostIdentifier_Hostname:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Hostname)
	case nil:
	default:
		return fmt.Errorf("HostIdentifier.HostnameOrIp has unexpected type %T", x)
	}
	return nil
}

func _HostIdentifier_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HostIdentifier)
	switch tag {
	case 1: // hostname_or_ip.ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HostnameOrIp = &HostIdentifier_Ip{x}
		return true, err
	case 2: // hostname_or_ip.hostname
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HostnameOrIp = &HostIdentifier_Hostname{x}
		return true, err
	default:
		return false, nil
	}
}

func _HostIdentifier_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HostIdentifier)
	// hostname_or_ip
	switch x := m.HostnameOrIp.(type) {
	case *HostIdentifier_Ip:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Ip)))
		n += len(x.Ip)
	case *HostIdentifier_Hostname:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Hostname)))
		n += len(x.Hostname)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Interface Identifier
//
// x-displayName: "Interface Identifier"
// Interface Identifier identifies one or all interfaces on a node
type InterfaceIdentifier struct {
	// Interface Choice
	//
	// x-displayName: "Interface Choice"
	// One of following
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*InterfaceIdentifier_AnyIntf
	//	*InterfaceIdentifier_Intf
	InterfaceChoice isInterfaceIdentifier_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *InterfaceIdentifier) Reset()                    { *m = InterfaceIdentifier{} }
func (*InterfaceIdentifier) ProtoMessage()               {}
func (*InterfaceIdentifier) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{73} }

type isInterfaceIdentifier_InterfaceChoice interface {
	isInterfaceIdentifier_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceIdentifier_AnyIntf struct {
	AnyIntf *Empty `protobuf:"bytes,1,opt,name=any_intf,json=anyIntf,oneof"`
}
type InterfaceIdentifier_Intf struct {
	Intf string `protobuf:"bytes,2,opt,name=intf,proto3,oneof"`
}

func (*InterfaceIdentifier_AnyIntf) isInterfaceIdentifier_InterfaceChoice() {}
func (*InterfaceIdentifier_Intf) isInterfaceIdentifier_InterfaceChoice()    {}

func (m *InterfaceIdentifier) GetInterfaceChoice() isInterfaceIdentifier_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *InterfaceIdentifier) GetAnyIntf() *Empty {
	if x, ok := m.GetInterfaceChoice().(*InterfaceIdentifier_AnyIntf); ok {
		return x.AnyIntf
	}
	return nil
}

func (m *InterfaceIdentifier) GetIntf() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceIdentifier_Intf); ok {
		return x.Intf
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InterfaceIdentifier) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InterfaceIdentifier_OneofMarshaler, _InterfaceIdentifier_OneofUnmarshaler, _InterfaceIdentifier_OneofSizer, []interface{}{
		(*InterfaceIdentifier_AnyIntf)(nil),
		(*InterfaceIdentifier_Intf)(nil),
	}
}

func _InterfaceIdentifier_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InterfaceIdentifier)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *InterfaceIdentifier_AnyIntf:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyIntf); err != nil {
			return err
		}
	case *InterfaceIdentifier_Intf:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Intf)
	case nil:
	default:
		return fmt.Errorf("InterfaceIdentifier.InterfaceChoice has unexpected type %T", x)
	}
	return nil
}

func _InterfaceIdentifier_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InterfaceIdentifier)
	switch tag {
	case 1: // interface_choice.any_intf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &InterfaceIdentifier_AnyIntf{msg}
		return true, err
	case 2: // interface_choice.intf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.InterfaceChoice = &InterfaceIdentifier_Intf{x}
		return true, err
	default:
		return false, nil
	}
}

func _InterfaceIdentifier_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InterfaceIdentifier)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *InterfaceIdentifier_AnyIntf:
		s := proto.Size(x.AnyIntf)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceIdentifier_Intf:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Intf)))
		n += len(x.Intf)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Interface Or Network
//
// x-displayName: "Interface Or Network"
// Selects an interface on a node
type InterfaceOrNetwork struct {
	// Interface Choice
	//
	// x-displayName: "Interface Choice"
	// One of following
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*InterfaceOrNetwork_Intf
	//	*InterfaceOrNetwork_Pod
	//	*InterfaceOrNetwork_VnType
	//	*InterfaceOrNetwork_Vn
	InterfaceChoice isInterfaceOrNetwork_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *InterfaceOrNetwork) Reset()                    { *m = InterfaceOrNetwork{} }
func (*InterfaceOrNetwork) ProtoMessage()               {}
func (*InterfaceOrNetwork) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{74} }

type isInterfaceOrNetwork_InterfaceChoice interface {
	isInterfaceOrNetwork_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceOrNetwork_Intf struct {
	Intf string `protobuf:"bytes,1,opt,name=intf,proto3,oneof"`
}
type InterfaceOrNetwork_Pod struct {
	Pod string `protobuf:"bytes,2,opt,name=pod,proto3,oneof"`
}
type InterfaceOrNetwork_VnType struct {
	VnType VirtualNetworkType `protobuf:"varint,3,opt,name=vn_type,json=vnType,proto3,enum=ves.io.schema.VirtualNetworkType,oneof"`
}
type InterfaceOrNetwork_Vn struct {
	Vn string `protobuf:"bytes,4,opt,name=vn,proto3,oneof"`
}

func (*InterfaceOrNetwork_Intf) isInterfaceOrNetwork_InterfaceChoice()   {}
func (*InterfaceOrNetwork_Pod) isInterfaceOrNetwork_InterfaceChoice()    {}
func (*InterfaceOrNetwork_VnType) isInterfaceOrNetwork_InterfaceChoice() {}
func (*InterfaceOrNetwork_Vn) isInterfaceOrNetwork_InterfaceChoice()     {}

func (m *InterfaceOrNetwork) GetInterfaceChoice() isInterfaceOrNetwork_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *InterfaceOrNetwork) GetIntf() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_Intf); ok {
		return x.Intf
	}
	return ""
}

func (m *InterfaceOrNetwork) GetPod() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_Pod); ok {
		return x.Pod
	}
	return ""
}

func (m *InterfaceOrNetwork) GetVnType() VirtualNetworkType {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_VnType); ok {
		return x.VnType
	}
	return VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *InterfaceOrNetwork) GetVn() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_Vn); ok {
		return x.Vn
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InterfaceOrNetwork) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InterfaceOrNetwork_OneofMarshaler, _InterfaceOrNetwork_OneofUnmarshaler, _InterfaceOrNetwork_OneofSizer, []interface{}{
		(*InterfaceOrNetwork_Intf)(nil),
		(*InterfaceOrNetwork_Pod)(nil),
		(*InterfaceOrNetwork_VnType)(nil),
		(*InterfaceOrNetwork_Vn)(nil),
	}
}

func _InterfaceOrNetwork_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InterfaceOrNetwork)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *InterfaceOrNetwork_Intf:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Intf)
	case *InterfaceOrNetwork_Pod:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Pod)
	case *InterfaceOrNetwork_VnType:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.VnType))
	case *InterfaceOrNetwork_Vn:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Vn)
	case nil:
	default:
		return fmt.Errorf("InterfaceOrNetwork.InterfaceChoice has unexpected type %T", x)
	}
	return nil
}

func _InterfaceOrNetwork_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InterfaceOrNetwork)
	switch tag {
	case 1: // interface_choice.intf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.InterfaceChoice = &InterfaceOrNetwork_Intf{x}
		return true, err
	case 2: // interface_choice.pod
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.InterfaceChoice = &InterfaceOrNetwork_Pod{x}
		return true, err
	case 3: // interface_choice.vn_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.InterfaceChoice = &InterfaceOrNetwork_VnType{VirtualNetworkType(x)}
		return true, err
	case 4: // interface_choice.vn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.InterfaceChoice = &InterfaceOrNetwork_Vn{x}
		return true, err
	default:
		return false, nil
	}
}

func _InterfaceOrNetwork_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InterfaceOrNetwork)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *InterfaceOrNetwork_Intf:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Intf)))
		n += len(x.Intf)
	case *InterfaceOrNetwork_Pod:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Pod)))
		n += len(x.Pod)
	case *InterfaceOrNetwork_VnType:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.VnType))
	case *InterfaceOrNetwork_Vn:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Vn)))
		n += len(x.Vn)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Empty)(nil), "ves.io.schema.Empty")
	golang_proto.RegisterType((*Empty)(nil), "ves.io.schema.Empty")
	proto.RegisterType((*ObjectRefType)(nil), "ves.io.schema.ObjectRefType")
	golang_proto.RegisterType((*ObjectRefType)(nil), "ves.io.schema.ObjectRefType")
	proto.RegisterType((*LabelSelectorType)(nil), "ves.io.schema.LabelSelectorType")
	golang_proto.RegisterType((*LabelSelectorType)(nil), "ves.io.schema.LabelSelectorType")
	proto.RegisterType((*LabelMatcherType)(nil), "ves.io.schema.LabelMatcherType")
	golang_proto.RegisterType((*LabelMatcherType)(nil), "ves.io.schema.LabelMatcherType")
	proto.RegisterType((*ConditionType)(nil), "ves.io.schema.ConditionType")
	golang_proto.RegisterType((*ConditionType)(nil), "ves.io.schema.ConditionType")
	proto.RegisterType((*StatusType)(nil), "ves.io.schema.StatusType")
	golang_proto.RegisterType((*StatusType)(nil), "ves.io.schema.StatusType")
	proto.RegisterType((*InitializerType)(nil), "ves.io.schema.InitializerType")
	golang_proto.RegisterType((*InitializerType)(nil), "ves.io.schema.InitializerType")
	proto.RegisterType((*InitializersType)(nil), "ves.io.schema.InitializersType")
	golang_proto.RegisterType((*InitializersType)(nil), "ves.io.schema.InitializersType")
	proto.RegisterType((*StatusMetaType)(nil), "ves.io.schema.StatusMetaType")
	golang_proto.RegisterType((*StatusMetaType)(nil), "ves.io.schema.StatusMetaType")
	proto.RegisterType((*ObjectMetaType)(nil), "ves.io.schema.ObjectMetaType")
	golang_proto.RegisterType((*ObjectMetaType)(nil), "ves.io.schema.ObjectMetaType")
	proto.RegisterType((*ListMetaType)(nil), "ves.io.schema.ListMetaType")
	golang_proto.RegisterType((*ListMetaType)(nil), "ves.io.schema.ListMetaType")
	proto.RegisterType((*ObjectGetMetaType)(nil), "ves.io.schema.ObjectGetMetaType")
	golang_proto.RegisterType((*ObjectGetMetaType)(nil), "ves.io.schema.ObjectGetMetaType")
	proto.RegisterType((*ObjectCreateMetaType)(nil), "ves.io.schema.ObjectCreateMetaType")
	golang_proto.RegisterType((*ObjectCreateMetaType)(nil), "ves.io.schema.ObjectCreateMetaType")
	proto.RegisterType((*ObjectReplaceMetaType)(nil), "ves.io.schema.ObjectReplaceMetaType")
	golang_proto.RegisterType((*ObjectReplaceMetaType)(nil), "ves.io.schema.ObjectReplaceMetaType")
	proto.RegisterType((*MessageMetaType)(nil), "ves.io.schema.MessageMetaType")
	golang_proto.RegisterType((*MessageMetaType)(nil), "ves.io.schema.MessageMetaType")
	proto.RegisterType((*ViewRefType)(nil), "ves.io.schema.ViewRefType")
	golang_proto.RegisterType((*ViewRefType)(nil), "ves.io.schema.ViewRefType")
	proto.RegisterType((*KubeRefType)(nil), "ves.io.schema.KubeRefType")
	golang_proto.RegisterType((*KubeRefType)(nil), "ves.io.schema.KubeRefType")
	proto.RegisterType((*SystemObjectMetaType)(nil), "ves.io.schema.SystemObjectMetaType")
	golang_proto.RegisterType((*SystemObjectMetaType)(nil), "ves.io.schema.SystemObjectMetaType")
	proto.RegisterType((*SystemObjectGetMetaType)(nil), "ves.io.schema.SystemObjectGetMetaType")
	golang_proto.RegisterType((*SystemObjectGetMetaType)(nil), "ves.io.schema.SystemObjectGetMetaType")
	proto.RegisterType((*AuthnTypeBasicAuth)(nil), "ves.io.schema.AuthnTypeBasicAuth")
	golang_proto.RegisterType((*AuthnTypeBasicAuth)(nil), "ves.io.schema.AuthnTypeBasicAuth")
	proto.RegisterType((*AuthnTypeHeaders)(nil), "ves.io.schema.AuthnTypeHeaders")
	golang_proto.RegisterType((*AuthnTypeHeaders)(nil), "ves.io.schema.AuthnTypeHeaders")
	proto.RegisterType((*AuthnTypeQueryParams)(nil), "ves.io.schema.AuthnTypeQueryParams")
	golang_proto.RegisterType((*AuthnTypeQueryParams)(nil), "ves.io.schema.AuthnTypeQueryParams")
	proto.RegisterType((*BlindfoldSecretInfoType)(nil), "ves.io.schema.BlindfoldSecretInfoType")
	golang_proto.RegisterType((*BlindfoldSecretInfoType)(nil), "ves.io.schema.BlindfoldSecretInfoType")
	proto.RegisterType((*VaultSecretInfoType)(nil), "ves.io.schema.VaultSecretInfoType")
	golang_proto.RegisterType((*VaultSecretInfoType)(nil), "ves.io.schema.VaultSecretInfoType")
	proto.RegisterType((*ClearSecretInfoType)(nil), "ves.io.schema.ClearSecretInfoType")
	golang_proto.RegisterType((*ClearSecretInfoType)(nil), "ves.io.schema.ClearSecretInfoType")
	proto.RegisterType((*WingmanSecretInfoType)(nil), "ves.io.schema.WingmanSecretInfoType")
	golang_proto.RegisterType((*WingmanSecretInfoType)(nil), "ves.io.schema.WingmanSecretInfoType")
	proto.RegisterType((*SecretType)(nil), "ves.io.schema.SecretType")
	golang_proto.RegisterType((*SecretType)(nil), "ves.io.schema.SecretType")
	proto.RegisterType((*NetworkRefType)(nil), "ves.io.schema.NetworkRefType")
	golang_proto.RegisterType((*NetworkRefType)(nil), "ves.io.schema.NetworkRefType")
	proto.RegisterType((*SiteRefType)(nil), "ves.io.schema.SiteRefType")
	golang_proto.RegisterType((*SiteRefType)(nil), "ves.io.schema.SiteRefType")
	proto.RegisterType((*IpPrefixSetRefType)(nil), "ves.io.schema.IpPrefixSetRefType")
	golang_proto.RegisterType((*IpPrefixSetRefType)(nil), "ves.io.schema.IpPrefixSetRefType")
	proto.RegisterType((*VSiteRefType)(nil), "ves.io.schema.VSiteRefType")
	golang_proto.RegisterType((*VSiteRefType)(nil), "ves.io.schema.VSiteRefType")
	proto.RegisterType((*PolicerRefType)(nil), "ves.io.schema.PolicerRefType")
	golang_proto.RegisterType((*PolicerRefType)(nil), "ves.io.schema.PolicerRefType")
	proto.RegisterType((*ProtocolPolicerRefType)(nil), "ves.io.schema.ProtocolPolicerRefType")
	golang_proto.RegisterType((*ProtocolPolicerRefType)(nil), "ves.io.schema.ProtocolPolicerRefType")
	proto.RegisterType((*NetworkSiteRefSelector)(nil), "ves.io.schema.NetworkSiteRefSelector")
	golang_proto.RegisterType((*NetworkSiteRefSelector)(nil), "ves.io.schema.NetworkSiteRefSelector")
	proto.RegisterType((*SiteVirtualSiteRefSelector)(nil), "ves.io.schema.SiteVirtualSiteRefSelector")
	golang_proto.RegisterType((*SiteVirtualSiteRefSelector)(nil), "ves.io.schema.SiteVirtualSiteRefSelector")
	proto.RegisterType((*HeaderManipulationOptionType)(nil), "ves.io.schema.HeaderManipulationOptionType")
	golang_proto.RegisterType((*HeaderManipulationOptionType)(nil), "ves.io.schema.HeaderManipulationOptionType")
	proto.RegisterType((*TlsValidationParamsType)(nil), "ves.io.schema.TlsValidationParamsType")
	golang_proto.RegisterType((*TlsValidationParamsType)(nil), "ves.io.schema.TlsValidationParamsType")
	proto.RegisterType((*TlsCertificateType)(nil), "ves.io.schema.TlsCertificateType")
	golang_proto.RegisterType((*TlsCertificateType)(nil), "ves.io.schema.TlsCertificateType")
	proto.RegisterType((*TlsParamsType)(nil), "ves.io.schema.TlsParamsType")
	golang_proto.RegisterType((*TlsParamsType)(nil), "ves.io.schema.TlsParamsType")
	proto.RegisterType((*UpstreamTlsParamsType)(nil), "ves.io.schema.UpstreamTlsParamsType")
	golang_proto.RegisterType((*UpstreamTlsParamsType)(nil), "ves.io.schema.UpstreamTlsParamsType")
	proto.RegisterType((*DownstreamTlsParamsType)(nil), "ves.io.schema.DownstreamTlsParamsType")
	golang_proto.RegisterType((*DownstreamTlsParamsType)(nil), "ves.io.schema.DownstreamTlsParamsType")
	proto.RegisterType((*DomainType)(nil), "ves.io.schema.DomainType")
	golang_proto.RegisterType((*DomainType)(nil), "ves.io.schema.DomainType")
	proto.RegisterType((*L4DestType)(nil), "ves.io.schema.L4DestType")
	golang_proto.RegisterType((*L4DestType)(nil), "ves.io.schema.L4DestType")
	proto.RegisterType((*TlsInterceptionRule)(nil), "ves.io.schema.TlsInterceptionRule")
	golang_proto.RegisterType((*TlsInterceptionRule)(nil), "ves.io.schema.TlsInterceptionRule")
	proto.RegisterType((*TlsInterceptionPolicy)(nil), "ves.io.schema.TlsInterceptionPolicy")
	golang_proto.RegisterType((*TlsInterceptionPolicy)(nil), "ves.io.schema.TlsInterceptionPolicy")
	proto.RegisterType((*TlsInterceptionType)(nil), "ves.io.schema.TlsInterceptionType")
	golang_proto.RegisterType((*TlsInterceptionType)(nil), "ves.io.schema.TlsInterceptionType")
	proto.RegisterType((*FractionalPercent)(nil), "ves.io.schema.FractionalPercent")
	golang_proto.RegisterType((*FractionalPercent)(nil), "ves.io.schema.FractionalPercent")
	proto.RegisterType((*BufferConfigType)(nil), "ves.io.schema.BufferConfigType")
	golang_proto.RegisterType((*BufferConfigType)(nil), "ves.io.schema.BufferConfigType")
	proto.RegisterType((*CorsPolicy)(nil), "ves.io.schema.CorsPolicy")
	golang_proto.RegisterType((*CorsPolicy)(nil), "ves.io.schema.CorsPolicy")
	proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.PathMatcherType")
	golang_proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.PathMatcherType")
	proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.HeaderMatcherType")
	golang_proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.HeaderMatcherType")
	proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.QueryParameterMatcherType")
	golang_proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.QueryParameterMatcherType")
	proto.RegisterType((*RouteMatch)(nil), "ves.io.schema.RouteMatch")
	golang_proto.RegisterType((*RouteMatch)(nil), "ves.io.schema.RouteMatch")
	proto.RegisterType((*WafRefType)(nil), "ves.io.schema.WafRefType")
	golang_proto.RegisterType((*WafRefType)(nil), "ves.io.schema.WafRefType")
	proto.RegisterType((*WafRulesRefType)(nil), "ves.io.schema.WafRulesRefType")
	golang_proto.RegisterType((*WafRulesRefType)(nil), "ves.io.schema.WafRulesRefType")
	proto.RegisterType((*WafType)(nil), "ves.io.schema.WafType")
	golang_proto.RegisterType((*WafType)(nil), "ves.io.schema.WafType")
	proto.RegisterType((*AppRoleAuthInfoType)(nil), "ves.io.schema.AppRoleAuthInfoType")
	golang_proto.RegisterType((*AppRoleAuthInfoType)(nil), "ves.io.schema.AppRoleAuthInfoType")
	proto.RegisterType((*VaultAuthInfoType)(nil), "ves.io.schema.VaultAuthInfoType")
	golang_proto.RegisterType((*VaultAuthInfoType)(nil), "ves.io.schema.VaultAuthInfoType")
	proto.RegisterType((*RestAuthInfoType)(nil), "ves.io.schema.RestAuthInfoType")
	golang_proto.RegisterType((*RestAuthInfoType)(nil), "ves.io.schema.RestAuthInfoType")
	proto.RegisterType((*HostAccessInfoType)(nil), "ves.io.schema.HostAccessInfoType")
	golang_proto.RegisterType((*HostAccessInfoType)(nil), "ves.io.schema.HostAccessInfoType")
	proto.RegisterType((*VaultAccessInfoType)(nil), "ves.io.schema.VaultAccessInfoType")
	golang_proto.RegisterType((*VaultAccessInfoType)(nil), "ves.io.schema.VaultAccessInfoType")
	proto.RegisterType((*VaultSecretType)(nil), "ves.io.schema.VaultSecretType")
	golang_proto.RegisterType((*VaultSecretType)(nil), "ves.io.schema.VaultSecretType")
	proto.RegisterType((*VolterraSecretType)(nil), "ves.io.schema.VolterraSecretType")
	golang_proto.RegisterType((*VolterraSecretType)(nil), "ves.io.schema.VolterraSecretType")
	proto.RegisterType((*PortValueType)(nil), "ves.io.schema.PortValueType")
	golang_proto.RegisterType((*PortValueType)(nil), "ves.io.schema.PortValueType")
	proto.RegisterType((*VirtualNetworkReferenceType)(nil), "ves.io.schema.VirtualNetworkReferenceType")
	golang_proto.RegisterType((*VirtualNetworkReferenceType)(nil), "ves.io.schema.VirtualNetworkReferenceType")
	proto.RegisterType((*VirtualNetworkSelectorType)(nil), "ves.io.schema.VirtualNetworkSelectorType")
	golang_proto.RegisterType((*VirtualNetworkSelectorType)(nil), "ves.io.schema.VirtualNetworkSelectorType")
	proto.RegisterType((*RetryBackOff)(nil), "ves.io.schema.RetryBackOff")
	golang_proto.RegisterType((*RetryBackOff)(nil), "ves.io.schema.RetryBackOff")
	proto.RegisterType((*RetryPolicyType)(nil), "ves.io.schema.RetryPolicyType")
	golang_proto.RegisterType((*RetryPolicyType)(nil), "ves.io.schema.RetryPolicyType")
	proto.RegisterType((*MetricValue)(nil), "ves.io.schema.MetricValue")
	golang_proto.RegisterType((*MetricValue)(nil), "ves.io.schema.MetricValue")
	proto.RegisterType((*NextHopType)(nil), "ves.io.schema.NextHopType")
	golang_proto.RegisterType((*NextHopType)(nil), "ves.io.schema.NextHopType")
	proto.RegisterType((*StaticRouteType)(nil), "ves.io.schema.StaticRouteType")
	golang_proto.RegisterType((*StaticRouteType)(nil), "ves.io.schema.StaticRouteType")
	proto.RegisterType((*ForwardProxyConfigType)(nil), "ves.io.schema.ForwardProxyConfigType")
	golang_proto.RegisterType((*ForwardProxyConfigType)(nil), "ves.io.schema.ForwardProxyConfigType")
	proto.RegisterType((*HostIdentifier)(nil), "ves.io.schema.HostIdentifier")
	golang_proto.RegisterType((*HostIdentifier)(nil), "ves.io.schema.HostIdentifier")
	proto.RegisterType((*InterfaceIdentifier)(nil), "ves.io.schema.InterfaceIdentifier")
	golang_proto.RegisterType((*InterfaceIdentifier)(nil), "ves.io.schema.InterfaceIdentifier")
	proto.RegisterType((*InterfaceOrNetwork)(nil), "ves.io.schema.InterfaceOrNetwork")
	golang_proto.RegisterType((*InterfaceOrNetwork)(nil), "ves.io.schema.InterfaceOrNetwork")
	proto.RegisterEnum("ves.io.schema.HttpMethod", HttpMethod_name, HttpMethod_value)
	golang_proto.RegisterEnum("ves.io.schema.HttpMethod", HttpMethod_name, HttpMethod_value)
	proto.RegisterEnum("ves.io.schema.StatusPublishType", StatusPublishType_name, StatusPublishType_value)
	golang_proto.RegisterEnum("ves.io.schema.StatusPublishType", StatusPublishType_name, StatusPublishType_value)
	proto.RegisterEnum("ves.io.schema.SecretEncodingType", SecretEncodingType_name, SecretEncodingType_value)
	golang_proto.RegisterEnum("ves.io.schema.SecretEncodingType", SecretEncodingType_name, SecretEncodingType_value)
	proto.RegisterEnum("ves.io.schema.URLSchemeType", URLSchemeType_name, URLSchemeType_value)
	golang_proto.RegisterEnum("ves.io.schema.URLSchemeType", URLSchemeType_name, URLSchemeType_value)
	proto.RegisterEnum("ves.io.schema.TlsProtocol", TlsProtocol_name, TlsProtocol_value)
	golang_proto.RegisterEnum("ves.io.schema.TlsProtocol", TlsProtocol_name, TlsProtocol_value)
	proto.RegisterEnum("ves.io.schema.RoutingPriority", RoutingPriority_name, RoutingPriority_value)
	golang_proto.RegisterEnum("ves.io.schema.RoutingPriority", RoutingPriority_name, RoutingPriority_value)
	proto.RegisterEnum("ves.io.schema.DenominatorType", DenominatorType_name, DenominatorType_value)
	golang_proto.RegisterEnum("ves.io.schema.DenominatorType", DenominatorType_name, DenominatorType_value)
	proto.RegisterEnum("ves.io.schema.DiscoveryType", DiscoveryType_name, DiscoveryType_value)
	golang_proto.RegisterEnum("ves.io.schema.DiscoveryType", DiscoveryType_name, DiscoveryType_value)
	proto.RegisterEnum("ves.io.schema.WafModeType", WafModeType_name, WafModeType_value)
	golang_proto.RegisterEnum("ves.io.schema.WafModeType", WafModeType_name, WafModeType_value)
	proto.RegisterEnum("ves.io.schema.VipVrrpType", VipVrrpType_name, VipVrrpType_value)
	golang_proto.RegisterEnum("ves.io.schema.VipVrrpType", VipVrrpType_name, VipVrrpType_value)
	proto.RegisterEnum("ves.io.schema.SiteToSiteTunnelType", SiteToSiteTunnelType_name, SiteToSiteTunnelType_value)
	golang_proto.RegisterEnum("ves.io.schema.SiteToSiteTunnelType", SiteToSiteTunnelType_name, SiteToSiteTunnelType_value)
	proto.RegisterEnum("ves.io.schema.SortOrder", SortOrder_name, SortOrder_value)
	golang_proto.RegisterEnum("ves.io.schema.SortOrder", SortOrder_name, SortOrder_value)
	proto.RegisterEnum("ves.io.schema.TunnelEncapsulationType", TunnelEncapsulationType_name, TunnelEncapsulationType_value)
	golang_proto.RegisterEnum("ves.io.schema.TunnelEncapsulationType", TunnelEncapsulationType_name, TunnelEncapsulationType_value)
	proto.RegisterEnum("ves.io.schema.TenantType", TenantType_name, TenantType_value)
	golang_proto.RegisterEnum("ves.io.schema.TenantType", TenantType_name, TenantType_value)
	proto.RegisterEnum("ves.io.schema.TaxExemptionType", TaxExemptionType_name, TaxExemptionType_value)
	golang_proto.RegisterEnum("ves.io.schema.TaxExemptionType", TaxExemptionType_name, TaxExemptionType_value)
	proto.RegisterEnum("ves.io.schema.PlanType", PlanType_name, PlanType_value)
	golang_proto.RegisterEnum("ves.io.schema.PlanType", PlanType_name, PlanType_value)
	proto.RegisterEnum("ves.io.schema.MetricLabelOp", MetricLabelOp_name, MetricLabelOp_value)
	golang_proto.RegisterEnum("ves.io.schema.MetricLabelOp", MetricLabelOp_name, MetricLabelOp_value)
	proto.RegisterEnum("ves.io.schema.RouteAttrType", RouteAttrType_name, RouteAttrType_value)
	golang_proto.RegisterEnum("ves.io.schema.RouteAttrType", RouteAttrType_name, RouteAttrType_value)
	proto.RegisterEnum("ves.io.schema.NextHopTypes", NextHopTypes_name, NextHopTypes_value)
	golang_proto.RegisterEnum("ves.io.schema.NextHopTypes", NextHopTypes_name, NextHopTypes_value)
}
func (x HttpMethod) String() string {
	s, ok := HttpMethod_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StatusPublishType) String() string {
	s, ok := StatusPublishType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SecretEncodingType) String() string {
	s, ok := SecretEncodingType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x URLSchemeType) String() string {
	s, ok := URLSchemeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TlsProtocol) String() string {
	s, ok := TlsProtocol_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RoutingPriority) String() string {
	s, ok := RoutingPriority_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DenominatorType) String() string {
	s, ok := DenominatorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DiscoveryType) String() string {
	s, ok := DiscoveryType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x WafModeType) String() string {
	s, ok := WafModeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VipVrrpType) String() string {
	s, ok := VipVrrpType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteToSiteTunnelType) String() string {
	s, ok := SiteToSiteTunnelType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SortOrder) String() string {
	s, ok := SortOrder_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TunnelEncapsulationType) String() string {
	s, ok := TunnelEncapsulationType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TenantType) String() string {
	s, ok := TenantType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TaxExemptionType) String() string {
	s, ok := TaxExemptionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PlanType) String() string {
	s, ok := PlanType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MetricLabelOp) String() string {
	s, ok := MetricLabelOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteAttrType) String() string {
	s, ok := RouteAttrType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NextHopTypes) String() string {
	s, ok := NextHopTypes_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ObjectRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectRefType)
	if !ok {
		that2, ok := that.(ObjectRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *LabelSelectorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelSelectorType)
	if !ok {
		that2, ok := that.(LabelSelectorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Expressions) != len(that1.Expressions) {
		return false
	}
	for i := range this.Expressions {
		if this.Expressions[i] != that1.Expressions[i] {
			return false
		}
	}
	return true
}
func (this *LabelMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelMatcherType)
	if !ok {
		that2, ok := that.(LabelMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	return true
}
func (this *ConditionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConditionType)
	if !ok {
		that2, ok := that.(ConditionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	return true
}
func (this *StatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusType)
	if !ok {
		that2, ok := that.(StatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	return true
}
func (this *InitializerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InitializerType)
	if !ok {
		that2, ok := that.(InitializerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *InitializersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InitializersType)
	if !ok {
		that2, ok := that.(InitializersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Pending) != len(that1.Pending) {
		return false
	}
	for i := range this.Pending {
		if !this.Pending[i].Equal(that1.Pending[i]) {
			return false
		}
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *StatusMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusMetaType)
	if !ok {
		that2, ok := that.(StatusMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.CreatorClass != that1.CreatorClass {
		return false
	}
	if this.CreatorId != that1.CreatorId {
		return false
	}
	if this.StatusId != that1.StatusId {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if this.Publish != that1.Publish {
		return false
	}
	return true
}
func (this *ObjectMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectMetaType)
	if !ok {
		that2, ok := that.(ObjectMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ListMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListMetaType)
	if !ok {
		that2, ok := that.(ListMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	return true
}
func (this *ObjectGetMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectGetMetaType)
	if !ok {
		that2, ok := that.(ObjectGetMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ObjectCreateMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectCreateMetaType)
	if !ok {
		that2, ok := that.(ObjectCreateMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ObjectReplaceMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectReplaceMetaType)
	if !ok {
		that2, ok := that.(ObjectReplaceMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *MessageMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageMetaType)
	if !ok {
		that2, ok := that.(MessageMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ViewRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ViewRefType)
	if !ok {
		that2, ok := that.(ViewRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *KubeRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KubeRefType)
	if !ok {
		that2, ok := that.(KubeRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *SystemObjectMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemObjectMetaType)
	if !ok {
		that2, ok := that.(SystemObjectMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.DeletionTimestamp.Equal(that1.DeletionTimestamp) {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if !this.Initializers.Equal(that1.Initializers) {
		return false
	}
	if len(this.Finalizers) != len(that1.Finalizers) {
		return false
	}
	for i := range this.Finalizers {
		if this.Finalizers[i] != that1.Finalizers[i] {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.CreatorClass != that1.CreatorClass {
		return false
	}
	if this.CreatorId != that1.CreatorId {
		return false
	}
	if this.CreatorCookie != that1.CreatorCookie {
		return false
	}
	if this.TraceInfo != that1.TraceInfo {
		return false
	}
	if this.ObjectIndex != that1.ObjectIndex {
		return false
	}
	if len(this.Namespace) != len(that1.Namespace) {
		return false
	}
	for i := range this.Namespace {
		if !this.Namespace[i].Equal(that1.Namespace[i]) {
			return false
		}
	}
	if !this.OwnerView.Equal(that1.OwnerView) {
		return false
	}
	return true
}
func (this *SystemObjectGetMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemObjectGetMetaType)
	if !ok {
		that2, ok := that.(SystemObjectGetMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.DeletionTimestamp.Equal(that1.DeletionTimestamp) {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if !this.Initializers.Equal(that1.Initializers) {
		return false
	}
	if len(this.Finalizers) != len(that1.Finalizers) {
		return false
	}
	for i := range this.Finalizers {
		if this.Finalizers[i] != that1.Finalizers[i] {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.CreatorClass != that1.CreatorClass {
		return false
	}
	if this.CreatorId != that1.CreatorId {
		return false
	}
	if this.ObjectIndex != that1.ObjectIndex {
		return false
	}
	if !this.OwnerView.Equal(that1.OwnerView) {
		return false
	}
	return true
}
func (this *AuthnTypeBasicAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthnTypeBasicAuth)
	if !ok {
		that2, ok := that.(AuthnTypeBasicAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	return true
}
func (this *AuthnTypeHeaders) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthnTypeHeaders)
	if !ok {
		that2, ok := that.(AuthnTypeHeaders)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	return true
}
func (this *AuthnTypeQueryParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthnTypeQueryParams)
	if !ok {
		that2, ok := that.(AuthnTypeQueryParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	return true
}
func (this *BlindfoldSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BlindfoldSecretInfoType)
	if !ok {
		that2, ok := that.(BlindfoldSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DecryptionProvider != that1.DecryptionProvider {
		return false
	}
	if this.StoreProvider != that1.StoreProvider {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	return true
}
func (this *VaultSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretInfoType)
	if !ok {
		that2, ok := that.(VaultSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.SecretEncoding != that1.SecretEncoding {
		return false
	}
	return true
}
func (this *ClearSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClearSecretInfoType)
	if !ok {
		that2, ok := that.(ClearSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *WingmanSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WingmanSecretInfoType)
	if !ok {
		that2, ok := that.(WingmanSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *SecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType)
	if !ok {
		that2, ok := that.(SecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SecretInfoOneof == nil {
		if this.SecretInfoOneof != nil {
			return false
		}
	} else if this.SecretInfoOneof == nil {
		return false
	} else if !this.SecretInfoOneof.Equal(that1.SecretInfoOneof) {
		return false
	}
	if !this.BlindfoldSecretInfoInternal.Equal(that1.BlindfoldSecretInfoInternal) {
		return false
	}
	if this.SecretEncodingType != that1.SecretEncodingType {
		return false
	}
	return true
}
func (this *SecretType_BlindfoldSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_BlindfoldSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_BlindfoldSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlindfoldSecretInfo.Equal(that1.BlindfoldSecretInfo) {
		return false
	}
	return true
}
func (this *SecretType_VaultSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_VaultSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_VaultSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultSecretInfo.Equal(that1.VaultSecretInfo) {
		return false
	}
	return true
}
func (this *SecretType_ClearSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_ClearSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_ClearSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClearSecretInfo.Equal(that1.ClearSecretInfo) {
		return false
	}
	return true
}
func (this *SecretType_WingmanSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_WingmanSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_WingmanSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WingmanSecretInfo.Equal(that1.WingmanSecretInfo) {
		return false
	}
	return true
}
func (this *NetworkRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkRefType)
	if !ok {
		that2, ok := that.(NetworkRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *SiteRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteRefType)
	if !ok {
		that2, ok := that.(SiteRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	if this.NetworkType != that1.NetworkType {
		return false
	}
	return true
}
func (this *IpPrefixSetRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpPrefixSetRefType)
	if !ok {
		that2, ok := that.(IpPrefixSetRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *VSiteRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VSiteRefType)
	if !ok {
		that2, ok := that.(VSiteRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	if this.NetworkType != that1.NetworkType {
		return false
	}
	return true
}
func (this *PolicerRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicerRefType)
	if !ok {
		that2, ok := that.(PolicerRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *ProtocolPolicerRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolPolicerRefType)
	if !ok {
		that2, ok := that.(ProtocolPolicerRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkSiteRefSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RefOrSelector == nil {
		if this.RefOrSelector != nil {
			return false
		}
	} else if this.RefOrSelector == nil {
		return false
	} else if !this.RefOrSelector.Equal(that1.RefOrSelector) {
		return false
	}
	return true
}
func (this *NetworkSiteRefSelector_VirtualNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector_VirtualNetwork)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector_VirtualNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualNetwork.Equal(that1.VirtualNetwork) {
		return false
	}
	return true
}
func (this *NetworkSiteRefSelector_Site) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector_Site)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector_Site)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	return true
}
func (this *NetworkSiteRefSelector_VirtualSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector_VirtualSite)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector_VirtualSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualSite.Equal(that1.VirtualSite) {
		return false
	}
	return true
}
func (this *SiteVirtualSiteRefSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteVirtualSiteRefSelector)
	if !ok {
		that2, ok := that.(SiteVirtualSiteRefSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RefOrSelector == nil {
		if this.RefOrSelector != nil {
			return false
		}
	} else if this.RefOrSelector == nil {
		return false
	} else if !this.RefOrSelector.Equal(that1.RefOrSelector) {
		return false
	}
	return true
}
func (this *SiteVirtualSiteRefSelector_Site) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteVirtualSiteRefSelector_Site)
	if !ok {
		that2, ok := that.(SiteVirtualSiteRefSelector_Site)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	return true
}
func (this *SiteVirtualSiteRefSelector_VirtualSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteVirtualSiteRefSelector_VirtualSite)
	if !ok {
		that2, ok := that.(SiteVirtualSiteRefSelector_VirtualSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualSite.Equal(that1.VirtualSite) {
		return false
	}
	return true
}
func (this *HeaderManipulationOptionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderManipulationOptionType)
	if !ok {
		that2, ok := that.(HeaderManipulationOptionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Append != that1.Append {
		return false
	}
	return true
}
func (this *TlsValidationParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsValidationParamsType)
	if !ok {
		that2, ok := that.(TlsValidationParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	if this.SkipHostnameVerification != that1.SkipHostnameVerification {
		return false
	}
	if len(this.VerifySubjectAltNames) != len(that1.VerifySubjectAltNames) {
		return false
	}
	for i := range this.VerifySubjectAltNames {
		if this.VerifySubjectAltNames[i] != that1.VerifySubjectAltNames[i] {
			return false
		}
	}
	if this.UseVolterraTrustedCaUrl != that1.UseVolterraTrustedCaUrl {
		return false
	}
	return true
}
func (this *TlsCertificateType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsCertificateType)
	if !ok {
		that2, ok := that.(TlsCertificateType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CertificateUrl != that1.CertificateUrl {
		return false
	}
	if !this.PrivateKey.Equal(that1.PrivateKey) {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	return true
}
func (this *TlsParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsParamsType)
	if !ok {
		that2, ok := that.(TlsParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinimumProtocolVersion != that1.MinimumProtocolVersion {
		return false
	}
	if this.MaximumProtocolVersion != that1.MaximumProtocolVersion {
		return false
	}
	if len(this.CipherSuites) != len(that1.CipherSuites) {
		return false
	}
	for i := range this.CipherSuites {
		if this.CipherSuites[i] != that1.CipherSuites[i] {
			return false
		}
	}
	if len(this.TlsCertificates) != len(that1.TlsCertificates) {
		return false
	}
	for i := range this.TlsCertificates {
		if !this.TlsCertificates[i].Equal(that1.TlsCertificates[i]) {
			return false
		}
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	if !this.ValidationParams.Equal(that1.ValidationParams) {
		return false
	}
	return true
}
func (this *UpstreamTlsParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamTlsParamsType)
	if !ok {
		that2, ok := that.(UpstreamTlsParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CommonParams.Equal(that1.CommonParams) {
		return false
	}
	if that1.SniChoice == nil {
		if this.SniChoice != nil {
			return false
		}
	} else if this.SniChoice == nil {
		return false
	} else if !this.SniChoice.Equal(that1.SniChoice) {
		return false
	}
	return true
}
func (this *UpstreamTlsParamsType_Sni) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamTlsParamsType_Sni)
	if !ok {
		that2, ok := that.(UpstreamTlsParamsType_Sni)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sni != that1.Sni {
		return false
	}
	return true
}
func (this *UpstreamTlsParamsType_UseHostHeaderAsSni) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamTlsParamsType_UseHostHeaderAsSni)
	if !ok {
		that2, ok := that.(UpstreamTlsParamsType_UseHostHeaderAsSni)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseHostHeaderAsSni.Equal(that1.UseHostHeaderAsSni) {
		return false
	}
	return true
}
func (this *UpstreamTlsParamsType_DisableSni) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamTlsParamsType_DisableSni)
	if !ok {
		that2, ok := that.(UpstreamTlsParamsType_DisableSni)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableSni.Equal(that1.DisableSni) {
		return false
	}
	return true
}
func (this *DownstreamTlsParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DownstreamTlsParamsType)
	if !ok {
		that2, ok := that.(DownstreamTlsParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CommonParams.Equal(that1.CommonParams) {
		return false
	}
	if this.RequireClientCertificate != that1.RequireClientCertificate {
		return false
	}
	return true
}
func (this *DomainType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType)
	if !ok {
		that2, ok := that.(DomainType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	return true
}
func (this *DomainType_ExactValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType_ExactValue)
	if !ok {
		that2, ok := that.(DomainType_ExactValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExactValue != that1.ExactValue {
		return false
	}
	return true
}
func (this *DomainType_SuffixValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType_SuffixValue)
	if !ok {
		that2, ok := that.(DomainType_SuffixValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SuffixValue != that1.SuffixValue {
		return false
	}
	return true
}
func (this *DomainType_RegexValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType_RegexValue)
	if !ok {
		that2, ok := that.(DomainType_RegexValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RegexValue != that1.RegexValue {
		return false
	}
	return true
}
func (this *L4DestType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L4DestType)
	if !ok {
		that2, ok := that.(L4DestType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Prefixes) != len(that1.Prefixes) {
		return false
	}
	for i := range this.Prefixes {
		if this.Prefixes[i] != that1.Prefixes[i] {
			return false
		}
	}
	if this.PortRanges != that1.PortRanges {
		return false
	}
	return true
}
func (this *TlsInterceptionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionRule)
	if !ok {
		that2, ok := that.(TlsInterceptionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DomainMatch.Equal(that1.DomainMatch) {
		return false
	}
	if that1.EnableDisableChoice == nil {
		if this.EnableDisableChoice != nil {
			return false
		}
	} else if this.EnableDisableChoice == nil {
		return false
	} else if !this.EnableDisableChoice.Equal(that1.EnableDisableChoice) {
		return false
	}
	return true
}
func (this *TlsInterceptionRule_DisableInterception) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionRule_DisableInterception)
	if !ok {
		that2, ok := that.(TlsInterceptionRule_DisableInterception)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableInterception.Equal(that1.DisableInterception) {
		return false
	}
	return true
}
func (this *TlsInterceptionRule_EnableInterception) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionRule_EnableInterception)
	if !ok {
		that2, ok := that.(TlsInterceptionRule_EnableInterception)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableInterception.Equal(that1.EnableInterception) {
		return false
	}
	return true
}
func (this *TlsInterceptionPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionPolicy)
	if !ok {
		that2, ok := that.(TlsInterceptionPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InterceptionRules) != len(that1.InterceptionRules) {
		return false
	}
	for i := range this.InterceptionRules {
		if !this.InterceptionRules[i].Equal(that1.InterceptionRules[i]) {
			return false
		}
	}
	return true
}
func (this *TlsInterceptionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType)
	if !ok {
		that2, ok := that.(TlsInterceptionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterceptionPolicyChoice == nil {
		if this.InterceptionPolicyChoice != nil {
			return false
		}
	} else if this.InterceptionPolicyChoice == nil {
		return false
	} else if !this.InterceptionPolicyChoice.Equal(that1.InterceptionPolicyChoice) {
		return false
	}
	if that1.SigningCertChoice == nil {
		if this.SigningCertChoice != nil {
			return false
		}
	} else if this.SigningCertChoice == nil {
		return false
	} else if !this.SigningCertChoice.Equal(that1.SigningCertChoice) {
		return false
	}
	if that1.TrustedCaChoice == nil {
		if this.TrustedCaChoice != nil {
			return false
		}
	} else if this.TrustedCaChoice == nil {
		return false
	} else if !this.TrustedCaChoice.Equal(that1.TrustedCaChoice) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_EnableForAllDomains) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_EnableForAllDomains)
	if !ok {
		that2, ok := that.(TlsInterceptionType_EnableForAllDomains)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableForAllDomains.Equal(that1.EnableForAllDomains) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_Policy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_Policy)
	if !ok {
		that2, ok := that.(TlsInterceptionType_Policy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_CustomCertificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_CustomCertificate)
	if !ok {
		that2, ok := that.(TlsInterceptionType_CustomCertificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomCertificate.Equal(that1.CustomCertificate) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_VolterraCertificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_VolterraCertificate)
	if !ok {
		that2, ok := that.(TlsInterceptionType_VolterraCertificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraCertificate.Equal(that1.VolterraCertificate) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_TrustedCaUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_TrustedCaUrl)
	if !ok {
		that2, ok := that.(TlsInterceptionType_TrustedCaUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *TlsInterceptionType_VolterraTrustedCa) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_VolterraTrustedCa)
	if !ok {
		that2, ok := that.(TlsInterceptionType_VolterraTrustedCa)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraTrustedCa.Equal(that1.VolterraTrustedCa) {
		return false
	}
	return true
}
func (this *FractionalPercent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FractionalPercent)
	if !ok {
		that2, ok := that.(FractionalPercent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Numerator != that1.Numerator {
		return false
	}
	if this.Denominator != that1.Denominator {
		return false
	}
	return true
}
func (this *BufferConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BufferConfigType)
	if !ok {
		that2, ok := that.(BufferConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if this.MaxRequestBytes != that1.MaxRequestBytes {
		return false
	}
	if this.MaxRequestTime != that1.MaxRequestTime {
		return false
	}
	return true
}
func (this *CorsPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CorsPolicy)
	if !ok {
		that2, ok := that.(CorsPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if len(this.AllowOrigin) != len(that1.AllowOrigin) {
		return false
	}
	for i := range this.AllowOrigin {
		if this.AllowOrigin[i] != that1.AllowOrigin[i] {
			return false
		}
	}
	if len(this.AllowOriginRegex) != len(that1.AllowOriginRegex) {
		return false
	}
	for i := range this.AllowOriginRegex {
		if this.AllowOriginRegex[i] != that1.AllowOriginRegex[i] {
			return false
		}
	}
	if this.AllowMethods != that1.AllowMethods {
		return false
	}
	if this.AllowHeaders != that1.AllowHeaders {
		return false
	}
	if this.ExposeHeaders != that1.ExposeHeaders {
		return false
	}
	if this.MaxAge != that1.MaxAge {
		return false
	}
	if this.MaximumAge != that1.MaximumAge {
		return false
	}
	if this.AllowCredentials != that1.AllowCredentials {
		return false
	}
	return true
}
func (this *PathMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType)
	if !ok {
		that2, ok := that.(PathMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PathMatch == nil {
		if this.PathMatch != nil {
			return false
		}
	} else if this.PathMatch == nil {
		return false
	} else if !this.PathMatch.Equal(that1.PathMatch) {
		return false
	}
	return true
}
func (this *PathMatcherType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType_Prefix)
	if !ok {
		that2, ok := that.(PathMatcherType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	return true
}
func (this *PathMatcherType_Path) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType_Path)
	if !ok {
		that2, ok := that.(PathMatcherType_Path)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *PathMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType_Regex)
	if !ok {
		that2, ok := that.(PathMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *HeaderMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType)
	if !ok {
		that2, ok := that.(HeaderMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.ValueMatch == nil {
		if this.ValueMatch != nil {
			return false
		}
	} else if this.ValueMatch == nil {
		return false
	} else if !this.ValueMatch.Equal(that1.ValueMatch) {
		return false
	}
	if this.InvertMatch != that1.InvertMatch {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Exact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Exact)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Exact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Regex)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Presence)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if that1.ValueMatch == nil {
		if this.ValueMatch != nil {
			return false
		}
	} else if this.ValueMatch == nil {
		return false
	} else if !this.ValueMatch.Equal(that1.ValueMatch) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Exact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Exact)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Exact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Regex)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *RouteMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteMatch)
	if !ok {
		that2, ok := that.(RouteMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if this.HttpMethod != that1.HttpMethod {
		return false
	}
	return true
}
func (this *WafRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafRefType)
	if !ok {
		that2, ok := that.(WafRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Waf) != len(that1.Waf) {
		return false
	}
	for i := range this.Waf {
		if !this.Waf[i].Equal(that1.Waf[i]) {
			return false
		}
	}
	return true
}
func (this *WafRulesRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafRulesRefType)
	if !ok {
		that2, ok := that.(WafRulesRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.WafRules) != len(that1.WafRules) {
		return false
	}
	for i := range this.WafRules {
		if !this.WafRules[i].Equal(that1.WafRules[i]) {
			return false
		}
	}
	return true
}
func (this *WafType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType)
	if !ok {
		that2, ok := that.(WafType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RefType == nil {
		if this.RefType != nil {
			return false
		}
	} else if this.RefType == nil {
		return false
	} else if !this.RefType.Equal(that1.RefType) {
		return false
	}
	return true
}
func (this *WafType_Waf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType_Waf)
	if !ok {
		that2, ok := that.(WafType_Waf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Waf.Equal(that1.Waf) {
		return false
	}
	return true
}
func (this *WafType_WafRules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType_WafRules)
	if !ok {
		that2, ok := that.(WafType_WafRules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafRules.Equal(that1.WafRules) {
		return false
	}
	return true
}
func (this *AppRoleAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppRoleAuthInfoType)
	if !ok {
		that2, ok := that.(AppRoleAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoleId != that1.RoleId {
		return false
	}
	if !this.SecretId.Equal(that1.SecretId) {
		return false
	}
	return true
}
func (this *VaultAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAuthInfoType)
	if !ok {
		that2, ok := that.(VaultAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthParams == nil {
		if this.AuthParams != nil {
			return false
		}
	} else if this.AuthParams == nil {
		return false
	} else if !this.AuthParams.Equal(that1.AuthParams) {
		return false
	}
	return true
}
func (this *VaultAuthInfoType_AppRoleAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAuthInfoType_AppRoleAuth)
	if !ok {
		that2, ok := that.(VaultAuthInfoType_AppRoleAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppRoleAuth.Equal(that1.AppRoleAuth) {
		return false
	}
	return true
}
func (this *VaultAuthInfoType_Token) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAuthInfoType_Token)
	if !ok {
		that2, ok := that.(VaultAuthInfoType_Token)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Token.Equal(that1.Token) {
		return false
	}
	return true
}
func (this *RestAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType)
	if !ok {
		that2, ok := that.(RestAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthParams == nil {
		if this.AuthParams != nil {
			return false
		}
	} else if this.AuthParams == nil {
		return false
	} else if !this.AuthParams.Equal(that1.AuthParams) {
		return false
	}
	return true
}
func (this *RestAuthInfoType_BasicAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType_BasicAuth)
	if !ok {
		that2, ok := that.(RestAuthInfoType_BasicAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BasicAuth.Equal(that1.BasicAuth) {
		return false
	}
	return true
}
func (this *RestAuthInfoType_HeadersAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType_HeadersAuth)
	if !ok {
		that2, ok := that.(RestAuthInfoType_HeadersAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HeadersAuth.Equal(that1.HeadersAuth) {
		return false
	}
	return true
}
func (this *RestAuthInfoType_QueryParamsAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType_QueryParamsAuth)
	if !ok {
		that2, ok := that.(RestAuthInfoType_QueryParamsAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.QueryParamsAuth.Equal(that1.QueryParamsAuth) {
		return false
	}
	return true
}
func (this *HostAccessInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostAccessInfoType)
	if !ok {
		that2, ok := that.(HostAccessInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Scheme != that1.Scheme {
		return false
	}
	if this.ServerEndpoint != that1.ServerEndpoint {
		return false
	}
	if !this.TlsConfig.Equal(that1.TlsConfig) {
		return false
	}
	if that1.AuthParams == nil {
		if this.AuthParams != nil {
			return false
		}
	} else if this.AuthParams == nil {
		return false
	} else if !this.AuthParams.Equal(that1.AuthParams) {
		return false
	}
	return true
}
func (this *HostAccessInfoType_RestAuthInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostAccessInfoType_RestAuthInfo)
	if !ok {
		that2, ok := that.(HostAccessInfoType_RestAuthInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RestAuthInfo.Equal(that1.RestAuthInfo) {
		return false
	}
	return true
}
func (this *HostAccessInfoType_VaultAuthInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostAccessInfoType_VaultAuthInfo)
	if !ok {
		that2, ok := that.(HostAccessInfoType_VaultAuthInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultAuthInfo.Equal(that1.VaultAuthInfo) {
		return false
	}
	return true
}
func (this *VaultAccessInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAccessInfoType)
	if !ok {
		that2, ok := that.(VaultAccessInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VaultAddr != that1.VaultAddr {
		return false
	}
	if this.VaultCaUrl != that1.VaultCaUrl {
		return false
	}
	if that1.AuthnChoice == nil {
		if this.AuthnChoice != nil {
			return false
		}
	} else if this.AuthnChoice == nil {
		return false
	} else if !this.AuthnChoice.Equal(that1.AuthnChoice) {
		return false
	}
	return true
}
func (this *VaultAccessInfoType_AppRoleAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAccessInfoType_AppRoleAuth)
	if !ok {
		that2, ok := that.(VaultAccessInfoType_AppRoleAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppRoleAuth.Equal(that1.AppRoleAuth) {
		return false
	}
	return true
}
func (this *VaultAccessInfoType_Token) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAccessInfoType_Token)
	if !ok {
		that2, ok := that.(VaultAccessInfoType_Token)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Token.Equal(that1.Token) {
		return false
	}
	return true
}
func (this *VaultSecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretType)
	if !ok {
		that2, ok := that.(VaultSecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AccessChoice == nil {
		if this.AccessChoice != nil {
			return false
		}
	} else if this.AccessChoice == nil {
		return false
	} else if !this.AccessChoice.Equal(that1.AccessChoice) {
		return false
	}
	if this.SecretPath != that1.SecretPath {
		return false
	}
	if this.SecretSubPath != that1.SecretSubPath {
		return false
	}
	if this.SecretVersion != that1.SecretVersion {
		return false
	}
	return true
}
func (this *VaultSecretType_VaultAccessInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretType_VaultAccessInfo)
	if !ok {
		that2, ok := that.(VaultSecretType_VaultAccessInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultAccessInfo.Equal(that1.VaultAccessInfo) {
		return false
	}
	return true
}
func (this *VaultSecretType_ProviderName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretType_ProviderName)
	if !ok {
		that2, ok := that.(VaultSecretType_ProviderName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProviderName != that1.ProviderName {
		return false
	}
	return true
}
func (this *VolterraSecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSecretType)
	if !ok {
		that2, ok := that.(VolterraSecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SecretTypeChoice == nil {
		if this.SecretTypeChoice != nil {
			return false
		}
	} else if this.SecretTypeChoice == nil {
		return false
	} else if !this.SecretTypeChoice.Equal(that1.SecretTypeChoice) {
		return false
	}
	return true
}
func (this *VolterraSecretType_BlindfoldSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSecretType_BlindfoldSecretInfo)
	if !ok {
		that2, ok := that.(VolterraSecretType_BlindfoldSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlindfoldSecretInfo.Equal(that1.BlindfoldSecretInfo) {
		return false
	}
	return true
}
func (this *VolterraSecretType_VaultSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSecretType_VaultSecretInfo)
	if !ok {
		that2, ok := that.(VolterraSecretType_VaultSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultSecretInfo.Equal(that1.VaultSecretInfo) {
		return false
	}
	return true
}
func (this *PortValueType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType)
	if !ok {
		that2, ok := that.(PortValueType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PortValueTypeChoice == nil {
		if this.PortValueTypeChoice != nil {
			return false
		}
	} else if this.PortValueTypeChoice == nil {
		return false
	} else if !this.PortValueTypeChoice.Equal(that1.PortValueTypeChoice) {
		return false
	}
	return true
}
func (this *PortValueType_All) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType_All)
	if !ok {
		that2, ok := that.(PortValueType_All)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.All.Equal(that1.All) {
		return false
	}
	return true
}
func (this *PortValueType_UserDefined) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType_UserDefined)
	if !ok {
		that2, ok := that.(PortValueType_UserDefined)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserDefined != that1.UserDefined {
		return false
	}
	return true
}
func (this *PortValueType_Dns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType_Dns)
	if !ok {
		that2, ok := that.(PortValueType_Dns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dns.Equal(that1.Dns) {
		return false
	}
	return true
}
func (this *VirtualNetworkReferenceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkReferenceType)
	if !ok {
		that2, ok := that.(VirtualNetworkReferenceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Refs) != len(that1.Refs) {
		return false
	}
	for i := range this.Refs {
		if !this.Refs[i].Equal(that1.Refs[i]) {
			return false
		}
	}
	return true
}
func (this *VirtualNetworkSelectorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.VnTypeChoice == nil {
		if this.VnTypeChoice != nil {
			return false
		}
	} else if this.VnTypeChoice == nil {
		return false
	} else if !this.VnTypeChoice.Equal(that1.VnTypeChoice) {
		return false
	}
	return true
}
func (this *VirtualNetworkSelectorType_SiteLocal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType_SiteLocal)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType_SiteLocal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocal.Equal(that1.SiteLocal) {
		return false
	}
	return true
}
func (this *VirtualNetworkSelectorType_SiteLocalInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType_SiteLocalInside)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType_SiteLocalInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInside.Equal(that1.SiteLocalInside) {
		return false
	}
	return true
}
func (this *VirtualNetworkSelectorType_Public) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType_Public)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType_Public)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Public.Equal(that1.Public) {
		return false
	}
	return true
}
func (this *RetryBackOff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetryBackOff)
	if !ok {
		that2, ok := that.(RetryBackOff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BaseInterval != that1.BaseInterval {
		return false
	}
	if this.MaxInterval != that1.MaxInterval {
		return false
	}
	return true
}
func (this *RetryPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetryPolicyType)
	if !ok {
		that2, ok := that.(RetryPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RetryOn != that1.RetryOn {
		return false
	}
	if this.NumRetries != that1.NumRetries {
		return false
	}
	if this.PerTryTimeout != that1.PerTryTimeout {
		return false
	}
	if len(this.RetriableStatusCodes) != len(that1.RetriableStatusCodes) {
		return false
	}
	for i := range this.RetriableStatusCodes {
		if this.RetriableStatusCodes[i] != that1.RetriableStatusCodes[i] {
			return false
		}
	}
	if !this.BackOff.Equal(that1.BackOff) {
		return false
	}
	return true
}
func (this *MetricValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricValue)
	if !ok {
		that2, ok := that.(MetricValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *NextHopType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NextHopType)
	if !ok {
		that2, ok := that.(NextHopType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.NexthopAddress.Equal(that1.NexthopAddress) {
		return false
	}
	if len(this.Interface) != len(that1.Interface) {
		return false
	}
	for i := range this.Interface {
		if !this.Interface[i].Equal(that1.Interface[i]) {
			return false
		}
	}
	return true
}
func (this *StaticRouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticRouteType)
	if !ok {
		that2, ok := that.(StaticRouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if this.Attrs[i] != that1.Attrs[i] {
			return false
		}
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if !this.Nexthop.Equal(that1.Nexthop) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *ForwardProxyConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForwardProxyConfigType)
	if !ok {
		that2, ok := that.(ForwardProxyConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.WhiteListedPrefixes) != len(that1.WhiteListedPrefixes) {
		return false
	}
	for i := range this.WhiteListedPrefixes {
		if this.WhiteListedPrefixes[i] != that1.WhiteListedPrefixes[i] {
			return false
		}
	}
	if len(this.WhiteListedPorts) != len(that1.WhiteListedPorts) {
		return false
	}
	for i := range this.WhiteListedPorts {
		if this.WhiteListedPorts[i] != that1.WhiteListedPorts[i] {
			return false
		}
	}
	if this.MaxConnectAttempts != that1.MaxConnectAttempts {
		return false
	}
	if this.ConnectionTimeout != that1.ConnectionTimeout {
		return false
	}
	if that1.TlsInterceptionChoice == nil {
		if this.TlsInterceptionChoice != nil {
			return false
		}
	} else if this.TlsInterceptionChoice == nil {
		return false
	} else if !this.TlsInterceptionChoice.Equal(that1.TlsInterceptionChoice) {
		return false
	}
	return true
}
func (this *ForwardProxyConfigType_NoInterception) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForwardProxyConfigType_NoInterception)
	if !ok {
		that2, ok := that.(ForwardProxyConfigType_NoInterception)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoInterception.Equal(that1.NoInterception) {
		return false
	}
	return true
}
func (this *ForwardProxyConfigType_TlsIntercept) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForwardProxyConfigType_TlsIntercept)
	if !ok {
		that2, ok := that.(ForwardProxyConfigType_TlsIntercept)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TlsIntercept.Equal(that1.TlsIntercept) {
		return false
	}
	return true
}
func (this *HostIdentifier) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostIdentifier)
	if !ok {
		that2, ok := that.(HostIdentifier)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HostnameOrIp == nil {
		if this.HostnameOrIp != nil {
			return false
		}
	} else if this.HostnameOrIp == nil {
		return false
	} else if !this.HostnameOrIp.Equal(that1.HostnameOrIp) {
		return false
	}
	return true
}
func (this *HostIdentifier_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostIdentifier_Ip)
	if !ok {
		that2, ok := that.(HostIdentifier_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *HostIdentifier_Hostname) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostIdentifier_Hostname)
	if !ok {
		that2, ok := that.(HostIdentifier_Hostname)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	return true
}
func (this *InterfaceIdentifier) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceIdentifier)
	if !ok {
		that2, ok := that.(InterfaceIdentifier)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *InterfaceIdentifier_AnyIntf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceIdentifier_AnyIntf)
	if !ok {
		that2, ok := that.(InterfaceIdentifier_AnyIntf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIntf.Equal(that1.AnyIntf) {
		return false
	}
	return true
}
func (this *InterfaceIdentifier_Intf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceIdentifier_Intf)
	if !ok {
		that2, ok := that.(InterfaceIdentifier_Intf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Intf != that1.Intf {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_Intf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_Intf)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_Intf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Intf != that1.Intf {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_Pod) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_Pod)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_Pod)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pod != that1.Pod {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_VnType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_VnType)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_VnType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VnType != that1.VnType {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_Vn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_Vn)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_Vn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Vn != that1.Vn {
		return false
	}
	return true
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.ObjectRefType{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelSelectorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.LabelSelectorType{")
	s = append(s, "Expressions: "+fmt.Sprintf("%#v", this.Expressions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.LabelMatcherType{")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConditionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ConditionType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	if this.LastUpdateTime != nil {
		s = append(s, "LastUpdateTime: "+fmt.Sprintf("%#v", this.LastUpdateTime)+",\n")
	}
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.StatusType{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InitializerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.InitializerType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InitializersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.InitializersType{")
	if this.Pending != nil {
		s = append(s, "Pending: "+fmt.Sprintf("%#v", this.Pending)+",\n")
	}
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.StatusMetaType{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "CreatorClass: "+fmt.Sprintf("%#v", this.CreatorClass)+",\n")
	s = append(s, "CreatorId: "+fmt.Sprintf("%#v", this.CreatorId)+",\n")
	s = append(s, "StatusId: "+fmt.Sprintf("%#v", this.StatusId)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	s = append(s, "Publish: "+fmt.Sprintf("%#v", this.Publish)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&schema.ObjectMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ListMetaType{")
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectGetMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ObjectGetMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectCreateMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ObjectCreateMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectReplaceMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ObjectReplaceMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.MessageMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ViewRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.ViewRefType{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KubeRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.KubeRefType{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SystemObjectMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&schema.SystemObjectMetaType{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.DeletionTimestamp != nil {
		s = append(s, "DeletionTimestamp: "+fmt.Sprintf("%#v", this.DeletionTimestamp)+",\n")
	}
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	if this.Initializers != nil {
		s = append(s, "Initializers: "+fmt.Sprintf("%#v", this.Initializers)+",\n")
	}
	s = append(s, "Finalizers: "+fmt.Sprintf("%#v", this.Finalizers)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "CreatorClass: "+fmt.Sprintf("%#v", this.CreatorClass)+",\n")
	s = append(s, "CreatorId: "+fmt.Sprintf("%#v", this.CreatorId)+",\n")
	s = append(s, "CreatorCookie: "+fmt.Sprintf("%#v", this.CreatorCookie)+",\n")
	s = append(s, "TraceInfo: "+fmt.Sprintf("%#v", this.TraceInfo)+",\n")
	s = append(s, "ObjectIndex: "+fmt.Sprintf("%#v", this.ObjectIndex)+",\n")
	if this.Namespace != nil {
		s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	}
	if this.OwnerView != nil {
		s = append(s, "OwnerView: "+fmt.Sprintf("%#v", this.OwnerView)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SystemObjectGetMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&schema.SystemObjectGetMetaType{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.DeletionTimestamp != nil {
		s = append(s, "DeletionTimestamp: "+fmt.Sprintf("%#v", this.DeletionTimestamp)+",\n")
	}
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	if this.Initializers != nil {
		s = append(s, "Initializers: "+fmt.Sprintf("%#v", this.Initializers)+",\n")
	}
	s = append(s, "Finalizers: "+fmt.Sprintf("%#v", this.Finalizers)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "CreatorClass: "+fmt.Sprintf("%#v", this.CreatorClass)+",\n")
	s = append(s, "CreatorId: "+fmt.Sprintf("%#v", this.CreatorId)+",\n")
	s = append(s, "ObjectIndex: "+fmt.Sprintf("%#v", this.ObjectIndex)+",\n")
	if this.OwnerView != nil {
		s = append(s, "OwnerView: "+fmt.Sprintf("%#v", this.OwnerView)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthnTypeBasicAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.AuthnTypeBasicAuth{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthnTypeHeaders) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.AuthnTypeHeaders{")
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]*SecretType{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%#v: %#v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	if this.Headers != nil {
		s = append(s, "Headers: "+mapStringForHeaders+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthnTypeQueryParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.AuthnTypeQueryParams{")
	keysForQueryParams := make([]string, 0, len(this.QueryParams))
	for k, _ := range this.QueryParams {
		keysForQueryParams = append(keysForQueryParams, k)
	}
	sortkeys.Strings(keysForQueryParams)
	mapStringForQueryParams := "map[string]*SecretType{"
	for _, k := range keysForQueryParams {
		mapStringForQueryParams += fmt.Sprintf("%#v: %#v,", k, this.QueryParams[k])
	}
	mapStringForQueryParams += "}"
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+mapStringForQueryParams+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BlindfoldSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.BlindfoldSecretInfoType{")
	s = append(s, "DecryptionProvider: "+fmt.Sprintf("%#v", this.DecryptionProvider)+",\n")
	s = append(s, "StoreProvider: "+fmt.Sprintf("%#v", this.StoreProvider)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.VaultSecretInfoType{")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "SecretEncoding: "+fmt.Sprintf("%#v", this.SecretEncoding)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClearSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.ClearSecretInfoType{")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WingmanSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WingmanSecretInfoType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.NetworkRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.SiteRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "NetworkType: "+fmt.Sprintf("%#v", this.NetworkType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpPrefixSetRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.IpPrefixSetRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VSiteRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.VSiteRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "NetworkType: "+fmt.Sprintf("%#v", this.NetworkType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PolicerRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.PolicerRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolPolicerRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ProtocolPolicerRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkSiteRefSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.NetworkSiteRefSelector{")
	if this.RefOrSelector != nil {
		s = append(s, "RefOrSelector: "+fmt.Sprintf("%#v", this.RefOrSelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkSiteRefSelector_VirtualNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkSiteRefSelector_VirtualNetwork{` +
		`VirtualNetwork:` + fmt.Sprintf("%#v", this.VirtualNetwork) + `}`}, ", ")
	return s
}
func (this *NetworkSiteRefSelector_Site) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkSiteRefSelector_Site{` +
		`Site:` + fmt.Sprintf("%#v", this.Site) + `}`}, ", ")
	return s
}
func (this *NetworkSiteRefSelector_VirtualSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkSiteRefSelector_VirtualSite{` +
		`VirtualSite:` + fmt.Sprintf("%#v", this.VirtualSite) + `}`}, ", ")
	return s
}
func (this *SiteVirtualSiteRefSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.SiteVirtualSiteRefSelector{")
	if this.RefOrSelector != nil {
		s = append(s, "RefOrSelector: "+fmt.Sprintf("%#v", this.RefOrSelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteVirtualSiteRefSelector_Site) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.SiteVirtualSiteRefSelector_Site{` +
		`Site:` + fmt.Sprintf("%#v", this.Site) + `}`}, ", ")
	return s
}
func (this *SiteVirtualSiteRefSelector_VirtualSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.SiteVirtualSiteRefSelector_VirtualSite{` +
		`VirtualSite:` + fmt.Sprintf("%#v", this.VirtualSite) + `}`}, ", ")
	return s
}
func (this *HeaderManipulationOptionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.HeaderManipulationOptionType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Append: "+fmt.Sprintf("%#v", this.Append)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsValidationParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.TlsValidationParamsType{")
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	s = append(s, "SkipHostnameVerification: "+fmt.Sprintf("%#v", this.SkipHostnameVerification)+",\n")
	s = append(s, "VerifySubjectAltNames: "+fmt.Sprintf("%#v", this.VerifySubjectAltNames)+",\n")
	s = append(s, "UseVolterraTrustedCaUrl: "+fmt.Sprintf("%#v", this.UseVolterraTrustedCaUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsCertificateType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.TlsCertificateType{")
	s = append(s, "CertificateUrl: "+fmt.Sprintf("%#v", this.CertificateUrl)+",\n")
	if this.PrivateKey != nil {
		s = append(s, "PrivateKey: "+fmt.Sprintf("%#v", this.PrivateKey)+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.TlsParamsType{")
	s = append(s, "MinimumProtocolVersion: "+fmt.Sprintf("%#v", this.MinimumProtocolVersion)+",\n")
	s = append(s, "MaximumProtocolVersion: "+fmt.Sprintf("%#v", this.MaximumProtocolVersion)+",\n")
	s = append(s, "CipherSuites: "+fmt.Sprintf("%#v", this.CipherSuites)+",\n")
	if this.TlsCertificates != nil {
		s = append(s, "TlsCertificates: "+fmt.Sprintf("%#v", this.TlsCertificates)+",\n")
	}
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	if this.ValidationParams != nil {
		s = append(s, "ValidationParams: "+fmt.Sprintf("%#v", this.ValidationParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpstreamTlsParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.UpstreamTlsParamsType{")
	if this.CommonParams != nil {
		s = append(s, "CommonParams: "+fmt.Sprintf("%#v", this.CommonParams)+",\n")
	}
	if this.SniChoice != nil {
		s = append(s, "SniChoice: "+fmt.Sprintf("%#v", this.SniChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpstreamTlsParamsType_Sni) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.UpstreamTlsParamsType_Sni{` +
		`Sni:` + fmt.Sprintf("%#v", this.Sni) + `}`}, ", ")
	return s
}
func (this *UpstreamTlsParamsType_UseHostHeaderAsSni) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.UpstreamTlsParamsType_UseHostHeaderAsSni{` +
		`UseHostHeaderAsSni:` + fmt.Sprintf("%#v", this.UseHostHeaderAsSni) + `}`}, ", ")
	return s
}
func (this *UpstreamTlsParamsType_DisableSni) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.UpstreamTlsParamsType_DisableSni{` +
		`DisableSni:` + fmt.Sprintf("%#v", this.DisableSni) + `}`}, ", ")
	return s
}
func (this *DownstreamTlsParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DownstreamTlsParamsType{")
	if this.CommonParams != nil {
		s = append(s, "CommonParams: "+fmt.Sprintf("%#v", this.CommonParams)+",\n")
	}
	s = append(s, "RequireClientCertificate: "+fmt.Sprintf("%#v", this.RequireClientCertificate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.DomainType{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainType_ExactValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DomainType_ExactValue{` +
		`ExactValue:` + fmt.Sprintf("%#v", this.ExactValue) + `}`}, ", ")
	return s
}
func (this *DomainType_SuffixValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DomainType_SuffixValue{` +
		`SuffixValue:` + fmt.Sprintf("%#v", this.SuffixValue) + `}`}, ", ")
	return s
}
func (this *DomainType_RegexValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DomainType_RegexValue{` +
		`RegexValue:` + fmt.Sprintf("%#v", this.RegexValue) + `}`}, ", ")
	return s
}
func (this *L4DestType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.L4DestType{")
	s = append(s, "Prefixes: "+fmt.Sprintf("%#v", this.Prefixes)+",\n")
	s = append(s, "PortRanges: "+fmt.Sprintf("%#v", this.PortRanges)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.TlsInterceptionRule{")
	if this.DomainMatch != nil {
		s = append(s, "DomainMatch: "+fmt.Sprintf("%#v", this.DomainMatch)+",\n")
	}
	if this.EnableDisableChoice != nil {
		s = append(s, "EnableDisableChoice: "+fmt.Sprintf("%#v", this.EnableDisableChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionRule_DisableInterception) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionRule_DisableInterception{` +
		`DisableInterception:` + fmt.Sprintf("%#v", this.DisableInterception) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionRule_EnableInterception) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionRule_EnableInterception{` +
		`EnableInterception:` + fmt.Sprintf("%#v", this.EnableInterception) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.TlsInterceptionPolicy{")
	if this.InterceptionRules != nil {
		s = append(s, "InterceptionRules: "+fmt.Sprintf("%#v", this.InterceptionRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.TlsInterceptionType{")
	if this.InterceptionPolicyChoice != nil {
		s = append(s, "InterceptionPolicyChoice: "+fmt.Sprintf("%#v", this.InterceptionPolicyChoice)+",\n")
	}
	if this.SigningCertChoice != nil {
		s = append(s, "SigningCertChoice: "+fmt.Sprintf("%#v", this.SigningCertChoice)+",\n")
	}
	if this.TrustedCaChoice != nil {
		s = append(s, "TrustedCaChoice: "+fmt.Sprintf("%#v", this.TrustedCaChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionType_EnableForAllDomains) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_EnableForAllDomains{` +
		`EnableForAllDomains:` + fmt.Sprintf("%#v", this.EnableForAllDomains) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_Policy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_Policy{` +
		`Policy:` + fmt.Sprintf("%#v", this.Policy) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_CustomCertificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_CustomCertificate{` +
		`CustomCertificate:` + fmt.Sprintf("%#v", this.CustomCertificate) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_VolterraCertificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_VolterraCertificate{` +
		`VolterraCertificate:` + fmt.Sprintf("%#v", this.VolterraCertificate) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_TrustedCaUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_TrustedCaUrl{` +
		`TrustedCaUrl:` + fmt.Sprintf("%#v", this.TrustedCaUrl) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_VolterraTrustedCa) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_VolterraTrustedCa{` +
		`VolterraTrustedCa:` + fmt.Sprintf("%#v", this.VolterraTrustedCa) + `}`}, ", ")
	return s
}
func (this *FractionalPercent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.FractionalPercent{")
	s = append(s, "Numerator: "+fmt.Sprintf("%#v", this.Numerator)+",\n")
	s = append(s, "Denominator: "+fmt.Sprintf("%#v", this.Denominator)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BufferConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.BufferConfigType{")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "MaxRequestBytes: "+fmt.Sprintf("%#v", this.MaxRequestBytes)+",\n")
	s = append(s, "MaxRequestTime: "+fmt.Sprintf("%#v", this.MaxRequestTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CorsPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&schema.CorsPolicy{")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "AllowOrigin: "+fmt.Sprintf("%#v", this.AllowOrigin)+",\n")
	s = append(s, "AllowOriginRegex: "+fmt.Sprintf("%#v", this.AllowOriginRegex)+",\n")
	s = append(s, "AllowMethods: "+fmt.Sprintf("%#v", this.AllowMethods)+",\n")
	s = append(s, "AllowHeaders: "+fmt.Sprintf("%#v", this.AllowHeaders)+",\n")
	s = append(s, "ExposeHeaders: "+fmt.Sprintf("%#v", this.ExposeHeaders)+",\n")
	s = append(s, "MaxAge: "+fmt.Sprintf("%#v", this.MaxAge)+",\n")
	s = append(s, "MaximumAge: "+fmt.Sprintf("%#v", this.MaximumAge)+",\n")
	s = append(s, "AllowCredentials: "+fmt.Sprintf("%#v", this.AllowCredentials)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PathMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.PathMatcherType{")
	if this.PathMatch != nil {
		s = append(s, "PathMatch: "+fmt.Sprintf("%#v", this.PathMatch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PathMatcherType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PathMatcherType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *PathMatcherType_Path) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PathMatcherType_Path{` +
		`Path:` + fmt.Sprintf("%#v", this.Path) + `}`}, ", ")
	return s
}
func (this *PathMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PathMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.HeaderMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ValueMatch != nil {
		s = append(s, "ValueMatch: "+fmt.Sprintf("%#v", this.ValueMatch)+",\n")
	}
	s = append(s, "InvertMatch: "+fmt.Sprintf("%#v", this.InvertMatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderMatcherType_Exact) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderMatcherType_Exact{` +
		`Exact:` + fmt.Sprintf("%#v", this.Exact) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.QueryParameterMatcherType{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.ValueMatch != nil {
		s = append(s, "ValueMatch: "+fmt.Sprintf("%#v", this.ValueMatch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryParameterMatcherType_Exact) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.QueryParameterMatcherType_Exact{` +
		`Exact:` + fmt.Sprintf("%#v", this.Exact) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.QueryParameterMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *RouteMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.RouteMatch{")
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WafRefType{")
	if this.Waf != nil {
		s = append(s, "Waf: "+fmt.Sprintf("%#v", this.Waf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafRulesRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WafRulesRefType{")
	if this.WafRules != nil {
		s = append(s, "WafRules: "+fmt.Sprintf("%#v", this.WafRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.WafType{")
	if this.RefType != nil {
		s = append(s, "RefType: "+fmt.Sprintf("%#v", this.RefType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafType_Waf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WafType_Waf{` +
		`Waf:` + fmt.Sprintf("%#v", this.Waf) + `}`}, ", ")
	return s
}
func (this *WafType_WafRules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WafType_WafRules{` +
		`WafRules:` + fmt.Sprintf("%#v", this.WafRules) + `}`}, ", ")
	return s
}
func (this *AppRoleAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.AppRoleAuthInfoType{")
	s = append(s, "RoleId: "+fmt.Sprintf("%#v", this.RoleId)+",\n")
	if this.SecretId != nil {
		s = append(s, "SecretId: "+fmt.Sprintf("%#v", this.SecretId)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.VaultAuthInfoType{")
	if this.AuthParams != nil {
		s = append(s, "AuthParams: "+fmt.Sprintf("%#v", this.AuthParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultAuthInfoType_AppRoleAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAuthInfoType_AppRoleAuth{` +
		`AppRoleAuth:` + fmt.Sprintf("%#v", this.AppRoleAuth) + `}`}, ", ")
	return s
}
func (this *VaultAuthInfoType_Token) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAuthInfoType_Token{` +
		`Token:` + fmt.Sprintf("%#v", this.Token) + `}`}, ", ")
	return s
}
func (this *RestAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.RestAuthInfoType{")
	if this.AuthParams != nil {
		s = append(s, "AuthParams: "+fmt.Sprintf("%#v", this.AuthParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RestAuthInfoType_BasicAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RestAuthInfoType_BasicAuth{` +
		`BasicAuth:` + fmt.Sprintf("%#v", this.BasicAuth) + `}`}, ", ")
	return s
}
func (this *RestAuthInfoType_HeadersAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RestAuthInfoType_HeadersAuth{` +
		`HeadersAuth:` + fmt.Sprintf("%#v", this.HeadersAuth) + `}`}, ", ")
	return s
}
func (this *RestAuthInfoType_QueryParamsAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RestAuthInfoType_QueryParamsAuth{` +
		`QueryParamsAuth:` + fmt.Sprintf("%#v", this.QueryParamsAuth) + `}`}, ", ")
	return s
}
func (this *HostAccessInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.HostAccessInfoType{")
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	s = append(s, "ServerEndpoint: "+fmt.Sprintf("%#v", this.ServerEndpoint)+",\n")
	if this.TlsConfig != nil {
		s = append(s, "TlsConfig: "+fmt.Sprintf("%#v", this.TlsConfig)+",\n")
	}
	if this.AuthParams != nil {
		s = append(s, "AuthParams: "+fmt.Sprintf("%#v", this.AuthParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostAccessInfoType_RestAuthInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostAccessInfoType_RestAuthInfo{` +
		`RestAuthInfo:` + fmt.Sprintf("%#v", this.RestAuthInfo) + `}`}, ", ")
	return s
}
func (this *HostAccessInfoType_VaultAuthInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostAccessInfoType_VaultAuthInfo{` +
		`VaultAuthInfo:` + fmt.Sprintf("%#v", this.VaultAuthInfo) + `}`}, ", ")
	return s
}
func (this *VaultAccessInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.VaultAccessInfoType{")
	s = append(s, "VaultAddr: "+fmt.Sprintf("%#v", this.VaultAddr)+",\n")
	s = append(s, "VaultCaUrl: "+fmt.Sprintf("%#v", this.VaultCaUrl)+",\n")
	if this.AuthnChoice != nil {
		s = append(s, "AuthnChoice: "+fmt.Sprintf("%#v", this.AuthnChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultAccessInfoType_AppRoleAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAccessInfoType_AppRoleAuth{` +
		`AppRoleAuth:` + fmt.Sprintf("%#v", this.AppRoleAuth) + `}`}, ", ")
	return s
}
func (this *VaultAccessInfoType_Token) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAccessInfoType_Token{` +
		`Token:` + fmt.Sprintf("%#v", this.Token) + `}`}, ", ")
	return s
}
func (this *VaultSecretType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.VaultSecretType{")
	if this.AccessChoice != nil {
		s = append(s, "AccessChoice: "+fmt.Sprintf("%#v", this.AccessChoice)+",\n")
	}
	s = append(s, "SecretPath: "+fmt.Sprintf("%#v", this.SecretPath)+",\n")
	s = append(s, "SecretSubPath: "+fmt.Sprintf("%#v", this.SecretSubPath)+",\n")
	s = append(s, "SecretVersion: "+fmt.Sprintf("%#v", this.SecretVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultSecretType_VaultAccessInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultSecretType_VaultAccessInfo{` +
		`VaultAccessInfo:` + fmt.Sprintf("%#v", this.VaultAccessInfo) + `}`}, ", ")
	return s
}
func (this *VaultSecretType_ProviderName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultSecretType_ProviderName{` +
		`ProviderName:` + fmt.Sprintf("%#v", this.ProviderName) + `}`}, ", ")
	return s
}
func (this *VolterraSecretType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.VolterraSecretType{")
	if this.SecretTypeChoice != nil {
		s = append(s, "SecretTypeChoice: "+fmt.Sprintf("%#v", this.SecretTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolterraSecretType_BlindfoldSecretInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VolterraSecretType_BlindfoldSecretInfo{` +
		`BlindfoldSecretInfo:` + fmt.Sprintf("%#v", this.BlindfoldSecretInfo) + `}`}, ", ")
	return s
}
func (this *VolterraSecretType_VaultSecretInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VolterraSecretType_VaultSecretInfo{` +
		`VaultSecretInfo:` + fmt.Sprintf("%#v", this.VaultSecretInfo) + `}`}, ", ")
	return s
}
func (this *PortValueType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.PortValueType{")
	if this.PortValueTypeChoice != nil {
		s = append(s, "PortValueTypeChoice: "+fmt.Sprintf("%#v", this.PortValueTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortValueType_All) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortValueType_All{` +
		`All:` + fmt.Sprintf("%#v", this.All) + `}`}, ", ")
	return s
}
func (this *PortValueType_UserDefined) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortValueType_UserDefined{` +
		`UserDefined:` + fmt.Sprintf("%#v", this.UserDefined) + `}`}, ", ")
	return s
}
func (this *PortValueType_Dns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortValueType_Dns{` +
		`Dns:` + fmt.Sprintf("%#v", this.Dns) + `}`}, ", ")
	return s
}
func (this *VirtualNetworkReferenceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.VirtualNetworkReferenceType{")
	if this.Refs != nil {
		s = append(s, "Refs: "+fmt.Sprintf("%#v", this.Refs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VirtualNetworkSelectorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.VirtualNetworkSelectorType{")
	if this.VnTypeChoice != nil {
		s = append(s, "VnTypeChoice: "+fmt.Sprintf("%#v", this.VnTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VirtualNetworkSelectorType_SiteLocal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VirtualNetworkSelectorType_SiteLocal{` +
		`SiteLocal:` + fmt.Sprintf("%#v", this.SiteLocal) + `}`}, ", ")
	return s
}
func (this *VirtualNetworkSelectorType_SiteLocalInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VirtualNetworkSelectorType_SiteLocalInside{` +
		`SiteLocalInside:` + fmt.Sprintf("%#v", this.SiteLocalInside) + `}`}, ", ")
	return s
}
func (this *VirtualNetworkSelectorType_Public) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VirtualNetworkSelectorType_Public{` +
		`Public:` + fmt.Sprintf("%#v", this.Public) + `}`}, ", ")
	return s
}
func (this *RetryBackOff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RetryBackOff{")
	s = append(s, "BaseInterval: "+fmt.Sprintf("%#v", this.BaseInterval)+",\n")
	s = append(s, "MaxInterval: "+fmt.Sprintf("%#v", this.MaxInterval)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RetryPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.RetryPolicyType{")
	s = append(s, "RetryOn: "+fmt.Sprintf("%#v", this.RetryOn)+",\n")
	s = append(s, "NumRetries: "+fmt.Sprintf("%#v", this.NumRetries)+",\n")
	s = append(s, "PerTryTimeout: "+fmt.Sprintf("%#v", this.PerTryTimeout)+",\n")
	s = append(s, "RetriableStatusCodes: "+fmt.Sprintf("%#v", this.RetriableStatusCodes)+",\n")
	if this.BackOff != nil {
		s = append(s, "BackOff: "+fmt.Sprintf("%#v", this.BackOff)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.MetricValue{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NextHopType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.NextHopType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NexthopAddress != nil {
		s = append(s, "NexthopAddress: "+fmt.Sprintf("%#v", this.NexthopAddress)+",\n")
	}
	if this.Interface != nil {
		s = append(s, "Interface: "+fmt.Sprintf("%#v", this.Interface)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticRouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.StaticRouteType{")
	s = append(s, "Attrs: "+fmt.Sprintf("%#v", this.Attrs)+",\n")
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.Nexthop != nil {
		s = append(s, "Nexthop: "+fmt.Sprintf("%#v", this.Nexthop)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ForwardProxyConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ForwardProxyConfigType{")
	s = append(s, "WhiteListedPrefixes: "+fmt.Sprintf("%#v", this.WhiteListedPrefixes)+",\n")
	s = append(s, "WhiteListedPorts: "+fmt.Sprintf("%#v", this.WhiteListedPorts)+",\n")
	s = append(s, "MaxConnectAttempts: "+fmt.Sprintf("%#v", this.MaxConnectAttempts)+",\n")
	s = append(s, "ConnectionTimeout: "+fmt.Sprintf("%#v", this.ConnectionTimeout)+",\n")
	if this.TlsInterceptionChoice != nil {
		s = append(s, "TlsInterceptionChoice: "+fmt.Sprintf("%#v", this.TlsInterceptionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ForwardProxyConfigType_NoInterception) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ForwardProxyConfigType_NoInterception{` +
		`NoInterception:` + fmt.Sprintf("%#v", this.NoInterception) + `}`}, ", ")
	return s
}
func (this *ForwardProxyConfigType_TlsIntercept) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ForwardProxyConfigType_TlsIntercept{` +
		`TlsIntercept:` + fmt.Sprintf("%#v", this.TlsIntercept) + `}`}, ", ")
	return s
}
func (this *HostIdentifier) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.HostIdentifier{")
	if this.HostnameOrIp != nil {
		s = append(s, "HostnameOrIp: "+fmt.Sprintf("%#v", this.HostnameOrIp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostIdentifier_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostIdentifier_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *HostIdentifier_Hostname) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostIdentifier_Hostname{` +
		`Hostname:` + fmt.Sprintf("%#v", this.Hostname) + `}`}, ", ")
	return s
}
func (this *InterfaceIdentifier) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.InterfaceIdentifier{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InterfaceIdentifier_AnyIntf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceIdentifier_AnyIntf{` +
		`AnyIntf:` + fmt.Sprintf("%#v", this.AnyIntf) + `}`}, ", ")
	return s
}
func (this *InterfaceIdentifier_Intf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceIdentifier_Intf{` +
		`Intf:` + fmt.Sprintf("%#v", this.Intf) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.InterfaceOrNetwork{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InterfaceOrNetwork_Intf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_Intf{` +
		`Intf:` + fmt.Sprintf("%#v", this.Intf) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork_Pod) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_Pod{` +
		`Pod:` + fmt.Sprintf("%#v", this.Pod) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork_VnType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_VnType{` +
		`VnType:` + fmt.Sprintf("%#v", this.VnType) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork_Vn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_Vn{` +
		`Vn:` + fmt.Sprintf("%#v", this.Vn) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ObjectRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Uid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *LabelSelectorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSelectorType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, s := range m.Expressions {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LabelMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ConditionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.LastUpdateTime != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdateTime.Size()))
		n1, err := m.LastUpdateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	return i, nil
}

func (m *StatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.Code != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *InitializerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitializerType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *InitializersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitializersType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pending) > 0 {
		for _, msg := range m.Pending {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Result != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Result.Size()))
		n2, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *StatusMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.CreatorClass) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorClass)))
		i += copy(dAtA[i:], m.CreatorClass)
	}
	if len(m.CreatorId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorId)))
		i += copy(dAtA[i:], m.CreatorId)
	}
	if len(m.StatusId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StatusId)))
		i += copy(dAtA[i:], m.StatusId)
	}
	if m.CreationTimestamp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CreationTimestamp.Size()))
		n3, err := m.CreationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Publish != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Publish))
	}
	return i, nil
}

func (m *ObjectMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Uid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x22
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k, _ := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		sortkeys.Strings(keysForAnnotations)
		for _, k := range keysForAnnotations {
			dAtA[i] = 0x2a
			i++
			v := m.Annotations[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Disable {
		dAtA[i] = 0x38
		i++
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceVersion)))
		i += copy(dAtA[i:], m.ResourceVersion)
	}
	return i, nil
}

func (m *ObjectGetMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectGetMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x22
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k, _ := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		sortkeys.Strings(keysForAnnotations)
		for _, k := range keysForAnnotations {
			dAtA[i] = 0x2a
			i++
			v := m.Annotations[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Disable {
		dAtA[i] = 0x38
		i++
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ObjectCreateMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectCreateMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x22
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k, _ := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		sortkeys.Strings(keysForAnnotations)
		for _, k := range keysForAnnotations {
			dAtA[i] = 0x2a
			i++
			v := m.Annotations[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Disable {
		dAtA[i] = 0x38
		i++
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ObjectReplaceMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectReplaceMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x1a
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k, _ := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		sortkeys.Strings(keysForAnnotations)
		for _, k := range keysForAnnotations {
			dAtA[i] = 0x22
			i++
			v := m.Annotations[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Disable {
		dAtA[i] = 0x30
		i++
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MessageMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Disable {
		dAtA[i] = 0x18
		i++
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ViewRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Uid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *KubeRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubeRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *SystemObjectMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemObjectMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if m.CreationTimestamp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CreationTimestamp.Size()))
		n4, err := m.CreationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.DeletionTimestamp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DeletionTimestamp.Size()))
		n5, err := m.DeletionTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ModificationTimestamp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ModificationTimestamp.Size()))
		n6, err := m.ModificationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Initializers != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Initializers.Size()))
		n7, err := m.Initializers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if len(m.CreatorClass) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorClass)))
		i += copy(dAtA[i:], m.CreatorClass)
	}
	if len(m.CreatorId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorId)))
		i += copy(dAtA[i:], m.CreatorId)
	}
	if len(m.TraceInfo) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TraceInfo)))
		i += copy(dAtA[i:], m.TraceInfo)
	}
	if m.ObjectIndex != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectIndex))
	}
	if len(m.Namespace) > 0 {
		for _, msg := range m.Namespace {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CreatorCookie) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorCookie)))
		i += copy(dAtA[i:], m.CreatorCookie)
	}
	if m.OwnerView != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OwnerView.Size()))
		n8, err := m.OwnerView.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SystemObjectGetMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemObjectGetMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if m.CreationTimestamp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CreationTimestamp.Size()))
		n9, err := m.CreationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.DeletionTimestamp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DeletionTimestamp.Size()))
		n10, err := m.DeletionTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ModificationTimestamp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ModificationTimestamp.Size()))
		n11, err := m.ModificationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Initializers != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Initializers.Size()))
		n12, err := m.Initializers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if len(m.CreatorClass) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorClass)))
		i += copy(dAtA[i:], m.CreatorClass)
	}
	if len(m.CreatorId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorId)))
		i += copy(dAtA[i:], m.CreatorId)
	}
	if m.ObjectIndex != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectIndex))
	}
	if m.OwnerView != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OwnerView.Size()))
		n13, err := m.OwnerView.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *AuthnTypeBasicAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnTypeBasicAuth) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.Password != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Password.Size()))
		n14, err := m.Password.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *AuthnTypeHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnTypeHeaders) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		keysForHeaders := make([]string, 0, len(m.Headers))
		for k, _ := range m.Headers {
			keysForHeaders = append(keysForHeaders, string(k))
		}
		sortkeys.Strings(keysForHeaders)
		for _, k := range keysForHeaders {
			dAtA[i] = 0xa
			i++
			v := m.Headers[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n15, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n15
			}
		}
	}
	return i, nil
}

func (m *AuthnTypeQueryParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnTypeQueryParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		keysForQueryParams := make([]string, 0, len(m.QueryParams))
		for k, _ := range m.QueryParams {
			keysForQueryParams = append(keysForQueryParams, string(k))
		}
		sortkeys.Strings(keysForQueryParams)
		for _, k := range keysForQueryParams {
			dAtA[i] = 0xa
			i++
			v := m.QueryParams[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n16, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n16
			}
		}
	}
	return i, nil
}

func (m *BlindfoldSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlindfoldSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DecryptionProvider) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DecryptionProvider)))
		i += copy(dAtA[i:], m.DecryptionProvider)
	}
	if len(m.StoreProvider) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StoreProvider)))
		i += copy(dAtA[i:], m.StoreProvider)
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	return i, nil
}

func (m *VaultSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Provider) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Version != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
	}
	if m.SecretEncoding != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SecretEncoding))
	}
	return i, nil
}

func (m *ClearSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Provider) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *WingmanSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WingmanSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *SecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SecretInfoOneof != nil {
		nn17, err := m.SecretInfoOneof.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn17
	}
	if m.SecretEncodingType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SecretEncodingType))
	}
	if m.BlindfoldSecretInfoInternal != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BlindfoldSecretInfoInternal.Size()))
		n18, err := m.BlindfoldSecretInfoInternal.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *SecretType_BlindfoldSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BlindfoldSecretInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BlindfoldSecretInfo.Size()))
		n19, err := m.BlindfoldSecretInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *SecretType_VaultSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VaultSecretInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VaultSecretInfo.Size()))
		n20, err := m.VaultSecretInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *SecretType_ClearSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClearSecretInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClearSecretInfo.Size()))
		n21, err := m.ClearSecretInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *SecretType_WingmanSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WingmanSecretInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WingmanSecretInfo.Size()))
		n22, err := m.WingmanSecretInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *NetworkRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, msg := range m.Ref {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SiteRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, msg := range m.Ref {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NetworkType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkType))
	}
	return i, nil
}

func (m *IpPrefixSetRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpPrefixSetRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, msg := range m.Ref {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSiteRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VSiteRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, msg := range m.Ref {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NetworkType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkType))
	}
	return i, nil
}

func (m *PolicerRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, msg := range m.Ref {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProtocolPolicerRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolPolicerRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, msg := range m.Ref {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NetworkSiteRefSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSiteRefSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RefOrSelector != nil {
		nn23, err := m.RefOrSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	return i, nil
}

func (m *NetworkSiteRefSelector_VirtualNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VirtualNetwork != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VirtualNetwork.Size()))
		n24, err := m.VirtualNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *NetworkSiteRefSelector_Site) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Site != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Site.Size()))
		n25, err := m.Site.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *NetworkSiteRefSelector_VirtualSite) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VirtualSite != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VirtualSite.Size()))
		n26, err := m.VirtualSite.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *SiteVirtualSiteRefSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteVirtualSiteRefSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RefOrSelector != nil {
		nn27, err := m.RefOrSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn27
	}
	return i, nil
}

func (m *SiteVirtualSiteRefSelector_Site) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Site != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Site.Size()))
		n28, err := m.Site.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *SiteVirtualSiteRefSelector_VirtualSite) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VirtualSite != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VirtualSite.Size()))
		n29, err := m.VirtualSite.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *HeaderManipulationOptionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderManipulationOptionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Append {
		dAtA[i] = 0x18
		i++
		if m.Append {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TlsValidationParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsValidationParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TrustedCaUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i += copy(dAtA[i:], m.TrustedCaUrl)
	}
	if m.SkipHostnameVerification {
		dAtA[i] = 0x10
		i++
		if m.SkipHostnameVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VerifySubjectAltNames) > 0 {
		for _, s := range m.VerifySubjectAltNames {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.UseVolterraTrustedCaUrl {
		dAtA[i] = 0x20
		i++
		if m.UseVolterraTrustedCaUrl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TlsCertificateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsCertificateType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CertificateUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CertificateUrl)))
		i += copy(dAtA[i:], m.CertificateUrl)
	}
	if m.PrivateKey != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrivateKey.Size()))
		n30, err := m.PrivateKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *TlsParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinimumProtocolVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MinimumProtocolVersion))
	}
	if m.MaximumProtocolVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaximumProtocolVersion))
	}
	if len(m.CipherSuites) > 0 {
		for _, s := range m.CipherSuites {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TlsCertificates) > 0 {
		for _, msg := range m.TlsCertificates {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TrustedCaUrl) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i += copy(dAtA[i:], m.TrustedCaUrl)
	}
	if m.ValidationParams != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ValidationParams.Size()))
		n31, err := m.ValidationParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *UpstreamTlsParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamTlsParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommonParams != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CommonParams.Size()))
		n32, err := m.CommonParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.SniChoice != nil {
		nn33, err := m.SniChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn33
	}
	return i, nil
}

func (m *UpstreamTlsParamsType_Sni) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Sni)))
	i += copy(dAtA[i:], m.Sni)
	return i, nil
}
func (m *UpstreamTlsParamsType_UseHostHeaderAsSni) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UseHostHeaderAsSni != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UseHostHeaderAsSni.Size()))
		n34, err := m.UseHostHeaderAsSni.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *UpstreamTlsParamsType_DisableSni) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DisableSni != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DisableSni.Size()))
		n35, err := m.DisableSni.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *DownstreamTlsParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownstreamTlsParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommonParams != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CommonParams.Size()))
		n36, err := m.CommonParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.RequireClientCertificate {
		dAtA[i] = 0x20
		i++
		if m.RequireClientCertificate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DomainType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DomainChoice != nil {
		nn37, err := m.DomainChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn37
	}
	return i, nil
}

func (m *DomainType_ExactValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValue)))
	i += copy(dAtA[i:], m.ExactValue)
	return i, nil
}
func (m *DomainType_SuffixValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.SuffixValue)))
	i += copy(dAtA[i:], m.SuffixValue)
	return i, nil
}
func (m *DomainType_RegexValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValue)))
	i += copy(dAtA[i:], m.RegexValue)
	return i, nil
}
func (m *L4DestType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4DestType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for _, s := range m.Prefixes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PortRanges) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PortRanges)))
		i += copy(dAtA[i:], m.PortRanges)
	}
	return i, nil
}

func (m *TlsInterceptionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsInterceptionRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DomainMatch != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DomainMatch.Size()))
		n38, err := m.DomainMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.EnableDisableChoice != nil {
		nn39, err := m.EnableDisableChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn39
	}
	return i, nil
}

func (m *TlsInterceptionRule_DisableInterception) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DisableInterception != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DisableInterception.Size()))
		n40, err := m.DisableInterception.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *TlsInterceptionRule_EnableInterception) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableInterception != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EnableInterception.Size()))
		n41, err := m.EnableInterception.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *TlsInterceptionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsInterceptionPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InterceptionRules) > 0 {
		for _, msg := range m.InterceptionRules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TlsInterceptionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsInterceptionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterceptionPolicyChoice != nil {
		nn42, err := m.InterceptionPolicyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn42
	}
	if m.SigningCertChoice != nil {
		nn43, err := m.SigningCertChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn43
	}
	if m.TrustedCaChoice != nil {
		nn44, err := m.TrustedCaChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn44
	}
	return i, nil
}

func (m *TlsInterceptionType_Policy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Policy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Policy.Size()))
		n45, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *TlsInterceptionType_CustomCertificate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CustomCertificate != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CustomCertificate.Size()))
		n46, err := m.CustomCertificate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func (m *TlsInterceptionType_VolterraCertificate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VolterraCertificate != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraCertificate.Size()))
		n47, err := m.VolterraCertificate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}
func (m *TlsInterceptionType_TrustedCaUrl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x32
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
	i += copy(dAtA[i:], m.TrustedCaUrl)
	return i, nil
}
func (m *TlsInterceptionType_VolterraTrustedCa) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VolterraTrustedCa != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraTrustedCa.Size()))
		n48, err := m.VolterraTrustedCa.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *TlsInterceptionType_EnableForAllDomains) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableForAllDomains != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EnableForAllDomains.Size()))
		n49, err := m.EnableForAllDomains.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *FractionalPercent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FractionalPercent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Numerator != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Denominator))
	}
	return i, nil
}

func (m *BufferConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Disabled {
		dAtA[i] = 0x8
		i++
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxRequestBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestBytes))
	}
	if m.MaxRequestTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestTime))
	}
	return i, nil
}

func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Disabled {
		dAtA[i] = 0x8
		i++
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AllowOrigin) > 0 {
		for _, s := range m.AllowOrigin {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AllowOriginRegex) > 0 {
		for _, s := range m.AllowOriginRegex {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AllowMethods) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowMethods)))
		i += copy(dAtA[i:], m.AllowMethods)
	}
	if len(m.AllowHeaders) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowHeaders)))
		i += copy(dAtA[i:], m.AllowHeaders)
	}
	if len(m.ExposeHeaders) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExposeHeaders)))
		i += copy(dAtA[i:], m.ExposeHeaders)
	}
	if len(m.MaxAge) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MaxAge)))
		i += copy(dAtA[i:], m.MaxAge)
	}
	if m.AllowCredentials {
		dAtA[i] = 0x40
		i++
		if m.AllowCredentials {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaximumAge != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaximumAge))
	}
	return i, nil
}

func (m *PathMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PathMatch != nil {
		nn50, err := m.PathMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn50
	}
	return i, nil
}

func (m *PathMatcherType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Prefix)))
	i += copy(dAtA[i:], m.Prefix)
	return i, nil
}
func (m *PathMatcherType_Path) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	return i, nil
}
func (m *PathMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i += copy(dAtA[i:], m.Regex)
	return i, nil
}
func (m *HeaderMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.ValueMatch != nil {
		nn51, err := m.ValueMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn51
	}
	if m.InvertMatch {
		dAtA[i] = 0x28
		i++
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HeaderMatcherType_Exact) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Exact)))
	i += copy(dAtA[i:], m.Exact)
	return i, nil
}
func (m *HeaderMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i += copy(dAtA[i:], m.Regex)
	return i, nil
}
func (m *HeaderMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *QueryParameterMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParameterMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.ValueMatch != nil {
		nn52, err := m.ValueMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn52
	}
	return i, nil
}

func (m *QueryParameterMatcherType_Exact) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Exact)))
	i += copy(dAtA[i:], m.Exact)
	return i, nil
}
func (m *QueryParameterMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i += copy(dAtA[i:], m.Regex)
	return i, nil
}
func (m *RouteMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Path != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Path.Size()))
		n53, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QueryParams) > 0 {
		for _, msg := range m.QueryParams {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HttpMethod != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod))
	}
	return i, nil
}

func (m *WafRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Waf) > 0 {
		for _, msg := range m.Waf {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WafRulesRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafRulesRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WafRules) > 0 {
		for _, msg := range m.WafRules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WafType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RefType != nil {
		nn54, err := m.RefType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn54
	}
	return i, nil
}

func (m *WafType_Waf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Waf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Waf.Size()))
		n55, err := m.Waf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}
func (m *WafType_WafRules) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WafRules != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafRules.Size()))
		n56, err := m.WafRules.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}
func (m *AppRoleAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppRoleAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RoleId)))
		i += copy(dAtA[i:], m.RoleId)
	}
	if m.SecretId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SecretId.Size()))
		n57, err := m.SecretId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}

func (m *VaultAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthParams != nil {
		nn58, err := m.AuthParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn58
	}
	return i, nil
}

func (m *VaultAuthInfoType_AppRoleAuth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AppRoleAuth != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AppRoleAuth.Size()))
		n59, err := m.AppRoleAuth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}
func (m *VaultAuthInfoType_Token) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Token != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Token.Size()))
		n60, err := m.Token.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}
func (m *RestAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthParams != nil {
		nn61, err := m.AuthParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn61
	}
	return i, nil
}

func (m *RestAuthInfoType_BasicAuth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BasicAuth != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BasicAuth.Size()))
		n62, err := m.BasicAuth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}
func (m *RestAuthInfoType_HeadersAuth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HeadersAuth != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HeadersAuth.Size()))
		n63, err := m.HeadersAuth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}
func (m *RestAuthInfoType_QueryParamsAuth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.QueryParamsAuth != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.QueryParamsAuth.Size()))
		n64, err := m.QueryParamsAuth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}
func (m *HostAccessInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostAccessInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Scheme != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Scheme))
	}
	if len(m.ServerEndpoint) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerEndpoint)))
		i += copy(dAtA[i:], m.ServerEndpoint)
	}
	if m.TlsConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsConfig.Size()))
		n65, err := m.TlsConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.AuthParams != nil {
		nn66, err := m.AuthParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn66
	}
	return i, nil
}

func (m *HostAccessInfoType_RestAuthInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RestAuthInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RestAuthInfo.Size()))
		n67, err := m.RestAuthInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}
func (m *HostAccessInfoType_VaultAuthInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VaultAuthInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VaultAuthInfo.Size()))
		n68, err := m.VaultAuthInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}
func (m *VaultAccessInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultAccessInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VaultAddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VaultAddr)))
		i += copy(dAtA[i:], m.VaultAddr)
	}
	if len(m.VaultCaUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VaultCaUrl)))
		i += copy(dAtA[i:], m.VaultCaUrl)
	}
	if m.AuthnChoice != nil {
		nn69, err := m.AuthnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn69
	}
	return i, nil
}

func (m *VaultAccessInfoType_AppRoleAuth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AppRoleAuth != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AppRoleAuth.Size()))
		n70, err := m.AppRoleAuth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}
func (m *VaultAccessInfoType_Token) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Token != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Token.Size()))
		n71, err := m.Token.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}
func (m *VaultSecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultSecretType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccessChoice != nil {
		nn72, err := m.AccessChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn72
	}
	if len(m.SecretPath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecretPath)))
		i += copy(dAtA[i:], m.SecretPath)
	}
	if len(m.SecretSubPath) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecretSubPath)))
		i += copy(dAtA[i:], m.SecretSubPath)
	}
	if len(m.SecretVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecretVersion)))
		i += copy(dAtA[i:], m.SecretVersion)
	}
	return i, nil
}

func (m *VaultSecretType_VaultAccessInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VaultAccessInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VaultAccessInfo.Size()))
		n73, err := m.VaultAccessInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}
func (m *VaultSecretType_ProviderName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderName)))
	i += copy(dAtA[i:], m.ProviderName)
	return i, nil
}
func (m *VolterraSecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolterraSecretType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SecretTypeChoice != nil {
		nn74, err := m.SecretTypeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn74
	}
	return i, nil
}

func (m *VolterraSecretType_BlindfoldSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BlindfoldSecretInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BlindfoldSecretInfo.Size()))
		n75, err := m.BlindfoldSecretInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	return i, nil
}
func (m *VolterraSecretType_VaultSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VaultSecretInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VaultSecretInfo.Size()))
		n76, err := m.VaultSecretInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}
func (m *PortValueType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortValueType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortValueTypeChoice != nil {
		nn77, err := m.PortValueTypeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn77
	}
	return i, nil
}

func (m *PortValueType_All) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.All != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.All.Size()))
		n78, err := m.All.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}
func (m *PortValueType_UserDefined) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.UserDefined))
	return i, nil
}
func (m *PortValueType_Dns) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dns != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Dns.Size()))
		n79, err := m.Dns.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	return i, nil
}
func (m *VirtualNetworkReferenceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualNetworkReferenceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, msg := range m.Refs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VirtualNetworkSelectorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualNetworkSelectorType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VnTypeChoice != nil {
		nn80, err := m.VnTypeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn80
	}
	return i, nil
}

func (m *VirtualNetworkSelectorType_SiteLocal) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SiteLocal != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteLocal.Size()))
		n81, err := m.SiteLocal.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	return i, nil
}
func (m *VirtualNetworkSelectorType_SiteLocalInside) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SiteLocalInside != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteLocalInside.Size()))
		n82, err := m.SiteLocalInside.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	return i, nil
}
func (m *VirtualNetworkSelectorType_Public) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Public != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Public.Size()))
		n83, err := m.Public.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}
func (m *RetryBackOff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryBackOff) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BaseInterval != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BaseInterval))
	}
	if m.MaxInterval != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxInterval))
	}
	return i, nil
}

func (m *RetryPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryPolicyType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RetryOn) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RetryOn)))
		i += copy(dAtA[i:], m.RetryOn)
	}
	if m.NumRetries != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NumRetries))
	}
	if m.PerTryTimeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PerTryTimeout))
	}
	if len(m.RetriableStatusCodes) > 0 {
		dAtA85 := make([]byte, len(m.RetriableStatusCodes)*10)
		var j84 int
		for _, num := range m.RetriableStatusCodes {
			for num >= 1<<7 {
				dAtA85[j84] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j84++
			}
			dAtA85[j84] = uint8(num)
			j84++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j84))
		i += copy(dAtA[i:], dAtA85[:j84])
	}
	if m.BackOff != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BackOff.Size()))
		n86, err := m.BackOff.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	return i, nil
}

func (m *MetricValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Timestamp))))
		i += 8
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *NextHopType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextHopType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.NexthopAddress != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NexthopAddress.Size()))
		n87, err := m.NexthopAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if len(m.Interface) > 0 {
		for _, msg := range m.Interface {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StaticRouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticRouteType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		dAtA89 := make([]byte, len(m.Attrs)*10)
		var j88 int
		for _, num := range m.Attrs {
			for num >= 1<<7 {
				dAtA89[j88] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j88++
			}
			dAtA89[j88] = uint8(num)
			j88++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j88))
		i += copy(dAtA[i:], dAtA89[:j88])
	}
	if len(m.Subnets) > 0 {
		for _, msg := range m.Subnets {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Nexthop != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Nexthop.Size()))
		n90, err := m.Nexthop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x5a
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *ForwardProxyConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardProxyConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WhiteListedPrefixes) > 0 {
		for _, s := range m.WhiteListedPrefixes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.WhiteListedPorts) > 0 {
		dAtA92 := make([]byte, len(m.WhiteListedPorts)*10)
		var j91 int
		for _, num := range m.WhiteListedPorts {
			for num >= 1<<7 {
				dAtA92[j91] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j91++
			}
			dAtA92[j91] = uint8(num)
			j91++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j91))
		i += copy(dAtA[i:], dAtA92[:j91])
	}
	if m.MaxConnectAttempts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxConnectAttempts))
	}
	if m.ConnectionTimeout != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionTimeout))
	}
	if m.TlsInterceptionChoice != nil {
		nn93, err := m.TlsInterceptionChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn93
	}
	return i, nil
}

func (m *ForwardProxyConfigType_NoInterception) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoInterception != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoInterception.Size()))
		n94, err := m.NoInterception.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	return i, nil
}
func (m *ForwardProxyConfigType_TlsIntercept) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TlsIntercept != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsIntercept.Size()))
		n95, err := m.TlsIntercept.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	return i, nil
}
func (m *HostIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIdentifier) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HostnameOrIp != nil {
		nn96, err := m.HostnameOrIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn96
	}
	return i, nil
}

func (m *HostIdentifier_Ip) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i += copy(dAtA[i:], m.Ip)
	return i, nil
}
func (m *HostIdentifier_Hostname) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
	i += copy(dAtA[i:], m.Hostname)
	return i, nil
}
func (m *InterfaceIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceIdentifier) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		nn97, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn97
	}
	return i, nil
}

func (m *InterfaceIdentifier_AnyIntf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyIntf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyIntf.Size()))
		n98, err := m.AnyIntf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	return i, nil
}
func (m *InterfaceIdentifier_Intf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Intf)))
	i += copy(dAtA[i:], m.Intf)
	return i, nil
}
func (m *InterfaceOrNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceOrNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		nn99, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn99
	}
	return i, nil
}

func (m *InterfaceOrNetwork_Intf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Intf)))
	i += copy(dAtA[i:], m.Intf)
	return i, nil
}
func (m *InterfaceOrNetwork_Pod) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Pod)))
	i += copy(dAtA[i:], m.Pod)
	return i, nil
}
func (m *InterfaceOrNetwork_VnType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.VnType))
	return i, nil
}
func (m *InterfaceOrNetwork_Vn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Vn)))
	i += copy(dAtA[i:], m.Vn)
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedEmpty(r randyTypes, easy bool) *Empty {
	this := &Empty{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedObjectRefType(r randyTypes, easy bool) *ObjectRefType {
	this := &ObjectRefType{}
	this.Kind = string(randStringTypes(r))
	this.Uid = string(randStringTypes(r))
	this.Tenant = string(randStringTypes(r))
	this.Namespace = string(randStringTypes(r))
	this.Name = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLabelSelectorType(r randyTypes, easy bool) *LabelSelectorType {
	this := &LabelSelectorType{}
	v1 := r.Intn(10)
	this.Expressions = make([]string, v1)
	for i := 0; i < v1; i++ {
		this.Expressions[i] = string(randStringTypes(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLabelMatcherType(r randyTypes, easy bool) *LabelMatcherType {
	this := &LabelMatcherType{}
	v2 := r.Intn(10)
	this.Keys = make([]string, v2)
	for i := 0; i < v2; i++ {
		this.Keys[i] = string(randStringTypes(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedConditionType(r randyTypes, easy bool) *ConditionType {
	this := &ConditionType{}
	this.Type = string(randStringTypes(r))
	this.Status = string(randStringTypes(r))
	this.Reason = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.LastUpdateTime = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	this.Hostname = string(randStringTypes(r))
	this.ServiceName = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStatusType(r randyTypes, easy bool) *StatusType {
	this := &StatusType{}
	this.Status = string(randStringTypes(r))
	this.Reason = string(randStringTypes(r))
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedInitializerType(r randyTypes, easy bool) *InitializerType {
	this := &InitializerType{}
	this.Name = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedInitializersType(r randyTypes, easy bool) *InitializersType {
	this := &InitializersType{}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Pending = make([]*InitializerType, v3)
		for i := 0; i < v3; i++ {
			this.Pending[i] = NewPopulatedInitializerType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Result = NewPopulatedStatusType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStatusMetaType(r randyTypes, easy bool) *StatusMetaType {
	this := &StatusMetaType{}
	this.Uid = string(randStringTypes(r))
	this.CreatorClass = string(randStringTypes(r))
	this.CreatorId = string(randStringTypes(r))
	this.StatusId = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.CreationTimestamp = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	this.Publish = StatusPublishType([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedObjectMetaType(r randyTypes, easy bool) *ObjectMetaType {
	this := &ObjectMetaType{}
	this.Name = string(randStringTypes(r))
	this.Namespace = string(randStringTypes(r))
	this.Uid = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Labels = make(map[string]string)
		for i := 0; i < v4; i++ {
			this.Labels[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.Annotations = make(map[string]string)
		for i := 0; i < v5; i++ {
			this.Annotations[randStringTypes(r)] = randStringTypes(r)
		}
	}
	this.Description = string(randStringTypes(r))
	this.Disable = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedListMetaType(r randyTypes, easy bool) *ListMetaType {
	this := &ListMetaType{}
	this.ResourceVersion = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedObjectGetMetaType(r randyTypes, easy bool) *ObjectGetMetaType {
	this := &ObjectGetMetaType{}
	this.Name = string(randStringTypes(r))
	this.Namespace = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v6 := r.Intn(10)
		this.Labels = make(map[string]string)
		for i := 0; i < v6; i++ {
			this.Labels[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.Annotations = make(map[string]string)
		for i := 0; i < v7; i++ {
			this.Annotations[randStringTypes(r)] = randStringTypes(r)
		}
	}
	this.Description = string(randStringTypes(r))
	this.Disable = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedObjectCreateMetaType(r randyTypes, easy bool) *ObjectCreateMetaType {
	this := &ObjectCreateMetaType{}
	this.Name = string(randStringTypes(r))
	this.Namespace = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v8 := r.Intn(10)
		this.Labels = make(map[string]string)
		for i := 0; i < v8; i++ {
			this.Labels[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(10)
		this.Annotations = make(map[string]string)
		for i := 0; i < v9; i++ {
			this.Annotations[randStringTypes(r)] = randStringTypes(r)
		}
	}
	this.Description = string(randStringTypes(r))
	this.Disable = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedObjectReplaceMetaType(r randyTypes, easy bool) *ObjectReplaceMetaType {
	this := &ObjectReplaceMetaType{}
	this.Name = string(randStringTypes(r))
	this.Namespace = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v10 := r.Intn(10)
		this.Labels = make(map[string]string)
		for i := 0; i < v10; i++ {
			this.Labels[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v11 := r.Intn(10)
		this.Annotations = make(map[string]string)
		for i := 0; i < v11; i++ {
			this.Annotations[randStringTypes(r)] = randStringTypes(r)
		}
	}
	this.Description = string(randStringTypes(r))
	this.Disable = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMessageMetaType(r randyTypes, easy bool) *MessageMetaType {
	this := &MessageMetaType{}
	this.Name = string(randStringTypes(r))
	this.Description = string(randStringTypes(r))
	this.Disable = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedViewRefType(r randyTypes, easy bool) *ViewRefType {
	this := &ViewRefType{}
	this.Kind = string(randStringTypes(r))
	this.Uid = string(randStringTypes(r))
	this.Namespace = string(randStringTypes(r))
	this.Name = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedKubeRefType(r randyTypes, easy bool) *KubeRefType {
	this := &KubeRefType{}
	this.Kind = string(randStringTypes(r))
	this.Namespace = string(randStringTypes(r))
	this.Name = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSystemObjectMetaType(r randyTypes, easy bool) *SystemObjectMetaType {
	this := &SystemObjectMetaType{}
	this.Uid = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.CreationTimestamp = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DeletionTimestamp = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ModificationTimestamp = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Initializers = NewPopulatedInitializersType(r, easy)
	}
	v12 := r.Intn(10)
	this.Finalizers = make([]string, v12)
	for i := 0; i < v12; i++ {
		this.Finalizers[i] = string(randStringTypes(r))
	}
	this.Tenant = string(randStringTypes(r))
	this.CreatorClass = string(randStringTypes(r))
	this.CreatorId = string(randStringTypes(r))
	this.TraceInfo = string(randStringTypes(r))
	this.ObjectIndex = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.Namespace = make([]*ObjectRefType, v13)
		for i := 0; i < v13; i++ {
			this.Namespace[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	this.CreatorCookie = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.OwnerView = NewPopulatedViewRefType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSystemObjectGetMetaType(r randyTypes, easy bool) *SystemObjectGetMetaType {
	this := &SystemObjectGetMetaType{}
	this.Uid = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.CreationTimestamp = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DeletionTimestamp = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ModificationTimestamp = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Initializers = NewPopulatedInitializersType(r, easy)
	}
	v14 := r.Intn(10)
	this.Finalizers = make([]string, v14)
	for i := 0; i < v14; i++ {
		this.Finalizers[i] = string(randStringTypes(r))
	}
	this.Tenant = string(randStringTypes(r))
	this.CreatorClass = string(randStringTypes(r))
	this.CreatorId = string(randStringTypes(r))
	this.ObjectIndex = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.OwnerView = NewPopulatedViewRefType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthnTypeBasicAuth(r randyTypes, easy bool) *AuthnTypeBasicAuth {
	this := &AuthnTypeBasicAuth{}
	this.Username = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.Password = NewPopulatedSecretType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthnTypeHeaders(r randyTypes, easy bool) *AuthnTypeHeaders {
	this := &AuthnTypeHeaders{}
	if r.Intn(10) != 0 {
		v15 := r.Intn(10)
		this.Headers = make(map[string]*SecretType)
		for i := 0; i < v15; i++ {
			this.Headers[randStringTypes(r)] = NewPopulatedSecretType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthnTypeQueryParams(r randyTypes, easy bool) *AuthnTypeQueryParams {
	this := &AuthnTypeQueryParams{}
	if r.Intn(10) != 0 {
		v16 := r.Intn(10)
		this.QueryParams = make(map[string]*SecretType)
		for i := 0; i < v16; i++ {
			this.QueryParams[randStringTypes(r)] = NewPopulatedSecretType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBlindfoldSecretInfoType(r randyTypes, easy bool) *BlindfoldSecretInfoType {
	this := &BlindfoldSecretInfoType{}
	this.DecryptionProvider = string(randStringTypes(r))
	this.StoreProvider = string(randStringTypes(r))
	this.Location = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVaultSecretInfoType(r randyTypes, easy bool) *VaultSecretInfoType {
	this := &VaultSecretInfoType{}
	this.Provider = string(randStringTypes(r))
	this.Location = string(randStringTypes(r))
	this.Key = string(randStringTypes(r))
	this.Version = uint32(r.Uint32())
	this.SecretEncoding = SecretEncodingType([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedClearSecretInfoType(r randyTypes, easy bool) *ClearSecretInfoType {
	this := &ClearSecretInfoType{}
	this.Provider = string(randStringTypes(r))
	this.Url = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWingmanSecretInfoType(r randyTypes, easy bool) *WingmanSecretInfoType {
	this := &WingmanSecretInfoType{}
	this.Name = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSecretType(r randyTypes, easy bool) *SecretType {
	this := &SecretType{}
	oneofNumber_SecretInfoOneof := []int32{4, 5, 6, 7}[r.Intn(4)]
	switch oneofNumber_SecretInfoOneof {
	case 4:
		this.SecretInfoOneof = NewPopulatedSecretType_BlindfoldSecretInfo(r, easy)
	case 5:
		this.SecretInfoOneof = NewPopulatedSecretType_VaultSecretInfo(r, easy)
	case 6:
		this.SecretInfoOneof = NewPopulatedSecretType_ClearSecretInfo(r, easy)
	case 7:
		this.SecretInfoOneof = NewPopulatedSecretType_WingmanSecretInfo(r, easy)
	}
	this.SecretEncodingType = SecretEncodingType([]int32{0, 1}[r.Intn(2)])
	if r.Intn(10) != 0 {
		this.BlindfoldSecretInfoInternal = NewPopulatedBlindfoldSecretInfoType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSecretType_BlindfoldSecretInfo(r randyTypes, easy bool) *SecretType_BlindfoldSecretInfo {
	this := &SecretType_BlindfoldSecretInfo{}
	this.BlindfoldSecretInfo = NewPopulatedBlindfoldSecretInfoType(r, easy)
	return this
}
func NewPopulatedSecretType_VaultSecretInfo(r randyTypes, easy bool) *SecretType_VaultSecretInfo {
	this := &SecretType_VaultSecretInfo{}
	this.VaultSecretInfo = NewPopulatedVaultSecretInfoType(r, easy)
	return this
}
func NewPopulatedSecretType_ClearSecretInfo(r randyTypes, easy bool) *SecretType_ClearSecretInfo {
	this := &SecretType_ClearSecretInfo{}
	this.ClearSecretInfo = NewPopulatedClearSecretInfoType(r, easy)
	return this
}
func NewPopulatedSecretType_WingmanSecretInfo(r randyTypes, easy bool) *SecretType_WingmanSecretInfo {
	this := &SecretType_WingmanSecretInfo{}
	this.WingmanSecretInfo = NewPopulatedWingmanSecretInfoType(r, easy)
	return this
}
func NewPopulatedNetworkRefType(r randyTypes, easy bool) *NetworkRefType {
	this := &NetworkRefType{}
	if r.Intn(10) != 0 {
		v17 := r.Intn(5)
		this.Ref = make([]*ObjectRefType, v17)
		for i := 0; i < v17; i++ {
			this.Ref[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSiteRefType(r randyTypes, easy bool) *SiteRefType {
	this := &SiteRefType{}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.Ref = make([]*ObjectRefType, v18)
		for i := 0; i < v18; i++ {
			this.Ref[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	this.NetworkType = VirtualNetworkType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}[r.Intn(11)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpPrefixSetRefType(r randyTypes, easy bool) *IpPrefixSetRefType {
	this := &IpPrefixSetRefType{}
	if r.Intn(10) != 0 {
		v19 := r.Intn(5)
		this.Ref = make([]*ObjectRefType, v19)
		for i := 0; i < v19; i++ {
			this.Ref[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSiteRefType(r randyTypes, easy bool) *VSiteRefType {
	this := &VSiteRefType{}
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.Ref = make([]*ObjectRefType, v20)
		for i := 0; i < v20; i++ {
			this.Ref[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	this.NetworkType = VirtualNetworkType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}[r.Intn(11)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPolicerRefType(r randyTypes, easy bool) *PolicerRefType {
	this := &PolicerRefType{}
	if r.Intn(10) != 0 {
		v21 := r.Intn(5)
		this.Ref = make([]*ObjectRefType, v21)
		for i := 0; i < v21; i++ {
			this.Ref[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProtocolPolicerRefType(r randyTypes, easy bool) *ProtocolPolicerRefType {
	this := &ProtocolPolicerRefType{}
	if r.Intn(10) != 0 {
		v22 := r.Intn(5)
		this.Ref = make([]*ObjectRefType, v22)
		for i := 0; i < v22; i++ {
			this.Ref[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNetworkSiteRefSelector(r randyTypes, easy bool) *NetworkSiteRefSelector {
	this := &NetworkSiteRefSelector{}
	oneofNumber_RefOrSelector := []int32{1, 2, 3}[r.Intn(3)]
	switch oneofNumber_RefOrSelector {
	case 1:
		this.RefOrSelector = NewPopulatedNetworkSiteRefSelector_VirtualNetwork(r, easy)
	case 2:
		this.RefOrSelector = NewPopulatedNetworkSiteRefSelector_Site(r, easy)
	case 3:
		this.RefOrSelector = NewPopulatedNetworkSiteRefSelector_VirtualSite(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNetworkSiteRefSelector_VirtualNetwork(r randyTypes, easy bool) *NetworkSiteRefSelector_VirtualNetwork {
	this := &NetworkSiteRefSelector_VirtualNetwork{}
	this.VirtualNetwork = NewPopulatedNetworkRefType(r, easy)
	return this
}
func NewPopulatedNetworkSiteRefSelector_Site(r randyTypes, easy bool) *NetworkSiteRefSelector_Site {
	this := &NetworkSiteRefSelector_Site{}
	this.Site = NewPopulatedSiteRefType(r, easy)
	return this
}
func NewPopulatedNetworkSiteRefSelector_VirtualSite(r randyTypes, easy bool) *NetworkSiteRefSelector_VirtualSite {
	this := &NetworkSiteRefSelector_VirtualSite{}
	this.VirtualSite = NewPopulatedVSiteRefType(r, easy)
	return this
}
func NewPopulatedSiteVirtualSiteRefSelector(r randyTypes, easy bool) *SiteVirtualSiteRefSelector {
	this := &SiteVirtualSiteRefSelector{}
	oneofNumber_RefOrSelector := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_RefOrSelector {
	case 2:
		this.RefOrSelector = NewPopulatedSiteVirtualSiteRefSelector_Site(r, easy)
	case 3:
		this.RefOrSelector = NewPopulatedSiteVirtualSiteRefSelector_VirtualSite(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSiteVirtualSiteRefSelector_Site(r randyTypes, easy bool) *SiteVirtualSiteRefSelector_Site {
	this := &SiteVirtualSiteRefSelector_Site{}
	this.Site = NewPopulatedSiteRefType(r, easy)
	return this
}
func NewPopulatedSiteVirtualSiteRefSelector_VirtualSite(r randyTypes, easy bool) *SiteVirtualSiteRefSelector_VirtualSite {
	this := &SiteVirtualSiteRefSelector_VirtualSite{}
	this.VirtualSite = NewPopulatedVSiteRefType(r, easy)
	return this
}
func NewPopulatedHeaderManipulationOptionType(r randyTypes, easy bool) *HeaderManipulationOptionType {
	this := &HeaderManipulationOptionType{}
	this.Name = string(randStringTypes(r))
	this.Value = string(randStringTypes(r))
	this.Append = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTlsValidationParamsType(r randyTypes, easy bool) *TlsValidationParamsType {
	this := &TlsValidationParamsType{}
	this.TrustedCaUrl = string(randStringTypes(r))
	this.SkipHostnameVerification = bool(bool(r.Intn(2) == 0))
	v23 := r.Intn(10)
	this.VerifySubjectAltNames = make([]string, v23)
	for i := 0; i < v23; i++ {
		this.VerifySubjectAltNames[i] = string(randStringTypes(r))
	}
	this.UseVolterraTrustedCaUrl = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTlsCertificateType(r randyTypes, easy bool) *TlsCertificateType {
	this := &TlsCertificateType{}
	this.CertificateUrl = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.PrivateKey = NewPopulatedSecretType(r, easy)
	}
	this.Description = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTlsParamsType(r randyTypes, easy bool) *TlsParamsType {
	this := &TlsParamsType{}
	this.MinimumProtocolVersion = TlsProtocol([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.MaximumProtocolVersion = TlsProtocol([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	v24 := r.Intn(10)
	this.CipherSuites = make([]string, v24)
	for i := 0; i < v24; i++ {
		this.CipherSuites[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		v25 := r.Intn(5)
		this.TlsCertificates = make([]*TlsCertificateType, v25)
		for i := 0; i < v25; i++ {
			this.TlsCertificates[i] = NewPopulatedTlsCertificateType(r, easy)
		}
	}
	this.TrustedCaUrl = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.ValidationParams = NewPopulatedTlsValidationParamsType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpstreamTlsParamsType(r randyTypes, easy bool) *UpstreamTlsParamsType {
	this := &UpstreamTlsParamsType{}
	if r.Intn(10) != 0 {
		this.CommonParams = NewPopulatedTlsParamsType(r, easy)
	}
	oneofNumber_SniChoice := []int32{2, 3, 4}[r.Intn(3)]
	switch oneofNumber_SniChoice {
	case 2:
		this.SniChoice = NewPopulatedUpstreamTlsParamsType_Sni(r, easy)
	case 3:
		this.SniChoice = NewPopulatedUpstreamTlsParamsType_UseHostHeaderAsSni(r, easy)
	case 4:
		this.SniChoice = NewPopulatedUpstreamTlsParamsType_DisableSni(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpstreamTlsParamsType_Sni(r randyTypes, easy bool) *UpstreamTlsParamsType_Sni {
	this := &UpstreamTlsParamsType_Sni{}
	this.Sni = string(randStringTypes(r))
	return this
}
func NewPopulatedUpstreamTlsParamsType_UseHostHeaderAsSni(r randyTypes, easy bool) *UpstreamTlsParamsType_UseHostHeaderAsSni {
	this := &UpstreamTlsParamsType_UseHostHeaderAsSni{}
	this.UseHostHeaderAsSni = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedUpstreamTlsParamsType_DisableSni(r randyTypes, easy bool) *UpstreamTlsParamsType_DisableSni {
	this := &UpstreamTlsParamsType_DisableSni{}
	this.DisableSni = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDownstreamTlsParamsType(r randyTypes, easy bool) *DownstreamTlsParamsType {
	this := &DownstreamTlsParamsType{}
	if r.Intn(10) != 0 {
		this.CommonParams = NewPopulatedTlsParamsType(r, easy)
	}
	this.RequireClientCertificate = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDomainType(r randyTypes, easy bool) *DomainType {
	this := &DomainType{}
	oneofNumber_DomainChoice := []int32{1, 2, 3}[r.Intn(3)]
	switch oneofNumber_DomainChoice {
	case 1:
		this.DomainChoice = NewPopulatedDomainType_ExactValue(r, easy)
	case 2:
		this.DomainChoice = NewPopulatedDomainType_SuffixValue(r, easy)
	case 3:
		this.DomainChoice = NewPopulatedDomainType_RegexValue(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDomainType_ExactValue(r randyTypes, easy bool) *DomainType_ExactValue {
	this := &DomainType_ExactValue{}
	this.ExactValue = string(randStringTypes(r))
	return this
}
func NewPopulatedDomainType_SuffixValue(r randyTypes, easy bool) *DomainType_SuffixValue {
	this := &DomainType_SuffixValue{}
	this.SuffixValue = string(randStringTypes(r))
	return this
}
func NewPopulatedDomainType_RegexValue(r randyTypes, easy bool) *DomainType_RegexValue {
	this := &DomainType_RegexValue{}
	this.RegexValue = string(randStringTypes(r))
	return this
}
func NewPopulatedL4DestType(r randyTypes, easy bool) *L4DestType {
	this := &L4DestType{}
	v26 := r.Intn(10)
	this.Prefixes = make([]string, v26)
	for i := 0; i < v26; i++ {
		this.Prefixes[i] = string(randStringTypes(r))
	}
	this.PortRanges = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTlsInterceptionRule(r randyTypes, easy bool) *TlsInterceptionRule {
	this := &TlsInterceptionRule{}
	if r.Intn(10) != 0 {
		this.DomainMatch = NewPopulatedDomainType(r, easy)
	}
	oneofNumber_EnableDisableChoice := []int32{3, 4}[r.Intn(2)]
	switch oneofNumber_EnableDisableChoice {
	case 3:
		this.EnableDisableChoice = NewPopulatedTlsInterceptionRule_DisableInterception(r, easy)
	case 4:
		this.EnableDisableChoice = NewPopulatedTlsInterceptionRule_EnableInterception(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTlsInterceptionRule_DisableInterception(r randyTypes, easy bool) *TlsInterceptionRule_DisableInterception {
	this := &TlsInterceptionRule_DisableInterception{}
	this.DisableInterception = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedTlsInterceptionRule_EnableInterception(r randyTypes, easy bool) *TlsInterceptionRule_EnableInterception {
	this := &TlsInterceptionRule_EnableInterception{}
	this.EnableInterception = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedTlsInterceptionPolicy(r randyTypes, easy bool) *TlsInterceptionPolicy {
	this := &TlsInterceptionPolicy{}
	if r.Intn(10) != 0 {
		v27 := r.Intn(5)
		this.InterceptionRules = make([]*TlsInterceptionRule, v27)
		for i := 0; i < v27; i++ {
			this.InterceptionRules[i] = NewPopulatedTlsInterceptionRule(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTlsInterceptionType(r randyTypes, easy bool) *TlsInterceptionType {
	this := &TlsInterceptionType{}
	oneofNumber_InterceptionPolicyChoice := []int32{1, 9}[r.Intn(2)]
	switch oneofNumber_InterceptionPolicyChoice {
	case 1:
		this.InterceptionPolicyChoice = NewPopulatedTlsInterceptionType_Policy(r, easy)
	case 9:
		this.InterceptionPolicyChoice = NewPopulatedTlsInterceptionType_EnableForAllDomains(r, easy)
	}
	oneofNumber_SigningCertChoice := []int32{3, 4}[r.Intn(2)]
	switch oneofNumber_SigningCertChoice {
	case 3:
		this.SigningCertChoice = NewPopulatedTlsInterceptionType_CustomCertificate(r, easy)
	case 4:
		this.SigningCertChoice = NewPopulatedTlsInterceptionType_VolterraCertificate(r, easy)
	}
	oneofNumber_TrustedCaChoice := []int32{6, 7}[r.Intn(2)]
	switch oneofNumber_TrustedCaChoice {
	case 6:
		this.TrustedCaChoice = NewPopulatedTlsInterceptionType_TrustedCaUrl(r, easy)
	case 7:
		this.TrustedCaChoice = NewPopulatedTlsInterceptionType_VolterraTrustedCa(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTlsInterceptionType_Policy(r randyTypes, easy bool) *TlsInterceptionType_Policy {
	this := &TlsInterceptionType_Policy{}
	this.Policy = NewPopulatedTlsInterceptionPolicy(r, easy)
	return this
}
func NewPopulatedTlsInterceptionType_CustomCertificate(r randyTypes, easy bool) *TlsInterceptionType_CustomCertificate {
	this := &TlsInterceptionType_CustomCertificate{}
	this.CustomCertificate = NewPopulatedTlsCertificateType(r, easy)
	return this
}
func NewPopulatedTlsInterceptionType_VolterraCertificate(r randyTypes, easy bool) *TlsInterceptionType_VolterraCertificate {
	this := &TlsInterceptionType_VolterraCertificate{}
	this.VolterraCertificate = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedTlsInterceptionType_TrustedCaUrl(r randyTypes, easy bool) *TlsInterceptionType_TrustedCaUrl {
	this := &TlsInterceptionType_TrustedCaUrl{}
	this.TrustedCaUrl = string(randStringTypes(r))
	return this
}
func NewPopulatedTlsInterceptionType_VolterraTrustedCa(r randyTypes, easy bool) *TlsInterceptionType_VolterraTrustedCa {
	this := &TlsInterceptionType_VolterraTrustedCa{}
	this.VolterraTrustedCa = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedTlsInterceptionType_EnableForAllDomains(r randyTypes, easy bool) *TlsInterceptionType_EnableForAllDomains {
	this := &TlsInterceptionType_EnableForAllDomains{}
	this.EnableForAllDomains = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedFractionalPercent(r randyTypes, easy bool) *FractionalPercent {
	this := &FractionalPercent{}
	this.Numerator = uint32(r.Uint32())
	this.Denominator = DenominatorType([]int32{0, 1, 2}[r.Intn(3)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBufferConfigType(r randyTypes, easy bool) *BufferConfigType {
	this := &BufferConfigType{}
	this.Disabled = bool(bool(r.Intn(2) == 0))
	this.MaxRequestBytes = uint32(r.Uint32())
	this.MaxRequestTime = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCorsPolicy(r randyTypes, easy bool) *CorsPolicy {
	this := &CorsPolicy{}
	this.Disabled = bool(bool(r.Intn(2) == 0))
	v28 := r.Intn(10)
	this.AllowOrigin = make([]string, v28)
	for i := 0; i < v28; i++ {
		this.AllowOrigin[i] = string(randStringTypes(r))
	}
	v29 := r.Intn(10)
	this.AllowOriginRegex = make([]string, v29)
	for i := 0; i < v29; i++ {
		this.AllowOriginRegex[i] = string(randStringTypes(r))
	}
	this.AllowMethods = string(randStringTypes(r))
	this.AllowHeaders = string(randStringTypes(r))
	this.ExposeHeaders = string(randStringTypes(r))
	this.MaxAge = string(randStringTypes(r))
	this.AllowCredentials = bool(bool(r.Intn(2) == 0))
	this.MaximumAge = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaximumAge *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPathMatcherType(r randyTypes, easy bool) *PathMatcherType {
	this := &PathMatcherType{}
	oneofNumber_PathMatch := []int32{1, 2, 3}[r.Intn(3)]
	switch oneofNumber_PathMatch {
	case 1:
		this.PathMatch = NewPopulatedPathMatcherType_Prefix(r, easy)
	case 2:
		this.PathMatch = NewPopulatedPathMatcherType_Path(r, easy)
	case 3:
		this.PathMatch = NewPopulatedPathMatcherType_Regex(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPathMatcherType_Prefix(r randyTypes, easy bool) *PathMatcherType_Prefix {
	this := &PathMatcherType_Prefix{}
	this.Prefix = string(randStringTypes(r))
	return this
}
func NewPopulatedPathMatcherType_Path(r randyTypes, easy bool) *PathMatcherType_Path {
	this := &PathMatcherType_Path{}
	this.Path = string(randStringTypes(r))
	return this
}
func NewPopulatedPathMatcherType_Regex(r randyTypes, easy bool) *PathMatcherType_Regex {
	this := &PathMatcherType_Regex{}
	this.Regex = string(randStringTypes(r))
	return this
}
func NewPopulatedHeaderMatcherType(r randyTypes, easy bool) *HeaderMatcherType {
	this := &HeaderMatcherType{}
	this.Name = string(randStringTypes(r))
	oneofNumber_ValueMatch := []int32{2, 3, 4}[r.Intn(3)]
	switch oneofNumber_ValueMatch {
	case 2:
		this.ValueMatch = NewPopulatedHeaderMatcherType_Exact(r, easy)
	case 3:
		this.ValueMatch = NewPopulatedHeaderMatcherType_Regex(r, easy)
	case 4:
		this.ValueMatch = NewPopulatedHeaderMatcherType_Presence(r, easy)
	}
	this.InvertMatch = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHeaderMatcherType_Exact(r randyTypes, easy bool) *HeaderMatcherType_Exact {
	this := &HeaderMatcherType_Exact{}
	this.Exact = string(randStringTypes(r))
	return this
}
func NewPopulatedHeaderMatcherType_Regex(r randyTypes, easy bool) *HeaderMatcherType_Regex {
	this := &HeaderMatcherType_Regex{}
	this.Regex = string(randStringTypes(r))
	return this
}
func NewPopulatedHeaderMatcherType_Presence(r randyTypes, easy bool) *HeaderMatcherType_Presence {
	this := &HeaderMatcherType_Presence{}
	this.Presence = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedQueryParameterMatcherType(r randyTypes, easy bool) *QueryParameterMatcherType {
	this := &QueryParameterMatcherType{}
	this.Key = string(randStringTypes(r))
	oneofNumber_ValueMatch := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_ValueMatch {
	case 2:
		this.ValueMatch = NewPopulatedQueryParameterMatcherType_Exact(r, easy)
	case 3:
		this.ValueMatch = NewPopulatedQueryParameterMatcherType_Regex(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedQueryParameterMatcherType_Exact(r randyTypes, easy bool) *QueryParameterMatcherType_Exact {
	this := &QueryParameterMatcherType_Exact{}
	this.Exact = string(randStringTypes(r))
	return this
}
func NewPopulatedQueryParameterMatcherType_Regex(r randyTypes, easy bool) *QueryParameterMatcherType_Regex {
	this := &QueryParameterMatcherType_Regex{}
	this.Regex = string(randStringTypes(r))
	return this
}
func NewPopulatedRouteMatch(r randyTypes, easy bool) *RouteMatch {
	this := &RouteMatch{}
	if r.Intn(10) != 0 {
		this.Path = NewPopulatedPathMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		v30 := r.Intn(5)
		this.Headers = make([]*HeaderMatcherType, v30)
		for i := 0; i < v30; i++ {
			this.Headers[i] = NewPopulatedHeaderMatcherType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v31 := r.Intn(5)
		this.QueryParams = make([]*QueryParameterMatcherType, v31)
		for i := 0; i < v31; i++ {
			this.QueryParams[i] = NewPopulatedQueryParameterMatcherType(r, easy)
		}
	}
	this.HttpMethod = HttpMethod([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}[r.Intn(10)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWafRefType(r randyTypes, easy bool) *WafRefType {
	this := &WafRefType{}
	if r.Intn(10) != 0 {
		v32 := r.Intn(5)
		this.Waf = make([]*ObjectRefType, v32)
		for i := 0; i < v32; i++ {
			this.Waf[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWafRulesRefType(r randyTypes, easy bool) *WafRulesRefType {
	this := &WafRulesRefType{}
	if r.Intn(10) != 0 {
		v33 := r.Intn(5)
		this.WafRules = make([]*ObjectRefType, v33)
		for i := 0; i < v33; i++ {
			this.WafRules[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWafType(r randyTypes, easy bool) *WafType {
	this := &WafType{}
	oneofNumber_RefType := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_RefType {
	case 1:
		this.RefType = NewPopulatedWafType_Waf(r, easy)
	case 2:
		this.RefType = NewPopulatedWafType_WafRules(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWafType_Waf(r randyTypes, easy bool) *WafType_Waf {
	this := &WafType_Waf{}
	this.Waf = NewPopulatedWafRefType(r, easy)
	return this
}
func NewPopulatedWafType_WafRules(r randyTypes, easy bool) *WafType_WafRules {
	this := &WafType_WafRules{}
	this.WafRules = NewPopulatedWafRulesRefType(r, easy)
	return this
}
func NewPopulatedAppRoleAuthInfoType(r randyTypes, easy bool) *AppRoleAuthInfoType {
	this := &AppRoleAuthInfoType{}
	this.RoleId = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.SecretId = NewPopulatedSecretType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVaultAuthInfoType(r randyTypes, easy bool) *VaultAuthInfoType {
	this := &VaultAuthInfoType{}
	oneofNumber_AuthParams := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_AuthParams {
	case 1:
		this.AuthParams = NewPopulatedVaultAuthInfoType_AppRoleAuth(r, easy)
	case 2:
		this.AuthParams = NewPopulatedVaultAuthInfoType_Token(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVaultAuthInfoType_AppRoleAuth(r randyTypes, easy bool) *VaultAuthInfoType_AppRoleAuth {
	this := &VaultAuthInfoType_AppRoleAuth{}
	this.AppRoleAuth = NewPopulatedAppRoleAuthInfoType(r, easy)
	return this
}
func NewPopulatedVaultAuthInfoType_Token(r randyTypes, easy bool) *VaultAuthInfoType_Token {
	this := &VaultAuthInfoType_Token{}
	this.Token = NewPopulatedSecretType(r, easy)
	return this
}
func NewPopulatedRestAuthInfoType(r randyTypes, easy bool) *RestAuthInfoType {
	this := &RestAuthInfoType{}
	oneofNumber_AuthParams := []int32{1, 2, 3}[r.Intn(3)]
	switch oneofNumber_AuthParams {
	case 1:
		this.AuthParams = NewPopulatedRestAuthInfoType_BasicAuth(r, easy)
	case 2:
		this.AuthParams = NewPopulatedRestAuthInfoType_HeadersAuth(r, easy)
	case 3:
		this.AuthParams = NewPopulatedRestAuthInfoType_QueryParamsAuth(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRestAuthInfoType_BasicAuth(r randyTypes, easy bool) *RestAuthInfoType_BasicAuth {
	this := &RestAuthInfoType_BasicAuth{}
	this.BasicAuth = NewPopulatedAuthnTypeBasicAuth(r, easy)
	return this
}
func NewPopulatedRestAuthInfoType_HeadersAuth(r randyTypes, easy bool) *RestAuthInfoType_HeadersAuth {
	this := &RestAuthInfoType_HeadersAuth{}
	this.HeadersAuth = NewPopulatedAuthnTypeHeaders(r, easy)
	return this
}
func NewPopulatedRestAuthInfoType_QueryParamsAuth(r randyTypes, easy bool) *RestAuthInfoType_QueryParamsAuth {
	this := &RestAuthInfoType_QueryParamsAuth{}
	this.QueryParamsAuth = NewPopulatedAuthnTypeQueryParams(r, easy)
	return this
}
func NewPopulatedHostAccessInfoType(r randyTypes, easy bool) *HostAccessInfoType {
	this := &HostAccessInfoType{}
	this.Scheme = URLSchemeType([]int32{0, 1}[r.Intn(2)])
	this.ServerEndpoint = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.TlsConfig = NewPopulatedUpstreamTlsParamsType(r, easy)
	}
	oneofNumber_AuthParams := []int32{5, 6}[r.Intn(2)]
	switch oneofNumber_AuthParams {
	case 5:
		this.AuthParams = NewPopulatedHostAccessInfoType_RestAuthInfo(r, easy)
	case 6:
		this.AuthParams = NewPopulatedHostAccessInfoType_VaultAuthInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHostAccessInfoType_RestAuthInfo(r randyTypes, easy bool) *HostAccessInfoType_RestAuthInfo {
	this := &HostAccessInfoType_RestAuthInfo{}
	this.RestAuthInfo = NewPopulatedRestAuthInfoType(r, easy)
	return this
}
func NewPopulatedHostAccessInfoType_VaultAuthInfo(r randyTypes, easy bool) *HostAccessInfoType_VaultAuthInfo {
	this := &HostAccessInfoType_VaultAuthInfo{}
	this.VaultAuthInfo = NewPopulatedVaultAuthInfoType(r, easy)
	return this
}
func NewPopulatedVaultAccessInfoType(r randyTypes, easy bool) *VaultAccessInfoType {
	this := &VaultAccessInfoType{}
	this.VaultAddr = string(randStringTypes(r))
	this.VaultCaUrl = string(randStringTypes(r))
	oneofNumber_AuthnChoice := []int32{3, 4}[r.Intn(2)]
	switch oneofNumber_AuthnChoice {
	case 3:
		this.AuthnChoice = NewPopulatedVaultAccessInfoType_AppRoleAuth(r, easy)
	case 4:
		this.AuthnChoice = NewPopulatedVaultAccessInfoType_Token(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVaultAccessInfoType_AppRoleAuth(r randyTypes, easy bool) *VaultAccessInfoType_AppRoleAuth {
	this := &VaultAccessInfoType_AppRoleAuth{}
	this.AppRoleAuth = NewPopulatedAppRoleAuthInfoType(r, easy)
	return this
}
func NewPopulatedVaultAccessInfoType_Token(r randyTypes, easy bool) *VaultAccessInfoType_Token {
	this := &VaultAccessInfoType_Token{}
	this.Token = NewPopulatedSecretType(r, easy)
	return this
}
func NewPopulatedVaultSecretType(r randyTypes, easy bool) *VaultSecretType {
	this := &VaultSecretType{}
	oneofNumber_AccessChoice := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_AccessChoice {
	case 1:
		this.AccessChoice = NewPopulatedVaultSecretType_VaultAccessInfo(r, easy)
	case 2:
		this.AccessChoice = NewPopulatedVaultSecretType_ProviderName(r, easy)
	}
	this.SecretPath = string(randStringTypes(r))
	this.SecretSubPath = string(randStringTypes(r))
	this.SecretVersion = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVaultSecretType_VaultAccessInfo(r randyTypes, easy bool) *VaultSecretType_VaultAccessInfo {
	this := &VaultSecretType_VaultAccessInfo{}
	this.VaultAccessInfo = NewPopulatedVaultAccessInfoType(r, easy)
	return this
}
func NewPopulatedVaultSecretType_ProviderName(r randyTypes, easy bool) *VaultSecretType_ProviderName {
	this := &VaultSecretType_ProviderName{}
	this.ProviderName = string(randStringTypes(r))
	return this
}
func NewPopulatedVolterraSecretType(r randyTypes, easy bool) *VolterraSecretType {
	this := &VolterraSecretType{}
	oneofNumber_SecretTypeChoice := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_SecretTypeChoice {
	case 1:
		this.SecretTypeChoice = NewPopulatedVolterraSecretType_BlindfoldSecretInfo(r, easy)
	case 2:
		this.SecretTypeChoice = NewPopulatedVolterraSecretType_VaultSecretInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVolterraSecretType_BlindfoldSecretInfo(r randyTypes, easy bool) *VolterraSecretType_BlindfoldSecretInfo {
	this := &VolterraSecretType_BlindfoldSecretInfo{}
	this.BlindfoldSecretInfo = NewPopulatedBlindfoldSecretInfoType(r, easy)
	return this
}
func NewPopulatedVolterraSecretType_VaultSecretInfo(r randyTypes, easy bool) *VolterraSecretType_VaultSecretInfo {
	this := &VolterraSecretType_VaultSecretInfo{}
	this.VaultSecretInfo = NewPopulatedVaultAccessInfoType(r, easy)
	return this
}
func NewPopulatedPortValueType(r randyTypes, easy bool) *PortValueType {
	this := &PortValueType{}
	oneofNumber_PortValueTypeChoice := []int32{1, 2, 3}[r.Intn(3)]
	switch oneofNumber_PortValueTypeChoice {
	case 1:
		this.PortValueTypeChoice = NewPopulatedPortValueType_All(r, easy)
	case 2:
		this.PortValueTypeChoice = NewPopulatedPortValueType_UserDefined(r, easy)
	case 3:
		this.PortValueTypeChoice = NewPopulatedPortValueType_Dns(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPortValueType_All(r randyTypes, easy bool) *PortValueType_All {
	this := &PortValueType_All{}
	this.All = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedPortValueType_UserDefined(r randyTypes, easy bool) *PortValueType_UserDefined {
	this := &PortValueType_UserDefined{}
	this.UserDefined = uint32(r.Uint32())
	return this
}
func NewPopulatedPortValueType_Dns(r randyTypes, easy bool) *PortValueType_Dns {
	this := &PortValueType_Dns{}
	this.Dns = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedVirtualNetworkReferenceType(r randyTypes, easy bool) *VirtualNetworkReferenceType {
	this := &VirtualNetworkReferenceType{}
	if r.Intn(10) != 0 {
		v34 := r.Intn(5)
		this.Refs = make([]*ObjectRefType, v34)
		for i := 0; i < v34; i++ {
			this.Refs[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVirtualNetworkSelectorType(r randyTypes, easy bool) *VirtualNetworkSelectorType {
	this := &VirtualNetworkSelectorType{}
	oneofNumber_VnTypeChoice := []int32{1, 2, 4}[r.Intn(3)]
	switch oneofNumber_VnTypeChoice {
	case 1:
		this.VnTypeChoice = NewPopulatedVirtualNetworkSelectorType_SiteLocal(r, easy)
	case 2:
		this.VnTypeChoice = NewPopulatedVirtualNetworkSelectorType_SiteLocalInside(r, easy)
	case 4:
		this.VnTypeChoice = NewPopulatedVirtualNetworkSelectorType_Public(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVirtualNetworkSelectorType_SiteLocal(r randyTypes, easy bool) *VirtualNetworkSelectorType_SiteLocal {
	this := &VirtualNetworkSelectorType_SiteLocal{}
	this.SiteLocal = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedVirtualNetworkSelectorType_SiteLocalInside(r randyTypes, easy bool) *VirtualNetworkSelectorType_SiteLocalInside {
	this := &VirtualNetworkSelectorType_SiteLocalInside{}
	this.SiteLocalInside = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedVirtualNetworkSelectorType_Public(r randyTypes, easy bool) *VirtualNetworkSelectorType_Public {
	this := &VirtualNetworkSelectorType_Public{}
	this.Public = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedRetryBackOff(r randyTypes, easy bool) *RetryBackOff {
	this := &RetryBackOff{}
	this.BaseInterval = uint32(r.Uint32())
	this.MaxInterval = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRetryPolicyType(r randyTypes, easy bool) *RetryPolicyType {
	this := &RetryPolicyType{}
	this.RetryOn = string(randStringTypes(r))
	this.NumRetries = uint32(r.Uint32())
	this.PerTryTimeout = uint32(r.Uint32())
	v35 := r.Intn(10)
	this.RetriableStatusCodes = make([]uint32, v35)
	for i := 0; i < v35; i++ {
		this.RetriableStatusCodes[i] = uint32(r.Uint32())
	}
	if r.Intn(10) != 0 {
		this.BackOff = NewPopulatedRetryBackOff(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMetricValue(r randyTypes, easy bool) *MetricValue {
	this := &MetricValue{}
	this.Timestamp = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Value = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNextHopType(r randyTypes, easy bool) *NextHopType {
	this := &NextHopType{}
	this.Type = NextHopTypes([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if r.Intn(10) != 0 {
		this.NexthopAddress = NewPopulatedIpAddressType(r, easy)
	}
	if r.Intn(10) != 0 {
		v36 := r.Intn(5)
		this.Interface = make([]*ObjectRefType, v36)
		for i := 0; i < v36; i++ {
			this.Interface[i] = NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStaticRouteType(r randyTypes, easy bool) *StaticRouteType {
	this := &StaticRouteType{}
	v37 := r.Intn(10)
	this.Attrs = make([]RouteAttrType, v37)
	for i := 0; i < v37; i++ {
		this.Attrs[i] = RouteAttrType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	}
	if r.Intn(10) != 0 {
		v38 := r.Intn(5)
		this.Subnets = make([]*IpSubnetType, v38)
		for i := 0; i < v38; i++ {
			this.Subnets[i] = NewPopulatedIpSubnetType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Nexthop = NewPopulatedNextHopType(r, easy)
	}
	if r.Intn(10) != 0 {
		v39 := r.Intn(10)
		this.Labels = make(map[string]string)
		for i := 0; i < v39; i++ {
			this.Labels[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedForwardProxyConfigType(r randyTypes, easy bool) *ForwardProxyConfigType {
	this := &ForwardProxyConfigType{}
	v40 := r.Intn(10)
	this.WhiteListedPrefixes = make([]string, v40)
	for i := 0; i < v40; i++ {
		this.WhiteListedPrefixes[i] = string(randStringTypes(r))
	}
	v41 := r.Intn(10)
	this.WhiteListedPorts = make([]uint32, v41)
	for i := 0; i < v41; i++ {
		this.WhiteListedPorts[i] = uint32(r.Uint32())
	}
	this.MaxConnectAttempts = uint32(r.Uint32())
	this.ConnectionTimeout = uint32(r.Uint32())
	oneofNumber_TlsInterceptionChoice := []int32{6, 7}[r.Intn(2)]
	switch oneofNumber_TlsInterceptionChoice {
	case 6:
		this.TlsInterceptionChoice = NewPopulatedForwardProxyConfigType_NoInterception(r, easy)
	case 7:
		this.TlsInterceptionChoice = NewPopulatedForwardProxyConfigType_TlsIntercept(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedForwardProxyConfigType_NoInterception(r randyTypes, easy bool) *ForwardProxyConfigType_NoInterception {
	this := &ForwardProxyConfigType_NoInterception{}
	this.NoInterception = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedForwardProxyConfigType_TlsIntercept(r randyTypes, easy bool) *ForwardProxyConfigType_TlsIntercept {
	this := &ForwardProxyConfigType_TlsIntercept{}
	this.TlsIntercept = NewPopulatedTlsInterceptionType(r, easy)
	return this
}
func NewPopulatedHostIdentifier(r randyTypes, easy bool) *HostIdentifier {
	this := &HostIdentifier{}
	oneofNumber_HostnameOrIp := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_HostnameOrIp {
	case 1:
		this.HostnameOrIp = NewPopulatedHostIdentifier_Ip(r, easy)
	case 2:
		this.HostnameOrIp = NewPopulatedHostIdentifier_Hostname(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHostIdentifier_Ip(r randyTypes, easy bool) *HostIdentifier_Ip {
	this := &HostIdentifier_Ip{}
	this.Ip = string(randStringTypes(r))
	return this
}
func NewPopulatedHostIdentifier_Hostname(r randyTypes, easy bool) *HostIdentifier_Hostname {
	this := &HostIdentifier_Hostname{}
	this.Hostname = string(randStringTypes(r))
	return this
}
func NewPopulatedInterfaceIdentifier(r randyTypes, easy bool) *InterfaceIdentifier {
	this := &InterfaceIdentifier{}
	oneofNumber_InterfaceChoice := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_InterfaceChoice {
	case 1:
		this.InterfaceChoice = NewPopulatedInterfaceIdentifier_AnyIntf(r, easy)
	case 2:
		this.InterfaceChoice = NewPopulatedInterfaceIdentifier_Intf(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedInterfaceIdentifier_AnyIntf(r randyTypes, easy bool) *InterfaceIdentifier_AnyIntf {
	this := &InterfaceIdentifier_AnyIntf{}
	this.AnyIntf = NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedInterfaceIdentifier_Intf(r randyTypes, easy bool) *InterfaceIdentifier_Intf {
	this := &InterfaceIdentifier_Intf{}
	this.Intf = string(randStringTypes(r))
	return this
}
func NewPopulatedInterfaceOrNetwork(r randyTypes, easy bool) *InterfaceOrNetwork {
	this := &InterfaceOrNetwork{}
	oneofNumber_InterfaceChoice := []int32{1, 2, 3, 4}[r.Intn(4)]
	switch oneofNumber_InterfaceChoice {
	case 1:
		this.InterfaceChoice = NewPopulatedInterfaceOrNetwork_Intf(r, easy)
	case 2:
		this.InterfaceChoice = NewPopulatedInterfaceOrNetwork_Pod(r, easy)
	case 3:
		this.InterfaceChoice = NewPopulatedInterfaceOrNetwork_VnType(r, easy)
	case 4:
		this.InterfaceChoice = NewPopulatedInterfaceOrNetwork_Vn(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedInterfaceOrNetwork_Intf(r randyTypes, easy bool) *InterfaceOrNetwork_Intf {
	this := &InterfaceOrNetwork_Intf{}
	this.Intf = string(randStringTypes(r))
	return this
}
func NewPopulatedInterfaceOrNetwork_Pod(r randyTypes, easy bool) *InterfaceOrNetwork_Pod {
	this := &InterfaceOrNetwork_Pod{}
	this.Pod = string(randStringTypes(r))
	return this
}
func NewPopulatedInterfaceOrNetwork_VnType(r randyTypes, easy bool) *InterfaceOrNetwork_VnType {
	this := &InterfaceOrNetwork_VnType{}
	this.VnType = VirtualNetworkType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}[r.Intn(11)])
	return this
}
func NewPopulatedInterfaceOrNetwork_Vn(r randyTypes, easy bool) *InterfaceOrNetwork_Vn {
	this := &InterfaceOrNetwork_Vn{}
	this.Vn = string(randStringTypes(r))
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v42 := r.Intn(100)
	tmps := make([]rune, v42)
	for i := 0; i < v42; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v43 := r.Int63()
		if r.Intn(2) == 0 {
			v43 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v43))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ObjectRefType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LabelSelectorType) Size() (n int) {
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, s := range m.Expressions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LabelMatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ConditionType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastUpdateTime != nil {
		l = m.LastUpdateTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StatusType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTypes(uint64(m.Code))
	}
	return n
}

func (m *InitializerType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *InitializersType) Size() (n int) {
	var l int
	_ = l
	if len(m.Pending) > 0 {
		for _, e := range m.Pending {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StatusMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorClass)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StatusId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Publish != 0 {
		n += 1 + sovTypes(uint64(m.Publish))
	}
	return n
}

func (m *ObjectMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ListMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ObjectGetMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ObjectCreateMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ObjectReplaceMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *MessageMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ViewRefType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *KubeRefType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SystemObjectMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeletionTimestamp != nil {
		l = m.DeletionTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Initializers != nil {
		l = m.Initializers.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorClass)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TraceInfo)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectIndex != 0 {
		n += 1 + sovTypes(uint64(m.ObjectIndex))
	}
	if len(m.Namespace) > 0 {
		for _, e := range m.Namespace {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.CreatorCookie)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OwnerView != nil {
		l = m.OwnerView.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SystemObjectGetMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeletionTimestamp != nil {
		l = m.DeletionTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Initializers != nil {
		l = m.Initializers.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorClass)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectIndex != 0 {
		n += 1 + sovTypes(uint64(m.ObjectIndex))
	}
	if m.OwnerView != nil {
		l = m.OwnerView.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuthnTypeBasicAuth) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuthnTypeHeaders) Size() (n int) {
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AuthnTypeQueryParams) Size() (n int) {
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for k, v := range m.QueryParams {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BlindfoldSecretInfoType) Size() (n int) {
	var l int
	_ = l
	l = len(m.DecryptionProvider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StoreProvider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VaultSecretInfoType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	if m.SecretEncoding != 0 {
		n += 1 + sovTypes(uint64(m.SecretEncoding))
	}
	return n
}

func (m *ClearSecretInfoType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *WingmanSecretInfoType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SecretType) Size() (n int) {
	var l int
	_ = l
	if m.SecretInfoOneof != nil {
		n += m.SecretInfoOneof.Size()
	}
	if m.SecretEncodingType != 0 {
		n += 1 + sovTypes(uint64(m.SecretEncodingType))
	}
	if m.BlindfoldSecretInfoInternal != nil {
		l = m.BlindfoldSecretInfoInternal.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SecretType_BlindfoldSecretInfo) Size() (n int) {
	var l int
	_ = l
	if m.BlindfoldSecretInfo != nil {
		l = m.BlindfoldSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecretType_VaultSecretInfo) Size() (n int) {
	var l int
	_ = l
	if m.VaultSecretInfo != nil {
		l = m.VaultSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecretType_ClearSecretInfo) Size() (n int) {
	var l int
	_ = l
	if m.ClearSecretInfo != nil {
		l = m.ClearSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecretType_WingmanSecretInfo) Size() (n int) {
	var l int
	_ = l
	if m.WingmanSecretInfo != nil {
		l = m.WingmanSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkRefType) Size() (n int) {
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteRefType) Size() (n int) {
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NetworkType != 0 {
		n += 1 + sovTypes(uint64(m.NetworkType))
	}
	return n
}

func (m *IpPrefixSetRefType) Size() (n int) {
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VSiteRefType) Size() (n int) {
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NetworkType != 0 {
		n += 1 + sovTypes(uint64(m.NetworkType))
	}
	return n
}

func (m *PolicerRefType) Size() (n int) {
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ProtocolPolicerRefType) Size() (n int) {
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkSiteRefSelector) Size() (n int) {
	var l int
	_ = l
	if m.RefOrSelector != nil {
		n += m.RefOrSelector.Size()
	}
	return n
}

func (m *NetworkSiteRefSelector_VirtualNetwork) Size() (n int) {
	var l int
	_ = l
	if m.VirtualNetwork != nil {
		l = m.VirtualNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkSiteRefSelector_Site) Size() (n int) {
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkSiteRefSelector_VirtualSite) Size() (n int) {
	var l int
	_ = l
	if m.VirtualSite != nil {
		l = m.VirtualSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteVirtualSiteRefSelector) Size() (n int) {
	var l int
	_ = l
	if m.RefOrSelector != nil {
		n += m.RefOrSelector.Size()
	}
	return n
}

func (m *SiteVirtualSiteRefSelector_Site) Size() (n int) {
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteVirtualSiteRefSelector_VirtualSite) Size() (n int) {
	var l int
	_ = l
	if m.VirtualSite != nil {
		l = m.VirtualSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderManipulationOptionType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Append {
		n += 2
	}
	return n
}

func (m *TlsValidationParamsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SkipHostnameVerification {
		n += 2
	}
	if len(m.VerifySubjectAltNames) > 0 {
		for _, s := range m.VerifySubjectAltNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.UseVolterraTrustedCaUrl {
		n += 2
	}
	return n
}

func (m *TlsCertificateType) Size() (n int) {
	var l int
	_ = l
	l = len(m.CertificateUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrivateKey != nil {
		l = m.PrivateKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TlsParamsType) Size() (n int) {
	var l int
	_ = l
	if m.MinimumProtocolVersion != 0 {
		n += 1 + sovTypes(uint64(m.MinimumProtocolVersion))
	}
	if m.MaximumProtocolVersion != 0 {
		n += 1 + sovTypes(uint64(m.MaximumProtocolVersion))
	}
	if len(m.CipherSuites) > 0 {
		for _, s := range m.CipherSuites {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.TlsCertificates) > 0 {
		for _, e := range m.TlsCertificates {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValidationParams != nil {
		l = m.ValidationParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *UpstreamTlsParamsType) Size() (n int) {
	var l int
	_ = l
	if m.CommonParams != nil {
		l = m.CommonParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SniChoice != nil {
		n += m.SniChoice.Size()
	}
	return n
}

func (m *UpstreamTlsParamsType_Sni) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sni)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *UpstreamTlsParamsType_UseHostHeaderAsSni) Size() (n int) {
	var l int
	_ = l
	if m.UseHostHeaderAsSni != nil {
		l = m.UseHostHeaderAsSni.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *UpstreamTlsParamsType_DisableSni) Size() (n int) {
	var l int
	_ = l
	if m.DisableSni != nil {
		l = m.DisableSni.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DownstreamTlsParamsType) Size() (n int) {
	var l int
	_ = l
	if m.CommonParams != nil {
		l = m.CommonParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequireClientCertificate {
		n += 2
	}
	return n
}

func (m *DomainType) Size() (n int) {
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	return n
}

func (m *DomainType_ExactValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.ExactValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DomainType_SuffixValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.SuffixValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DomainType_RegexValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.RegexValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *L4DestType) Size() (n int) {
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for _, s := range m.Prefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PortRanges)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TlsInterceptionRule) Size() (n int) {
	var l int
	_ = l
	if m.DomainMatch != nil {
		l = m.DomainMatch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnableDisableChoice != nil {
		n += m.EnableDisableChoice.Size()
	}
	return n
}

func (m *TlsInterceptionRule_DisableInterception) Size() (n int) {
	var l int
	_ = l
	if m.DisableInterception != nil {
		l = m.DisableInterception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionRule_EnableInterception) Size() (n int) {
	var l int
	_ = l
	if m.EnableInterception != nil {
		l = m.EnableInterception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.InterceptionRules) > 0 {
		for _, e := range m.InterceptionRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TlsInterceptionType) Size() (n int) {
	var l int
	_ = l
	if m.InterceptionPolicyChoice != nil {
		n += m.InterceptionPolicyChoice.Size()
	}
	if m.SigningCertChoice != nil {
		n += m.SigningCertChoice.Size()
	}
	if m.TrustedCaChoice != nil {
		n += m.TrustedCaChoice.Size()
	}
	return n
}

func (m *TlsInterceptionType_Policy) Size() (n int) {
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_CustomCertificate) Size() (n int) {
	var l int
	_ = l
	if m.CustomCertificate != nil {
		l = m.CustomCertificate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_VolterraCertificate) Size() (n int) {
	var l int
	_ = l
	if m.VolterraCertificate != nil {
		l = m.VolterraCertificate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_TrustedCaUrl) Size() (n int) {
	var l int
	_ = l
	l = len(m.TrustedCaUrl)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *TlsInterceptionType_VolterraTrustedCa) Size() (n int) {
	var l int
	_ = l
	if m.VolterraTrustedCa != nil {
		l = m.VolterraTrustedCa.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_EnableForAllDomains) Size() (n int) {
	var l int
	_ = l
	if m.EnableForAllDomains != nil {
		l = m.EnableForAllDomains.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FractionalPercent) Size() (n int) {
	var l int
	_ = l
	if m.Numerator != 0 {
		n += 1 + sovTypes(uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		n += 1 + sovTypes(uint64(m.Denominator))
	}
	return n
}

func (m *BufferConfigType) Size() (n int) {
	var l int
	_ = l
	if m.Disabled {
		n += 2
	}
	if m.MaxRequestBytes != 0 {
		n += 1 + sovTypes(uint64(m.MaxRequestBytes))
	}
	if m.MaxRequestTime != 0 {
		n += 1 + sovTypes(uint64(m.MaxRequestTime))
	}
	return n
}

func (m *CorsPolicy) Size() (n int) {
	var l int
	_ = l
	if m.Disabled {
		n += 2
	}
	if len(m.AllowOrigin) > 0 {
		for _, s := range m.AllowOrigin {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowOriginRegex) > 0 {
		for _, s := range m.AllowOriginRegex {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AllowMethods)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AllowHeaders)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExposeHeaders)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MaxAge)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowCredentials {
		n += 2
	}
	if m.MaximumAge != 0 {
		n += 1 + sovTypes(uint64(m.MaximumAge))
	}
	return n
}

func (m *PathMatcherType) Size() (n int) {
	var l int
	_ = l
	if m.PathMatch != nil {
		n += m.PathMatch.Size()
	}
	return n
}

func (m *PathMatcherType_Prefix) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PathMatcherType_Path) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PathMatcherType_Regex) Size() (n int) {
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderMatcherType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValueMatch != nil {
		n += m.ValueMatch.Size()
	}
	if m.InvertMatch {
		n += 2
	}
	return n
}

func (m *HeaderMatcherType_Exact) Size() (n int) {
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderMatcherType_Regex) Size() (n int) {
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderMatcherType_Presence) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *QueryParameterMatcherType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValueMatch != nil {
		n += m.ValueMatch.Size()
	}
	return n
}

func (m *QueryParameterMatcherType_Exact) Size() (n int) {
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *QueryParameterMatcherType_Regex) Size() (n int) {
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteMatch) Size() (n int) {
	var l int
	_ = l
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != 0 {
		n += 1 + sovTypes(uint64(m.HttpMethod))
	}
	return n
}

func (m *WafRefType) Size() (n int) {
	var l int
	_ = l
	if len(m.Waf) > 0 {
		for _, e := range m.Waf {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *WafRulesRefType) Size() (n int) {
	var l int
	_ = l
	if len(m.WafRules) > 0 {
		for _, e := range m.WafRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *WafType) Size() (n int) {
	var l int
	_ = l
	if m.RefType != nil {
		n += m.RefType.Size()
	}
	return n
}

func (m *WafType_Waf) Size() (n int) {
	var l int
	_ = l
	if m.Waf != nil {
		l = m.Waf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafType_WafRules) Size() (n int) {
	var l int
	_ = l
	if m.WafRules != nil {
		l = m.WafRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AppRoleAuthInfoType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoleId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SecretId != nil {
		l = m.SecretId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VaultAuthInfoType) Size() (n int) {
	var l int
	_ = l
	if m.AuthParams != nil {
		n += m.AuthParams.Size()
	}
	return n
}

func (m *VaultAuthInfoType_AppRoleAuth) Size() (n int) {
	var l int
	_ = l
	if m.AppRoleAuth != nil {
		l = m.AppRoleAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultAuthInfoType_Token) Size() (n int) {
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RestAuthInfoType) Size() (n int) {
	var l int
	_ = l
	if m.AuthParams != nil {
		n += m.AuthParams.Size()
	}
	return n
}

func (m *RestAuthInfoType_BasicAuth) Size() (n int) {
	var l int
	_ = l
	if m.BasicAuth != nil {
		l = m.BasicAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RestAuthInfoType_HeadersAuth) Size() (n int) {
	var l int
	_ = l
	if m.HeadersAuth != nil {
		l = m.HeadersAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RestAuthInfoType_QueryParamsAuth) Size() (n int) {
	var l int
	_ = l
	if m.QueryParamsAuth != nil {
		l = m.QueryParamsAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HostAccessInfoType) Size() (n int) {
	var l int
	_ = l
	if m.Scheme != 0 {
		n += 1 + sovTypes(uint64(m.Scheme))
	}
	l = len(m.ServerEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TlsConfig != nil {
		l = m.TlsConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AuthParams != nil {
		n += m.AuthParams.Size()
	}
	return n
}

func (m *HostAccessInfoType_RestAuthInfo) Size() (n int) {
	var l int
	_ = l
	if m.RestAuthInfo != nil {
		l = m.RestAuthInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HostAccessInfoType_VaultAuthInfo) Size() (n int) {
	var l int
	_ = l
	if m.VaultAuthInfo != nil {
		l = m.VaultAuthInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultAccessInfoType) Size() (n int) {
	var l int
	_ = l
	l = len(m.VaultAddr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VaultCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AuthnChoice != nil {
		n += m.AuthnChoice.Size()
	}
	return n
}

func (m *VaultAccessInfoType_AppRoleAuth) Size() (n int) {
	var l int
	_ = l
	if m.AppRoleAuth != nil {
		l = m.AppRoleAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultAccessInfoType_Token) Size() (n int) {
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultSecretType) Size() (n int) {
	var l int
	_ = l
	if m.AccessChoice != nil {
		n += m.AccessChoice.Size()
	}
	l = len(m.SecretPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecretSubPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecretVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VaultSecretType_VaultAccessInfo) Size() (n int) {
	var l int
	_ = l
	if m.VaultAccessInfo != nil {
		l = m.VaultAccessInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultSecretType_ProviderName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProviderName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *VolterraSecretType) Size() (n int) {
	var l int
	_ = l
	if m.SecretTypeChoice != nil {
		n += m.SecretTypeChoice.Size()
	}
	return n
}

func (m *VolterraSecretType_BlindfoldSecretInfo) Size() (n int) {
	var l int
	_ = l
	if m.BlindfoldSecretInfo != nil {
		l = m.BlindfoldSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VolterraSecretType_VaultSecretInfo) Size() (n int) {
	var l int
	_ = l
	if m.VaultSecretInfo != nil {
		l = m.VaultSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortValueType) Size() (n int) {
	var l int
	_ = l
	if m.PortValueTypeChoice != nil {
		n += m.PortValueTypeChoice.Size()
	}
	return n
}

func (m *PortValueType_All) Size() (n int) {
	var l int
	_ = l
	if m.All != nil {
		l = m.All.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortValueType_UserDefined) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.UserDefined))
	return n
}
func (m *PortValueType_Dns) Size() (n int) {
	var l int
	_ = l
	if m.Dns != nil {
		l = m.Dns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualNetworkReferenceType) Size() (n int) {
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VirtualNetworkSelectorType) Size() (n int) {
	var l int
	_ = l
	if m.VnTypeChoice != nil {
		n += m.VnTypeChoice.Size()
	}
	return n
}

func (m *VirtualNetworkSelectorType_SiteLocal) Size() (n int) {
	var l int
	_ = l
	if m.SiteLocal != nil {
		l = m.SiteLocal.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualNetworkSelectorType_SiteLocalInside) Size() (n int) {
	var l int
	_ = l
	if m.SiteLocalInside != nil {
		l = m.SiteLocalInside.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualNetworkSelectorType_Public) Size() (n int) {
	var l int
	_ = l
	if m.Public != nil {
		l = m.Public.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RetryBackOff) Size() (n int) {
	var l int
	_ = l
	if m.BaseInterval != 0 {
		n += 1 + sovTypes(uint64(m.BaseInterval))
	}
	if m.MaxInterval != 0 {
		n += 1 + sovTypes(uint64(m.MaxInterval))
	}
	return n
}

func (m *RetryPolicyType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RetryOn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NumRetries != 0 {
		n += 1 + sovTypes(uint64(m.NumRetries))
	}
	if m.PerTryTimeout != 0 {
		n += 1 + sovTypes(uint64(m.PerTryTimeout))
	}
	if len(m.RetriableStatusCodes) > 0 {
		l = 0
		for _, e := range m.RetriableStatusCodes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.BackOff != nil {
		l = m.BackOff.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MetricValue) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 9
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NextHopType) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.NexthopAddress != nil {
		l = m.NexthopAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Interface) > 0 {
		for _, e := range m.Interface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *StaticRouteType) Size() (n int) {
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		l = 0
		for _, e := range m.Attrs {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Nexthop != nil {
		l = m.Nexthop.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ForwardProxyConfigType) Size() (n int) {
	var l int
	_ = l
	if len(m.WhiteListedPrefixes) > 0 {
		for _, s := range m.WhiteListedPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.WhiteListedPorts) > 0 {
		l = 0
		for _, e := range m.WhiteListedPorts {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.MaxConnectAttempts != 0 {
		n += 1 + sovTypes(uint64(m.MaxConnectAttempts))
	}
	if m.ConnectionTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionTimeout))
	}
	if m.TlsInterceptionChoice != nil {
		n += m.TlsInterceptionChoice.Size()
	}
	return n
}

func (m *ForwardProxyConfigType_NoInterception) Size() (n int) {
	var l int
	_ = l
	if m.NoInterception != nil {
		l = m.NoInterception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ForwardProxyConfigType_TlsIntercept) Size() (n int) {
	var l int
	_ = l
	if m.TlsIntercept != nil {
		l = m.TlsIntercept.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HostIdentifier) Size() (n int) {
	var l int
	_ = l
	if m.HostnameOrIp != nil {
		n += m.HostnameOrIp.Size()
	}
	return n
}

func (m *HostIdentifier_Ip) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HostIdentifier_Hostname) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceIdentifier) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *InterfaceIdentifier_AnyIntf) Size() (n int) {
	var l int
	_ = l
	if m.AnyIntf != nil {
		l = m.AnyIntf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InterfaceIdentifier_Intf) Size() (n int) {
	var l int
	_ = l
	l = len(m.Intf)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceOrNetwork) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *InterfaceOrNetwork_Intf) Size() (n int) {
	var l int
	_ = l
	l = len(m.Intf)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceOrNetwork_Pod) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pod)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceOrNetwork_VnType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.VnType))
	return n
}
func (m *InterfaceOrNetwork_Vn) Size() (n int) {
	var l int
	_ = l
	l = len(m.Vn)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *ObjectRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ObjectRefType{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelSelectorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelSelectorType{`,
		`Expressions:` + fmt.Sprintf("%v", this.Expressions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelMatcherType{`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConditionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConditionType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`LastUpdateTime:` + strings.Replace(fmt.Sprintf("%v", this.LastUpdateTime), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusType{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InitializerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InitializerType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InitializersType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InitializersType{`,
		`Pending:` + strings.Replace(fmt.Sprintf("%v", this.Pending), "InitializerType", "InitializerType", 1) + `,`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "StatusType", "StatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusMetaType{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreatorClass:` + fmt.Sprintf("%v", this.CreatorClass) + `,`,
		`CreatorId:` + fmt.Sprintf("%v", this.CreatorId) + `,`,
		`StatusId:` + fmt.Sprintf("%v", this.StatusId) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`Publish:` + fmt.Sprintf("%v", this.Publish) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListMetaType{`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectGetMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectGetMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectCreateMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectCreateMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectReplaceMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectReplaceMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ViewRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ViewRefType{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KubeRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KubeRefType{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SystemObjectMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SystemObjectMetaType{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`DeletionTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.DeletionTimestamp), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`Initializers:` + strings.Replace(fmt.Sprintf("%v", this.Initializers), "InitializersType", "InitializersType", 1) + `,`,
		`Finalizers:` + fmt.Sprintf("%v", this.Finalizers) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`CreatorClass:` + fmt.Sprintf("%v", this.CreatorClass) + `,`,
		`CreatorId:` + fmt.Sprintf("%v", this.CreatorId) + `,`,
		`TraceInfo:` + fmt.Sprintf("%v", this.TraceInfo) + `,`,
		`ObjectIndex:` + fmt.Sprintf("%v", this.ObjectIndex) + `,`,
		`Namespace:` + strings.Replace(fmt.Sprintf("%v", this.Namespace), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`CreatorCookie:` + fmt.Sprintf("%v", this.CreatorCookie) + `,`,
		`OwnerView:` + strings.Replace(fmt.Sprintf("%v", this.OwnerView), "ViewRefType", "ViewRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SystemObjectGetMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SystemObjectGetMetaType{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`DeletionTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.DeletionTimestamp), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`Initializers:` + strings.Replace(fmt.Sprintf("%v", this.Initializers), "InitializersType", "InitializersType", 1) + `,`,
		`Finalizers:` + fmt.Sprintf("%v", this.Finalizers) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`CreatorClass:` + fmt.Sprintf("%v", this.CreatorClass) + `,`,
		`CreatorId:` + fmt.Sprintf("%v", this.CreatorId) + `,`,
		`ObjectIndex:` + fmt.Sprintf("%v", this.ObjectIndex) + `,`,
		`OwnerView:` + strings.Replace(fmt.Sprintf("%v", this.OwnerView), "ViewRefType", "ViewRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthnTypeBasicAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthnTypeBasicAuth{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthnTypeHeaders) String() string {
	if this == nil {
		return "nil"
	}
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]*SecretType{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%v: %v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	s := strings.Join([]string{`&AuthnTypeHeaders{`,
		`Headers:` + mapStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthnTypeQueryParams) String() string {
	if this == nil {
		return "nil"
	}
	keysForQueryParams := make([]string, 0, len(this.QueryParams))
	for k, _ := range this.QueryParams {
		keysForQueryParams = append(keysForQueryParams, k)
	}
	sortkeys.Strings(keysForQueryParams)
	mapStringForQueryParams := "map[string]*SecretType{"
	for _, k := range keysForQueryParams {
		mapStringForQueryParams += fmt.Sprintf("%v: %v,", k, this.QueryParams[k])
	}
	mapStringForQueryParams += "}"
	s := strings.Join([]string{`&AuthnTypeQueryParams{`,
		`QueryParams:` + mapStringForQueryParams + `,`,
		`}`,
	}, "")
	return s
}
func (this *BlindfoldSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BlindfoldSecretInfoType{`,
		`DecryptionProvider:` + fmt.Sprintf("%v", this.DecryptionProvider) + `,`,
		`StoreProvider:` + fmt.Sprintf("%v", this.StoreProvider) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretInfoType{`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`SecretEncoding:` + fmt.Sprintf("%v", this.SecretEncoding) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClearSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClearSecretInfoType{`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WingmanSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WingmanSecretInfoType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkRefType{`,
		`Ref:` + strings.Replace(fmt.Sprintf("%v", this.Ref), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteRefType{`,
		`Ref:` + strings.Replace(fmt.Sprintf("%v", this.Ref), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`NetworkType:` + fmt.Sprintf("%v", this.NetworkType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpPrefixSetRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpPrefixSetRefType{`,
		`Ref:` + strings.Replace(fmt.Sprintf("%v", this.Ref), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VSiteRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VSiteRefType{`,
		`Ref:` + strings.Replace(fmt.Sprintf("%v", this.Ref), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`NetworkType:` + fmt.Sprintf("%v", this.NetworkType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicerRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PolicerRefType{`,
		`Ref:` + strings.Replace(fmt.Sprintf("%v", this.Ref), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolPolicerRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolPolicerRefType{`,
		`Ref:` + strings.Replace(fmt.Sprintf("%v", this.Ref), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector{`,
		`RefOrSelector:` + fmt.Sprintf("%v", this.RefOrSelector) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector_VirtualNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector_VirtualNetwork{`,
		`VirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.VirtualNetwork), "NetworkRefType", "NetworkRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector_Site) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector_Site{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "SiteRefType", "SiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector_VirtualSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector_VirtualSite{`,
		`VirtualSite:` + strings.Replace(fmt.Sprintf("%v", this.VirtualSite), "VSiteRefType", "VSiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteVirtualSiteRefSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteVirtualSiteRefSelector{`,
		`RefOrSelector:` + fmt.Sprintf("%v", this.RefOrSelector) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteVirtualSiteRefSelector_Site) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteVirtualSiteRefSelector_Site{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "SiteRefType", "SiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteVirtualSiteRefSelector_VirtualSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteVirtualSiteRefSelector_VirtualSite{`,
		`VirtualSite:` + strings.Replace(fmt.Sprintf("%v", this.VirtualSite), "VSiteRefType", "VSiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderManipulationOptionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderManipulationOptionType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Append:` + fmt.Sprintf("%v", this.Append) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsValidationParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsValidationParamsType{`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`SkipHostnameVerification:` + fmt.Sprintf("%v", this.SkipHostnameVerification) + `,`,
		`VerifySubjectAltNames:` + fmt.Sprintf("%v", this.VerifySubjectAltNames) + `,`,
		`UseVolterraTrustedCaUrl:` + fmt.Sprintf("%v", this.UseVolterraTrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsCertificateType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsCertificateType{`,
		`CertificateUrl:` + fmt.Sprintf("%v", this.CertificateUrl) + `,`,
		`PrivateKey:` + strings.Replace(fmt.Sprintf("%v", this.PrivateKey), "SecretType", "SecretType", 1) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsParamsType{`,
		`MinimumProtocolVersion:` + fmt.Sprintf("%v", this.MinimumProtocolVersion) + `,`,
		`MaximumProtocolVersion:` + fmt.Sprintf("%v", this.MaximumProtocolVersion) + `,`,
		`CipherSuites:` + fmt.Sprintf("%v", this.CipherSuites) + `,`,
		`TlsCertificates:` + strings.Replace(fmt.Sprintf("%v", this.TlsCertificates), "TlsCertificateType", "TlsCertificateType", 1) + `,`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`ValidationParams:` + strings.Replace(fmt.Sprintf("%v", this.ValidationParams), "TlsValidationParamsType", "TlsValidationParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpstreamTlsParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpstreamTlsParamsType{`,
		`CommonParams:` + strings.Replace(fmt.Sprintf("%v", this.CommonParams), "TlsParamsType", "TlsParamsType", 1) + `,`,
		`SniChoice:` + fmt.Sprintf("%v", this.SniChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpstreamTlsParamsType_Sni) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpstreamTlsParamsType_Sni{`,
		`Sni:` + fmt.Sprintf("%v", this.Sni) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpstreamTlsParamsType_UseHostHeaderAsSni) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpstreamTlsParamsType_UseHostHeaderAsSni{`,
		`UseHostHeaderAsSni:` + strings.Replace(fmt.Sprintf("%v", this.UseHostHeaderAsSni), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpstreamTlsParamsType_DisableSni) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpstreamTlsParamsType_DisableSni{`,
		`DisableSni:` + strings.Replace(fmt.Sprintf("%v", this.DisableSni), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DownstreamTlsParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DownstreamTlsParamsType{`,
		`CommonParams:` + strings.Replace(fmt.Sprintf("%v", this.CommonParams), "TlsParamsType", "TlsParamsType", 1) + `,`,
		`RequireClientCertificate:` + fmt.Sprintf("%v", this.RequireClientCertificate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType_ExactValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType_ExactValue{`,
		`ExactValue:` + fmt.Sprintf("%v", this.ExactValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType_SuffixValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType_SuffixValue{`,
		`SuffixValue:` + fmt.Sprintf("%v", this.SuffixValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType_RegexValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType_RegexValue{`,
		`RegexValue:` + fmt.Sprintf("%v", this.RegexValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L4DestType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L4DestType{`,
		`Prefixes:` + fmt.Sprintf("%v", this.Prefixes) + `,`,
		`PortRanges:` + fmt.Sprintf("%v", this.PortRanges) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionRule{`,
		`DomainMatch:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatch), "DomainType", "DomainType", 1) + `,`,
		`EnableDisableChoice:` + fmt.Sprintf("%v", this.EnableDisableChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionRule_DisableInterception) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionRule_DisableInterception{`,
		`DisableInterception:` + strings.Replace(fmt.Sprintf("%v", this.DisableInterception), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionRule_EnableInterception) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionRule_EnableInterception{`,
		`EnableInterception:` + strings.Replace(fmt.Sprintf("%v", this.EnableInterception), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionPolicy{`,
		`InterceptionRules:` + strings.Replace(fmt.Sprintf("%v", this.InterceptionRules), "TlsInterceptionRule", "TlsInterceptionRule", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType{`,
		`InterceptionPolicyChoice:` + fmt.Sprintf("%v", this.InterceptionPolicyChoice) + `,`,
		`SigningCertChoice:` + fmt.Sprintf("%v", this.SigningCertChoice) + `,`,
		`TrustedCaChoice:` + fmt.Sprintf("%v", this.TrustedCaChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_Policy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_Policy{`,
		`Policy:` + strings.Replace(fmt.Sprintf("%v", this.Policy), "TlsInterceptionPolicy", "TlsInterceptionPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_CustomCertificate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_CustomCertificate{`,
		`CustomCertificate:` + strings.Replace(fmt.Sprintf("%v", this.CustomCertificate), "TlsCertificateType", "TlsCertificateType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_VolterraCertificate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_VolterraCertificate{`,
		`VolterraCertificate:` + strings.Replace(fmt.Sprintf("%v", this.VolterraCertificate), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_TrustedCaUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_TrustedCaUrl{`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_VolterraTrustedCa) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_VolterraTrustedCa{`,
		`VolterraTrustedCa:` + strings.Replace(fmt.Sprintf("%v", this.VolterraTrustedCa), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_EnableForAllDomains) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_EnableForAllDomains{`,
		`EnableForAllDomains:` + strings.Replace(fmt.Sprintf("%v", this.EnableForAllDomains), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FractionalPercent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FractionalPercent{`,
		`Numerator:` + fmt.Sprintf("%v", this.Numerator) + `,`,
		`Denominator:` + fmt.Sprintf("%v", this.Denominator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BufferConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BufferConfigType{`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`MaxRequestBytes:` + fmt.Sprintf("%v", this.MaxRequestBytes) + `,`,
		`MaxRequestTime:` + fmt.Sprintf("%v", this.MaxRequestTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CorsPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CorsPolicy{`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`AllowOrigin:` + fmt.Sprintf("%v", this.AllowOrigin) + `,`,
		`AllowOriginRegex:` + fmt.Sprintf("%v", this.AllowOriginRegex) + `,`,
		`AllowMethods:` + fmt.Sprintf("%v", this.AllowMethods) + `,`,
		`AllowHeaders:` + fmt.Sprintf("%v", this.AllowHeaders) + `,`,
		`ExposeHeaders:` + fmt.Sprintf("%v", this.ExposeHeaders) + `,`,
		`MaxAge:` + fmt.Sprintf("%v", this.MaxAge) + `,`,
		`AllowCredentials:` + fmt.Sprintf("%v", this.AllowCredentials) + `,`,
		`MaximumAge:` + fmt.Sprintf("%v", this.MaximumAge) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType{`,
		`PathMatch:` + fmt.Sprintf("%v", this.PathMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType_Prefix{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType_Path) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType_Path{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ValueMatch:` + fmt.Sprintf("%v", this.ValueMatch) + `,`,
		`InvertMatch:` + fmt.Sprintf("%v", this.InvertMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Exact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Exact{`,
		`Exact:` + fmt.Sprintf("%v", this.Exact) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ValueMatch:` + fmt.Sprintf("%v", this.ValueMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Exact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Exact{`,
		`Exact:` + fmt.Sprintf("%v", this.Exact) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteMatch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteMatch{`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "PathMatcherType", 1) + `,`,
		`Headers:` + strings.Replace(fmt.Sprintf("%v", this.Headers), "HeaderMatcherType", "HeaderMatcherType", 1) + `,`,
		`QueryParams:` + strings.Replace(fmt.Sprintf("%v", this.QueryParams), "QueryParameterMatcherType", "QueryParameterMatcherType", 1) + `,`,
		`HttpMethod:` + fmt.Sprintf("%v", this.HttpMethod) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafRefType{`,
		`Waf:` + strings.Replace(fmt.Sprintf("%v", this.Waf), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafRulesRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafRulesRefType{`,
		`WafRules:` + strings.Replace(fmt.Sprintf("%v", this.WafRules), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType{`,
		`RefType:` + fmt.Sprintf("%v", this.RefType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType_Waf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType_Waf{`,
		`Waf:` + strings.Replace(fmt.Sprintf("%v", this.Waf), "WafRefType", "WafRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType_WafRules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType_WafRules{`,
		`WafRules:` + strings.Replace(fmt.Sprintf("%v", this.WafRules), "WafRulesRefType", "WafRulesRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppRoleAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppRoleAuthInfoType{`,
		`RoleId:` + fmt.Sprintf("%v", this.RoleId) + `,`,
		`SecretId:` + strings.Replace(fmt.Sprintf("%v", this.SecretId), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAuthInfoType{`,
		`AuthParams:` + fmt.Sprintf("%v", this.AuthParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAuthInfoType_AppRoleAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAuthInfoType_AppRoleAuth{`,
		`AppRoleAuth:` + strings.Replace(fmt.Sprintf("%v", this.AppRoleAuth), "AppRoleAuthInfoType", "AppRoleAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAuthInfoType_Token) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAuthInfoType_Token{`,
		`Token:` + strings.Replace(fmt.Sprintf("%v", this.Token), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType{`,
		`AuthParams:` + fmt.Sprintf("%v", this.AuthParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType_BasicAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType_BasicAuth{`,
		`BasicAuth:` + strings.Replace(fmt.Sprintf("%v", this.BasicAuth), "AuthnTypeBasicAuth", "AuthnTypeBasicAuth", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType_HeadersAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType_HeadersAuth{`,
		`HeadersAuth:` + strings.Replace(fmt.Sprintf("%v", this.HeadersAuth), "AuthnTypeHeaders", "AuthnTypeHeaders", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType_QueryParamsAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType_QueryParamsAuth{`,
		`QueryParamsAuth:` + strings.Replace(fmt.Sprintf("%v", this.QueryParamsAuth), "AuthnTypeQueryParams", "AuthnTypeQueryParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostAccessInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostAccessInfoType{`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`ServerEndpoint:` + fmt.Sprintf("%v", this.ServerEndpoint) + `,`,
		`TlsConfig:` + strings.Replace(fmt.Sprintf("%v", this.TlsConfig), "UpstreamTlsParamsType", "UpstreamTlsParamsType", 1) + `,`,
		`AuthParams:` + fmt.Sprintf("%v", this.AuthParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostAccessInfoType_RestAuthInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostAccessInfoType_RestAuthInfo{`,
		`RestAuthInfo:` + strings.Replace(fmt.Sprintf("%v", this.RestAuthInfo), "RestAuthInfoType", "RestAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostAccessInfoType_VaultAuthInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostAccessInfoType_VaultAuthInfo{`,
		`VaultAuthInfo:` + strings.Replace(fmt.Sprintf("%v", this.VaultAuthInfo), "VaultAuthInfoType", "VaultAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAccessInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAccessInfoType{`,
		`VaultAddr:` + fmt.Sprintf("%v", this.VaultAddr) + `,`,
		`VaultCaUrl:` + fmt.Sprintf("%v", this.VaultCaUrl) + `,`,
		`AuthnChoice:` + fmt.Sprintf("%v", this.AuthnChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAccessInfoType_AppRoleAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAccessInfoType_AppRoleAuth{`,
		`AppRoleAuth:` + strings.Replace(fmt.Sprintf("%v", this.AppRoleAuth), "AppRoleAuthInfoType", "AppRoleAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAccessInfoType_Token) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAccessInfoType_Token{`,
		`Token:` + strings.Replace(fmt.Sprintf("%v", this.Token), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretType{`,
		`AccessChoice:` + fmt.Sprintf("%v", this.AccessChoice) + `,`,
		`SecretPath:` + fmt.Sprintf("%v", this.SecretPath) + `,`,
		`SecretSubPath:` + fmt.Sprintf("%v", this.SecretSubPath) + `,`,
		`SecretVersion:` + fmt.Sprintf("%v", this.SecretVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretType_VaultAccessInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretType_VaultAccessInfo{`,
		`VaultAccessInfo:` + strings.Replace(fmt.Sprintf("%v", this.VaultAccessInfo), "VaultAccessInfoType", "VaultAccessInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretType_ProviderName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretType_ProviderName{`,
		`ProviderName:` + fmt.Sprintf("%v", this.ProviderName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSecretType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSecretType{`,
		`SecretTypeChoice:` + fmt.Sprintf("%v", this.SecretTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSecretType_BlindfoldSecretInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSecretType_BlindfoldSecretInfo{`,
		`BlindfoldSecretInfo:` + strings.Replace(fmt.Sprintf("%v", this.BlindfoldSecretInfo), "BlindfoldSecretInfoType", "BlindfoldSecretInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSecretType_VaultSecretInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSecretType_VaultSecretInfo{`,
		`VaultSecretInfo:` + strings.Replace(fmt.Sprintf("%v", this.VaultSecretInfo), "VaultAccessInfoType", "VaultAccessInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType{`,
		`PortValueTypeChoice:` + fmt.Sprintf("%v", this.PortValueTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType_All) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType_All{`,
		`All:` + strings.Replace(fmt.Sprintf("%v", this.All), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType_UserDefined) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType_UserDefined{`,
		`UserDefined:` + fmt.Sprintf("%v", this.UserDefined) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType_Dns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType_Dns{`,
		`Dns:` + strings.Replace(fmt.Sprintf("%v", this.Dns), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkReferenceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkReferenceType{`,
		`Refs:` + strings.Replace(fmt.Sprintf("%v", this.Refs), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType{`,
		`VnTypeChoice:` + fmt.Sprintf("%v", this.VnTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType_SiteLocal) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType_SiteLocal{`,
		`SiteLocal:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocal), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType_SiteLocalInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType_SiteLocalInside{`,
		`SiteLocalInside:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInside), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType_Public) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType_Public{`,
		`Public:` + strings.Replace(fmt.Sprintf("%v", this.Public), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RetryBackOff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RetryBackOff{`,
		`BaseInterval:` + fmt.Sprintf("%v", this.BaseInterval) + `,`,
		`MaxInterval:` + fmt.Sprintf("%v", this.MaxInterval) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RetryPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RetryPolicyType{`,
		`RetryOn:` + fmt.Sprintf("%v", this.RetryOn) + `,`,
		`NumRetries:` + fmt.Sprintf("%v", this.NumRetries) + `,`,
		`PerTryTimeout:` + fmt.Sprintf("%v", this.PerTryTimeout) + `,`,
		`RetriableStatusCodes:` + fmt.Sprintf("%v", this.RetriableStatusCodes) + `,`,
		`BackOff:` + strings.Replace(fmt.Sprintf("%v", this.BackOff), "RetryBackOff", "RetryBackOff", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricValue{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NextHopType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NextHopType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NexthopAddress:` + strings.Replace(fmt.Sprintf("%v", this.NexthopAddress), "IpAddressType", "IpAddressType", 1) + `,`,
		`Interface:` + strings.Replace(fmt.Sprintf("%v", this.Interface), "ObjectRefType", "ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticRouteType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&StaticRouteType{`,
		`Attrs:` + fmt.Sprintf("%v", this.Attrs) + `,`,
		`Subnets:` + strings.Replace(fmt.Sprintf("%v", this.Subnets), "IpSubnetType", "IpSubnetType", 1) + `,`,
		`Nexthop:` + strings.Replace(fmt.Sprintf("%v", this.Nexthop), "NextHopType", "NextHopType", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForwardProxyConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForwardProxyConfigType{`,
		`WhiteListedPrefixes:` + fmt.Sprintf("%v", this.WhiteListedPrefixes) + `,`,
		`WhiteListedPorts:` + fmt.Sprintf("%v", this.WhiteListedPorts) + `,`,
		`MaxConnectAttempts:` + fmt.Sprintf("%v", this.MaxConnectAttempts) + `,`,
		`ConnectionTimeout:` + fmt.Sprintf("%v", this.ConnectionTimeout) + `,`,
		`TlsInterceptionChoice:` + fmt.Sprintf("%v", this.TlsInterceptionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForwardProxyConfigType_NoInterception) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForwardProxyConfigType_NoInterception{`,
		`NoInterception:` + strings.Replace(fmt.Sprintf("%v", this.NoInterception), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForwardProxyConfigType_TlsIntercept) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForwardProxyConfigType_TlsIntercept{`,
		`TlsIntercept:` + strings.Replace(fmt.Sprintf("%v", this.TlsIntercept), "TlsInterceptionType", "TlsInterceptionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostIdentifier) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostIdentifier{`,
		`HostnameOrIp:` + fmt.Sprintf("%v", this.HostnameOrIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostIdentifier_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostIdentifier_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostIdentifier_Hostname) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostIdentifier_Hostname{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceIdentifier) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceIdentifier{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceIdentifier_AnyIntf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceIdentifier_AnyIntf{`,
		`AnyIntf:` + strings.Replace(fmt.Sprintf("%v", this.AnyIntf), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceIdentifier_Intf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceIdentifier_Intf{`,
		`Intf:` + fmt.Sprintf("%v", this.Intf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_Intf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_Intf{`,
		`Intf:` + fmt.Sprintf("%v", this.Intf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_Pod) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_Pod{`,
		`Pod:` + fmt.Sprintf("%v", this.Pod) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_VnType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_VnType{`,
		`VnType:` + fmt.Sprintf("%v", this.VnType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_Vn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_Vn{`,
		`Vn:` + fmt.Sprintf("%v", this.Vn) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSelectorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSelectorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSelectorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expressions = append(m.Expressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdateTime == nil {
				m.LastUpdateTime = &google_protobuf3.Timestamp{}
			}
			if err := m.LastUpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitializerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitializerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitializerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitializersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitializersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitializersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pending", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pending = append(m.Pending, &InitializerType{})
			if err := m.Pending[len(m.Pending)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &StatusType{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &google_protobuf3.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			m.Publish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Publish |= (StatusPublishType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectGetMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectGetMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectGetMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectCreateMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectCreateMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectCreateMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectReplaceMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectReplaceMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectReplaceMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubeRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubeRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubeRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemObjectMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemObjectMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemObjectMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &google_protobuf3.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionTimestamp == nil {
				m.DeletionTimestamp = &google_protobuf3.Timestamp{}
			}
			if err := m.DeletionTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &google_protobuf3.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initializers == nil {
				m.Initializers = &InitializersType{}
			}
			if err := m.Initializers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectIndex", wireType)
			}
			m.ObjectIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = append(m.Namespace, &ObjectRefType{})
			if err := m.Namespace[len(m.Namespace)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerView == nil {
				m.OwnerView = &ViewRefType{}
			}
			if err := m.OwnerView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemObjectGetMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemObjectGetMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemObjectGetMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &google_protobuf3.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionTimestamp == nil {
				m.DeletionTimestamp = &google_protobuf3.Timestamp{}
			}
			if err := m.DeletionTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &google_protobuf3.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initializers == nil {
				m.Initializers = &InitializersType{}
			}
			if err := m.Initializers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectIndex", wireType)
			}
			m.ObjectIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerView == nil {
				m.OwnerView = &ViewRefType{}
			}
			if err := m.OwnerView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnTypeBasicAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnTypeBasicAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnTypeBasicAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnTypeHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnTypeHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnTypeHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]*SecretType)
			}
			var mapkey string
			var mapvalue *SecretType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SecretType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnTypeQueryParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnTypeQueryParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnTypeQueryParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryParams == nil {
				m.QueryParams = make(map[string]*SecretType)
			}
			var mapkey string
			var mapvalue *SecretType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SecretType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.QueryParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlindfoldSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlindfoldSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlindfoldSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptionProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecryptionProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretEncoding", wireType)
			}
			m.SecretEncoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretEncoding |= (SecretEncodingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WingmanSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WingmanSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WingmanSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindfoldSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlindfoldSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_BlindfoldSecretInfo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_VaultSecretInfo{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClearSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_ClearSecretInfo{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingmanSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WingmanSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_WingmanSecretInfo{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretEncodingType", wireType)
			}
			m.SecretEncodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretEncodingType |= (SecretEncodingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindfoldSecretInfoInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlindfoldSecretInfoInternal == nil {
				m.BlindfoldSecretInfoInternal = &BlindfoldSecretInfoType{}
			}
			if err := m.BlindfoldSecretInfoInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			m.NetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkType |= (VirtualNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpPrefixSetRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpPrefixSetRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpPrefixSetRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSiteRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSiteRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSiteRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			m.NetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkType |= (VirtualNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolPolicerRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolPolicerRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolPolicerRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSiteRefSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSiteRefSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSiteRefSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &NetworkSiteRefSelector_VirtualNetwork{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &NetworkSiteRefSelector_Site{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VSiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &NetworkSiteRefSelector_VirtualSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteVirtualSiteRefSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteVirtualSiteRefSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteVirtualSiteRefSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &SiteVirtualSiteRefSelector_Site{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VSiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &SiteVirtualSiteRefSelector_VirtualSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderManipulationOptionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderManipulationOptionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderManipulationOptionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Append", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Append = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsValidationParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsValidationParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsValidationParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipHostnameVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipHostnameVerification = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySubjectAltNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifySubjectAltNames = append(m.VerifySubjectAltNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseVolterraTrustedCaUrl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseVolterraTrustedCaUrl = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsCertificateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsCertificateType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsCertificateType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivateKey == nil {
				m.PrivateKey = &SecretType{}
			}
			if err := m.PrivateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumProtocolVersion", wireType)
			}
			m.MinimumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumProtocolVersion |= (TlsProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumProtocolVersion", wireType)
			}
			m.MaximumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumProtocolVersion |= (TlsProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherSuites = append(m.CipherSuites, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertificates = append(m.TlsCertificates, &TlsCertificateType{})
			if err := m.TlsCertificates[len(m.TlsCertificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidationParams == nil {
				m.ValidationParams = &TlsValidationParamsType{}
			}
			if err := m.ValidationParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamTlsParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamTlsParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamTlsParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonParams == nil {
				m.CommonParams = &TlsParamsType{}
			}
			if err := m.CommonParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sni", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SniChoice = &UpstreamTlsParamsType_Sni{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHostHeaderAsSni", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SniChoice = &UpstreamTlsParamsType_UseHostHeaderAsSni{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableSni", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SniChoice = &UpstreamTlsParamsType_DisableSni{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownstreamTlsParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownstreamTlsParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownstreamTlsParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonParams == nil {
				m.CommonParams = &TlsParamsType{}
			}
			if err := m.CommonParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireClientCertificate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireClientCertificate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &DomainType_ExactValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &DomainType_SuffixValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &DomainType_RegexValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4DestType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4DestType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4DestType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsInterceptionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsInterceptionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsInterceptionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatch == nil {
				m.DomainMatch = &DomainType{}
			}
			if err := m.DomainMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableInterception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EnableDisableChoice = &TlsInterceptionRule_DisableInterception{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableInterception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EnableDisableChoice = &TlsInterceptionRule_EnableInterception{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsInterceptionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsInterceptionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsInterceptionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterceptionRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterceptionRules = append(m.InterceptionRules, &TlsInterceptionRule{})
			if err := m.InterceptionRules[len(m.InterceptionRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsInterceptionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsInterceptionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsInterceptionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsInterceptionPolicy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterceptionPolicyChoice = &TlsInterceptionType_Policy{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsCertificateType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SigningCertChoice = &TlsInterceptionType_CustomCertificate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SigningCertChoice = &TlsInterceptionType_VolterraCertificate{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaChoice = &TlsInterceptionType_TrustedCaUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraTrustedCa", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrustedCaChoice = &TlsInterceptionType_VolterraTrustedCa{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableForAllDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterceptionPolicyChoice = &TlsInterceptionType_EnableForAllDomains{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FractionalPercent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FractionalPercent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FractionalPercent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerator", wireType)
			}
			m.Numerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numerator |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominator", wireType)
			}
			m.Denominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Denominator |= (DenominatorType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestBytes", wireType)
			}
			m.MaxRequestBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestBytes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestTime", wireType)
			}
			m.MaxRequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOriginRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOriginRegex = append(m.AllowOriginRegex, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowMethods = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExposeHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxAge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCredentials = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumAge", wireType)
			}
			m.MaximumAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumAge |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathMatch = &PathMatcherType_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathMatch = &PathMatcherType_Path{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathMatch = &PathMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &HeaderMatcherType_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &HeaderMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ValueMatch = &HeaderMatcherType_Presence{b}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParameterMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParameterMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParameterMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &QueryParameterMatcherType_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &QueryParameterMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			m.HttpMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpMethod |= (HttpMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waf = append(m.Waf, &ObjectRefType{})
			if err := m.Waf[len(m.Waf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafRulesRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafRulesRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafRulesRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WafRules = append(m.WafRules, &ObjectRefType{})
			if err := m.WafRules[len(m.WafRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefType = &WafType_Waf{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafRulesRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefType = &WafType_WafRules{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppRoleAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppRoleAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppRoleAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretId == nil {
				m.SecretId = &SecretType{}
			}
			if err := m.SecretId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppRoleAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppRoleAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &VaultAuthInfoType_AppRoleAuth{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &VaultAuthInfoType_Token{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthnTypeBasicAuth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &RestAuthInfoType_BasicAuth{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadersAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthnTypeHeaders{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &RestAuthInfoType_HeadersAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParamsAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthnTypeQueryParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &RestAuthInfoType_QueryParamsAuth{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostAccessInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostAccessInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostAccessInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			m.Scheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scheme |= (URLSchemeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsConfig == nil {
				m.TlsConfig = &UpstreamTlsParamsType{}
			}
			if err := m.TlsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestAuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &HostAccessInfoType_RestAuthInfo{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &HostAccessInfoType_VaultAuthInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultAccessInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultAccessInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultAccessInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppRoleAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppRoleAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthnChoice = &VaultAccessInfoType_AppRoleAuth{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthnChoice = &VaultAccessInfoType_Token{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultSecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultSecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultSecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAccessInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultAccessInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AccessChoice = &VaultSecretType_VaultAccessInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessChoice = &VaultSecretType_ProviderName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretSubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretSubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolterraSecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolterraSecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolterraSecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindfoldSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlindfoldSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretTypeChoice = &VolterraSecretType_BlindfoldSecretInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultAccessInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretTypeChoice = &VolterraSecretType_VaultSecretInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortValueType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortValueType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortValueType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortValueTypeChoice = &PortValueType_All{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefined", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortValueTypeChoice = &PortValueType_UserDefined{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortValueTypeChoice = &PortValueType_Dns{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualNetworkReferenceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualNetworkReferenceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualNetworkReferenceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, &ObjectRefType{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualNetworkSelectorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualNetworkSelectorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualNetworkSelectorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VnTypeChoice = &VirtualNetworkSelectorType_SiteLocal{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VnTypeChoice = &VirtualNetworkSelectorType_SiteLocalInside{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VnTypeChoice = &VirtualNetworkSelectorType_Public{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryBackOff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryBackOff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryBackOff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseInterval", wireType)
			}
			m.BaseInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInterval", wireType)
			}
			m.MaxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryOn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRetries", wireType)
			}
			m.NumRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRetries |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
			}
			m.PerTryTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerTryTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RetriableStatusCodes = append(m.RetriableStatusCodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RetriableStatusCodes = append(m.RetriableStatusCodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RetriableStatusCodes", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackOff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackOff == nil {
				m.BackOff = &RetryBackOff{}
			}
			if err := m.BackOff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Timestamp = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextHopType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextHopType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextHopType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (NextHopTypes(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NexthopAddress == nil {
				m.NexthopAddress = &IpAddressType{}
			}
			if err := m.NexthopAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = append(m.Interface, &ObjectRefType{})
			if err := m.Interface[len(m.Interface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticRouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticRouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticRouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v RouteAttrType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (RouteAttrType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Attrs = append(m.Attrs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v RouteAttrType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (RouteAttrType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Attrs = append(m.Attrs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &IpSubnetType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nexthop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nexthop == nil {
				m.Nexthop = &NextHopType{}
			}
			if err := m.Nexthop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardProxyConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardProxyConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardProxyConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteListedPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhiteListedPrefixes = append(m.WhiteListedPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WhiteListedPorts = append(m.WhiteListedPorts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WhiteListedPorts = append(m.WhiteListedPorts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteListedPorts", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnectAttempts", wireType)
			}
			m.MaxConnectAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConnectAttempts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionTimeout", wireType)
			}
			m.ConnectionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoInterception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsInterceptionChoice = &ForwardProxyConfigType_NoInterception{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsIntercept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsInterceptionType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsInterceptionChoice = &ForwardProxyConfigType_TlsIntercept{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostnameOrIp = &HostIdentifier_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostnameOrIp = &HostIdentifier_Hostname{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIntf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &InterfaceIdentifier_AnyIntf{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceIdentifier_Intf{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceOrNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceOrNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceOrNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceOrNetwork_Intf{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceOrNetwork_Pod{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnType", wireType)
			}
			var v VirtualNetworkType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (VirtualNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InterfaceChoice = &InterfaceOrNetwork_VnType{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceOrNetwork_Vn{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 7465 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7c, 0x6d, 0x6c, 0x1b, 0x49,
	0x96, 0x18, 0x8b, 0x1f, 0x22, 0xf5, 0x28, 0x8a, 0xad, 0x92, 0x2c, 0xd1, 0xb2, 0x47, 0xa6, 0x39,
	0x9e, 0x59, 0xaf, 0x46, 0x96, 0x2d, 0x8d, 0xed, 0x99, 0x51, 0xe6, 0xbc, 0x43, 0x52, 0xb4, 0x45,
	0x5b, 0x26, 0x39, 0x4d, 0x4a, 0xde, 0xd9, 0x0d, 0xae, 0xaf, 0x45, 0x16, 0xa5, 0x3e, 0x93, 0xdd,
	0x9c, 0xee, 0xa6, 0x3e, 0x02, 0x38, 0x31, 0x82, 0x0d, 0x10, 0x38, 0x1f, 0xb8, 0x4c, 0x0e, 0xc8,
	0x62, 0x10, 0x20, 0x0b, 0xec, 0x5d, 0xee, 0x30, 0xbf, 0x12, 0x04, 0x09, 0x82, 0xd0, 0x87, 0x33,
	0x8c, 0x04, 0xd8, 0x2c, 0x02, 0x64, 0x7e, 0x2e, 0x36, 0x07, 0xdc, 0x8e, 0x36, 0x38, 0xdc, 0x2d,
	0xf2, 0x63, 0x31, 0x3f, 0x72, 0xf3, 0x6f, 0x83, 0xfa, 0xe8, 0x66, 0xb3, 0x45, 0x7d, 0xec, 0xec,
	0x2c, 0x36, 0x3f, 0x76, 0x7e, 0x8c, 0x59, 0x55, 0xef, 0xbd, 0x7a, 0xf5, 0xde, 0xab, 0x57, 0xef,
	0x55, 0xbd, 0x16, 0x9c, 0xdf, 0x25, 0xd6, 0xa2, 0x66, 0x5c, 0xb7, 0xea, 0x3b, 0xa4, 0xad, 0x5e,
	0xb7, 0x0f, 0x3a, 0xc4, 0x5a, 0xec, 0x98, 0x86, 0x6d, 0xe0, 0x04, 0x1f, 0x5a, 0xe4, 0x43, 0xb3,
	0xd7, 0xb6, 0x35, 0x7b, 0xa7, 0xbb, 0xb5, 0x58, 0x37, 0xda, 0xd7, 0xb7, 0x8d, 0x6d, 0xe3, 0x3a,
	0x83, 0xda, 0xea, 0x36, 0x59, 0x8b, 0x35, 0xd8, 0x2f, 0x8e, 0x3d, 0x7b, 0x69, 0xdb, 0x30, 0xb6,
	0x5b, 0xa4, 0x0f, 0x65, 0x6b, 0x6d, 0x62, 0xd9, 0x6a, 0xbb, 0x23, 0x00, 0x66, 0x06, 0x67, 0xd6,
	0x89, 0x2d, 0x06, 0x2e, 0x0c, 0x0e, 0x18, 0x1d, 0x5b, 0x33, 0x74, 0xc1, 0xd4, 0xec, 0xc5, 0xc1,
	0xc1, 0x5d, 0xb5, 0xa5, 0x35, 0x54, 0x9b, 0x88, 0xd1, 0xb4, 0x6f, 0x54, 0x23, 0x7b, 0xca, 0x00,
	0x7e, 0x26, 0x0a, 0x91, 0x42, 0xbb, 0x63, 0x1f, 0x64, 0xbe, 0x8b, 0x20, 0x51, 0xde, 0xfa, 0x7d,
	0x52, 0xb7, 0x65, 0xd2, 0xac, 0x1d, 0x74, 0x08, 0x9e, 0x81, 0xf0, 0x63, 0x4d, 0x6f, 0xa4, 0x50,
	0x1a, 0x5d, 0x1d, 0xcd, 0x85, 0x3e, 0x7d, 0x82, 0x64, 0xd6, 0x81, 0xcf, 0x41, 0xa8, 0xab, 0x35,
	0x52, 0xc1, 0x7e, 0x3f, 0x6d, 0xe3, 0x0b, 0x30, 0x62, 0x13, 0x5d, 0xd5, 0xed, 0x54, 0xa8, 0x3f,
	0x22, 0xba, 0xf0, 0x65, 0x18, 0xd5, 0xd5, 0x36, 0xb1, 0x3a, 0x6a, 0x9d, 0xa4, 0xc2, 0xfd, 0xf1,
	0x7e, 0x2f, 0x9d, 0x8f, 0x36, 0x52, 0x11, 0xcf, 0x7c, 0xb4, 0x23, 0xf3, 0x3e, 0x4c, 0xac, 0xab,
	0x5b, 0xa4, 0x55, 0x25, 0x2d, 0x52, 0xb7, 0x0d, 0x93, 0x71, 0xf7, 0x2e, 0xc4, 0xc9, 0x7e, 0xc7,
	0x24, 0x96, 0x45, 0x57, 0x93, 0x42, 0xe9, 0xd0, 0xd5, 0xd1, 0xdc, 0xec, 0x17, 0x3d, 0x14, 0xfc,
	0x2f, 0x7f, 0xf3, 0x22, 0x14, 0xf9, 0x08, 0x05, 0x25, 0x44, 0x7f, 0x45, 0xcd, 0x88, 0x84, 0x52,
	0x4f, 0xd3, 0xb2, 0x17, 0x3c, 0xf3, 0x2e, 0x48, 0x8c, 0xe4, 0x43, 0xd5, 0xae, 0xef, 0x10, 0x4e,
	0xf1, 0x2a, 0x84, 0x1f, 0x93, 0x03, 0x87, 0xd4, 0x94, 0x4b, 0x46, 0x72, 0x7e, 0xa5, 0xa8, 0x00,
	0xc8, 0x81, 0x95, 0xf9, 0x61, 0x10, 0x12, 0x79, 0x43, 0x6f, 0x68, 0x54, 0x92, 0x0c, 0xf7, 0x26,
	0x84, 0xa9, 0xa9, 0x08, 0x59, 0xa5, 0x29, 0xc6, 0x05, 0xf3, 0xbc, 0x0c, 0x9b, 0x5c, 0x1f, 0x9a,
	0xa1, 0xcb, 0xf1, 0x72, 0x87, 0x98, 0xec, 0xa7, 0xda, 0x92, 0x19, 0x34, 0x6e, 0xc2, 0x88, 0x65,
	0xab, 0x76, 0xd7, 0x12, 0xb2, 0x2c, 0x51, 0xbc, 0xa2, 0x79, 0x4f, 0x8e, 0x56, 0xbb, 0xf5, 0x3a,
	0xb1, 0x2c, 0x79, 0xe4, 0xae, 0xaa, 0xb5, 0x48, 0x43, 0x86, 0xa2, 0x5e, 0x37, 0xda, 0x9d, 0x16,
	0xb1, 0x89, 0x3c, 0x5a, 0xd4, 0x2d, 0x5b, 0x6d, 0xd1, 0xee, 0xf0, 0xaa, 0xb1, 0xa7, 0xcb, 0xb1,
	0x55, 0xcd, 0x52, 0xb7, 0x68, 0x3b, 0x51, 0x32, 0xec, 0x6c, 0xa7, 0xd3, 0xd2, 0xea, 0xb4, 0x2d,
	0x0b, 0xea, 0x78, 0x1a, 0x46, 0x4c, 0xa2, 0x5a, 0x86, 0xce, 0x35, 0x23, 0x8b, 0x16, 0x5e, 0x05,
	0xa9, 0xa5, 0x5a, 0xb6, 0xd2, 0xed, 0x50, 0x9b, 0x51, 0xa8, 0x45, 0x32, 0xe9, 0xc7, 0x97, 0x67,
	0x17, 0xb9, 0xb9, 0x2e, 0x3a, 0xe6, 0xba, 0x58, 0x73, 0xcc, 0x55, 0x1e, 0xa7, 0x38, 0x1b, 0x0c,
	0x85, 0x76, 0xe2, 0x59, 0x88, 0xed, 0x18, 0x96, 0xcd, 0x74, 0x37, 0xc2, 0xe8, 0xbb, 0x6d, 0x7c,
	0x19, 0xc6, 0x2c, 0x62, 0xee, 0x6a, 0x75, 0xa2, 0xb0, 0xf1, 0x28, 0x1b, 0x8f, 0x8b, 0xbe, 0x12,
	0xd5, 0x6e, 0x05, 0xa0, 0xca, 0xd8, 0x64, 0x82, 0x9c, 0x76, 0x45, 0x82, 0x38, 0xab, 0xa7, 0x2c,
	0x01, 0x43, 0xb8, 0x6e, 0x34, 0xb8, 0x49, 0x45, 0x64, 0xf6, 0x3b, 0xf3, 0x1a, 0x24, 0x8b, 0xba,
	0x66, 0x6b, 0x6a, 0x4b, 0xfb, 0x7b, 0x42, 0xb7, 0x58, 0xd8, 0x16, 0x27, 0xca, 0xcd, 0xea, 0x1f,
	0x80, 0xe4, 0x01, 0xe3, 0xd3, 0xbf, 0x0d, 0xd1, 0x0e, 0xd1, 0x1b, 0x9a, 0xbe, 0xcd, 0xcc, 0x20,
	0xbe, 0x3c, 0xb7, 0x38, 0xb0, 0xeb, 0x17, 0x7d, 0x84, 0x65, 0x07, 0x1c, 0x2f, 0x51, 0x06, 0xad,
	0x6e, 0xcb, 0x66, 0xba, 0x8c, 0x2f, 0x9f, 0xf7, 0x21, 0xf6, 0xd7, 0x28, 0x0b, 0xc0, 0xcc, 0xf7,
	0x83, 0x30, 0xce, 0xbb, 0x1f, 0x12, 0x5b, 0x65, 0xf3, 0x8b, 0xad, 0x85, 0x7c, 0x5b, 0xeb, 0x2a,
	0x24, 0xea, 0x26, 0x51, 0x6d, 0xc3, 0x54, 0xea, 0x2d, 0xd5, 0xb2, 0xbc, 0x7b, 0x6f, 0x4c, 0x8c,
	0xe4, 0xe9, 0x00, 0xce, 0x00, 0x38, 0x90, 0x5a, 0xc3, 0xbb, 0x11, 0x47, 0x45, 0x77, 0xb1, 0x81,
	0xd3, 0x30, 0xca, 0xa5, 0x4a, 0x41, 0x3c, 0x7b, 0x31, 0xc6, 0x7b, 0x8b, 0x0d, 0x5c, 0x02, 0xcc,
	0xc0, 0x35, 0x43, 0x57, 0x5c, 0x3f, 0x75, 0xba, 0x69, 0x70, 0x32, 0x13, 0x0e, 0xaa, 0xdb, 0x8f,
	0x57, 0x20, 0xda, 0xe9, 0x6e, 0xb5, 0x34, 0x6b, 0x87, 0x59, 0xc8, 0xf8, 0x72, 0x7a, 0xa8, 0x74,
	0x2a, 0x1c, 0x46, 0x08, 0x96, 0x37, 0x32, 0xff, 0x38, 0x0c, 0xe3, 0xdc, 0x31, 0xb9, 0x52, 0x9a,
	0xf1, 0x6a, 0xd3, 0xe3, 0x29, 0xf0, 0x45, 0xaf, 0x97, 0x61, 0x32, 0xf2, 0x3a, 0x18, 0x21, 0xdc,
	0x90, 0x4f, 0xb8, 0x25, 0x18, 0x69, 0x51, 0x5f, 0x60, 0xa5, 0xc2, 0x4c, 0xe5, 0x5f, 0xf7, 0xf1,
	0x36, 0x38, 0xf9, 0x22, 0xf3, 0x1b, 0x56, 0x41, 0xb7, 0xcd, 0x83, 0x5c, 0xfc, 0xf0, 0x27, 0xff,
	0x2d, 0x34, 0xf2, 0xec, 0x39, 0x0a, 0xc6, 0x02, 0xb2, 0xa0, 0x82, 0xbf, 0x87, 0x20, 0xae, 0xea,
	0xba, 0x61, 0x33, 0x21, 0x58, 0xa9, 0x08, 0xa3, 0xba, 0x78, 0x32, 0xd5, 0x6c, 0x1f, 0x81, 0x93,
	0x2e, 0x7d, 0xda, 0x43, 0xcc, 0x81, 0xc5, 0x3f, 0x46, 0xb1, 0xcc, 0x88, 0x19, 0x96, 0x50, 0xea,
	0x3d, 0xda, 0x1e, 0xfb, 0x18, 0x8d, 0xce, 0x0b, 0xaf, 0x16, 0xa3, 0xf3, 0xc3, 0xb3, 0xe7, 0x68,
	0x04, 0x87, 0x7f, 0xd0, 0x43, 0x81, 0x3e, 0x3b, 0xc8, 0x1d, 0x99, 0xa5, 0x23, 0x21, 0xd9, 0xcb,
	0x12, 0x4e, 0x43, 0xbc, 0x41, 0xac, 0xba, 0xa9, 0xb1, 0xb3, 0x40, 0xec, 0x5a, 0x6f, 0x17, 0x4e,
	0x41, 0xb4, 0xc1, 0xbd, 0x0a, 0xdb, 0xb3, 0x31, 0xd9, 0x69, 0xce, 0xbe, 0x03, 0x71, 0x8f, 0x08,
	0xb0, 0x04, 0xa1, 0xc7, 0xe4, 0x40, 0x6c, 0x2c, 0xfa, 0x13, 0x4f, 0x41, 0x64, 0x57, 0x6d, 0x75,
	0x1d, 0x05, 0xf0, 0xc6, 0x4a, 0xf0, 0x6d, 0x34, 0x7b, 0x07, 0x24, 0xff, 0x3a, 0x7f, 0x19, 0xfc,
	0xcc, 0x37, 0x60, 0x6c, 0x5d, 0xb3, 0xfa, 0x76, 0x70, 0x1d, 0x24, 0x93, 0x58, 0x46, 0xd7, 0xac,
	0x13, 0x65, 0x97, 0x98, 0xd4, 0xb5, 0x0b, 0x9b, 0x08, 0xff, 0x75, 0x0f, 0x21, 0x39, 0xe9, 0x8c,
	0x6e, 0xf2, 0x41, 0x6a, 0x4b, 0x13, 0x5c, 0xf0, 0xf7, 0x48, 0x9f, 0xcc, 0x10, 0xe7, 0x70, 0x8a,
	0x25, 0xbd, 0xef, 0x33, 0x99, 0x85, 0xa1, 0xca, 0xf5, 0xcc, 0x71, 0xba, 0xd5, 0x7c, 0x7f, 0xa8,
	0xd5, 0x2c, 0x9d, 0x4a, 0xf8, 0xb7, 0x86, 0x73, 0x3a, 0xfe, 0xca, 0xc4, 0x0f, 0xef, 0xf8, 0x7c,
	0x48, 0xe6, 0x5f, 0x84, 0x61, 0x8a, 0x77, 0xe5, 0xa9, 0xbb, 0x22, 0xbf, 0x82, 0x35, 0xd4, 0x7c,
	0xd6, 0x70, 0x7d, 0xa8, 0xd2, 0x06, 0xa7, 0x39, 0xdd, 0x20, 0xfe, 0xed, 0x50, 0x83, 0xb8, 0x79,
	0x16, 0xda, 0xbf, 0xb5, 0x89, 0x2f, 0x67, 0x13, 0x7f, 0x18, 0x86, 0x73, 0x4e, 0x0c, 0xdc, 0x69,
	0xa9, 0xf5, 0x5f, 0xc5, 0x28, 0x36, 0x5c, 0xa3, 0x08, 0x31, 0xc5, 0xdd, 0x18, 0xaa, 0x38, 0xdf,
	0x3c, 0xa7, 0x5b, 0xc5, 0x9f, 0xf8, 0xac, 0x82, 0x5b, 0xdc, 0xad, 0x33, 0x11, 0xff, 0x8d, 0x9a,
	0x45, 0xe4, 0x44, 0xb3, 0x18, 0xf9, 0xff, 0xd9, 0x2c, 0x7e, 0x1f, 0x92, 0x0f, 0x89, 0x65, 0xa9,
	0xdb, 0x27, 0xdb, 0x83, 0x6f, 0xc1, 0xc1, 0xa3, 0x0b, 0xbe, 0xdc, 0x5f, 0x30, 0x0d, 0x42, 0x62,
	0xb9, 0xe8, 0x8f, 0x9e, 0x20, 0x76, 0x52, 0x39, 0xfd, 0x19, 0x02, 0xf1, 0x4d, 0x8d, 0xec, 0x39,
	0x39, 0x18, 0xf6, 0xe6, 0x60, 0x22, 0xfd, 0x92, 0x3c, 0xe9, 0x17, 0x8f, 0x60, 0x2e, 0x1e, 0x49,
	0xae, 0xbc, 0x96, 0x88, 0xbd, 0x79, 0x95, 0x88, 0x7d, 0xab, 0x10, 0x7f, 0xd0, 0xdd, 0x22, 0x27,
	0x4d, 0x73, 0xb2, 0x79, 0x3b, 0x44, 0x43, 0x1e, 0xa2, 0x7f, 0x1b, 0x81, 0xa9, 0xea, 0x81, 0x65,
	0x93, 0xb6, 0x2f, 0x5e, 0x3b, 0x26, 0xaa, 0x1d, 0x1e, 0x65, 0x86, 0xbe, 0x74, 0x94, 0x59, 0x04,
	0xdc, 0x20, 0x2d, 0xe2, 0xa3, 0x17, 0x3e, 0x35, 0xa1, 0x99, 0x70, 0xb0, 0xfa, 0xa4, 0x36, 0x61,
	0xba, 0x6d, 0x34, 0xb4, 0xa6, 0x56, 0xff, 0x92, 0x41, 0xf0, 0x39, 0x2f, 0x7a, 0x9f, 0x6e, 0x1e,
	0xc6, 0x34, 0x4f, 0xce, 0xc1, 0xec, 0x3e, 0xbe, 0x7c, 0xe9, 0xf8, 0x24, 0x83, 0x67, 0x0c, 0x03,
	0x48, 0x78, 0x0e, 0xa0, 0xa9, 0xe9, 0x0e, 0x89, 0x28, 0x4d, 0x57, 0x65, 0x4f, 0x8f, 0x27, 0x11,
	0x8f, 0x1d, 0x4d, 0xc4, 0x8f, 0xa4, 0x12, 0xa3, 0x67, 0x4b, 0x25, 0x60, 0x68, 0x2a, 0x91, 0x01,
	0xb0, 0x4d, 0xb5, 0x4e, 0x14, 0x4d, 0x6f, 0x1a, 0xa9, 0xb8, 0x07, 0x86, 0x75, 0x17, 0xf5, 0xa6,
	0x81, 0x5f, 0x87, 0x31, 0x83, 0xd9, 0x83, 0xa2, 0xe9, 0x0d, 0xb2, 0x9f, 0x1a, 0x4b, 0xa3, 0xab,
	0x09, 0x0e, 0x15, 0xe7, 0x03, 0x45, 0xda, 0x8f, 0x65, 0xaf, 0xc1, 0x25, 0x98, 0x5f, 0xbb, 0x78,
	0x8c, 0x5f, 0x63, 0x56, 0x9b, 0x9b, 0xfe, 0xe4, 0x49, 0x1f, 0xa3, 0x9f, 0xf5, 0x7b, 0xcd, 0x74,
	0x1e, 0xc6, 0xdd, 0xd5, 0x1a, 0xc6, 0x63, 0x8d, 0xa4, 0xc6, 0xfb, 0x3c, 0x3a, 0x82, 0xc8, 0xb3,
	0x11, 0xfc, 0x0e, 0x80, 0xb1, 0xa7, 0x13, 0x53, 0xd9, 0xd5, 0xc8, 0x5e, 0x2a, 0x29, 0xf4, 0x3c,
	0xc8, 0x80, 0x67, 0x6f, 0xca, 0xa3, 0x0c, 0x9a, 0xf6, 0x64, 0xfe, 0x47, 0x18, 0x66, 0xbc, 0x96,
	0xef, 0x8d, 0x2e, 0x25, 0x8f, 0xf1, 0x73, 0xbb, 0x2f, 0x7e, 0x39, 0xbb, 0xff, 0x35, 0x9b, 0xfc,
	0xfb, 0x5f, 0xde, 0xe4, 0x7f, 0xa3, 0xd6, 0x3e, 0x3d, 0x68, 0xed, 0xae, 0xa1, 0xbf, 0x3a, 0xd4,
	0xd0, 0x7d, 0x36, 0xfe, 0xca, 0x51, 0x1b, 0xf7, 0x9a, 0xf7, 0xe5, 0x61, 0xa6, 0x3b, 0x68, 0xb5,
	0x5f, 0xde, 0x6a, 0x56, 0x66, 0x7e, 0x78, 0x67, 0xa8, 0xbf, 0xcc, 0xb4, 0x01, 0x67, 0xbb, 0xf6,
	0x0e, 0xbb, 0x5a, 0xca, 0xa9, 0x96, 0x56, 0xa7, 0x2d, 0x3c, 0x0b, 0xb1, 0xae, 0x45, 0x4c, 0xcf,
	0xb9, 0xe3, 0xb6, 0xf1, 0xdf, 0x81, 0x58, 0x47, 0xb5, 0xac, 0x3d, 0xc3, 0x6c, 0x1c, 0x77, 0xff,
	0x40, 0xea, 0x26, 0xb1, 0x19, 0xc5, 0x30, 0x3d, 0xf6, 0x65, 0x17, 0x21, 0xd3, 0x0b, 0x81, 0xe4,
	0xce, 0xb7, 0x46, 0xd4, 0x06, 0x15, 0xeb, 0x1f, 0x05, 0x21, 0xba, 0xc3, 0x7f, 0x8b, 0xab, 0x10,
	0x7f, 0x92, 0xe3, 0x47, 0x59, 0x14, 0xff, 0xf2, 0xd8, 0xe2, 0x7f, 0x21, 0x27, 0x90, 0xc8, 0x88,
	0x40, 0x82, 0x5f, 0xcc, 0x7d, 0x8c, 0x82, 0x92, 0x44, 0x03, 0x87, 0x8b, 0xcf, 0x9e, 0xa3, 0x14,
	0x9e, 0xfe, 0x59, 0x0f, 0xe1, 0xb5, 0x5a, 0xad, 0x92, 0xe6, 0x93, 0xa5, 0x2d, 0xdb, 0xd4, 0xf4,
	0x6d, 0x0a, 0x70, 0xee, 0xd9, 0x73, 0x34, 0x81, 0x93, 0x87, 0x3d, 0x14, 0x67, 0x00, 0x9c, 0xfc,
	0xc9, 0xd1, 0x48, 0xee, 0xd9, 0x73, 0x74, 0x67, 0xf6, 0xdd, 0x9f, 0xf5, 0xd0, 0xdb, 0xb9, 0x96,
	0xa6, 0x37, 0x9a, 0x46, 0xab, 0x91, 0x36, 0xcc, 0x74, 0xbd, 0x45, 0x54, 0x33, 0x6d, 0x31, 0x19,
	0xa4, 0xd9, 0x61, 0x9f, 0x6e, 0x1a, 0x66, 0xda, 0xde, 0xd1, 0xac, 0xf4, 0x8e, 0x6d, 0x77, 0x9c,
	0xd9, 0x1f, 0x93, 0x03, 0x4a, 0x46, 0x7a, 0xf6, 0x1c, 0x8d, 0xcd, 0xc2, 0x61, 0x0f, 0x8d, 0x70,
	0xb9, 0x79, 0x22, 0x9d, 0x17, 0xec, 0xbc, 0x16, 0xa2, 0x99, 0xdd, 0x80, 0x31, 0xef, 0xb2, 0x87,
	0x84, 0x1a, 0xd7, 0xbd, 0xa1, 0xc6, 0x49, 0x7a, 0xf1, 0x46, 0x21, 0x5f, 0x7f, 0xd9, 0x43, 0xaf,
	0xc1, 0xab, 0x30, 0x47, 0xf3, 0xdd, 0xb4, 0xd1, 0x4c, 0x53, 0x61, 0x13, 0xdd, 0x16, 0x5b, 0x2c,
	0xed, 0x68, 0x09, 0x2d, 0x65, 0xfe, 0x77, 0x08, 0xa6, 0x5c, 0x55, 0xbc, 0xdf, 0x25, 0xe6, 0x41,
	0x45, 0x35, 0xd5, 0xb6, 0x85, 0xff, 0x2c, 0x08, 0x63, 0x1f, 0xd2, 0xb6, 0xd2, 0x61, 0x1d, 0x42,
	0x8d, 0x37, 0x8f, 0x53, 0xa3, 0x07, 0x77, 0xd1, 0xf3, 0x9b, 0xab, 0xf3, 0xa7, 0xa7, 0xa9, 0x33,
	0xfd, 0xec, 0x39, 0xba, 0x88, 0x67, 0x7f, 0xd6, 0x43, 0xd3, 0x0c, 0x39, 0xcd, 0xb0, 0x89, 0x3d,
	0xa0, 0xd2, 0xf3, 0xcf, 0x9e, 0xa3, 0x73, 0x78, 0xf2, 0xb0, 0x87, 0x92, 0x3e, 0xa0, 0xaf, 0x5e,
	0xad, 0x6c, 0xe9, 0xe9, 0x8e, 0x77, 0x82, 0x53, 0xd5, 0x1a, 0xff, 0xb0, 0xbf, 0xee, 0xd9, 0x0f,
	0x40, 0xf2, 0x8b, 0xe1, 0xab, 0x52, 0xef, 0xd2, 0xcb, 0x1e, 0xba, 0x06, 0x6f, 0xc0, 0xeb, 0x55,
	0x32, 0x4c, 0xbb, 0x3e, 0xd9, 0x30, 0x35, 0xff, 0x09, 0x82, 0x19, 0x77, 0xed, 0x9c, 0x2a, 0x3d,
	0x5d, 0xc5, 0x3d, 0xc8, 0x64, 0x83, 0xd4, 0xcd, 0x03, 0x16, 0x65, 0x2a, 0x1d, 0xd3, 0xd8, 0xd5,
	0x1a, 0xc4, 0x14, 0x5c, 0xe2, 0xfe, 0x50, 0x45, 0x8c, 0xe0, 0xd7, 0x60, 0xdc, 0xb2, 0x0d, 0x93,
	0xf4, 0x61, 0x79, 0x80, 0x97, 0x60, 0xbd, 0x2e, 0xd8, 0x3c, 0xc4, 0x5a, 0x06, 0xe7, 0x49, 0xdc,
	0x9a, 0x8d, 0x7f, 0xd1, 0x43, 0x21, 0xa6, 0x78, 0x33, 0xf4, 0x07, 0xd4, 0x89, 0x38, 0xe3, 0x2b,
	0xb1, 0xcf, 0xef, 0x44, 0xde, 0x5c, 0x58, 0x5a, 0x58, 0xce, 0xfc, 0x15, 0x82, 0xc9, 0x4d, 0xb5,
	0xdb, 0xb2, 0x7d, 0x5c, 0x5e, 0x83, 0xd8, 0x20, 0x6b, 0xb9, 0x89, 0x1f, 0xf7, 0x50, 0xa2, 0x41,
	0x9a, 0x14, 0xf8, 0xda, 0x2e, 0xfd, 0xbf, 0xec, 0x82, 0x50, 0x77, 0xe7, 0x4e, 0xce, 0xb9, 0x73,
	0xdb, 0x8e, 0x1a, 0x42, 0x7d, 0x35, 0xa4, 0x20, 0xea, 0xdc, 0x00, 0x85, 0x99, 0x93, 0x76, 0x9a,
	0xf8, 0x3e, 0x24, 0xb9, 0x81, 0x28, 0x44, 0xaf, 0x1b, 0xec, 0x6a, 0x37, 0xc2, 0xee, 0x20, 0x2f,
	0x0f, 0x55, 0x55, 0x41, 0x00, 0x31, 0x95, 0x8d, 0x5b, 0x03, 0x7d, 0x2b, 0x63, 0x9f, 0xdf, 0x19,
	0x5d, 0x5a, 0x58, 0x5e, 0x78, 0x73, 0xe1, 0xe6, 0xc2, 0xad, 0xcc, 0xb7, 0x61, 0x32, 0x4f, 0x0d,
	0xd0, 0xb7, 0xce, 0x59, 0xff, 0x3a, 0x3d, 0x8b, 0x4a, 0x43, 0xa8, 0x6b, 0xb6, 0xc4, 0xf5, 0xad,
	0x5f, 0x98, 0x74, 0x68, 0x65, 0xe4, 0xf3, 0x3b, 0xa1, 0xe5, 0x85, 0xa5, 0xcc, 0x1b, 0x70, 0xee,
	0x91, 0xa6, 0x6f, 0xb7, 0x55, 0xdd, 0x47, 0x7e, 0xd8, 0x55, 0xf6, 0x7f, 0x8a, 0x00, 0xf4, 0x2d,
	0x0d, 0xff, 0x5d, 0x38, 0xb7, 0xe5, 0x98, 0x8a, 0x22, 0x16, 0xcf, 0x02, 0x34, 0x1e, 0x18, 0xbc,
	0xee, 0x5b, 0xf8, 0x31, 0x66, 0xb5, 0x16, 0x90, 0x27, 0xb7, 0x8e, 0x0e, 0xe1, 0x6f, 0xc3, 0x04,
	0xd3, 0xd5, 0x00, 0x65, 0x1e, 0x23, 0x64, 0xfc, 0x07, 0xdf, 0x51, 0x33, 0xc8, 0x8d, 0x8a, 0x9c,
	0x27, 0x85, 0xd6, 0x02, 0x72, 0x72, 0x77, 0x10, 0x02, 0x57, 0x60, 0x82, 0x6d, 0xea, 0x01, 0xe2,
	0x23, 0x43, 0x89, 0x0f, 0x91, 0x3d, 0xa5, 0x58, 0x1f, 0xec, 0xc6, 0x0a, 0x4c, 0xee, 0x71, 0x41,
	0x0e, 0xd0, 0x8c, 0x32, 0x9a, 0x57, 0x7c, 0x34, 0x87, 0x8a, 0xdc, 0x4d, 0xd3, 0xd6, 0x02, 0xf2,
	0xc4, 0x9e, 0x1f, 0x02, 0xff, 0x2e, 0x4c, 0xf9, 0x0c, 0x4c, 0x61, 0x6f, 0x41, 0xb1, 0x33, 0x5a,
	0x99, 0x47, 0x22, 0x32, 0xb6, 0x8e, 0x0c, 0x63, 0x1b, 0xe6, 0x86, 0x6a, 0x53, 0xd1, 0x74, 0x9b,
	0x1e, 0xff, 0x2d, 0x16, 0xb7, 0x9c, 0x59, 0xad, 0xfd, 0xa4, 0xf3, 0xc2, 0x10, 0xed, 0x16, 0x05,
	0xcd, 0x95, 0xcc, 0x4f, 0xee, 0xa0, 0x97, 0x3d, 0x94, 0x84, 0x04, 0x08, 0x67, 0x89, 0x43, 0xef,
	0x2c, 0xbc, 0xfd, 0xdd, 0xef, 0x5d, 0x0a, 0xfc, 0xbb, 0xef, 0x5d, 0x0a, 0x3c, 0xfd, 0x8b, 0x74,
	0x20, 0x77, 0x15, 0x26, 0xbc, 0xfc, 0x18, 0x3a, 0x31, 0x9a, 0x78, 0xf2, 0x45, 0x0f, 0xd1, 0x08,
	0x63, 0xf4, 0xb0, 0x87, 0xa2, 0x37, 0x17, 0x6e, 0x2d, 0xdc, 0x5e, 0x78, 0xeb, 0x7e, 0x38, 0x86,
	0xa4, 0xe0, 0xfd, 0x70, 0x2c, 0x28, 0x85, 0xee, 0x87, 0x63, 0x21, 0x29, 0x7c, 0x3f, 0x1c, 0x1b,
	0x95, 0x20, 0xb3, 0x05, 0xe3, 0x25, 0x62, 0xef, 0x19, 0xe6, 0x63, 0x27, 0x15, 0xad, 0x40, 0xc8,
	0x24, 0x4d, 0x71, 0x56, 0x9d, 0x1c, 0xff, 0xa7, 0x3f, 0x79, 0x92, 0xdc, 0xd5, 0x4c, 0xbb, 0xab,
	0xb6, 0x14, 0x9d, 0x53, 0x79, 0xfa, 0x9c, 0x5f, 0x68, 0x88, 0x4c, 0x80, 0x92, 0xca, 0x7c, 0x8c,
	0x20, 0x5e, 0xd5, 0x6c, 0x37, 0xd9, 0x2d, 0x9c, 0x7d, 0x86, 0x73, 0x9f, 0x3c, 0x09, 0x5b, 0x9a,
	0x4d, 0x86, 0x90, 0xc5, 0xab, 0x30, 0x26, 0x26, 0xe5, 0xea, 0x0e, 0x0e, 0x55, 0xf7, 0x26, 0xe7,
	0x4f, 0x2c, 0x92, 0x39, 0x95, 0xb8, 0xde, 0x6f, 0x64, 0x7e, 0x0f, 0x70, 0xb1, 0x53, 0x31, 0x49,
	0x53, 0xdb, 0xaf, 0x12, 0xf7, 0xe9, 0xf5, 0xfe, 0xd9, 0x59, 0x9c, 0xfd, 0xe4, 0x49, 0x42, 0xeb,
	0x28, 0x1d, 0x46, 0x42, 0xb1, 0x88, 0xed, 0x5f, 0xfe, 0xbf, 0x41, 0x30, 0xb6, 0xe9, 0x5d, 0x7f,
	0xf1, 0xec, 0xc4, 0xcf, 0x7f, 0xf2, 0x64, 0xcc, 0x91, 0x30, 0x95, 0xc3, 0xaf, 0x47, 0x06, 0x9b,
	0x30, 0x5e, 0x31, 0x5a, 0x5a, 0x9d, 0x98, 0x0e, 0x8b, 0xab, 0x67, 0x67, 0x71, 0xea, 0x93, 0x27,
	0xd1, 0x0e, 0xc7, 0xf6, 0xaf, 0x7c, 0x1b, 0xa6, 0x2b, 0x34, 0x57, 0xa9, 0x1b, 0x2d, 0x1f, 0xfd,
	0x87, 0x67, 0xa7, 0xff, 0xca, 0x27, 0x4f, 0xa4, 0x8e, 0xa0, 0xa2, 0x1c, 0x33, 0xd1, 0x3f, 0x0f,
	0xc2, 0xb4, 0x58, 0x9d, 0x10, 0xb4, 0xf3, 0x54, 0x8d, 0x4b, 0xe0, 0x37, 0x51, 0xe6, 0xb8, 0xe3,
	0xcb, 0xaf, 0xf8, 0x66, 0x1d, 0xdc, 0x06, 0x39, 0x16, 0x8f, 0xac, 0x05, 0xe4, 0xf1, 0xdd, 0x01,
	0xe1, 0xe1, 0x1b, 0xc0, 0x0c, 0x52, 0x44, 0x1b, 0xfe, 0x44, 0xc3, 0xa3, 0xe6, 0xb5, 0x80, 0xcc,
	0x20, 0xf1, 0x7b, 0x30, 0xa0, 0x42, 0x91, 0x67, 0x5e, 0xf0, 0xeb, 0x68, 0x10, 0x35, 0x2e, 0x50,
	0x68, 0x6f, 0xee, 0x0a, 0x24, 0x4d, 0xd2, 0x54, 0x0c, 0xea, 0x94, 0xc5, 0xb2, 0x26, 0x5e, 0xf4,
	0x50, 0xe8, 0xd3, 0x1e, 0x8a, 0x1c, 0xf6, 0x50, 0xe4, 0xcd, 0x85, 0xe5, 0x85, 0xa5, 0xfb, 0xe1,
	0x58, 0x58, 0x8a, 0xdc, 0x0f, 0xc7, 0x22, 0xd2, 0x48, 0xe6, 0x3f, 0x20, 0x98, 0xa5, 0xa8, 0x9b,
	0x7d, 0x2a, 0x5e, 0xa1, 0xfc, 0x26, 0x16, 0x71, 0xe1, 0xe8, 0x22, 0x62, 0x2f, 0x7a, 0x28, 0xf8,
	0x69, 0x0f, 0x85, 0x39, 0xef, 0x99, 0x3f, 0x46, 0x70, 0x91, 0x07, 0xd6, 0x0f, 0x55, 0x5d, 0xeb,
	0x74, 0x5b, 0x2c, 0xd8, 0x28, 0x77, 0xdc, 0x57, 0xfe, 0xcc, 0xc0, 0xbb, 0x23, 0x3d, 0xbe, 0x03,
	0xe2, 0xf8, 0x4e, 0x3d, 0x0d, 0x8a, 0x5b, 0xc0, 0x2b, 0x03, 0x37, 0x8b, 0x83, 0x40, 0xdf, 0xfb,
	0x86, 0x08, 0x02, 0xf1, 0x45, 0x18, 0x51, 0x3b, 0x1d, 0xa2, 0x37, 0xc4, 0x45, 0x60, 0x98, 0x82,
	0xc9, 0xa2, 0x6f, 0xe5, 0x95, 0x97, 0x3d, 0x74, 0x1e, 0x66, 0x60, 0x5c, 0x84, 0xf9, 0x69, 0xdb,
	0x48, 0x67, 0x1b, 0x0d, 0x1c, 0x61, 0xb1, 0x47, 0xe6, 0xbb, 0x41, 0x98, 0xa9, 0xb5, 0xac, 0x7e,
	0x6d, 0x01, 0x8f, 0x50, 0x19, 0x8b, 0xdf, 0x80, 0x71, 0xdb, 0xec, 0x5a, 0x36, 0x69, 0x28, 0x75,
	0x55, 0xa1, 0xb1, 0x06, 0x67, 0xf6, 0xfc, 0x17, 0x3d, 0x14, 0xa6, 0x7c, 0x8c, 0x98, 0xe1, 0xab,
	0x4f, 0x9f, 0xc6, 0x3c, 0x61, 0xc7, 0x98, 0x40, 0xc8, 0xab, 0x1b, 0x66, 0x0b, 0xbf, 0x0b, 0xb3,
	0xd6, 0x63, 0xad, 0xa3, 0x38, 0x4f, 0xf8, 0xca, 0x2e, 0x31, 0xdd, 0xd4, 0x9e, 0x2d, 0x2a, 0x26,
	0xa7, 0x28, 0xc4, 0x9a, 0x00, 0xd8, 0xf4, 0x8c, 0xe3, 0xb7, 0x20, 0xc5, 0xe0, 0x0f, 0x14, 0xab,
	0xcb, 0x13, 0x67, 0xb5, 0x65, 0xb3, 0xa7, 0x7f, 0x7e, 0x0f, 0x3e, 0x2a, 0x9f, 0xe3, 0xe3, 0x55,
	0x3e, 0x9c, 0x6d, 0xd9, 0x25, 0x3a, 0x88, 0x0b, 0x70, 0xa1, 0x6b, 0x11, 0x65, 0xd7, 0x68, 0xd9,
	0xc4, 0x34, 0x55, 0xc5, 0xb7, 0x88, 0xf0, 0xe0, 0x75, 0xe9, 0x4c, 0xd7, 0x22, 0x9b, 0x02, 0xb4,
	0xe6, 0xe1, 0x3e, 0xf3, 0x39, 0x02, 0x5c, 0x6b, 0x59, 0x79, 0x62, 0xda, 0x9c, 0x29, 0x22, 0xfc,
	0x49, 0xb2, 0xde, 0xef, 0xf2, 0x88, 0xe5, 0x82, 0x23, 0x96, 0x98, 0x49, 0x83, 0x8c, 0x41, 0xc1,
	0x8c, 0x7b, 0x70, 0xa8, 0x68, 0xde, 0x83, 0x78, 0xc7, 0xd4, 0x76, 0x29, 0x05, 0x1a, 0x7d, 0x86,
	0xcf, 0x96, 0x67, 0x83, 0xc0, 0x79, 0x40, 0x0e, 0x4e, 0xbf, 0x13, 0x5f, 0x79, 0xfd, 0xf3, 0x3b,
	0x91, 0x25, 0x1a, 0x5d, 0xbe, 0xec, 0xa1, 0x59, 0x48, 0x41, 0xb2, 0xb6, 0x5e, 0x4d, 0x7b, 0x96,
	0x83, 0xf9, 0xa8, 0x7b, 0x88, 0x06, 0xa5, 0x50, 0xe6, 0x65, 0x0c, 0x12, 0xb5, 0x96, 0xe5, 0xb1,
	0x82, 0x1a, 0xa4, 0xda, 0x9a, 0xae, 0xb5, 0xbb, 0x6d, 0xc5, 0xf5, 0x5d, 0xde, 0x07, 0xd2, 0xf1,
	0x23, 0x9b, 0x8e, 0xe2, 0x0b, 0x48, 0x79, 0x5a, 0xe0, 0x3a, 0x1d, 0xe2, 0xf5, 0x94, 0x51, 0x55,
	0xf7, 0x87, 0x53, 0x0d, 0x9e, 0x81, 0x2a, 0xc7, 0xf5, 0x53, 0xfd, 0xd7, 0x11, 0x48, 0xd4, 0xb5,
	0xce, 0x0e, 0x31, 0x15, 0xab, 0xab, 0xd9, 0x8e, 0xa1, 0xe4, 0xfe, 0x2f, 0xd3, 0xcb, 0x5f, 0x85,
	0x3f, 0x42, 0x87, 0xe1, 0xcc, 0x5f, 0x86, 0xcd, 0xbf, 0x08, 0xcb, 0xd3, 0xb5, 0xf5, 0xaa, 0x92,
	0x2d, 0x54, 0x95, 0xa5, 0xe5, 0xb7, 0x95, 0x7b, 0xf9, 0x87, 0x4a, 0x75, 0x2d, 0xbb, 0x7c, 0xeb,
	0x76, 0xbf, 0x7f, 0xf9, 0xd6, 0x6d, 0xa7, 0xff, 0xcd, 0xb7, 0x6f, 0xca, 0x17, 0x69, 0x7f, 0x7e,
	0x2d, 0x9b, 0x5f, 0xcb, 0x2e, 0xdf, 0x50, 0x2a, 0xe5, 0xf5, 0x0f, 0x96, 0xde, 0xbc, 0x71, 0xcb,
	0xc1, 0xfa, 0x1a, 0x1d, 0x2d, 0xe4, 0x57, 0xd7, 0x0a, 0xf4, 0xff, 0xd5, 0xac, 0xf2, 0xa8, 0x58,
	0x5b, 0x1b, 0x46, 0xfe, 0x78, 0x40, 0xdf, 0x7c, 0xd7, 0x86, 0x02, 0x1e, 0xcb, 0xc0, 0x6b, 0x7d,
	0x70, 0xf9, 0x84, 0xe9, 0x8f, 0x03, 0xf3, 0x4d, 0xfe, 0xc6, 0x10, 0xb0, 0x63, 0xa7, 0xbe, 0x72,
	0xe2, 0xda, 0xf3, 0xb9, 0x3c, 0x05, 0x3c, 0x01, 0x8a, 0xce, 0xed, 0x40, 0x65, 0x4e, 0x58, 0xc6,
	0x69, 0x30, 0x5e, 0x3a, 0x4c, 0x5b, 0xc7, 0x52, 0xb8, 0x34, 0x74, 0xd4, 0x23, 0xa6, 0xa3, 0xe8,
	0x5e, 0xe2, 0x97, 0x86, 0x8e, 0xf6, 0xc5, 0xe7, 0xa9, 0xf1, 0x1a, 0xe3, 0xd6, 0x58, 0x65, 0xc6,
	0x88, 0xd7, 0x41, 0xb2, 0x5b, 0x96, 0xe2, 0x71, 0x05, 0xce, 0xa3, 0xdb, 0xe5, 0xa3, 0xc6, 0xee,
	0xf3, 0x3b, 0x72, 0xd2, 0x1e, 0xe8, 0xb3, 0xf0, 0xf5, 0x23, 0xee, 0x99, 0x57, 0xbb, 0x79, 0x52,
	0x80, 0x41, 0x77, 0x5c, 0xa5, 0xc9, 0x96, 0xe3, 0xe7, 0x9d, 0x8b, 0x9c, 0xe8, 0xd0, 0x78, 0xff,
	0x98, 0x23, 0x41, 0x96, 0x76, 0x7d, 0xbd, 0x2c, 0x8d, 0xa5, 0x91, 0x39, 0x3b, 0x4e, 0xee, 0x87,
	0x63, 0x23, 0x52, 0x34, 0xf3, 0x97, 0x41, 0x38, 0xb7, 0xd1, 0xb1, 0x6c, 0x93, 0xa8, 0xed, 0x41,
	0x67, 0x92, 0x85, 0x44, 0xdd, 0x68, 0xb7, 0xfb, 0xd3, 0xf3, 0x00, 0xe6, 0xe2, 0x90, 0xbd, 0xde,
	0x9f, 0x74, 0x8c, 0xa3, 0x88, 0xab, 0xa8, 0x37, 0x20, 0x64, 0xe9, 0x9a, 0x38, 0x12, 0x67, 0x9c,
	0x23, 0x31, 0x6c, 0x06, 0x77, 0x50, 0xff, 0x00, 0x5d, 0x0b, 0xc8, 0x14, 0x0a, 0xdf, 0x87, 0x69,
	0x7a, 0x14, 0xd0, 0x03, 0x48, 0xe1, 0xd7, 0x6c, 0x8a, 0x6a, 0x29, 0x14, 0x9f, 0x9f, 0xfa, 0x53,
	0xbe, 0x89, 0x59, 0xfd, 0xe2, 0x5a, 0x40, 0xc6, 0x5d, 0x8b, 0xd0, 0x43, 0x89, 0x1f, 0x9a, 0x59,
	0xab, 0xaa, 0x6b, 0xf8, 0x2d, 0x88, 0x8b, 0x97, 0x35, 0x46, 0x20, 0x7c, 0x22, 0x01, 0x10, 0xa0,
	0x55, 0x5d, 0x5b, 0x99, 0xff, 0xfc, 0x4e, 0xe8, 0xd6, 0xc2, 0xd2, 0xcb, 0x1e, 0x4a, 0xc3, 0x1c,
	0xcc, 0x38, 0x92, 0x49, 0x53, 0x77, 0xec, 0xb9, 0x98, 0xa1, 0x30, 0xb9, 0x4b, 0x00, 0x96, 0xae,
	0x29, 0xf5, 0x1d, 0x43, 0xab, 0x13, 0x16, 0x1a, 0x05, 0x9d, 0xd0, 0x88, 0x5d, 0x15, 0x88, 0xa0,
	0xe8, 0x63, 0x04, 0x33, 0xab, 0xc6, 0x9e, 0xfe, 0x6b, 0x92, 0xf1, 0xbb, 0x30, 0x6b, 0x92, 0x0f,
	0xbb, 0x9a, 0x49, 0x94, 0x7a, 0x4b, 0x23, 0xba, 0xed, 0xb5, 0x59, 0x7e, 0x80, 0xca, 0x29, 0x01,
	0x91, 0x67, 0x00, 0x1e, 0xcb, 0xcc, 0x3c, 0x0b, 0x02, 0xac, 0x1a, 0x6d, 0x55, 0xe3, 0x91, 0xce,
	0x0a, 0xc4, 0xc9, 0xbe, 0x5a, 0xb7, 0x15, 0x1e, 0xcb, 0xa0, 0x41, 0xc5, 0x71, 0x7d, 0x09, 0x15,
	0x4a, 0x34, 0x4c, 0x05, 0x06, 0xbd, 0xc9, 0x62, 0x9b, 0x77, 0x61, 0xcc, 0xea, 0x36, 0x69, 0x36,
	0xe2, 0x0d, 0x84, 0x4e, 0x40, 0x8e, 0x73, 0x70, 0x8e, 0xbd, 0x0a, 0x71, 0x93, 0x6c, 0x13, 0x07,
	0x99, 0x5f, 0x3b, 0x5d, 0x3e, 0x06, 0x59, 0x74, 0xbd, 0x60, 0xa1, 0x32, 0x30, 0x3c, 0x46, 0x65,
	0x05, 0xbf, 0xec, 0xa1, 0x71, 0x18, 0x83, 0x28, 0x5f, 0x93, 0x85, 0xd1, 0xcd, 0x5c, 0x06, 0x12,
	0x0d, 0xd6, 0xf2, 0x6a, 0x0a, 0xd1, 0xf8, 0x8f, 0x6a, 0xca, 0xd9, 0x0b, 0x34, 0x10, 0xfc, 0x0e,
	0x02, 0x58, 0xbf, 0xb9, 0x4a, 0x2c, 0x5b, 0x24, 0x4c, 0x31, 0x9e, 0x5e, 0x11, 0xa7, 0x38, 0xf4,
	0x1a, 0x9d, 0x18, 0x3e, 0x42, 0xd1, 0x4c, 0xc4, 0x0c, 0x7d, 0xe1, 0xc9, 0x0d, 0xd3, 0xce, 0xaf,
	0x18, 0xf2, 0x78, 0x14, 0x17, 0x1d, 0xbf, 0x01, 0xf1, 0x8e, 0x61, 0xda, 0x8a, 0xa9, 0xea, 0xdb,
	0xc4, 0x29, 0xe3, 0x03, 0xb1, 0x8c, 0x1f, 0x04, 0x69, 0xb4, 0x60, 0x98, 0xb6, 0xcc, 0x46, 0x33,
	0xff, 0x2a, 0x08, 0x93, 0xb5, 0x96, 0xc5, 0x52, 0xf2, 0x3a, 0x61, 0xf1, 0x81, 0xdc, 0x6d, 0x31,
	0x01, 0x8b, 0x85, 0xb4, 0x55, 0xbb, 0xbe, 0x23, 0x6c, 0xc5, 0x1f, 0x88, 0xf4, 0xb5, 0x29, 0xc7,
	0x39, 0x38, 0x2b, 0x76, 0xc5, 0x45, 0x98, 0x72, 0xb6, 0x84, 0xe6, 0xa1, 0x7c, 0xca, 0xe6, 0x9a,
	0x14, 0x38, 0x5e, 0x66, 0xf0, 0x3d, 0x98, 0x24, 0xfa, 0x51, 0x4a, 0x27, 0xef, 0x32, 0xcc, 0x51,
	0xbc, 0x84, 0x72, 0x57, 0xe1, 0x9c, 0x20, 0xe4, 0xb0, 0x26, 0x54, 0x94, 0x14, 0x79, 0x46, 0xf0,
	0xb0, 0x87, 0x42, 0x7c, 0x2b, 0xd1, 0x88, 0xe7, 0x19, 0x82, 0x73, 0x3e, 0xc9, 0xb0, 0x0c, 0xef,
	0x00, 0x7f, 0x08, 0xd8, 0xcb, 0x8b, 0x62, 0x76, 0x5b, 0xc4, 0xb9, 0xf9, 0xce, 0x1c, 0xdd, 0x4d,
	0x7e, 0xd9, 0xe6, 0xe6, 0x4e, 0x51, 0xe5, 0x84, 0xe6, 0xc3, 0xb0, 0x32, 0xff, 0x3d, 0x72, 0x44,
	0x4d, 0xcc, 0x6c, 0xee, 0xc0, 0x08, 0xcb, 0x17, 0x0f, 0x84, 0x82, 0xae, 0x9c, 0x3c, 0x3d, 0x5f,
	0xc0, 0x5a, 0x40, 0x16, 0x58, 0x58, 0x06, 0x5c, 0xef, 0x5a, 0xb6, 0xd1, 0x1e, 0xd8, 0xc8, 0x5c,
	0x4d, 0xa7, 0x9f, 0x3d, 0x6b, 0x48, 0x9e, 0xe0, 0xe8, 0xde, 0xe8, 0x51, 0x86, 0x29, 0x37, 0xc4,
	0xf6, 0xbb, 0x87, 0x63, 0x54, 0xd6, 0xbf, 0xfd, 0x42, 0xf2, 0xa4, 0x83, 0xec, 0xa5, 0x99, 0x3d,
	0x72, 0xa6, 0x8d, 0x9c, 0x92, 0x72, 0xac, 0x05, 0x7d, 0xa7, 0xdc, 0x5d, 0x98, 0x1c, 0x12, 0xf9,
	0x8b, 0x73, 0x6e, 0xb8, 0x21, 0x05, 0xe5, 0x89, 0x5d, 0x7f, 0x06, 0x80, 0x1f, 0xc0, 0xb4, 0xb0,
	0xa3, 0xa6, 0x61, 0x2a, 0x6a, 0xab, 0xa5, 0x70, 0xcb, 0xe7, 0x8f, 0x7f, 0x27, 0x58, 0x37, 0xc7,
	0xba, 0x6b, 0x98, 0xd9, 0x56, 0x4b, 0xb8, 0x8c, 0x95, 0xfa, 0xcb, 0x1e, 0x52, 0xe0, 0xeb, 0x70,
	0xa5, 0xef, 0xb4, 0xbd, 0x91, 0x78, 0x3a, 0x6f, 0xe8, 0x4d, 0x6d, 0xbb, 0xcb, 0x6b, 0xba, 0x31,
	0x5a, 0x86, 0x14, 0x4c, 0xf6, 0xcf, 0x09, 0xce, 0x53, 0x3a, 0x9f, 0xc5, 0xe8, 0x16, 0x1d, 0xf1,
	0xaa, 0x3a, 0x2d, 0x8c, 0x15, 0xbd, 0x9d, 0xbb, 0x06, 0xb3, 0x03, 0xf6, 0xca, 0x75, 0xef, 0x35,
	0xff, 0xd1, 0x4f, 0x7b, 0x28, 0x46, 0xcd, 0xff, 0x9d, 0x85, 0xa5, 0xdc, 0xeb, 0x30, 0x69, 0x69,
	0xdb, 0xba, 0xa6, 0x6f, 0x33, 0xf5, 0x1d, 0xb7, 0x4d, 0x72, 0x57, 0x60, 0xc2, 0xa3, 0x13, 0x0f,
	0x54, 0x54, 0x9c, 0x4c, 0xa1, 0xb7, 0x16, 0x6e, 0xdf, 0x0f, 0xc7, 0x62, 0xd2, 0xa8, 0x7b, 0x2b,
	0x47, 0xcf, 0xa8, 0x7f, 0x8a, 0x60, 0xe2, 0xae, 0xa9, 0xd6, 0x79, 0x99, 0x7a, 0x85, 0xf2, 0xa5,
	0xdb, 0xf8, 0x6b, 0x30, 0xaa, 0x77, 0xdb, 0xc4, 0x54, 0x6d, 0x83, 0x5f, 0x69, 0x27, 0x72, 0xa3,
	0x3f, 0xee, 0x21, 0x74, 0x8b, 0x65, 0xad, 0xfd, 0x31, 0x7c, 0x97, 0xe6, 0x37, 0xba, 0xd1, 0xd6,
	0x74, 0x06, 0xca, 0x93, 0x02, 0x7f, 0x09, 0xf5, 0x6a, 0x1f, 0x82, 0xa7, 0x49, 0x8c, 0x8a, 0x17,
	0x91, 0x5d, 0x82, 0x2f, 0x2d, 0x2c, 0x67, 0xfe, 0x1c, 0x81, 0x94, 0xeb, 0x36, 0x9b, 0xc4, 0xe4,
	0xc2, 0x66, 0xfb, 0x2a, 0x0d, 0x31, 0xe1, 0x25, 0xf8, 0xab, 0xba, 0x93, 0x3d, 0xbb, 0xbd, 0xf8,
	0x5d, 0x98, 0x68, 0xab, 0xfb, 0x0a, 0x3d, 0xec, 0x88, 0x65, 0x2b, 0x5b, 0x07, 0xb6, 0xf0, 0xb5,
	0x89, 0x9c, 0xe4, 0x9c, 0x24, 0xd1, 0xf9, 0x48, 0xea, 0xe9, 0xd3, 0xa7, 0x11, 0x39, 0xd9, 0x56,
	0xf7, 0x65, 0x0e, 0x99, 0xa3, 0x80, 0x38, 0x0b, 0x92, 0x17, 0x9b, 0x55, 0xc5, 0x87, 0x18, 0xf2,
	0x8c, 0xd8, 0x09, 0xee, 0x69, 0x34, 0x1f, 0x4a, 0xfd, 0x28, 0x9c, 0x42, 0xf2, 0x78, 0x9f, 0x46,
	0x4d, 0x6b, 0x13, 0xf6, 0x18, 0x42, 0x8f, 0xfe, 0xa5, 0xcc, 0x1f, 0x85, 0x01, 0xf2, 0x86, 0x69,
	0x09, 0x8d, 0xcf, 0xfa, 0x79, 0xf7, 0x70, 0x5d, 0x84, 0x31, 0xb5, 0xd5, 0x32, 0xf6, 0x14, 0xc3,
	0xd4, 0xb6, 0x35, 0x9a, 0x52, 0xd1, 0xa3, 0xe6, 0x75, 0xf6, 0xee, 0xf6, 0x91, 0xef, 0xdd, 0x6d,
	0xe4, 0x23, 0x14, 0x92, 0x9e, 0x7a, 0x1d, 0x53, 0x9c, 0xe1, 0x96, 0x19, 0x2a, 0xd6, 0x01, 0x7b,
	0x49, 0x29, 0xec, 0x64, 0x14, 0x79, 0xd5, 0x7b, 0xde, 0xb3, 0xeb, 0x2a, 0x27, 0x37, 0xfa, 0x11,
	0x1a, 0xc9, 0x84, 0xcd, 0x60, 0x1a, 0x79, 0x07, 0x5f, 0x78, 0x0e, 0x36, 0xef, 0x47, 0x10, 0x92,
	0x67, 0x2a, 0x99, 0x52, 0xc6, 0xaf, 0x42, 0x82, 0xcf, 0xd7, 0x26, 0xf6, 0x8e, 0xd1, 0xb0, 0x44,
	0x11, 0x12, 0x5f, 0xcf, 0x43, 0xde, 0xd7, 0x07, 0x72, 0x9e, 0x95, 0x23, 0x1e, 0x20, 0xe7, 0x41,
	0xf3, 0x35, 0x18, 0x27, 0xfb, 0x1d, 0x83, 0xc6, 0x7f, 0x02, 0x8a, 0xd7, 0x13, 0x26, 0x78, 0xaf,
	0x03, 0x96, 0x81, 0x28, 0xd5, 0x91, 0xba, 0x2d, 0x3e, 0x29, 0xf0, 0x06, 0xd0, 0x23, 0x6d, 0x75,
	0x3f, 0xbb, 0x4d, 0xf0, 0x1b, 0x30, 0xc1, 0xe7, 0xab, 0x9b, 0xa4, 0x41, 0x74, 0x5b, 0x53, 0x5b,
	0x16, 0xbb, 0x94, 0x8f, 0x89, 0x15, 0xe4, 0xfb, 0xfd, 0x34, 0x50, 0x74, 0x72, 0x5b, 0x4a, 0x94,
	0xba, 0x8b, 0x48, 0x6e, 0x9a, 0x2e, 0x7a, 0x62, 0x36, 0x99, 0x7a, 0xfa, 0xfd, 0xc8, 0xd5, 0x5f,
	0x38, 0xff, 0x21, 0x19, 0x04, 0x68, 0x76, 0x9b, 0xac, 0xac, 0x7e, 0x7e, 0x27, 0x29, 0x1e, 0x84,
	0x16, 0x6e, 0x2f, 0xbc, 0xb3, 0xf0, 0x36, 0x0b, 0x1a, 0x17, 0x61, 0x01, 0xce, 0xe7, 0xcb, 0x72,
	0x55, 0x6c, 0x75, 0x9f, 0xb3, 0xf0, 0x63, 0x64, 0xfe, 0x18, 0x41, 0xb2, 0xa2, 0xda, 0x3b, 0xde,
	0xef, 0x51, 0x52, 0x30, 0xc2, 0xe3, 0x06, 0x1e, 0x7e, 0xb1, 0x93, 0x81, 0xb5, 0xf1, 0x14, 0x84,
	0x3b, 0xaa, 0xbd, 0xc3, 0xc3, 0x87, 0xb5, 0x80, 0xcc, 0x5a, 0xf8, 0x16, 0x44, 0x1c, 0x3d, 0x53,
	0x89, 0xbc, 0x22, 0xfc, 0xed, 0x55, 0x37, 0x5e, 0x4a, 0x0f, 0xc6, 0x4b, 0x1c, 0x7a, 0x25, 0xfc,
	0xf9, 0x1d, 0x74, 0x93, 0xc6, 0xb0, 0x94, 0x08, 0x8f, 0x28, 0x8e, 0x8f, 0x8c, 0x7e, 0x81, 0x60,
	0xc2, 0xb9, 0x22, 0xeb, 0x73, 0x3a, 0xac, 0x1a, 0x6e, 0x1a, 0x22, 0x2c, 0x26, 0x74, 0x99, 0xe4,
	0xcd, 0x2f, 0xc9, 0x25, 0xbe, 0xc8, 0x62, 0x30, 0x8b, 0xe8, 0xa2, 0xc2, 0x2d, 0xb6, 0x16, 0x90,
	0xdd, 0x1e, 0x7c, 0x19, 0xc6, 0x34, 0x7d, 0x97, 0x3a, 0x44, 0x1e, 0x11, 0x45, 0x98, 0x96, 0xe3,
	0xbc, 0x8f, 0x71, 0xba, 0x32, 0xe7, 0x5c, 0xa8, 0x70, 0xf6, 0xd3, 0xb6, 0x91, 0xe6, 0xf1, 0x50,
	0x64, 0x69, 0xe1, 0xf6, 0xc2, 0xad, 0x5c, 0x1a, 0xe2, 0x2c, 0xe2, 0xf4, 0x48, 0x80, 0x46, 0xf1,
	0x23, 0xde, 0x28, 0x9e, 0xe6, 0x49, 0xff, 0x15, 0xc1, 0xf9, 0xfe, 0xb3, 0x30, 0xcd, 0x02, 0xbc,
	0x92, 0x38, 0xfa, 0x3e, 0xfc, 0xd5, 0xca, 0x61, 0x25, 0xfd, 0xb2, 0x87, 0x2e, 0xc2, 0x2c, 0x4c,
	0x56, 0x35, 0x9b, 0xa4, 0xe9, 0x9c, 0x69, 0x7e, 0xad, 0x4a, 0xcd, 0x2a, 0xb4, 0xb4, 0x70, 0x33,
	0x37, 0x37, 0xb8, 0x90, 0xa4, 0x73, 0xc9, 0x49, 0x9d, 0x7e, 0x5f, 0x91, 0x7f, 0x16, 0x04, 0x90,
	0x8d, 0xae, 0x4d, 0xb8, 0x10, 0x96, 0x85, 0x45, 0xf1, 0x48, 0xc5, 0xef, 0xb1, 0x7d, 0x96, 0x29,
	0xec, 0xed, 0xbd, 0x7e, 0x81, 0x48, 0x90, 0xc5, 0x57, 0xfe, 0x8f, 0x3a, 0x8e, 0x18, 0x8a, 0xb8,
	0x11, 0x73, 0xd0, 0xf0, 0xfb, 0xbe, 0x02, 0x05, 0x5e, 0x29, 0x7b, 0xd5, 0x47, 0xe6, 0x58, 0x69,
	0x0b, 0x72, 0xde, 0x47, 0x7b, 0x9a, 0xb8, 0xec, 0xd8, 0x76, 0x47, 0x38, 0x22, 0x66, 0x2a, 0xe3,
	0x47, 0x42, 0xe3, 0x35, 0xdb, 0xee, 0x70, 0xaf, 0x24, 0xc3, 0x8e, 0xfb, 0x9b, 0xe6, 0x7c, 0xd1,
	0x9b, 0x0b, 0x4b, 0x0b, 0x6f, 0x2e, 0x2c, 0x0b, 0x29, 0x27, 0xd9, 0x6c, 0x69, 0xf7, 0x5b, 0x2f,
	0xec, 0x8c, 0x67, 0x4a, 0x00, 0x8f, 0xd4, 0xa6, 0xf3, 0x9e, 0xf0, 0x1e, 0x84, 0xf6, 0xd4, 0xb3,
	0xbd, 0x27, 0x48, 0x9f, 0x3c, 0xa1, 0xb0, 0xde, 0x27, 0x84, 0x3d, 0xb5, 0x99, 0x69, 0x40, 0x92,
	0xd2, 0xa3, 0x01, 0xa5, 0x43, 0xf4, 0x7d, 0x18, 0xdd, 0x53, 0x9b, 0x03, 0x11, 0xec, 0xe9, 0xf5,
	0x70, 0x2e, 0x86, 0x67, 0x82, 0xd8, 0x9e, 0xa0, 0x9c, 0xf9, 0x97, 0x08, 0xa2, 0x8f, 0xd4, 0xa6,
	0x78, 0x8e, 0x17, 0x3c, 0x0f, 0x4b, 0x1e, 0xfa, 0x6b, 0xa3, 0x59, 0xf9, 0x9e, 0xda, 0xc4, 0xbf,
	0xe3, 0xe5, 0x26, 0x38, 0xd4, 0x4c, 0x7c, 0x0b, 0xa0, 0x3b, 0xd4, 0x99, 0x39, 0x37, 0x05, 0x31,
	0x93, 0x34, 0xd9, 0x2b, 0x11, 0xbb, 0x77, 0xa7, 0xde, 0x45, 0x3c, 0x05, 0x66, 0x5a, 0x30, 0x99,
	0xed, 0x74, 0x64, 0xa3, 0x45, 0xb2, 0x5d, 0x7b, 0xc7, 0x7d, 0xe8, 0x9e, 0x81, 0xa8, 0x69, 0xd0,
	0xdc, 0xc2, 0x29, 0x9e, 0x1b, 0xa1, 0xcd, 0x22, 0x3d, 0xde, 0x47, 0x9d, 0x67, 0xc7, 0xb3, 0x57,
	0x3b, 0x71, 0x8c, 0x62, 0x23, 0xf3, 0x1f, 0x11, 0x4c, 0xb0, 0x77, 0xe9, 0x81, 0xc9, 0xd6, 0x20,
	0xa1, 0x76, 0x3a, 0x0a, 0x9b, 0x50, 0xed, 0xba, 0x3b, 0xc1, 0x9f, 0x32, 0x0c, 0xe1, 0x93, 0x26,
	0xb0, 0x6a, 0xbf, 0x1b, 0xbf, 0x05, 0x11, 0xdb, 0x78, 0x4c, 0xf4, 0x33, 0x72, 0x46, 0xb7, 0x36,
	0x83, 0xcf, 0xcd, 0x40, 0x9c, 0xce, 0x2c, 0x36, 0xc3, 0x11, 0x29, 0x7d, 0x1c, 0x04, 0x49, 0x26,
	0xd6, 0x20, 0xdb, 0x39, 0x80, 0x2d, 0xd5, 0xd2, 0xea, 0x5e, 0x9e, 0x2f, 0x1f, 0x57, 0xe0, 0xe3,
	0x96, 0x92, 0xad, 0x05, 0xe4, 0xd1, 0x2d, 0xb7, 0xae, 0xec, 0x3e, 0x8c, 0x89, 0x0d, 0xc9, 0xa9,
	0x04, 0x87, 0x56, 0xe9, 0xf9, 0xab, 0xbd, 0x5c, 0xee, 0xe3, 0x02, 0x99, 0xd1, 0x7a, 0x04, 0x13,
	0xde, 0x1d, 0xcd, 0x09, 0xf2, 0x94, 0xe5, 0xd5, 0x33, 0xd4, 0x1d, 0xb9, 0x44, 0x93, 0x9e, 0x3d,
	0x4d, 0x01, 0x8f, 0x13, 0x8e, 0xf3, 0x74, 0xf3, 0x9d, 0x10, 0xe0, 0x35, 0xc3, 0xb2, 0xb3, 0xec,
	0xb3, 0x49, 0x57, 0x3c, 0x37, 0x61, 0x84, 0xcd, 0x46, 0xc4, 0xad, 0xb7, 0x7f, 0xff, 0x6c, 0xc8,
	0xeb, 0x55, 0x36, 0xce, 0xbf, 0xcb, 0xe3, 0xb0, 0xf8, 0x1d, 0x48, 0x5a, 0xc4, 0xdc, 0x25, 0xa6,
	0x42, 0xf4, 0x46, 0xc7, 0xd0, 0x74, 0xe1, 0xbc, 0x3d, 0xc1, 0xa3, 0x08, 0xc5, 0xe4, 0x71, 0x0e,
	0x58, 0x10, 0x70, 0xb8, 0x08, 0xc0, 0x6e, 0x0b, 0xd9, 0x69, 0x2f, 0xb2, 0x2a, 0x7f, 0xde, 0x37,
	0xf4, 0x96, 0x4d, 0x98, 0xe9, 0xa8, 0xdd, 0xb2, 0x78, 0xa8, 0x80, 0xef, 0xc1, 0xb8, 0x49, 0xe3,
	0x4f, 0xb6, 0x6c, 0x4f, 0x8d, 0x85, 0x5f, 0x31, 0x7e, 0x9b, 0x58, 0x0b, 0xc8, 0x63, 0xa6, 0xa7,
	0x0f, 0xdf, 0x07, 0x5e, 0x65, 0xe1, 0xa1, 0xc4, 0x0b, 0x2a, 0xd2, 0xc3, 0xaa, 0x35, 0x7c, 0xa4,
	0x12, 0xbb, 0xde, 0xce, 0x61, 0x6a, 0x88, 0x7c, 0xda, 0x43, 0xd1, 0xfb, 0xe1, 0x58, 0x54, 0x8a,
	0x65, 0xfe, 0xc6, 0x29, 0xfd, 0xf1, 0xe9, 0xe1, 0x15, 0x00, 0xc1, 0x42, 0xa3, 0xe1, 0x14, 0xc5,
	0x8c, 0x72, 0xca, 0x8d, 0x86, 0x89, 0xd3, 0x30, 0xc6, 0x87, 0x45, 0xfe, 0xc8, 0xcb, 0x7d, 0x38,
	0x0a, 0x4f, 0x10, 0x8f, 0x6c, 0xcf, 0xd0, 0xaf, 0xbc, 0x3d, 0xc3, 0xbf, 0xe4, 0xf6, 0x1c, 0x87,
	0x31, 0x3a, 0xb3, 0x73, 0x7b, 0x94, 0xf9, 0x27, 0x41, 0x48, 0x7a, 0xea, 0x5b, 0x44, 0xf1, 0x82,
	0x28, 0x8d, 0x51, 0xd9, 0xfa, 0xb9, 0xb0, 0xd1, 0xf1, 0xa5, 0x31, 0x83, 0x62, 0x72, 0xeb, 0x61,
	0xfa, 0xdd, 0xf8, 0x35, 0x48, 0x38, 0xc5, 0x43, 0xfc, 0x0b, 0x5a, 0x27, 0x8c, 0x18, 0x73, 0xba,
	0x4b, 0x34, 0xda, 0xba, 0x04, 0x71, 0xe1, 0x12, 0xd9, 0x31, 0xce, 0x0b, 0xa3, 0x80, 0x77, 0xd1,
	0xd3, 0x1b, 0xbf, 0xee, 0x56, 0x41, 0x59, 0xdd, 0x2d, 0x0e, 0x14, 0x16, 0x25, 0x5f, 0xac, 0xbb,
	0xda, 0xdd, 0x62, 0x70, 0xaf, 0x81, 0xa8, 0x79, 0x72, 0x5f, 0x76, 0x22, 0x5e, 0x30, 0xf1, 0x68,
	0x93, 0x4b, 0x42, 0x42, 0x2c, 0x51, 0x48, 0xe3, 0xc7, 0x08, 0xb0, 0xf3, 0x22, 0x77, 0x96, 0x4a,
	0x24, 0xf4, 0x55, 0x54, 0x22, 0x55, 0x86, 0x55, 0x22, 0x05, 0x7f, 0x69, 0x71, 0xf7, 0x29, 0xe6,
	0xa6, 0x40, 0x54, 0xe0, 0xb0, 0x93, 0xca, 0x59, 0xdc, 0x9f, 0x23, 0x48, 0x54, 0x0c, 0x93, 0xdf,
	0x6f, 0x8a, 0x6f, 0xc5, 0x43, 0x6a, 0xab, 0x25, 0x56, 0x71, 0xdc, 0xad, 0x02, 0x05, 0xc1, 0x37,
	0x60, 0xac, 0x6b, 0x11, 0x53, 0x69, 0x90, 0xa6, 0xa6, 0x93, 0x86, 0x48, 0x43, 0xe3, 0x2c, 0x89,
	0x9b, 0x0f, 0xa7, 0x7e, 0xf1, 0x8b, 0x10, 0xb5, 0x50, 0x0a, 0xb2, 0xca, 0x21, 0x28, 0xed, 0x86,
	0x6e, 0x9d, 0x72, 0x1f, 0x47, 0x41, 0x72, 0x19, 0x98, 0x66, 0xb7, 0x89, 0x3c, 0xde, 0xf3, 0x70,
	0x7c, 0xc4, 0x3f, 0x7e, 0x08, 0x17, 0x06, 0xab, 0x30, 0x64, 0xd2, 0x24, 0x26, 0x8d, 0x9d, 0xd9,
	0x72, 0x64, 0x08, 0x9b, 0xa4, 0x69, 0x7d, 0x45, 0x55, 0x37, 0x8c, 0x16, 0xf5, 0x05, 0xb3, 0x83,
	0x73, 0x0e, 0x7c, 0xbf, 0x7f, 0x0b, 0xc0, 0xd2, 0x6c, 0xa2, 0xb4, 0x8c, 0xba, 0x7a, 0x9a, 0x20,
	0x47, 0x29, 0xe4, 0x3a, 0x05, 0xc4, 0x39, 0x98, 0xe8, 0xa3, 0x29, 0x9a, 0x6e, 0x69, 0x0d, 0xa7,
	0x8e, 0xe0, 0x38, 0xec, 0xa4, 0x8b, 0x5d, 0x64, 0xe0, 0x78, 0x11, 0x46, 0xd8, 0xc7, 0xc5, 0xf5,
	0x53, 0x6e, 0x2a, 0x05, 0x54, 0x6e, 0x16, 0xc6, 0x77, 0xf5, 0xa1, 0xe2, 0x75, 0xea, 0x1d, 0xf6,
	0x60, 0x4c, 0x26, 0xb6, 0x79, 0x90, 0x53, 0xeb, 0x8f, 0xcb, 0xcd, 0x26, 0xbe, 0x0d, 0x89, 0x2d,
	0xd5, 0x12, 0xd7, 0xa2, 0xbb, 0x62, 0x7d, 0x09, 0x56, 0xef, 0x18, 0x5c, 0xbe, 0xe5, 0x9c, 0x22,
	0xc1, 0xf9, 0x80, 0x3c, 0x46, 0xe1, 0x8a, 0x02, 0x0c, 0x7f, 0x0d, 0xc6, 0x68, 0x5a, 0xeb, 0xa2,
	0x71, 0x63, 0x11, 0x17, 0x24, 0x6d, 0x75, 0xdf, 0x01, 0x74, 0x2f, 0x48, 0xfe, 0x59, 0x08, 0x92,
	0x6c, 0x66, 0x9e, 0x66, 0x32, 0xc9, 0x7e, 0x07, 0xd1, 0x58, 0xcb, 0x36, 0x0f, 0x14, 0xf7, 0x73,
	0x58, 0xcd, 0x99, 0xf2, 0xf7, 0xcc, 0xdf, 0x95, 0x03, 0x72, 0xe8, 0xd6, 0xfe, 0xbe, 0x9c, 0xd8,
	0x56, 0x6d, 0xb2, 0xa7, 0x1e, 0x5c, 0x23, 0xa6, 0x69, 0x98, 0x72, 0xb2, 0x6e, 0xe8, 0x3a, 0xa9,
	0xdb, 0xd7, 0x9a, 0xaa, 0xd6, 0xea, 0x9a, 0x44, 0x1e, 0x37, 0x49, 0xb3, 0x6b, 0x91, 0xc6, 0x35,
	0x7e, 0x5a, 0xc9, 0x09, 0x4a, 0x53, 0x53, 0xb7, 0x5a, 0xe4, 0xda, 0xcd, 0xfd, 0x7d, 0x79, 0xba,
	0xdf, 0xe4, 0x9f, 0x8d, 0x5f, 0xab, 0x1b, 0x0d, 0x62, 0xc9, 0x51, 0x36, 0x75, 0x59, 0xc7, 0x8b,
	0x10, 0xd7, 0xbb, 0x6d, 0x85, 0x81, 0xb9, 0xd7, 0x2f, 0x09, 0xf7, 0xed, 0x67, 0x3e, 0x98, 0x8a,
	0xc9, 0xa0, 0x77, 0xdb, 0x32, 0x07, 0xc0, 0x6f, 0x41, 0xb2, 0x43, 0x4c, 0x85, 0xf2, 0x6d, 0x6b,
	0x6d, 0x62, 0x74, 0x6d, 0x71, 0xeb, 0x92, 0x74, 0x70, 0xe8, 0x7e, 0x79, 0xf1, 0x3f, 0xaf, 0xc8,
	0x89, 0x0e, 0x31, 0x6b, 0xe6, 0x41, 0x8d, 0x43, 0xe1, 0x55, 0xe8, 0xf3, 0xa2, 0x88, 0x0f, 0xdb,
	0x19, 0x2f, 0xec, 0x9d, 0x2e, 0xe1, 0x29, 0xc1, 0x60, 0x17, 0x19, 0xf2, 0x94, 0x0b, 0xcd, 0xbf,
	0x3a, 0xcf, 0x53, 0x58, 0x7c, 0x1b, 0x62, 0x5b, 0x6a, 0xfd, 0xb1, 0x62, 0x34, 0x9b, 0xe2, 0xa0,
	0xbd, 0x70, 0xe4, 0xa0, 0xed, 0x6b, 0x58, 0x8e, 0x6e, 0xf1, 0x1f, 0xbe, 0x92, 0xd0, 0x2c, 0xc4,
	0x1f, 0x52, 0xea, 0xf5, 0x4d, 0x51, 0xe6, 0x31, 0xda, 0xff, 0x8c, 0x82, 0xaa, 0x82, 0x9e, 0xf0,
	0xee, 0xe7, 0x11, 0x43, 0x3f, 0x42, 0xcb, 0x7c, 0x86, 0x20, 0x5e, 0x22, 0xfb, 0xf6, 0x9a, 0xd1,
	0x11, 0xc5, 0xbd, 0xfd, 0x3f, 0x2d, 0x31, 0x7e, 0x84, 0x29, 0x0f, 0xa4, 0x25, 0xfe, 0xaa, 0x44,
	0x01, 0x92, 0x3a, 0xd9, 0xb7, 0x77, 0x8c, 0x0e, 0x3b, 0x6e, 0x89, 0xe5, 0xc4, 0xeb, 0xfe, 0x7d,
	0x5d, 0xec, 0x64, 0xf9, 0x38, 0xaf, 0x75, 0x15, 0x48, 0xa2, 0x0f, 0x7f, 0x0b, 0x46, 0x99, 0x1d,
	0x36, 0xd5, 0x3a, 0x11, 0x99, 0xd9, 0xc9, 0x8e, 0x61, 0xee, 0x93, 0x27, 0x13, 0x4e, 0x35, 0x98,
	0x8b, 0xe9, 0xfd, 0x2c, 0xc7, 0xed, 0xcc, 0xfc, 0x9f, 0x20, 0x24, 0xa9, 0xf0, 0xb5, 0x3a, 0xcb,
	0x41, 0xc5, 0x75, 0x79, 0x44, 0xb5, 0x6d, 0xf1, 0xb5, 0xc1, 0xd1, 0x50, 0x8d, 0x01, 0x66, 0x6d,
	0x9b, 0x67, 0x7e, 0xe0, 0xd2, 0x0d, 0xcb, 0x1c, 0x0d, 0xe7, 0x20, 0x6a, 0x75, 0xb7, 0x74, 0x62,
	0x3b, 0xe9, 0xe8, 0x85, 0x23, 0xcb, 0xad, 0xb2, 0x71, 0x46, 0x20, 0xde, 0xbf, 0x45, 0x0b, 0xca,
	0x0e, 0x22, 0xbe, 0x09, 0x51, 0x21, 0x05, 0x51, 0x53, 0x39, 0x7b, 0xbc, 0xb8, 0x65, 0x07, 0x14,
	0x6f, 0xba, 0x9f, 0x7a, 0xc6, 0xd9, 0xc4, 0xf3, 0x43, 0xfe, 0xb8, 0x81, 0x67, 0xa5, 0x03, 0x1f,
	0x79, 0xe2, 0x8f, 0x9f, 0xa3, 0x10, 0x20, 0x34, 0xe4, 0x5b, 0xcf, 0x5f, 0xe1, 0x2b, 0x48, 0x66,
	0x95, 0xcb, 0x0b, 0x4b, 0x37, 0x16, 0x96, 0x96, 0x16, 0x96, 0x32, 0x9f, 0x87, 0x61, 0xfa, 0xae,
	0x61, 0xee, 0xa9, 0x66, 0xa3, 0x62, 0x1a, 0xfb, 0x07, 0x9e, 0xcb, 0x54, 0x05, 0xce, 0xed, 0xed,
	0x30, 0x87, 0xaa, 0xb1, 0xdb, 0x62, 0xdf, 0x43, 0xd7, 0x1b, 0x2f, 0x3c, 0xd7, 0x9d, 0xc3, 0x1e,
	0xbc, 0xde, 0xf3, 0xdc, 0x0b, 0x4e, 0x32, 0x4a, 0xeb, 0x8c, 0x50, 0xc5, 0x79, 0xf1, 0x5a, 0x07,
	0x3c, 0x38, 0x81, 0x61, 0x0a, 0x0d, 0x25, 0x72, 0x73, 0x2f, 0x9c, 0xef, 0x4f, 0x3f, 0x42, 0xb1,
	0x8c, 0x38, 0x0e, 0xfb, 0xa4, 0x65, 0xc9, 0x4b, 0x90, 0xe2, 0xe1, 0x55, 0x98, 0xa2, 0x0e, 0x52,
	0xf8, 0x2a, 0x45, 0xb5, 0x6d, 0xd2, 0xee, 0xd8, 0x96, 0xf0, 0x14, 0x98, 0xd2, 0xfb, 0x71, 0x0f,
	0xa1, 0xa5, 0xbe, 0x8b, 0xc1, 0x6d, 0x75, 0x3f, 0xcf, 0xc1, 0xb3, 0x02, 0x1a, 0xdf, 0x05, 0x2c,
	0x28, 0x38, 0x1f, 0x3a, 0x51, 0x6f, 0x13, 0xe6, 0x77, 0xbc, 0x82, 0x46, 0x78, 0xf9, 0xc6, 0x8d,
	0x1b, 0x5e, 0xaf, 0x33, 0xd1, 0x47, 0x71, 0x3c, 0xcf, 0x37, 0x20, 0xa9, 0x1b, 0x83, 0x6f, 0x5f,
	0x23, 0x27, 0x9e, 0x28, 0xe3, 0xba, 0x31, 0xf0, 0x80, 0x56, 0x86, 0x04, 0x4d, 0x17, 0x5c, 0x0a,
	0xe2, 0xc5, 0xe3, 0x94, 0x87, 0xaa, 0x81, 0xe8, 0x74, 0xcc, 0xf6, 0x0c, 0xae, 0x54, 0x5f, 0xf6,
	0x50, 0x19, 0x2e, 0xc2, 0xb9, 0xea, 0x63, 0xad, 0x93, 0x76, 0x4a, 0x6d, 0xd2, 0x1d, 0xd5, 0xb4,
	0x34, 0x7d, 0x1b, 0xd3, 0x33, 0x03, 0xae, 0xc3, 0xd5, 0xbb, 0xdc, 0xc7, 0xa7, 0x77, 0x54, 0xbd,
	0xd1, 0xd2, 0xf4, 0x6d, 0xf6, 0xd5, 0x44, 0xd7, 0x79, 0xbb, 0xe8, 0x2f, 0x14, 0xb3, 0xc7, 0x84,
	0x45, 0x98, 0x19, 0xe0, 0x92, 0x0a, 0x4d, 0x1c, 0x84, 0x93, 0x2f, 0x7a, 0x68, 0xc4, 0x79, 0x52,
	0xb8, 0xbd, 0xf0, 0xd6, 0xcf, 0x7b, 0x08, 0x89, 0x33, 0xf1, 0x19, 0x82, 0x71, 0x9a, 0x92, 0x15,
	0xd9, 0x1d, 0x6b, 0x53, 0x23, 0x26, 0xbe, 0x04, 0x41, 0xad, 0x23, 0x8e, 0xa4, 0x84, 0xa7, 0x0a,
	0xa0, 0x43, 0x17, 0x12, 0xd4, 0x3a, 0xf8, 0x96, 0xe7, 0x4f, 0xc9, 0x9c, 0xf4, 0x6c, 0xbc, 0x43,
	0x11, 0x5c, 0x50, 0x7a, 0x40, 0xbb, 0xe5, 0x6a, 0x86, 0xa9, 0x68, 0x9d, 0x23, 0xf1, 0xcf, 0x1f,
	0x22, 0xf1, 0x02, 0x43, 0xdd, 0x8f, 0x87, 0xa3, 0x25, 0x88, 0xa9, 0xfa, 0x01, 0x5d, 0x5a, 0xf3,
	0x94, 0x18, 0x24, 0xaa, 0xea, 0x07, 0x45, 0xdd, 0x6e, 0xe2, 0xd7, 0x21, 0xcc, 0xc0, 0x8f, 0x49,
	0x09, 0xd7, 0x02, 0x32, 0x1b, 0xcf, 0x5d, 0x04, 0xc9, 0x75, 0x78, 0xc7, 0x85, 0x65, 0x7f, 0x8b,
	0x00, 0xbb, 0x6c, 0x95, 0x4d, 0xa7, 0xc8, 0xd3, 0x99, 0x02, 0x9d, 0x3c, 0x05, 0xbe, 0x02, 0xa1,
	0x8e, 0xd1, 0x38, 0x81, 0x13, 0x3a, 0x8c, 0x1f, 0x40, 0x54, 0x84, 0x2f, 0x6c, 0x9b, 0x9c, 0xa5,
	0x3e, 0x37, 0x97, 0x60, 0x35, 0x71, 0xff, 0x10, 0x45, 0x66, 0x43, 0x01, 0x44, 0x23, 0xd4, 0x91,
	0x5d, 0xa7, 0x04, 0x32, 0xb8, 0xab, 0x8b, 0x3f, 0x1a, 0x33, 0x6c, 0xc6, 0xe0, 0xae, 0x7e, 0xe2,
	0xca, 0x45, 0xc4, 0x34, 0xbf, 0x07, 0xd0, 0xbf, 0x85, 0xc3, 0x51, 0x08, 0x65, 0x4b, 0x1f, 0x48,
	0x01, 0xfa, 0xe3, 0x5e, 0xa1, 0x26, 0x21, 0x1c, 0x83, 0xf0, 0x5a, 0x21, 0xbb, 0x2a, 0x05, 0xe9,
	0xaf, 0x4a, 0xb9, 0x5a, 0x93, 0x42, 0x74, 0xb0, 0xb2, 0x51, 0x93, 0xc2, 0x18, 0x60, 0x64, 0xb5,
	0xb0, 0x5e, 0xa8, 0x15, 0xa4, 0x08, 0x8e, 0x43, 0x34, 0x5f, 0x2e, 0x95, 0x0a, 0xf9, 0x9a, 0x34,
	0x42, 0x1b, 0xe5, 0x4a, 0xad, 0x58, 0x2e, 0x55, 0xa5, 0x28, 0x1e, 0x85, 0x48, 0x4d, 0xce, 0xe6,
	0x0b, 0x52, 0x8c, 0xfe, 0xac, 0x64, 0x6b, 0xf9, 0x35, 0x69, 0x74, 0x3e, 0x07, 0x13, 0x47, 0xfe,
	0xd8, 0x0c, 0x3e, 0x0f, 0xe7, 0xaa, 0xb5, 0x6c, 0x6d, 0xa3, 0xaa, 0xac, 0x96, 0x95, 0x52, 0xb9,
	0xa6, 0x54, 0x36, 0x72, 0xeb, 0xc5, 0xea, 0x9a, 0x14, 0xc0, 0x18, 0xc6, 0xc5, 0x90, 0xd3, 0x87,
	0xe6, 0x57, 0x00, 0x1f, 0x2d, 0xe3, 0xc7, 0x12, 0x8c, 0x39, 0xed, 0x92, 0xa1, 0x13, 0x8e, 0xeb,
	0xf4, 0xe4, 0x54, 0x8b, 0xdc, 0xbe, 0x29, 0xa1, 0xf9, 0x2b, 0x90, 0x18, 0xb8, 0x75, 0x60, 0x2b,
	0xad, 0xd5, 0x2a, 0x52, 0x80, 0x72, 0x49, 0x7f, 0x55, 0x25, 0x34, 0x5f, 0x86, 0xb8, 0xa7, 0x76,
	0x0e, 0x8f, 0x41, 0x8c, 0x95, 0xb8, 0x6d, 0xd4, 0xca, 0x52, 0x80, 0xae, 0xb2, 0xb6, 0x5e, 0xdd,
	0x5d, 0x52, 0x6e, 0x48, 0xa8, 0xdf, 0x58, 0x92, 0x82, 0xfd, 0xc6, 0xb2, 0x14, 0xea, 0x37, 0xde,
	0x94, 0xc2, 0xf3, 0x57, 0x21, 0x49, 0x0f, 0x20, 0x4d, 0xdf, 0xae, 0x98, 0x9a, 0x61, 0x6a, 0xf6,
	0x01, 0x1d, 0x5f, 0x2d, 0xdc, 0xcd, 0x6e, 0xac, 0xd7, 0xa4, 0x00, 0xe3, 0xa2, 0x78, 0x8f, 0x2e,
	0xee, 0x77, 0x20, 0xe9, 0x7b, 0xa1, 0xa3, 0x90, 0x6b, 0x1b, 0xa5, 0x55, 0xb9, 0xb0, 0x2a, 0x05,
	0xe8, 0x32, 0x6b, 0x85, 0x92, 0x52, 0x5b, 0x2b, 0x6f, 0x54, 0xb3, 0xa5, 0x55, 0xce, 0xc2, 0xc3,
	0xe2, 0xfa, 0x7a, 0xb1, 0x5c, 0x92, 0x82, 0xf3, 0xef, 0x41, 0x62, 0x55, 0xb3, 0xea, 0xc6, 0x2e,
	0x31, 0x0f, 0xc4, 0xe7, 0x30, 0x13, 0xc5, 0xd2, 0x66, 0x76, 0xbd, 0xb8, 0xaa, 0xac, 0x16, 0xab,
	0xf9, 0xf2, 0x66, 0x41, 0xfe, 0x40, 0x0a, 0xcc, 0x86, 0x9e, 0x3e, 0x41, 0x54, 0xa3, 0x0f, 0xde,
	0xae, 0x4a, 0x88, 0x6a, 0x34, 0x5f, 0x2e, 0x55, 0x37, 0xd6, 0xa5, 0xe0, 0xfc, 0x55, 0x88, 0x3f,
	0x52, 0x9b, 0x0f, 0x8d, 0x06, 0x97, 0xcf, 0x28, 0x44, 0x72, 0xeb, 0xe5, 0xfc, 0x03, 0x29, 0x80,
	0xc7, 0x01, 0xb2, 0xeb, 0x05, 0xb9, 0xa6, 0x94, 0x4b, 0xeb, 0x1f, 0x48, 0x68, 0xbe, 0x0a, 0xf1,
	0x4d, 0xad, 0xb3, 0x69, 0x9a, 0x1d, 0xa1, 0x45, 0x69, 0xb3, 0x58, 0x51, 0x36, 0x65, 0xb9, 0xa2,
	0x88, 0x29, 0x9d, 0x89, 0x26, 0x21, 0xe9, 0x0e, 0x15, 0x4a, 0xd9, 0xdc, 0x7a, 0x41, 0x42, 0x78,
	0xca, 0x03, 0xbf, 0x5a, 0xac, 0xb2, 0xde, 0xe0, 0xfc, 0xdf, 0x87, 0xa9, 0xaa, 0x66, 0x93, 0x9a,
	0xc1, 0xfe, 0xdf, 0xd5, 0x75, 0xd2, 0x62, 0xd4, 0xaf, 0x40, 0xba, 0x5a, 0xac, 0x15, 0x94, 0x5a,
	0x59, 0xe1, 0xff, 0x6e, 0x94, 0x4a, 0x85, 0x75, 0xa5, 0x58, 0xa9, 0x16, 0xf2, 0x4a, 0x59, 0x56,
	0xaa, 0xd5, 0x75, 0x29, 0x80, 0x5f, 0x81, 0xf3, 0xc7, 0x42, 0x49, 0x08, 0x5f, 0x80, 0x99, 0x61,
	0xc3, 0x14, 0x37, 0x98, 0x09, 0xc7, 0x42, 0x52, 0x68, 0x7e, 0x1e, 0x46, 0xab, 0x86, 0x69, 0x97,
	0xcd, 0x06, 0x31, 0xe9, 0x8a, 0x57, 0x0b, 0xd5, 0x7c, 0xa1, 0xb4, 0x5a, 0x2c, 0xdd, 0x93, 0x02,
	0x38, 0x01, 0xa3, 0x59, 0xb7, 0x89, 0xe6, 0x8b, 0x30, 0xc3, 0x39, 0x2c, 0xe8, 0x75, 0xb5, 0x63,
	0x89, 0x8a, 0x65, 0xc6, 0x6e, 0x02, 0x46, 0x39, 0x6b, 0x95, 0x07, 0x45, 0x8e, 0x28, 0x9a, 0xd5,
	0x07, 0x12, 0x13, 0x3c, 0x9b, 0x93, 0x6d, 0x38, 0xb9, 0x20, 0x85, 0xe6, 0xdf, 0x02, 0xa8, 0xb1,
	0x0f, 0x67, 0x1d, 0x8d, 0x6f, 0x94, 0x1e, 0x94, 0xca, 0x8f, 0x4a, 0x52, 0x80, 0x5a, 0xdf, 0x5d,
	0xb9, 0x50, 0x78, 0x58, 0xdc, 0x78, 0x28, 0x21, 0xca, 0x52, 0xa1, 0x54, 0x2b, 0xc8, 0x15, 0xb9,
	0x58, 0xa5, 0xf2, 0xfa, 0xf7, 0x08, 0xa4, 0x9a, 0xba, 0x5f, 0xd8, 0xa7, 0x67, 0xab, 0x33, 0x7b,
	0x12, 0xe2, 0xb5, 0xec, 0x37, 0x95, 0x3e, 0x0d, 0xd1, 0x21, 0x17, 0xee, 0x6d, 0xac, 0x67, 0x65,
	0x09, 0xd1, 0x2d, 0x47, 0x3b, 0x0a, 0xdf, 0x2c, 0x3c, 0xac, 0xd4, 0x94, 0x8d, 0xd2, 0x66, 0x41,
	0x2e, 0xde, 0x2d, 0x16, 0xe8, 0x8e, 0x9f, 0x81, 0x49, 0xcf, 0x90, 0x3b, 0x10, 0xc2, 0x19, 0x98,
	0x3b, 0x32, 0x90, 0xcf, 0xd2, 0xfd, 0xae, 0xdc, 0xcd, 0x16, 0xd7, 0x0b, 0xab, 0x52, 0x18, 0xbf,
	0x0a, 0x97, 0x8e, 0x83, 0xa9, 0x08, 0xb9, 0x45, 0xe6, 0xbf, 0x0d, 0xb1, 0x4a, 0x4b, 0xd5, 0x9d,
	0xfd, 0x47, 0x57, 0xc7, 0xcd, 0xab, 0x58, 0x5a, 0x2d, 0x6e, 0x16, 0x57, 0x37, 0xb2, 0xeb, 0xdc,
	0x07, 0xd5, 0x0a, 0xd9, 0x87, 0x52, 0x90, 0xda, 0x7c, 0x59, 0xbe, 0x97, 0x2d, 0x15, 0xbf, 0xc5,
	0x28, 0x49, 0x21, 0xca, 0x7e, 0x65, 0x3d, 0x5b, 0x52, 0x6a, 0x1f, 0x54, 0x0a, 0xca, 0x46, 0xa9,
	0x5a, 0x29, 0xe4, 0x39, 0x97, 0xe1, 0xf9, 0x34, 0x24, 0x78, 0x0e, 0xc0, 0x82, 0xb7, 0x72, 0x07,
	0x8f, 0x40, 0xb0, 0xf0, 0x3e, 0x77, 0x6e, 0xa5, 0xc2, 0xfb, 0x12, 0x9a, 0xff, 0x18, 0x41, 0x62,
	0x20, 0x9e, 0xa5, 0xa6, 0x28, 0x97, 0x37, 0x6a, 0x05, 0x25, 0x5b, 0xab, 0xc9, 0x4a, 0xa9, 0xac,
	0x94, 0xa9, 0x43, 0x48, 0xc1, 0x94, 0xa7, 0x37, 0xbb, 0xba, 0x59, 0x90, 0x6b, 0x54, 0xe8, 0xcc,
	0x8e, 0x3c, 0x23, 0xc5, 0x52, 0xb5, 0x96, 0x5d, 0x5f, 0x57, 0xd6, 0xa8, 0x9f, 0x0c, 0xe2, 0xcb,
	0xf0, 0xca, 0x90, 0xc1, 0xbb, 0x65, 0xf9, 0x51, 0x56, 0x66, 0x02, 0x60, 0xec, 0x7b, 0x40, 0x1e,
	0x16, 0xe4, 0x7b, 0x05, 0xbe, 0xa9, 0xc2, 0xf3, 0x7f, 0x8a, 0x60, 0xcc, 0x9b, 0x55, 0xe0, 0x8b,
	0x90, 0x2a, 0x15, 0xbe, 0x59, 0x53, 0xd6, 0xca, 0x15, 0x45, 0x38, 0x0c, 0xe5, 0x5e, 0xb6, 0x56,
	0x78, 0x94, 0xa5, 0x1e, 0xfb, 0x02, 0xcc, 0xb8, 0xa3, 0x1b, 0xd5, 0x82, 0x92, 0x2f, 0x97, 0xee,
	0x16, 0xef, 0x6d, 0x50, 0x5f, 0x81, 0xf0, 0x1c, 0xcc, 0xba, 0x83, 0xa5, 0x42, 0xed, 0x51, 0x59,
	0x7e, 0xa0, 0x14, 0xa9, 0xf1, 0xdc, 0xa5, 0x7e, 0x39, 0x88, 0x67, 0x41, 0xea, 0x93, 0x2e, 0x56,
	0xf3, 0x59, 0x79, 0x55, 0x0a, 0xf1, 0x6f, 0x31, 0xf1, 0x65, 0x0f, 0xe1, 0x6a, 0x29, 0x5b, 0xa3,
	0x7b, 0x86, 0xb9, 0xe0, 0xbc, 0x14, 0xe6, 0x20, 0xb9, 0x7f, 0x84, 0x3e, 0xfd, 0x6c, 0x2e, 0xf0,
	0xa3, 0xcf, 0xe6, 0x02, 0x3f, 0xff, 0x6c, 0x0e, 0x7d, 0xf1, 0xd9, 0x1c, 0x7a, 0x7a, 0x38, 0x87,
	0xfe, 0xf4, 0x70, 0x0e, 0xfd, 0xe7, 0xc3, 0x39, 0xf4, 0xe2, 0x70, 0x0e, 0xfd, 0xe0, 0x70, 0x0e,
	0x7d, 0x7a, 0x38, 0x87, 0x7e, 0x74, 0x38, 0x87, 0x7e, 0x72, 0x38, 0x87, 0xfe, 0xfa, 0x70, 0x2e,
	0xf0, 0xf3, 0xc3, 0x39, 0xf4, 0x07, 0x3f, 0x9d, 0x0b, 0xbc, 0xf8, 0xe9, 0x1c, 0xfa, 0x56, 0x7e,
	0xdb, 0xe8, 0x3c, 0xde, 0x5e, 0x74, 0x4a, 0x49, 0x16, 0xbb, 0xd6, 0x75, 0xf6, 0xa3, 0x69, 0x98,
	0xed, 0x6b, 0xce, 0x15, 0xdb, 0x35, 0x67, 0xf8, 0x7a, 0x67, 0x6b, 0xdb, 0xb8, 0x4e, 0xf6, 0x6d,
	0xf1, 0x07, 0x15, 0xf9, 0x3f, 0x5b, 0x23, 0xac, 0x1c, 0xfa, 0xcd, 0xff, 0x17, 0x00, 0x00, 0xff,
	0xff, 0x76, 0x09, 0xea, 0x5a, 0x3d, 0x52, 0x00, 0x00,
}

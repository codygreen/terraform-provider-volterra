// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/virtual_host/types.proto

package virtual_host

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	google_protobuf3 "github.com/gogo/protobuf/types"

	google_protobuf1 "github.com/gogo/protobuf/types"

	ves_io_schema3 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema_virtual_host_dns_info "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host_dns_info"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	sortkeys "github.com/gogo/protobuf/sortkeys"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// VirtualHostType
//
// x-displayName: "Virtual Host Type"
// VirtualHostType tells the type of virtual_host. Functionally, all types are same,
// this is mainly used for categorizing metrics.
type VirtualHostType int32

const (
	// VirtualService
	//
	// x-displayName: "Virtual Service"
	// Virtual Host used Virtual Service
	VIRTUAL_SERVICE VirtualHostType = 0
	// HTTP LoadBalancer
	//
	// x-displayName: "HTTP Load Balancer"
	// Virtual Host used as Load Balancer
	HTTP_LOAD_BALANCER VirtualHostType = 1
	// APIGateway
	//
	// x-displayName: "API Gateway"
	// Virtual Host used API Gateway
	API_GATEWAY VirtualHostType = 2
	// TCP LoadBalancer
	//
	// x-displayName: "Load balancer"
	// Virtual Host used as Load Balancer
	TCP_LOAD_BALANCER VirtualHostType = 3
	// Proxy
	//
	// x-displayName: "Proxy"
	// Virtual Host used as Proxy
	PROXY VirtualHostType = 4
)

var VirtualHostType_name = map[int32]string{
	0: "VIRTUAL_SERVICE",
	1: "HTTP_LOAD_BALANCER",
	2: "API_GATEWAY",
	3: "TCP_LOAD_BALANCER",
	4: "PROXY",
}
var VirtualHostType_value = map[string]int32{
	"VIRTUAL_SERVICE":    0,
	"HTTP_LOAD_BALANCER": 1,
	"API_GATEWAY":        2,
	"TCP_LOAD_BALANCER":  3,
	"PROXY":              4,
}

func (VirtualHostType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// ProxyType tells the type of proxy to install for the virtual host.
//
// x-displayName: "Type of Proxy"
// Only the following combination of VirtualHosts within same AdvertisePolicy is permitted
// (None of them should have "*" in domains when used with other VirtualHosts in same AdvertisePolicy)
// 1. Multiple TCP_PROXY_WITH_SNI and multiple HTTPS_PROXY
// 2. Multiple HTTP_PROXY
// 3. Multiple HTTPS_PROXY
// 4. Multiple TCP_PROXY_WITH_SNI
//
// HTTPS_PROXY without TLS parameters is not permitted
// HTTP_PROXY/HTTPS_PROXY/TCP_PROXY_WITH_SNI/SMA_PROXY with empty domains is not permitted
// TCP_PROXY_WITH_SNI/SMA_PROXY should not have "*" in domains
type ProxyType int32

const (
	// HTTP_PROXY
	//
	// x-displayName: "HTTP Proxy"
	// Install HTTP proxy. HTTP Proxy is the default proxy installed.
	HTTP_PROXY ProxyType = 0
	// TCP_PROXY
	//
	// x-displayName: "TCP Proxy"
	// Install TCP proxy
	TCP_PROXY ProxyType = 1
	// TCP_PROXY_WITH_SNI
	//
	// x-displayName: "TCP Proxy with SNI"
	// Install TCP proxy with SNI Routing
	TCP_PROXY_WITH_SNI ProxyType = 2
	// HTTPS_PROXY
	//
	// x-displayName: "HTTPS Proxy"
	// Install HTTPS proxy
	HTTPS_PROXY ProxyType = 3
	// UDP_PROXY
	//
	// x-displayName: "UDP Proxy"
	// Install UDP proxy
	UDP_PROXY ProxyType = 4
	// SMA_PROXY
	//
	// x-displayName: "Secret Management Access Proxy"
	// Install Secret Management Access proxy
	SMA_PROXY ProxyType = 5
)

var ProxyType_name = map[int32]string{
	0: "HTTP_PROXY",
	1: "TCP_PROXY",
	2: "TCP_PROXY_WITH_SNI",
	3: "HTTPS_PROXY",
	4: "UDP_PROXY",
	5: "SMA_PROXY",
}
var ProxyType_value = map[string]int32{
	"HTTP_PROXY":         0,
	"TCP_PROXY":          1,
	"TCP_PROXY_WITH_SNI": 2,
	"HTTPS_PROXY":        3,
	"UDP_PROXY":          4,
	"SMA_PROXY":          5,
}

func (ProxyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// VirtualHostState
//
// x-displayName: "Virtual Host State"
// State of the virtual host
type VirtualHostState int32

const (
	// VIRTUAL_HOST_READY
	//
	// x-displayName: "Ready"
	// Virtual host is ready to install
	VIRTUAL_HOST_READY VirtualHostState = 0
	// VIRTUAL_HOST_PENDING_VERIFICATION
	//
	// x-displayName: "Pending Verification"
	// Virtual host is verfication pending for some or all of its domains
	VIRTUAL_HOST_PENDING_VERIFICATION VirtualHostState = 1
	// VIRTUAL_HOST_VERIFICATION_FAILED
	//
	// x-displayName: "Verification Failed"
	// Virtual host has one or more domains for which verification failed
	VIRTUAL_HOST_VERIFICATION_FAILED VirtualHostState = 2
	// VIRTUAL_HOST_PENDING_DNS_DELEGATION
	//
	// x-displayName: "Pending DNS delegation"
	// Virtual host is pending DNS delegation
	VIRTUAL_HOST_PENDING_DNS_DELEGATION VirtualHostState = 3
	// VIRTUAL_HOST_PENDING_A_RECORD
	//
	// x-displayName: "Pending A record"
	// Virtual host is waiting for one or more A records to be created
	VIRTUAL_HOST_PENDING_A_RECORD VirtualHostState = 4
	// VIRTUAL_HOST_DNS_A_RECORD_ADDED
	//
	// x-displayName: "DNS A record was added"
	// DNS A record has been added for this Virtual host
	VIRTUAL_HOST_DNS_A_RECORD_ADDED VirtualHostState = 5
)

var VirtualHostState_name = map[int32]string{
	0: "VIRTUAL_HOST_READY",
	1: "VIRTUAL_HOST_PENDING_VERIFICATION",
	2: "VIRTUAL_HOST_VERIFICATION_FAILED",
	3: "VIRTUAL_HOST_PENDING_DNS_DELEGATION",
	4: "VIRTUAL_HOST_PENDING_A_RECORD",
	5: "VIRTUAL_HOST_DNS_A_RECORD_ADDED",
}
var VirtualHostState_value = map[string]int32{
	"VIRTUAL_HOST_READY":                  0,
	"VIRTUAL_HOST_PENDING_VERIFICATION":   1,
	"VIRTUAL_HOST_VERIFICATION_FAILED":    2,
	"VIRTUAL_HOST_PENDING_DNS_DELEGATION": 3,
	"VIRTUAL_HOST_PENDING_A_RECORD":       4,
	"VIRTUAL_HOST_DNS_A_RECORD_ADDED":     5,
}

func (VirtualHostState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// Certification State
//
// x-displayName: "Certification State"
// State of auto certification generation for the virtual host
type CertificationState int32

const (
	// Auto Cert Disabled
	//
	// x-displayName: "Auto Cert Disabled"
	// Auto Certification is disabled.
	AutoCertDisabled CertificationState = 0
	// Dns Domain Verification
	//
	// x-displayName: "DnsDomainVerification"
	// Auto Certification is waiting for domain verification.
	DnsDomainVerification CertificationState = 1
	// Auto Cert Started
	//
	// x-displayName: "Auto Cert Started"
	// Auto Certificate generation action has started.
	AutoCertStarted CertificationState = 2
	// Domain Challenge Pending
	//
	// x-displayName: "Domain Challenge Pending"
	// The domains in the virtual host configuration are being verified. This requires
	// the _acme-challenge TXT record in the domain to have the correct TXT.
	DomainChallengePending CertificationState = 3
	// Domain Challenge Verified
	//
	// x-displayName: "Domain Challenge Verified"
	// All the domains in the virtual host have been verified.
	DomainChallengeVerified CertificationState = 4
	// Auto Cert Finalize
	//
	// x-displayName: "Auto Cert Finalize"
	// Certificate generation order is Ready and Finalized.
	AutoCertFinalize CertificationState = 5
	// Certificate Invalid
	//
	// x-displayName: "Certificate Invalid"
	// Certificate is invalid
	CertificateInvalid CertificationState = 6
	// Certificate Valid
	//
	// x-displayName: "Certificate Valid"
	// Valid certificate generated and tls_parameters are updated
	CertificateValid CertificationState = 7
	// Auto Cert Not Applicable
	//
	// x-displayName: "Not Applicable"
	// Auto certificate not applicable because virtual host does not use TLS
	AutoCertNotApplicable CertificationState = 8
	// Auto Cert Rate Limited
	//
	// x-displayName: "Rate Limited"
	// Auto certificate not available because CA has rate limited the request
	AutoCertRateLimited CertificationState = 9
	// Auto Cert Generation Retry
	//
	// x-displayName: "Auto Cert Generation Retry"
	// Auto certificate generate failed in the previous attempt, will be retried automatically
	AutoCertGenerationRetry CertificationState = 10
	// Auto Cert Error
	//
	// x-displayName: "Auto Cert Error"
	// Error in Certificate generation
	AutoCertError CertificationState = 11
)

var CertificationState_name = map[int32]string{
	0:  "AutoCertDisabled",
	1:  "DnsDomainVerification",
	2:  "AutoCertStarted",
	3:  "DomainChallengePending",
	4:  "DomainChallengeVerified",
	5:  "AutoCertFinalize",
	6:  "CertificateInvalid",
	7:  "CertificateValid",
	8:  "AutoCertNotApplicable",
	9:  "AutoCertRateLimited",
	10: "AutoCertGenerationRetry",
	11: "AutoCertError",
}
var CertificationState_value = map[string]int32{
	"AutoCertDisabled":        0,
	"DnsDomainVerification":   1,
	"AutoCertStarted":         2,
	"DomainChallengePending":  3,
	"DomainChallengeVerified": 4,
	"AutoCertFinalize":        5,
	"CertificateInvalid":      6,
	"CertificateValid":        7,
	"AutoCertNotApplicable":   8,
	"AutoCertRateLimited":     9,
	"AutoCertGenerationRetry": 10,
	"AutoCertError":           11,
}

func (CertificationState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// JavaScriptConfigType
//
// x-displayName: "JavaScript Configuration"
// Custom JavaScript Configuration. Custom JavaScript code can be executed at various stages of request processing.
type JavaScriptConfigType struct {
	// CachePrefix
	//
	// x-displayName: "Cache Identifier"
	// Identifier for data store to be used by JavaScript. Data store can be
	// KeyValue store referred by script.
	CachePrefix string `protobuf:"bytes,1,opt,name=cache_prefix,json=cachePrefix,proto3" json:"cache_prefix,omitempty"`
	// ScriptConfig
	//
	// x-displayName: "Configuration for Script"
	// Input passed to the script
	ScriptConfig *google_protobuf3.Struct `protobuf:"bytes,2,opt,name=script_config,json=scriptConfig" json:"script_config,omitempty"`
	// ScriptURL
	//
	// x-displayName: "Path of Javascript"
	// URL of JavaScript that gets executed
	CustomScriptUrl string `protobuf:"bytes,3,opt,name=custom_script_url,json=customScriptUrl,proto3" json:"custom_script_url,omitempty"`
}

func (m *JavaScriptConfigType) Reset()                    { *m = JavaScriptConfigType{} }
func (*JavaScriptConfigType) ProtoMessage()               {}
func (*JavaScriptConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *JavaScriptConfigType) GetCachePrefix() string {
	if m != nil {
		return m.CachePrefix
	}
	return ""
}

func (m *JavaScriptConfigType) GetScriptConfig() *google_protobuf3.Struct {
	if m != nil {
		return m.ScriptConfig
	}
	return nil
}

func (m *JavaScriptConfigType) GetCustomScriptUrl() string {
	if m != nil {
		return m.CustomScriptUrl
	}
	return ""
}

// DynamicReverseProxyType
//
// x-displayName: "Dynamic Reverse Proxy Type"
// In this mode of proxy, virtual host will resolve the destination endpoint dynamically.
//
// The dynamic resolution is done using a predefined field in the request. This predefined
// field depends on the ProxyType configured on the Virtual Host.
//
// For HTTP traffic, i.e. with ProxyType as HTTP_PROXY or HTTPS_PROXY, virtual host will use the
// "HOST" http header from the request and perform DNS resolution to select destination endpoint.
//
// For TCP traffic with SNI, (If the ProxyType is TCP_PROXY_WITH_SNI), virtual host will perform DNS
// resolution using the SNI.
//
// The DNS resolution is performed in the virtual network specified in outside_network_type or
// outside_network
//
// In both modes of operation(either using Host header or SNI), the DNS resolution could return
// multiple addresses. First IPv4 address from such returned list is used as endpoint for the
// request. The DNS response is cached for 60s by default.
type DynamicReverseProxyType struct {
	// Enable the dynamic resolution of the endpoint
	//
	// x-displayName: "Dynamic Endpoint Resolution"
	// x-example : true
	// In this mode of proxy, virtual host will resolve the destination endpoint dynamically.
	//
	// The dynamic resolution is done using a predefined field in the request. This predefined
	// field depends on the ProxyType configured on the Virtual Host.
	//
	// For HTTP traffic, i.e. with ProxyType as HTTP_PROXY or HTTPS_PROXY, virtual host will use the
	// "HOST" http header from the request and perform DNS resolution to select destination endpoint.
	//
	// For TCP traffic with SNI, (If the ProxyType is TCP_PROXY_WITH_SNI), virtual host will perform DNS
	// resolution using the SNI.
	//
	// The DNS resolution is performed in the virtual network specified in outside_network_type or
	// outside_network
	//
	// In both modes of operation(either using Host header or SNI), the DNS resolution could return
	// multiple addresses. First IPv4 address from such returned list is used as endpoint for the
	// request. The DNS response is cached for 60s by default.
	ResolveEndpointDynamically bool `protobuf:"varint,1,opt,name=resolve_endpoint_dynamically,json=resolveEndpointDynamically,proto3" json:"resolve_endpoint_dynamically,omitempty"`
	// resolution_network_type
	//
	// x-displayName: "Resolution Network Type"
	// Type of the network to resolve the destination
	ResolutionNetworkType ves_io_schema3.VirtualNetworkType `protobuf:"varint,2,opt,name=resolution_network_type,json=resolutionNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"resolution_network_type,omitempty"`
	// resolution_network
	//
	// x-displayName: "Resolution Network"
	// Reference to virtual network where the endpoint is resolved.
	// Reference is valid only when the network type is VIRTUAL_NETWORK_PER_SITE or
	// VIRTUAL_NETWORK_GLOBAL. It is ignored for all other network types
	ResolutionNetwork []*ves_io_schema4.ObjectRefType `protobuf:"bytes,3,rep,name=resolution_network,json=resolutionNetwork" json:"resolution_network,omitempty"`
}

func (m *DynamicReverseProxyType) Reset()                    { *m = DynamicReverseProxyType{} }
func (*DynamicReverseProxyType) ProtoMessage()               {}
func (*DynamicReverseProxyType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *DynamicReverseProxyType) GetResolveEndpointDynamically() bool {
	if m != nil {
		return m.ResolveEndpointDynamically
	}
	return false
}

func (m *DynamicReverseProxyType) GetResolutionNetworkType() ves_io_schema3.VirtualNetworkType {
	if m != nil {
		return m.ResolutionNetworkType
	}
	return ves_io_schema3.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *DynamicReverseProxyType) GetResolutionNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ResolutionNetwork
	}
	return nil
}

// CompressionType
//
// x-displayName: "Compression Parameters"
// Enables loadbalancer to compress dispatched data from an upstream service upon client request.
// The content is compressed and then sent to the client with the appropriate headers if either response and request allow.
// Only GZIP compression is supported.
//
// By default compression will be skipped when:
//
//   A request does NOT contain accept-encoding header.
//   A request includes accept-encoding header, but it does not contain “gzip” or “*”.
//   A request includes accept-encoding with “gzip” or “*” with the weight “q=0”. Note that the “gzip” will have a higher weight then “*”. For example, if accept-encoding is “gzip;q=0,*;q=1”, the filter will not compress. But if the header is set to “*;q=0,gzip;q=1”, the filter will compress.
//   A request whose accept-encoding header includes “identity”.
//   A response contains a content-encoding header.
//   A response contains a cache-control header whose value includes “no-transform”.
//   A response contains a transfer-encoding header whose value includes “gzip”.
//   A response does not contain a content-type value that matches one of the selected mime-types, which default to application/javascript, application/json, application/xhtml+xml, image/svg+xml, text/css, text/html, text/plain, text/xml.
//   Neither content-length nor transfer-encoding headers are present in the response.
//   Response size is smaller than 30 bytes (only applicable when transfer-encoding is not chunked).
//
// When compression is applied:
//
//   The content-length is removed from response headers.
//   Response headers contain “transfer-encoding: chunked” and do not contain “content-encoding” header.
//   The “vary: accept-encoding” header is inserted on every response.
//
// GZIP Compression Level:
//
// A value which is optimal balance between speed of compression and amount of compression is chosen.
type CompressionType struct {
	// content_length
	//
	// x-displayName: "Content Length"
	// x-example: 100
	// Minimum response length, in bytes, which will trigger compression. The default value is 30.
	ContentLength uint32 `protobuf:"varint,1,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
	// content_type
	//
	// x-displayName: "Content Type"
	// x-example: "application/json"
	// Set of strings that allows specifying which mime-types yield compression
	// When this field is not defined, compression will be applied
	// to the following mime-types:
	//     "application/javascript"
	//     "application/json",
	//     "application/xhtml+xml"
	//     "image/svg+xml"
	//     "text/css"
	//     "text/html"
	//     "text/plain"
	//     "text/xml"
	ContentType []string `protobuf:"bytes,2,rep,name=content_type,json=contentType" json:"content_type,omitempty"`
	// disable_on_etag_header
	//
	// x-displayName: "Disable On Etag Header"
	// x-example: "true"
	// If true, disables compression when the response contains an etag header. When it is false,
	// weak etags will be preserved and the ones that require strong validation will be removed.
	DisableOnEtagHeader bool `protobuf:"varint,3,opt,name=disable_on_etag_header,json=disableOnEtagHeader,proto3" json:"disable_on_etag_header,omitempty"`
	// remove_accept_encoding_header
	//
	// x-displayName: "Remove Accept-Encoding Header"
	// x-example: "true"
	// If true, removes accept-encoding from the request headers before dispatching it to the upstream
	// so that responses do not get compressed before reaching the filter.
	RemoveAcceptEncodingHeader bool `protobuf:"varint,4,opt,name=remove_accept_encoding_header,json=removeAcceptEncodingHeader,proto3" json:"remove_accept_encoding_header,omitempty"`
}

func (m *CompressionType) Reset()                    { *m = CompressionType{} }
func (*CompressionType) ProtoMessage()               {}
func (*CompressionType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *CompressionType) GetContentLength() uint32 {
	if m != nil {
		return m.ContentLength
	}
	return 0
}

func (m *CompressionType) GetContentType() []string {
	if m != nil {
		return m.ContentType
	}
	return nil
}

func (m *CompressionType) GetDisableOnEtagHeader() bool {
	if m != nil {
		return m.DisableOnEtagHeader
	}
	return false
}

func (m *CompressionType) GetRemoveAcceptEncodingHeader() bool {
	if m != nil {
		return m.RemoveAcceptEncodingHeader
	}
	return false
}

// JavascriptChallengeType
//
// x-displayName: "Javascript Challenge Parameters"
//
// Enables loadbalancer to perform client browser compatibility test by redirecting to a page
// with Javascript.
//
// With this feature enabled, only clients that are capable of executing Javascript(mostly browsers)
// will be allowed to complete the HTTP request.
//
// When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an
// HTML page on every new HTTP request. This HTML page will have Javascript embedded in it.
// Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an
// encrypted answer with the request such that it embed these numbers as input in the Javascript.
// Javascript will run on the requestor browser and perform a complex Math operation.
// Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated
// answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow
// the request to the upstream server only if the answer is correct.
// Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests.
//
// Javascript challenge serves following purposes
//    * Validate that the request is coming via a browser that is capable for running Javascript
//    * Force the browser to run a complex operation, f(X), that requires it to spend a large number
//      of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch
//    a large request flood without having to spend even larger CPU cost at their end.
//
// You can enable either Javascript challenge or Captcha challenge on a virtual host
type JavascriptChallengeType struct {
	// Enable Javascript Challenge
	//
	// x-displayName: "Enable"
	// x-example: "true"
	// Turn this configuration knob to enable Javascript Challenge
	EnableJsChallenge bool `protobuf:"varint,1,opt,name=enable_js_challenge,json=enableJsChallenge,proto3" json:"enable_js_challenge,omitempty"`
	// js_script_delay
	//
	// x-displayName: "Javascript Delay"
	// x-example: 1000
	// Specifies, in milliseconds, the delay that Javascript introduces.
	// Default delay is 5 seconds
	JsScriptDelay uint32 `protobuf:"varint,2,opt,name=js_script_delay,json=jsScriptDelay,proto3" json:"js_script_delay,omitempty"`
	// cookie_expiry
	//
	// x-displayName: "Cookie Expiry period"
	// x-example: 1000
	// Specifies, in seconds, cookie expiry duration.
	// Expired cookie will cause loadbalancer to perform Javascript challenge
	// Default cookie expiry is set as 1 hour
	CookieExpiry uint32 `protobuf:"varint,3,opt,name=cookie_expiry,json=cookieExpiry,proto3" json:"cookie_expiry,omitempty"`
	// custom_page
	//
	// x-displayName: "Custom Message for Javascript Challenge"
	// x-example: "string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	// Custom message is of type uri_ref. Currently supported URL schemes is string:///.
	// For string:/// scheme, message needs to be encoded in Base64 format.
	// You can specify this message as base64 encoded plain text message e.g. "Please Wait.."
	// or it can be HTML paragraph or a body string encoded as base64 string
	// E.g. "<p> Please Wait </p>". Base64 encoded string for this html is "PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	CustomPage string `protobuf:"bytes,4,opt,name=custom_page,json=customPage,proto3" json:"custom_page,omitempty"`
}

func (m *JavascriptChallengeType) Reset()                    { *m = JavascriptChallengeType{} }
func (*JavascriptChallengeType) ProtoMessage()               {}
func (*JavascriptChallengeType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *JavascriptChallengeType) GetEnableJsChallenge() bool {
	if m != nil {
		return m.EnableJsChallenge
	}
	return false
}

func (m *JavascriptChallengeType) GetJsScriptDelay() uint32 {
	if m != nil {
		return m.JsScriptDelay
	}
	return 0
}

func (m *JavascriptChallengeType) GetCookieExpiry() uint32 {
	if m != nil {
		return m.CookieExpiry
	}
	return 0
}

func (m *JavascriptChallengeType) GetCustomPage() string {
	if m != nil {
		return m.CustomPage
	}
	return ""
}

// CaptchaChallengeType
//
// x-displayName: "Captcha Challenge Parameters"
//
// Enables loadbalancer to perform captcha challenge
//
// Captcha challenge will be based on Google Recaptcha.
//
// With this feature enabled, only clients that pass the captcha challenge will be allowed to
// complete the HTTP request.
//
// When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an
// HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it.
// Client will be allowed to make the request only if the captcha challenge is successful.
// Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests.
//
// CAPTCHA is mainly used as a security check to ensure only human users can pass through.
// Generally, computers or bots are not capable of solving a captcha.
//
// You can enable either Javascript challenge or Captcha challenge on a virtual host
type CaptchaChallengeType struct {
	// Enable Captcha Challenge
	//
	// x-displayName: "Enable"
	// x-example: "true"
	// Turn this configuration knob to enable Captcha Challenge
	EnableCaptchaChallenge bool `protobuf:"varint,1,opt,name=enable_captcha_challenge,json=enableCaptchaChallenge,proto3" json:"enable_captcha_challenge,omitempty"`
	// cookie_expiry
	//
	// x-displayName: "Cookie Expiry period"
	// x-example: 1000
	// Specifies, in seconds, cookie expiry duration.
	// Expired cookie will cause loadbalancer to perform Captcha challenge
	// Default cookie expiry is set as 1 hour
	CookieExpiry uint32 `protobuf:"varint,2,opt,name=cookie_expiry,json=cookieExpiry,proto3" json:"cookie_expiry,omitempty"`
	// custom_page
	//
	// x-displayName: "Custom message for Captcha Challenge"
	// x-example: "string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	// Custom message is of type uri_ref. Currently supported URL schemes is string:///.
	// For string:/// scheme, message needs to be encoded in Base64 format.
	// You can specify this message as base64 encoded plain text message e.g. "Please Wait.."
	// or it can be HTML paragraph or a body string encoded as base64 string
	// E.g. "<p> Please Wait </p>". Base64 encoded string for this html is "PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	CustomPage string `protobuf:"bytes,3,opt,name=custom_page,json=customPage,proto3" json:"custom_page,omitempty"`
}

func (m *CaptchaChallengeType) Reset()                    { *m = CaptchaChallengeType{} }
func (*CaptchaChallengeType) ProtoMessage()               {}
func (*CaptchaChallengeType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *CaptchaChallengeType) GetEnableCaptchaChallenge() bool {
	if m != nil {
		return m.EnableCaptchaChallenge
	}
	return false
}

func (m *CaptchaChallengeType) GetCookieExpiry() uint32 {
	if m != nil {
		return m.CookieExpiry
	}
	return 0
}

func (m *CaptchaChallengeType) GetCustomPage() string {
	if m != nil {
		return m.CustomPage
	}
	return ""
}

// TemporaryUserBlockingType
//
// x-displayName: "Temporary User Blocking"
//
// Specifies configuration for temporary user blocking resulting from user behavior analysis.
//
// When Malicious User Mitigation is enabled from service policy rules, users' accessing the application will be analyzed for
// malicious activity and the configured mitigation actions will be taken on identified malicious users.
// These mitigation actions include setting up temporary blocking on that user.
// This configuration specifies settings on how that blocking should be done by the loadbalancer.
type TemporaryUserBlockingType struct {
	// custom_page
	//
	// x-displayName: "Custom Message for Temporary Blocking"
	// x-example: "string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	// Custom message is of type `uri_ref`. Currently supported URL schemes is `string:///`.
	// For `string:///` scheme, message needs to be encoded in Base64 format.
	// You can specify this message as base64 encoded plain text message e.g. "Blocked.."
	// or it can be HTML paragraph or a body string encoded as base64 string
	// E.g. "<p> Blocked </p>". Base64 encoded string for this html is "PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	CustomPage string `protobuf:"bytes,1,opt,name=custom_page,json=customPage,proto3" json:"custom_page,omitempty"`
}

func (m *TemporaryUserBlockingType) Reset()                    { *m = TemporaryUserBlockingType{} }
func (*TemporaryUserBlockingType) ProtoMessage()               {}
func (*TemporaryUserBlockingType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *TemporaryUserBlockingType) GetCustomPage() string {
	if m != nil {
		return m.CustomPage
	}
	return ""
}

// AutoCertInfoType
//
// x-displayName: "Auto Cert Information"
// Information related to auto certificate
type AutoCertInfoType struct {
	// Auto Cert State
	//
	// x-displayName: "Auto Cert State"
	// State of auto certificate generation.
	AutoCertState CertificationState `protobuf:"varint,1,opt,name=auto_cert_state,json=autoCertState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"auto_cert_state,omitempty"`
	// Auto Cert Expiry Timestamp
	//
	// x-displayName: "Auto Cert Expiry Timestamp"
	// Auto certificate expiry timestamp
	AutoCertExpiry *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=auto_cert_expiry,json=autoCertExpiry" json:"auto_cert_expiry,omitempty"`
	// Auto Cert Subject
	//
	// x-displayName: "Auto Cert Subject"
	// Subject of the auto certificate
	AutoCertSubject string `protobuf:"bytes,3,opt,name=auto_cert_subject,json=autoCertSubject,proto3" json:"auto_cert_subject,omitempty"`
	// Auto Cert Issuer
	//
	// x-displayName: "Auto Cert Issuer"
	// Issuer of the auto certificate
	AutoCertIssuer string `protobuf:"bytes,4,opt,name=auto_cert_issuer,json=autoCertIssuer,proto3" json:"auto_cert_issuer,omitempty"`
}

func (m *AutoCertInfoType) Reset()                    { *m = AutoCertInfoType{} }
func (*AutoCertInfoType) ProtoMessage()               {}
func (*AutoCertInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *AutoCertInfoType) GetAutoCertState() CertificationState {
	if m != nil {
		return m.AutoCertState
	}
	return AutoCertDisabled
}

func (m *AutoCertInfoType) GetAutoCertExpiry() *google_protobuf1.Timestamp {
	if m != nil {
		return m.AutoCertExpiry
	}
	return nil
}

func (m *AutoCertInfoType) GetAutoCertSubject() string {
	if m != nil {
		return m.AutoCertSubject
	}
	return ""
}

func (m *AutoCertInfoType) GetAutoCertIssuer() string {
	if m != nil {
		return m.AutoCertIssuer
	}
	return ""
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for VirtualHost
type GlobalSpecType struct {
	// domains
	//
	// x-displayName: "Domains"
	// x-example: "www.foo.com"
	// A list of domains (host/authority header) that will be matched to this virtual host.
	// Wildcard hosts are supported in the suffix or prefix form
	//
	// Domain search order:
	//  1. Exact domain names: www.foo.com.
	//  2. Prefix domain wildcards: *.foo.com or *-bar.foo.com.
	//  3. Special wildcard * matching any domain.
	//
	// Wildcard will not match empty string.
	// e.g. *-bar.foo.com will match baz-bar.foo.com but not -bar.foo.com.
	// The longest wildcards match first.
	// Only a single virtual host in the entire route configuration can match on *.
	// Also a domain must be unique across all virtual hosts within an advertise policy.
	//
	// Domains are also used for SNI matching if the virtual host proxy type is TCP_PROXY_WITH_SNI/HTTPS_PROXY
	// Domains also indicate the list of names for which DNS resolution will be done by VER
	Domains []string `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	// routes
	//
	// x-displayName: "Routes"
	// The list of routes that will be matched, in order, for incoming requests.
	// The first route that matches will be used. Currently route object is redundant in case of TCP proxy but required.
	// For TCP_PROXY/TCP_PROXY_WITH_SNI/SMA_PROXY VirtualHosts, the route object only specifies the cluster/weighted-cluster
	// as route destination without any match condition. In other words, match condition in route object is ignored for
	// TCP_PROXY/TCP_PROXY_WITH_SNI/SMA_PROXY VirtualHosts. Routes used for TCP_PROXY/TCP_PROXY_WITH_SNI/SMA_PROXY
	// VirtualHosts cannot have DirectResponse or Redirect as actions.
	Routes []*ves_io_schema4.ObjectRefType `protobuf:"bytes,3,rep,name=routes" json:"routes,omitempty"`
	// javascript_info
	//
	// x-displayName: "Javascript Info"
	// Custom JavaScript Configuration. Custom JavaScript code can be executed at various stages of request processing.
	JavascriptInfo *JavaScriptConfigType `protobuf:"bytes,4,opt,name=javascript_info,json=javascriptInfo" json:"javascript_info,omitempty"`
	// Advertise Policy
	//
	// x-displayName: "Advertise Policies"
	// Advertise Policy allows you to define networks or sites where you want a VIP for this virtual host to be advertised.
	// Each Policy rule can have different parameters, like TLS configuration, ports, optionally ip address to be used for VIP.
	// If advertise policy is not specified then no VIP is assigned for this virtual host.
	AdvertisePolicies []*ves_io_schema4.ObjectRefType `protobuf:"bytes,5,rep,name=advertise_policies,json=advertisePolicies" json:"advertise_policies,omitempty"`
	// Headers to add in request
	//
	// x-displayName: "Add Request Headers"
	// Headers are key-value pairs to be added to HTTP request being routed towards upstream.
	// Headers specified at this level are applied after headers from matched Route are applied
	RequestHeadersToAdd []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd" json:"request_headers_to_add,omitempty"`
	// Headers to add in response
	//
	// x-displayName: "Add Response Headers"
	// Headers are key-value pairs to be added to HTTP response being sent towards downstream.
	// Headers specified at this level are applied after headers from matched Route are applied
	ResponseHeadersToAdd []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=response_headers_to_add,json=responseHeadersToAdd" json:"response_headers_to_add,omitempty"`
	// Header to be removed from request
	//
	// x-displayName: "Remove Request Headers"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP request being sent towards upstream.
	RequestHeadersToRemove []string `protobuf:"bytes,17,rep,name=request_headers_to_remove,json=requestHeadersToRemove" json:"request_headers_to_remove,omitempty"`
	// Header to be removed from response
	//
	// x-displayName: "Remove Response Headers"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP response being sent towards downstream.
	ResponseHeadersToRemove []string `protobuf:"bytes,8,rep,name=response_headers_to_remove,json=responseHeadersToRemove" json:"response_headers_to_remove,omitempty"`
	// TLS parameters.
	//
	// x-displayName: "TLS Parameters"
	// TLS parameters for downstream connections. These parameters are used if not specified
	// in advertise policy
	TlsParameters *ves_io_schema4.DownstreamTlsParamsType `protobuf:"bytes,9,opt,name=tls_parameters,json=tlsParameters" json:"tls_parameters,omitempty"`
	// Virtual host type
	//
	// x-displayName: "Virtual Host Type"
	// VirtualHostType indicates if virtual_host is used as VIRTUAL_SERVICE/LOAD_BALANCER/API_GATEWAY.
	// Functionally, all types are same, this is mainly used for categorizing metrics and UI visualization.
	Type VirtualHostType `protobuf:"varint,10,opt,name=type,proto3,enum=ves.io.schema.virtual_host.VirtualHostType" json:"type,omitempty"`
	// Buffer configuration for requests
	//
	// x-displayName: "Buffer Policy"
	// Some upstream applications are not capable of handling streamed data and high network latency.
	// This config enables buffering the entire request before sending to upstream application. We can
	// specify the maximum buffer size and buffer interval with this config.
	BufferPolicy *ves_io_schema4.BufferConfigType `protobuf:"bytes,12,opt,name=buffer_policy,json=bufferPolicy" json:"buffer_policy,omitempty"`
	// Cross-Origin Resource Sharing (CORS) configuration for requests
	//
	// x-displayName: "CORS Policy"
	// CORS is a mechanism that uses additional HTTP headers to tell a browser to let
	// a web application running at one origin (domain) have permission to access selected
	// resources from a server at a different origin
	CorsPolicy *ves_io_schema4.CorsPolicy `protobuf:"bytes,13,opt,name=cors_policy,json=corsPolicy" json:"cors_policy,omitempty"`
	// Proxy Type
	//
	// x-displayName: "Proxy Type"
	// Indicates whether the type of proxy is HTTP/HTTPS/TCP/UDP/Secret Management Access
	Proxy ProxyType `protobuf:"varint,15,opt,name=proxy,proto3,enum=ves.io.schema.virtual_host.ProxyType" json:"proxy,omitempty"`
	// JSON Web Token authentication (JWT) configuration for requests
	//
	// x-displayName: "JWT Config"
	// This HTTP filter specifies how to verify JSON Web Token (JWT). It will verify its signature,
	// audiences and issuer
	Jwt []*ves_io_schema4.ObjectRefType `protobuf:"bytes,16,rep,name=jwt" json:"jwt,omitempty"`
	// Enable the WAF (Web Application Firewall) functionality for VirtualHost
	//
	// x-displayName: "WAF Config"
	// WAF can be used to analyze inbound and outbound http/https traffic.
	// WAF can be configured either in BLOCKing Mode or ALERTing Mode.
	// In BLOCKing mode if WAF detects suspicious inbound/outbound traffic it blocks the request or response.
	// In ALERTing mode if suspicious traffic is detected, WAF generates ALERTs with details on the
	// suspicious traffic (instead of blocking traffic).
	//
	// waf_type can be either WAF or WAFRules.
	// WAF Object allows to
	//     Configure mode of the WAF (BLOCK/ALERT)
	//     Configure language used by the application which is being protected by the WAF
	//     Disable different high level security tags if required (e.g. SQLI_DETECTION, XSS_DETECTION etc)
	// WAFRules allows to
	//     Configure mode of the WAF (BLOCK/ALERT)
	//     Enable/Disable individual WAF security rules
	WafType *ves_io_schema4.WafType `protobuf:"bytes,18,opt,name=waf_type,json=wafType" json:"waf_type,omitempty"`
	// Enable the dynamic resolution of the endpoint
	//
	// x-displayName: "Dynamic Reverse Proxy"
	// In this mode of proxy, virtual host will resolve the destination endpoint dynamically.
	//
	// The dynamic resolution is done using a predefined field in the request. This predefined
	// field depends on the ProxyType configured on the Virtual Host.
	//
	// For HTTP traffic, i.e. with ProxyType as HTTP_PROXY or HTTPS_PROXY, virtual host will use the
	// "HOST" http header from the request and perform DNS resolution to select destination endpoint.
	//
	// For TCP traffic with SNI, (If the ProxyType is TCP_PROXY_WITH_SNI), virtual host will perform DNS
	// resolution using the SNI.
	//
	// The DNS resolution is performed in the virtual network specified in outside_network_type or
	// outside_network
	//
	// In both modes of operation(either using Host header or SNI), the DNS resolution could return
	// multiple addresses. First IPv4 address from such returned list is used as endpoint for the
	// request. The DNS response is cached for 60s by default.
	DynamicReverseProxy *DynamicReverseProxyType `protobuf:"bytes,19,opt,name=dynamic_reverse_proxy,json=dynamicReverseProxy" json:"dynamic_reverse_proxy,omitempty"`
	// Add Site information
	//
	// x-displayName: "Add Location"
	// x-example: "true"
	// x-example: true
	// Appends header x-volterra-location = <re-site-name> in responses. This configuration
	// is ignored on CE sites.
	AddLocation bool `protobuf:"varint,20,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	// Compression configuration
	//
	// x-displayName: "Compression Parameters"
	// Enables loadbalancer to compress dispatched data from an upstream service upon client request.
	// Only GZIP compression is supported
	CompressionParams *CompressionType `protobuf:"bytes,21,opt,name=compression_params,json=compressionParams" json:"compression_params,omitempty"`
	// Custom Errors
	//
	// x-displayName: "Custom Error Responses"
	// x-example: "value"
	//
	// Map of integer error codes as keys and string values that can be used to provide custom
	// http pages for each error code.
	// Key of the map can be either response code class or HTTP Error code. Response code classes
	// for key is configured as follows
	// 3 -- for 3xx response code class
	// 4 -- for 4xx response code class
	// 5 -- for 5xx response code class
	// Value is the uri_ref. Currently supported URL schemes is string:///.
	// For string:/// scheme, message needs to be encoded in Base64 format.
	// You can specify this message as base64 encoded plain text message e.g. "Access Denied"
	// or it can be HTML paragraph or a body string encoded as base64 string
	// E.g. "<p> Access Denied </p>". Base64 encoded string for this html is "PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg=="
	// Specific response code takes preference when both response code and response code class
	// matches for a request.
	//
	// The configured custom errors are only applicable for loadbalancer generated errors.
	// Errors returned from upstream server is propagated as is.
	//
	// Volterra provides default error pages for the errors generated by the loadbalancer. Content of
	// these pages are not editable. User has an option to disable the use of default Volterra error pages
	CustomErrors map[uint32]string `protobuf:"bytes,22,rep,name=custom_errors,json=customErrors" json:"custom_errors,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Disable use of default Error page
	//
	// x-displayName: "Disable default error pages"
	// x-example: "true"
	//
	// An option to specify whether to disable using default Volterra error pages
	DisableDefaultErrorPages bool `protobuf:"varint,33,opt,name=disable_default_error_pages,json=disableDefaultErrorPages,proto3" json:"disable_default_error_pages,omitempty"`
	// Maximum request header size
	//
	// x-displayName: "Maximum Request Header Size (KiB)"
	// x-example: "42"
	//
	// The maximum request header size in KiB for incoming connections.
	//
	// If un-configured, the default max request headers allowed is 60 KiB.
	//
	// Requests that exceed this limit will receive a 431 response.
	//
	// The max configurable limit is 96 KiB, based on current implementation constraints.
	//
	// Note:
	//   a. This configuration parameter is applicable only for HTTP_PROXY and HTTPS_PROXY
	//   b. When multiple HTTP_PROXY virtual hosts share the same advertise policy, the effective
	//      "maximum request header size" for such virtual hosts is the highest value configured
	//      on any of the virtual hosts
	MaxRequestHeaderSize uint32 `protobuf:"varint,23,opt,name=max_request_header_size,json=maxRequestHeaderSize,proto3" json:"max_request_header_size,omitempty"`
	// Challenge choice
	//
	// x-displayName: "Select Type of Challenge"
	// x-required
	// Selection of different types of challenge at Virtual Host
	//
	// Types that are valid to be assigned to ChallengeType:
	//	*GlobalSpecType_NoChallenge
	//	*GlobalSpecType_JsChallenge
	//	*GlobalSpecType_CaptchaChallenge
	ChallengeType isGlobalSpecType_ChallengeType `protobuf_oneof:"challenge_type"`
	// user_identification
	//
	// x-displayName: "User Identification Policy"
	// A reference to user_identification object.
	// The rules in the user_identification object are evaluated to determine the user identifier to be rate limited.
	UserIdentification []*ves_io_schema4.ObjectRefType `protobuf:"bytes,25,rep,name=user_identification,json=userIdentification" json:"user_identification,omitempty"`
	// rate_limiter
	//
	// x-displayName: "Rate Limiter"
	// A reference to rate_limiter object.
	// Requests to the virtual_host are rate limited based on the parameters specified in the rate_limiter.
	RateLimiter []*ves_io_schema4.ObjectRefType `protobuf:"bytes,26,rep,name=rate_limiter,json=rateLimiter" json:"rate_limiter,omitempty"`
	// rate_limiter_allowed_prefixes
	//
	// x-displayName: "Rate Limiter Allowed Prefixes"
	// References to ip_prefix_set objects.
	// Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.
	RateLimiterAllowedPrefixes []*ves_io_schema4.ObjectRefType `protobuf:"bytes,27,rep,name=rate_limiter_allowed_prefixes,json=rateLimiterAllowedPrefixes" json:"rate_limiter_allowed_prefixes,omitempty"`
	// retry_policy
	//
	// x-displayName: "Retry Policy"
	// Indicates that the virtual_host has a retry policy.
	RetryPolicy *ves_io_schema4.RetryPolicyType `protobuf:"bytes,28,opt,name=retry_policy,json=retryPolicy" json:"retry_policy,omitempty"`
	// Temporary User Blocking
	//
	// x-displayName: "Temporary User Blocking"
	// Specifies configuration for temporary user blocking resulting from malicious user detection
	TemporaryUserBlocking *TemporaryUserBlockingType `protobuf:"bytes,35,opt,name=temporary_user_blocking,json=temporaryUserBlocking" json:"temporary_user_blocking,omitempty"`
	// Malicious User Mitigation
	//
	// x-displayName: "Malicious User Mitigation"
	// Settings that specify the actions to be taken when malicious users are determined to be at different threat levels.
	// User's activity is monitored and continuously analyzed for malicious behavior. From this analysis, a threat level is assigned to each user.
	// The settings defined in malicious user mitigation specify what mitigation actions to take for users determined to be at different threat levels.
	MaliciousUserMitigation []*ves_io_schema4.ObjectRefType `protobuf:"bytes,36,rep,name=malicious_user_mitigation,json=maliciousUserMitigation" json:"malicious_user_mitigation,omitempty"`
	// TLS Interception
	//
	// x-displayName: "TLS Interception"
	//
	// Specify TLS interception configuration for the virtual host
	TlsIntercept *ves_io_schema4.TlsInterceptionType `protobuf:"bytes,37,opt,name=tls_intercept,json=tlsIntercept" json:"tls_intercept,omitempty"`
	// DNS domain refs
	//
	// x-displayName: "DNS Domains"
	// Internal reference to dns_domain object
	DnsDomains []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1001,rep,name=dns_domains,json=dnsDomains" json:"dns_domains,omitempty"`
	// Auto Certificates
	//
	// x-displayName: "Auto Certificates"
	// Automatically generated certificates. If this field is set, the user cannot specifi the TLS certificates
	AutoCert bool `protobuf:"varint,1002,opt,name=auto_cert,json=autoCert,proto3" json:"auto_cert,omitempty"`
	// Virtual Host state
	//
	// x-displayName: "Virtual Host State"
	// State of the virtual host
	State VirtualHostState `protobuf:"varint,1003,opt,name=state,proto3,enum=ves.io.schema.virtual_host.VirtualHostState" json:"state,omitempty"`
	// host name
	//
	// x-displayName: "Host Name"
	// x-example: "ves-io-cf8684b9-a18f-4843-a24f-1f9ee8ea2776.ac.vh.ves.io"
	// Internally generated host name to be used for the virtual host
	HostName string `protobuf:"bytes,1004,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// DNS information
	//
	// x-displayName: "DNS Information"
	// DNS information for this virtual host
	DnsInfo []*ves_io_schema_virtual_host_dns_info.DnsInfo `protobuf:"bytes,1005,rep,name=dns_info,json=dnsInfo" json:"dns_info,omitempty"`
	// Idle timeout
	//
	// x-displayName: "Idle timeout (in milliseconds)"
	// x-example: "2000"
	// Idle timeout is the amount of time that the loadbalancer will allow a stream to exist with
	// no upstream or downstream activity.
	//
	// Idle timeout and Proxy Type:
	//
	// HTTP_PROXY, HTTPS_PROXY:
	// Idle timer is started when the first byte is received on the connection.
	// Each time an encode/decode event for headers or data is processed for the stream,
	// the timer will be reset.
	// If the timeout fires, the stream is terminated with a 408 (Request Timeout) error code if
	// no upstream response header has been received, otherwise a stream reset occurs.
	// The default idle timeout is 30 seconds
	//
	// TCP PROXY, TCP_PROXY_WITH_SNI, SMA_PROXY:
	// The idle timeout is defined as the period in which there are no bytes sent or received on
	// either the upstream or downstream connection.
	// The default idle timeout is 1 hour.
	//
	// UDP PROXY:
	// The idle timeout for sessions. Idle timeout is defined as the period in which there are no
	// datagrams sent or received on the session.
	// The default if not specified is 1 minute.
	IdleTimeout uint32 `protobuf:"varint,32,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	// Auto Cert State
	//
	// x-displayName: "Auto Cert State"
	// State of auto certificate generation.
	AutoCertState CertificationState `protobuf:"varint,1006,opt,name=auto_cert_state,json=autoCertState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"auto_cert_state,omitempty"`
	// Auto Cert Information
	//
	// x-displayName: "Auto Cert Information"
	// Auto certificate related information
	AutoCertInfo *AutoCertInfoType `protobuf:"bytes,1010,opt,name=auto_cert_info,json=autoCertInfo" json:"auto_cert_info,omitempty"`
	// User Domains
	//
	// x-displayName: "User Provided Domains"
	// User Provided domains. Used internally.
	UserDomains []string `protobuf:"bytes,1011,rep,name=user_domains,json=userDomains" json:"user_domains,omitempty"`
	// Disable DNS Resolve
	//
	// x-displayName: "Disable DNS resolution"
	// x-example: "false"
	//
	// Disable DNS resolution for domains specified in the virtual host
	//
	// When the  virtual host is configured as Dynamive Resolve Proxy (DRP), disable DNS resolution
	// for domains configured.  This configuration is suitable for HTTP CONNECT proxy.
	DisableDnsResolve bool `protobuf:"varint,34,opt,name=disable_dns_resolve,json=disableDnsResolve,proto3" json:"disable_dns_resolve,omitempty"`
	//  Service Policy Set
	//
	// x-displayName: "" Service Policy Set
	// Per VH service policy set, created by system via policies in the http load balancer and http connect view.
	ServicePolicySet []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1012,rep,name=service_policy_set,json=servicePolicySet" json:"service_policy_set,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

type isGlobalSpecType_ChallengeType interface {
	isGlobalSpecType_ChallengeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_NoChallenge struct {
	NoChallenge *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=no_challenge,json=noChallenge,oneof"`
}
type GlobalSpecType_JsChallenge struct {
	JsChallenge *JavascriptChallengeType `protobuf:"bytes,24,opt,name=js_challenge,json=jsChallenge,oneof"`
}
type GlobalSpecType_CaptchaChallenge struct {
	CaptchaChallenge *CaptchaChallengeType `protobuf:"bytes,29,opt,name=captcha_challenge,json=captchaChallenge,oneof"`
}

func (*GlobalSpecType_NoChallenge) isGlobalSpecType_ChallengeType()      {}
func (*GlobalSpecType_JsChallenge) isGlobalSpecType_ChallengeType()      {}
func (*GlobalSpecType_CaptchaChallenge) isGlobalSpecType_ChallengeType() {}

func (m *GlobalSpecType) GetChallengeType() isGlobalSpecType_ChallengeType {
	if m != nil {
		return m.ChallengeType
	}
	return nil
}

func (m *GlobalSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *GlobalSpecType) GetRoutes() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *GlobalSpecType) GetJavascriptInfo() *JavaScriptConfigType {
	if m != nil {
		return m.JavascriptInfo
	}
	return nil
}

func (m *GlobalSpecType) GetAdvertisePolicies() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.AdvertisePolicies
	}
	return nil
}

func (m *GlobalSpecType) GetRequestHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *GlobalSpecType) GetResponseHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *GlobalSpecType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *GlobalSpecType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *GlobalSpecType) GetTlsParameters() *ves_io_schema4.DownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *GlobalSpecType) GetType() VirtualHostType {
	if m != nil {
		return m.Type
	}
	return VIRTUAL_SERVICE
}

func (m *GlobalSpecType) GetBufferPolicy() *ves_io_schema4.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetCorsPolicy() *ves_io_schema4.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetProxy() ProxyType {
	if m != nil {
		return m.Proxy
	}
	return HTTP_PROXY
}

func (m *GlobalSpecType) GetJwt() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Jwt
	}
	return nil
}

func (m *GlobalSpecType) GetWafType() *ves_io_schema4.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *GlobalSpecType) GetDynamicReverseProxy() *DynamicReverseProxyType {
	if m != nil {
		return m.DynamicReverseProxy
	}
	return nil
}

func (m *GlobalSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *GlobalSpecType) GetCompressionParams() *CompressionType {
	if m != nil {
		return m.CompressionParams
	}
	return nil
}

func (m *GlobalSpecType) GetCustomErrors() map[uint32]string {
	if m != nil {
		return m.CustomErrors
	}
	return nil
}

func (m *GlobalSpecType) GetDisableDefaultErrorPages() bool {
	if m != nil {
		return m.DisableDefaultErrorPages
	}
	return false
}

func (m *GlobalSpecType) GetMaxRequestHeaderSize() uint32 {
	if m != nil {
		return m.MaxRequestHeaderSize
	}
	return 0
}

func (m *GlobalSpecType) GetNoChallenge() *ves_io_schema4.Empty {
	if x, ok := m.GetChallengeType().(*GlobalSpecType_NoChallenge); ok {
		return x.NoChallenge
	}
	return nil
}

func (m *GlobalSpecType) GetJsChallenge() *JavascriptChallengeType {
	if x, ok := m.GetChallengeType().(*GlobalSpecType_JsChallenge); ok {
		return x.JsChallenge
	}
	return nil
}

func (m *GlobalSpecType) GetCaptchaChallenge() *CaptchaChallengeType {
	if x, ok := m.GetChallengeType().(*GlobalSpecType_CaptchaChallenge); ok {
		return x.CaptchaChallenge
	}
	return nil
}

func (m *GlobalSpecType) GetUserIdentification() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.UserIdentification
	}
	return nil
}

func (m *GlobalSpecType) GetRateLimiter() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *GlobalSpecType) GetRateLimiterAllowedPrefixes() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiterAllowedPrefixes
	}
	return nil
}

func (m *GlobalSpecType) GetRetryPolicy() *ves_io_schema4.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetTemporaryUserBlocking() *TemporaryUserBlockingType {
	if m != nil {
		return m.TemporaryUserBlocking
	}
	return nil
}

func (m *GlobalSpecType) GetMaliciousUserMitigation() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.MaliciousUserMitigation
	}
	return nil
}

func (m *GlobalSpecType) GetTlsIntercept() *ves_io_schema4.TlsInterceptionType {
	if m != nil {
		return m.TlsIntercept
	}
	return nil
}

func (m *GlobalSpecType) GetDnsDomains() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.DnsDomains
	}
	return nil
}

func (m *GlobalSpecType) GetAutoCert() bool {
	if m != nil {
		return m.AutoCert
	}
	return false
}

func (m *GlobalSpecType) GetState() VirtualHostState {
	if m != nil {
		return m.State
	}
	return VIRTUAL_HOST_READY
}

func (m *GlobalSpecType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *GlobalSpecType) GetDnsInfo() []*ves_io_schema_virtual_host_dns_info.DnsInfo {
	if m != nil {
		return m.DnsInfo
	}
	return nil
}

func (m *GlobalSpecType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *GlobalSpecType) GetAutoCertState() CertificationState {
	if m != nil {
		return m.AutoCertState
	}
	return AutoCertDisabled
}

func (m *GlobalSpecType) GetAutoCertInfo() *AutoCertInfoType {
	if m != nil {
		return m.AutoCertInfo
	}
	return nil
}

func (m *GlobalSpecType) GetUserDomains() []string {
	if m != nil {
		return m.UserDomains
	}
	return nil
}

func (m *GlobalSpecType) GetDisableDnsResolve() bool {
	if m != nil {
		return m.DisableDnsResolve
	}
	return false
}

func (m *GlobalSpecType) GetServicePolicySet() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ServicePolicySet
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_NoChallenge)(nil),
		(*GlobalSpecType_JsChallenge)(nil),
		(*GlobalSpecType_CaptchaChallenge)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// challenge_type
	switch x := m.ChallengeType.(type) {
	case *GlobalSpecType_NoChallenge:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoChallenge); err != nil {
			return err
		}
	case *GlobalSpecType_JsChallenge:
		_ = b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JsChallenge); err != nil {
			return err
		}
	case *GlobalSpecType_CaptchaChallenge:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CaptchaChallenge); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.ChallengeType has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 31: // challenge_type.no_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &GlobalSpecType_NoChallenge{msg}
		return true, err
	case 24: // challenge_type.js_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JavascriptChallengeType)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &GlobalSpecType_JsChallenge{msg}
		return true, err
	case 29: // challenge_type.captcha_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CaptchaChallengeType)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &GlobalSpecType_CaptchaChallenge{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// challenge_type
	switch x := m.ChallengeType.(type) {
	case *GlobalSpecType_NoChallenge:
		s := proto.Size(x.NoChallenge)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_JsChallenge:
		s := proto.Size(x.JsChallenge)
		n += proto.SizeVarint(24<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_CaptchaChallenge:
		s := proto.Size(x.CaptchaChallenge)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create virtual host
//
// x-displayName: "Create Configuration Specification"
// Creates virtual host in a given namespace.
type CreateSpecType struct {
	Domains                  []string                                       `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	Routes                   []*ves_io_schema4.ObjectRefType                `protobuf:"bytes,3,rep,name=routes" json:"routes,omitempty"`
	AdvertisePolicies        []*ves_io_schema4.ObjectRefType                `protobuf:"bytes,5,rep,name=advertise_policies,json=advertisePolicies" json:"advertise_policies,omitempty"`
	RequestHeadersToAdd      []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd" json:"request_headers_to_add,omitempty"`
	ResponseHeadersToAdd     []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=response_headers_to_add,json=responseHeadersToAdd" json:"response_headers_to_add,omitempty"`
	RequestHeadersToRemove   []string                                       `protobuf:"bytes,17,rep,name=request_headers_to_remove,json=requestHeadersToRemove" json:"request_headers_to_remove,omitempty"`
	ResponseHeadersToRemove  []string                                       `protobuf:"bytes,8,rep,name=response_headers_to_remove,json=responseHeadersToRemove" json:"response_headers_to_remove,omitempty"`
	TlsParameters            *ves_io_schema4.DownstreamTlsParamsType        `protobuf:"bytes,9,opt,name=tls_parameters,json=tlsParameters" json:"tls_parameters,omitempty"`
	BufferPolicy             *ves_io_schema4.BufferConfigType               `protobuf:"bytes,12,opt,name=buffer_policy,json=bufferPolicy" json:"buffer_policy,omitempty"`
	CorsPolicy               *ves_io_schema4.CorsPolicy                     `protobuf:"bytes,13,opt,name=cors_policy,json=corsPolicy" json:"cors_policy,omitempty"`
	Proxy                    ProxyType                                      `protobuf:"varint,15,opt,name=proxy,proto3,enum=ves.io.schema.virtual_host.ProxyType" json:"proxy,omitempty"`
	WafType                  *ves_io_schema4.WafType                        `protobuf:"bytes,18,opt,name=waf_type,json=wafType" json:"waf_type,omitempty"`
	DynamicReverseProxy      *DynamicReverseProxyType                       `protobuf:"bytes,19,opt,name=dynamic_reverse_proxy,json=dynamicReverseProxy" json:"dynamic_reverse_proxy,omitempty"`
	AddLocation              bool                                           `protobuf:"varint,20,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	CompressionParams        *CompressionType                               `protobuf:"bytes,21,opt,name=compression_params,json=compressionParams" json:"compression_params,omitempty"`
	CustomErrors             map[uint32]string                              `protobuf:"bytes,22,rep,name=custom_errors,json=customErrors" json:"custom_errors,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DisableDefaultErrorPages bool                                           `protobuf:"varint,33,opt,name=disable_default_error_pages,json=disableDefaultErrorPages,proto3" json:"disable_default_error_pages,omitempty"`
	MaxRequestHeaderSize     uint32                                         `protobuf:"varint,23,opt,name=max_request_header_size,json=maxRequestHeaderSize,proto3" json:"max_request_header_size,omitempty"`
	// Types that are valid to be assigned to ChallengeType:
	//	*CreateSpecType_NoChallenge
	//	*CreateSpecType_JsChallenge
	//	*CreateSpecType_CaptchaChallenge
	ChallengeType              isCreateSpecType_ChallengeType  `protobuf_oneof:"challenge_type"`
	UserIdentification         []*ves_io_schema4.ObjectRefType `protobuf:"bytes,25,rep,name=user_identification,json=userIdentification" json:"user_identification,omitempty"`
	RateLimiter                []*ves_io_schema4.ObjectRefType `protobuf:"bytes,26,rep,name=rate_limiter,json=rateLimiter" json:"rate_limiter,omitempty"`
	RateLimiterAllowedPrefixes []*ves_io_schema4.ObjectRefType `protobuf:"bytes,27,rep,name=rate_limiter_allowed_prefixes,json=rateLimiterAllowedPrefixes" json:"rate_limiter_allowed_prefixes,omitempty"`
	RetryPolicy                *ves_io_schema4.RetryPolicyType `protobuf:"bytes,28,opt,name=retry_policy,json=retryPolicy" json:"retry_policy,omitempty"`
	IdleTimeout                uint32                          `protobuf:"varint,32,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	DisableDnsResolve          bool                            `protobuf:"varint,34,opt,name=disable_dns_resolve,json=disableDnsResolve,proto3" json:"disable_dns_resolve,omitempty"`
	TemporaryUserBlocking      *TemporaryUserBlockingType      `protobuf:"bytes,35,opt,name=temporary_user_blocking,json=temporaryUserBlocking" json:"temporary_user_blocking,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

type isCreateSpecType_ChallengeType interface {
	isCreateSpecType_ChallengeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_NoChallenge struct {
	NoChallenge *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=no_challenge,json=noChallenge,oneof"`
}
type CreateSpecType_JsChallenge struct {
	JsChallenge *JavascriptChallengeType `protobuf:"bytes,24,opt,name=js_challenge,json=jsChallenge,oneof"`
}
type CreateSpecType_CaptchaChallenge struct {
	CaptchaChallenge *CaptchaChallengeType `protobuf:"bytes,29,opt,name=captcha_challenge,json=captchaChallenge,oneof"`
}

func (*CreateSpecType_NoChallenge) isCreateSpecType_ChallengeType()      {}
func (*CreateSpecType_JsChallenge) isCreateSpecType_ChallengeType()      {}
func (*CreateSpecType_CaptchaChallenge) isCreateSpecType_ChallengeType() {}

func (m *CreateSpecType) GetChallengeType() isCreateSpecType_ChallengeType {
	if m != nil {
		return m.ChallengeType
	}
	return nil
}

func (m *CreateSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *CreateSpecType) GetRoutes() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *CreateSpecType) GetAdvertisePolicies() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.AdvertisePolicies
	}
	return nil
}

func (m *CreateSpecType) GetRequestHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *CreateSpecType) GetResponseHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *CreateSpecType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *CreateSpecType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *CreateSpecType) GetTlsParameters() *ves_io_schema4.DownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *CreateSpecType) GetBufferPolicy() *ves_io_schema4.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *CreateSpecType) GetCorsPolicy() *ves_io_schema4.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *CreateSpecType) GetProxy() ProxyType {
	if m != nil {
		return m.Proxy
	}
	return HTTP_PROXY
}

func (m *CreateSpecType) GetWafType() *ves_io_schema4.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *CreateSpecType) GetDynamicReverseProxy() *DynamicReverseProxyType {
	if m != nil {
		return m.DynamicReverseProxy
	}
	return nil
}

func (m *CreateSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *CreateSpecType) GetCompressionParams() *CompressionType {
	if m != nil {
		return m.CompressionParams
	}
	return nil
}

func (m *CreateSpecType) GetCustomErrors() map[uint32]string {
	if m != nil {
		return m.CustomErrors
	}
	return nil
}

func (m *CreateSpecType) GetDisableDefaultErrorPages() bool {
	if m != nil {
		return m.DisableDefaultErrorPages
	}
	return false
}

func (m *CreateSpecType) GetMaxRequestHeaderSize() uint32 {
	if m != nil {
		return m.MaxRequestHeaderSize
	}
	return 0
}

func (m *CreateSpecType) GetNoChallenge() *ves_io_schema4.Empty {
	if x, ok := m.GetChallengeType().(*CreateSpecType_NoChallenge); ok {
		return x.NoChallenge
	}
	return nil
}

func (m *CreateSpecType) GetJsChallenge() *JavascriptChallengeType {
	if x, ok := m.GetChallengeType().(*CreateSpecType_JsChallenge); ok {
		return x.JsChallenge
	}
	return nil
}

func (m *CreateSpecType) GetCaptchaChallenge() *CaptchaChallengeType {
	if x, ok := m.GetChallengeType().(*CreateSpecType_CaptchaChallenge); ok {
		return x.CaptchaChallenge
	}
	return nil
}

func (m *CreateSpecType) GetUserIdentification() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.UserIdentification
	}
	return nil
}

func (m *CreateSpecType) GetRateLimiter() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *CreateSpecType) GetRateLimiterAllowedPrefixes() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiterAllowedPrefixes
	}
	return nil
}

func (m *CreateSpecType) GetRetryPolicy() *ves_io_schema4.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *CreateSpecType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *CreateSpecType) GetDisableDnsResolve() bool {
	if m != nil {
		return m.DisableDnsResolve
	}
	return false
}

func (m *CreateSpecType) GetTemporaryUserBlocking() *TemporaryUserBlockingType {
	if m != nil {
		return m.TemporaryUserBlocking
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_NoChallenge)(nil),
		(*CreateSpecType_JsChallenge)(nil),
		(*CreateSpecType_CaptchaChallenge)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// challenge_type
	switch x := m.ChallengeType.(type) {
	case *CreateSpecType_NoChallenge:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoChallenge); err != nil {
			return err
		}
	case *CreateSpecType_JsChallenge:
		_ = b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JsChallenge); err != nil {
			return err
		}
	case *CreateSpecType_CaptchaChallenge:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CaptchaChallenge); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.ChallengeType has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 31: // challenge_type.no_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &CreateSpecType_NoChallenge{msg}
		return true, err
	case 24: // challenge_type.js_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JavascriptChallengeType)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &CreateSpecType_JsChallenge{msg}
		return true, err
	case 29: // challenge_type.captcha_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CaptchaChallengeType)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &CreateSpecType_CaptchaChallenge{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// challenge_type
	switch x := m.ChallengeType.(type) {
	case *CreateSpecType_NoChallenge:
		s := proto.Size(x.NoChallenge)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_JsChallenge:
		s := proto.Size(x.JsChallenge)
		n += proto.SizeVarint(24<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_CaptchaChallenge:
		s := proto.Size(x.CaptchaChallenge)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace virtual host
//
// x-displayName: "Replace Configuration Specification"
// Replace a given virtual host in a given namespace.
type ReplaceSpecType struct {
	Domains                  []string                                       `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	Routes                   []*ves_io_schema4.ObjectRefType                `protobuf:"bytes,3,rep,name=routes" json:"routes,omitempty"`
	AdvertisePolicies        []*ves_io_schema4.ObjectRefType                `protobuf:"bytes,5,rep,name=advertise_policies,json=advertisePolicies" json:"advertise_policies,omitempty"`
	RequestHeadersToAdd      []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd" json:"request_headers_to_add,omitempty"`
	ResponseHeadersToAdd     []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=response_headers_to_add,json=responseHeadersToAdd" json:"response_headers_to_add,omitempty"`
	RequestHeadersToRemove   []string                                       `protobuf:"bytes,17,rep,name=request_headers_to_remove,json=requestHeadersToRemove" json:"request_headers_to_remove,omitempty"`
	ResponseHeadersToRemove  []string                                       `protobuf:"bytes,8,rep,name=response_headers_to_remove,json=responseHeadersToRemove" json:"response_headers_to_remove,omitempty"`
	TlsParameters            *ves_io_schema4.DownstreamTlsParamsType        `protobuf:"bytes,9,opt,name=tls_parameters,json=tlsParameters" json:"tls_parameters,omitempty"`
	BufferPolicy             *ves_io_schema4.BufferConfigType               `protobuf:"bytes,12,opt,name=buffer_policy,json=bufferPolicy" json:"buffer_policy,omitempty"`
	CorsPolicy               *ves_io_schema4.CorsPolicy                     `protobuf:"bytes,13,opt,name=cors_policy,json=corsPolicy" json:"cors_policy,omitempty"`
	Proxy                    ProxyType                                      `protobuf:"varint,15,opt,name=proxy,proto3,enum=ves.io.schema.virtual_host.ProxyType" json:"proxy,omitempty"`
	WafType                  *ves_io_schema4.WafType                        `protobuf:"bytes,18,opt,name=waf_type,json=wafType" json:"waf_type,omitempty"`
	DynamicReverseProxy      *DynamicReverseProxyType                       `protobuf:"bytes,19,opt,name=dynamic_reverse_proxy,json=dynamicReverseProxy" json:"dynamic_reverse_proxy,omitempty"`
	AddLocation              bool                                           `protobuf:"varint,20,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	CompressionParams        *CompressionType                               `protobuf:"bytes,21,opt,name=compression_params,json=compressionParams" json:"compression_params,omitempty"`
	CustomErrors             map[uint32]string                              `protobuf:"bytes,22,rep,name=custom_errors,json=customErrors" json:"custom_errors,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DisableDefaultErrorPages bool                                           `protobuf:"varint,33,opt,name=disable_default_error_pages,json=disableDefaultErrorPages,proto3" json:"disable_default_error_pages,omitempty"`
	MaxRequestHeaderSize     uint32                                         `protobuf:"varint,23,opt,name=max_request_header_size,json=maxRequestHeaderSize,proto3" json:"max_request_header_size,omitempty"`
	// Types that are valid to be assigned to ChallengeType:
	//	*ReplaceSpecType_NoChallenge
	//	*ReplaceSpecType_JsChallenge
	//	*ReplaceSpecType_CaptchaChallenge
	ChallengeType              isReplaceSpecType_ChallengeType `protobuf_oneof:"challenge_type"`
	UserIdentification         []*ves_io_schema4.ObjectRefType `protobuf:"bytes,25,rep,name=user_identification,json=userIdentification" json:"user_identification,omitempty"`
	RateLimiter                []*ves_io_schema4.ObjectRefType `protobuf:"bytes,26,rep,name=rate_limiter,json=rateLimiter" json:"rate_limiter,omitempty"`
	RateLimiterAllowedPrefixes []*ves_io_schema4.ObjectRefType `protobuf:"bytes,27,rep,name=rate_limiter_allowed_prefixes,json=rateLimiterAllowedPrefixes" json:"rate_limiter_allowed_prefixes,omitempty"`
	RetryPolicy                *ves_io_schema4.RetryPolicyType `protobuf:"bytes,28,opt,name=retry_policy,json=retryPolicy" json:"retry_policy,omitempty"`
	IdleTimeout                uint32                          `protobuf:"varint,32,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	DisableDnsResolve          bool                            `protobuf:"varint,34,opt,name=disable_dns_resolve,json=disableDnsResolve,proto3" json:"disable_dns_resolve,omitempty"`
	TemporaryUserBlocking      *TemporaryUserBlockingType      `protobuf:"bytes,35,opt,name=temporary_user_blocking,json=temporaryUserBlocking" json:"temporary_user_blocking,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

type isReplaceSpecType_ChallengeType interface {
	isReplaceSpecType_ChallengeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_NoChallenge struct {
	NoChallenge *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=no_challenge,json=noChallenge,oneof"`
}
type ReplaceSpecType_JsChallenge struct {
	JsChallenge *JavascriptChallengeType `protobuf:"bytes,24,opt,name=js_challenge,json=jsChallenge,oneof"`
}
type ReplaceSpecType_CaptchaChallenge struct {
	CaptchaChallenge *CaptchaChallengeType `protobuf:"bytes,29,opt,name=captcha_challenge,json=captchaChallenge,oneof"`
}

func (*ReplaceSpecType_NoChallenge) isReplaceSpecType_ChallengeType()      {}
func (*ReplaceSpecType_JsChallenge) isReplaceSpecType_ChallengeType()      {}
func (*ReplaceSpecType_CaptchaChallenge) isReplaceSpecType_ChallengeType() {}

func (m *ReplaceSpecType) GetChallengeType() isReplaceSpecType_ChallengeType {
	if m != nil {
		return m.ChallengeType
	}
	return nil
}

func (m *ReplaceSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *ReplaceSpecType) GetRoutes() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *ReplaceSpecType) GetAdvertisePolicies() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.AdvertisePolicies
	}
	return nil
}

func (m *ReplaceSpecType) GetRequestHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *ReplaceSpecType) GetResponseHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *ReplaceSpecType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *ReplaceSpecType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *ReplaceSpecType) GetTlsParameters() *ves_io_schema4.DownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *ReplaceSpecType) GetBufferPolicy() *ves_io_schema4.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *ReplaceSpecType) GetCorsPolicy() *ves_io_schema4.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *ReplaceSpecType) GetProxy() ProxyType {
	if m != nil {
		return m.Proxy
	}
	return HTTP_PROXY
}

func (m *ReplaceSpecType) GetWafType() *ves_io_schema4.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *ReplaceSpecType) GetDynamicReverseProxy() *DynamicReverseProxyType {
	if m != nil {
		return m.DynamicReverseProxy
	}
	return nil
}

func (m *ReplaceSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *ReplaceSpecType) GetCompressionParams() *CompressionType {
	if m != nil {
		return m.CompressionParams
	}
	return nil
}

func (m *ReplaceSpecType) GetCustomErrors() map[uint32]string {
	if m != nil {
		return m.CustomErrors
	}
	return nil
}

func (m *ReplaceSpecType) GetDisableDefaultErrorPages() bool {
	if m != nil {
		return m.DisableDefaultErrorPages
	}
	return false
}

func (m *ReplaceSpecType) GetMaxRequestHeaderSize() uint32 {
	if m != nil {
		return m.MaxRequestHeaderSize
	}
	return 0
}

func (m *ReplaceSpecType) GetNoChallenge() *ves_io_schema4.Empty {
	if x, ok := m.GetChallengeType().(*ReplaceSpecType_NoChallenge); ok {
		return x.NoChallenge
	}
	return nil
}

func (m *ReplaceSpecType) GetJsChallenge() *JavascriptChallengeType {
	if x, ok := m.GetChallengeType().(*ReplaceSpecType_JsChallenge); ok {
		return x.JsChallenge
	}
	return nil
}

func (m *ReplaceSpecType) GetCaptchaChallenge() *CaptchaChallengeType {
	if x, ok := m.GetChallengeType().(*ReplaceSpecType_CaptchaChallenge); ok {
		return x.CaptchaChallenge
	}
	return nil
}

func (m *ReplaceSpecType) GetUserIdentification() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.UserIdentification
	}
	return nil
}

func (m *ReplaceSpecType) GetRateLimiter() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *ReplaceSpecType) GetRateLimiterAllowedPrefixes() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiterAllowedPrefixes
	}
	return nil
}

func (m *ReplaceSpecType) GetRetryPolicy() *ves_io_schema4.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *ReplaceSpecType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *ReplaceSpecType) GetDisableDnsResolve() bool {
	if m != nil {
		return m.DisableDnsResolve
	}
	return false
}

func (m *ReplaceSpecType) GetTemporaryUserBlocking() *TemporaryUserBlockingType {
	if m != nil {
		return m.TemporaryUserBlocking
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_NoChallenge)(nil),
		(*ReplaceSpecType_JsChallenge)(nil),
		(*ReplaceSpecType_CaptchaChallenge)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// challenge_type
	switch x := m.ChallengeType.(type) {
	case *ReplaceSpecType_NoChallenge:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoChallenge); err != nil {
			return err
		}
	case *ReplaceSpecType_JsChallenge:
		_ = b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JsChallenge); err != nil {
			return err
		}
	case *ReplaceSpecType_CaptchaChallenge:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CaptchaChallenge); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.ChallengeType has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 31: // challenge_type.no_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &ReplaceSpecType_NoChallenge{msg}
		return true, err
	case 24: // challenge_type.js_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JavascriptChallengeType)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &ReplaceSpecType_JsChallenge{msg}
		return true, err
	case 29: // challenge_type.captcha_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CaptchaChallengeType)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &ReplaceSpecType_CaptchaChallenge{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// challenge_type
	switch x := m.ChallengeType.(type) {
	case *ReplaceSpecType_NoChallenge:
		s := proto.Size(x.NoChallenge)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_JsChallenge:
		s := proto.Size(x.JsChallenge)
		n += proto.SizeVarint(24<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_CaptchaChallenge:
		s := proto.Size(x.CaptchaChallenge)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get virtual host
//
// x-displayName: "Get Configuration Specification"
// Get virtual host from a given namespace.
type GetSpecType struct {
	Domains                  []string                                       `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	Routes                   []*ves_io_schema4.ObjectRefType                `protobuf:"bytes,3,rep,name=routes" json:"routes,omitempty"`
	AdvertisePolicies        []*ves_io_schema4.ObjectRefType                `protobuf:"bytes,5,rep,name=advertise_policies,json=advertisePolicies" json:"advertise_policies,omitempty"`
	RequestHeadersToAdd      []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd" json:"request_headers_to_add,omitempty"`
	ResponseHeadersToAdd     []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=response_headers_to_add,json=responseHeadersToAdd" json:"response_headers_to_add,omitempty"`
	RequestHeadersToRemove   []string                                       `protobuf:"bytes,17,rep,name=request_headers_to_remove,json=requestHeadersToRemove" json:"request_headers_to_remove,omitempty"`
	ResponseHeadersToRemove  []string                                       `protobuf:"bytes,8,rep,name=response_headers_to_remove,json=responseHeadersToRemove" json:"response_headers_to_remove,omitempty"`
	TlsParameters            *ves_io_schema4.DownstreamTlsParamsType        `protobuf:"bytes,9,opt,name=tls_parameters,json=tlsParameters" json:"tls_parameters,omitempty"`
	Type                     VirtualHostType                                `protobuf:"varint,10,opt,name=type,proto3,enum=ves.io.schema.virtual_host.VirtualHostType" json:"type,omitempty"`
	BufferPolicy             *ves_io_schema4.BufferConfigType               `protobuf:"bytes,12,opt,name=buffer_policy,json=bufferPolicy" json:"buffer_policy,omitempty"`
	CorsPolicy               *ves_io_schema4.CorsPolicy                     `protobuf:"bytes,13,opt,name=cors_policy,json=corsPolicy" json:"cors_policy,omitempty"`
	Proxy                    ProxyType                                      `protobuf:"varint,15,opt,name=proxy,proto3,enum=ves.io.schema.virtual_host.ProxyType" json:"proxy,omitempty"`
	WafType                  *ves_io_schema4.WafType                        `protobuf:"bytes,18,opt,name=waf_type,json=wafType" json:"waf_type,omitempty"`
	DynamicReverseProxy      *DynamicReverseProxyType                       `protobuf:"bytes,19,opt,name=dynamic_reverse_proxy,json=dynamicReverseProxy" json:"dynamic_reverse_proxy,omitempty"`
	AddLocation              bool                                           `protobuf:"varint,20,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	CompressionParams        *CompressionType                               `protobuf:"bytes,21,opt,name=compression_params,json=compressionParams" json:"compression_params,omitempty"`
	CustomErrors             map[uint32]string                              `protobuf:"bytes,22,rep,name=custom_errors,json=customErrors" json:"custom_errors,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DisableDefaultErrorPages bool                                           `protobuf:"varint,33,opt,name=disable_default_error_pages,json=disableDefaultErrorPages,proto3" json:"disable_default_error_pages,omitempty"`
	MaxRequestHeaderSize     uint32                                         `protobuf:"varint,23,opt,name=max_request_header_size,json=maxRequestHeaderSize,proto3" json:"max_request_header_size,omitempty"`
	// Types that are valid to be assigned to ChallengeType:
	//	*GetSpecType_NoChallenge
	//	*GetSpecType_JsChallenge
	//	*GetSpecType_CaptchaChallenge
	ChallengeType              isGetSpecType_ChallengeType                    `protobuf_oneof:"challenge_type"`
	UserIdentification         []*ves_io_schema4.ObjectRefType                `protobuf:"bytes,25,rep,name=user_identification,json=userIdentification" json:"user_identification,omitempty"`
	RateLimiter                []*ves_io_schema4.ObjectRefType                `protobuf:"bytes,26,rep,name=rate_limiter,json=rateLimiter" json:"rate_limiter,omitempty"`
	RateLimiterAllowedPrefixes []*ves_io_schema4.ObjectRefType                `protobuf:"bytes,27,rep,name=rate_limiter_allowed_prefixes,json=rateLimiterAllowedPrefixes" json:"rate_limiter_allowed_prefixes,omitempty"`
	RetryPolicy                *ves_io_schema4.RetryPolicyType                `protobuf:"bytes,28,opt,name=retry_policy,json=retryPolicy" json:"retry_policy,omitempty"`
	IdleTimeout                uint32                                         `protobuf:"varint,32,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	TemporaryUserBlocking      *TemporaryUserBlockingType                     `protobuf:"bytes,35,opt,name=temporary_user_blocking,json=temporaryUserBlocking" json:"temporary_user_blocking,omitempty"`
	State                      VirtualHostState                               `protobuf:"varint,1003,opt,name=state,proto3,enum=ves.io.schema.virtual_host.VirtualHostState" json:"state,omitempty"`
	HostName                   string                                         `protobuf:"bytes,1004,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	DnsInfo                    []*ves_io_schema_virtual_host_dns_info.DnsInfo `protobuf:"bytes,1005,rep,name=dns_info,json=dnsInfo" json:"dns_info,omitempty"`
	AutoCertState              CertificationState                             `protobuf:"varint,1006,opt,name=auto_cert_state,json=autoCertState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"auto_cert_state,omitempty"`
	AutoCertInfo               *AutoCertInfoType                              `protobuf:"bytes,1010,opt,name=auto_cert_info,json=autoCertInfo" json:"auto_cert_info,omitempty"`
	DisableDnsResolve          bool                                           `protobuf:"varint,34,opt,name=disable_dns_resolve,json=disableDnsResolve,proto3" json:"disable_dns_resolve,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

type isGetSpecType_ChallengeType interface {
	isGetSpecType_ChallengeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_NoChallenge struct {
	NoChallenge *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=no_challenge,json=noChallenge,oneof"`
}
type GetSpecType_JsChallenge struct {
	JsChallenge *JavascriptChallengeType `protobuf:"bytes,24,opt,name=js_challenge,json=jsChallenge,oneof"`
}
type GetSpecType_CaptchaChallenge struct {
	CaptchaChallenge *CaptchaChallengeType `protobuf:"bytes,29,opt,name=captcha_challenge,json=captchaChallenge,oneof"`
}

func (*GetSpecType_NoChallenge) isGetSpecType_ChallengeType()      {}
func (*GetSpecType_JsChallenge) isGetSpecType_ChallengeType()      {}
func (*GetSpecType_CaptchaChallenge) isGetSpecType_ChallengeType() {}

func (m *GetSpecType) GetChallengeType() isGetSpecType_ChallengeType {
	if m != nil {
		return m.ChallengeType
	}
	return nil
}

func (m *GetSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *GetSpecType) GetRoutes() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *GetSpecType) GetAdvertisePolicies() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.AdvertisePolicies
	}
	return nil
}

func (m *GetSpecType) GetRequestHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *GetSpecType) GetResponseHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *GetSpecType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *GetSpecType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *GetSpecType) GetTlsParameters() *ves_io_schema4.DownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *GetSpecType) GetType() VirtualHostType {
	if m != nil {
		return m.Type
	}
	return VIRTUAL_SERVICE
}

func (m *GetSpecType) GetBufferPolicy() *ves_io_schema4.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *GetSpecType) GetCorsPolicy() *ves_io_schema4.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *GetSpecType) GetProxy() ProxyType {
	if m != nil {
		return m.Proxy
	}
	return HTTP_PROXY
}

func (m *GetSpecType) GetWafType() *ves_io_schema4.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *GetSpecType) GetDynamicReverseProxy() *DynamicReverseProxyType {
	if m != nil {
		return m.DynamicReverseProxy
	}
	return nil
}

func (m *GetSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *GetSpecType) GetCompressionParams() *CompressionType {
	if m != nil {
		return m.CompressionParams
	}
	return nil
}

func (m *GetSpecType) GetCustomErrors() map[uint32]string {
	if m != nil {
		return m.CustomErrors
	}
	return nil
}

func (m *GetSpecType) GetDisableDefaultErrorPages() bool {
	if m != nil {
		return m.DisableDefaultErrorPages
	}
	return false
}

func (m *GetSpecType) GetMaxRequestHeaderSize() uint32 {
	if m != nil {
		return m.MaxRequestHeaderSize
	}
	return 0
}

func (m *GetSpecType) GetNoChallenge() *ves_io_schema4.Empty {
	if x, ok := m.GetChallengeType().(*GetSpecType_NoChallenge); ok {
		return x.NoChallenge
	}
	return nil
}

func (m *GetSpecType) GetJsChallenge() *JavascriptChallengeType {
	if x, ok := m.GetChallengeType().(*GetSpecType_JsChallenge); ok {
		return x.JsChallenge
	}
	return nil
}

func (m *GetSpecType) GetCaptchaChallenge() *CaptchaChallengeType {
	if x, ok := m.GetChallengeType().(*GetSpecType_CaptchaChallenge); ok {
		return x.CaptchaChallenge
	}
	return nil
}

func (m *GetSpecType) GetUserIdentification() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.UserIdentification
	}
	return nil
}

func (m *GetSpecType) GetRateLimiter() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *GetSpecType) GetRateLimiterAllowedPrefixes() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiterAllowedPrefixes
	}
	return nil
}

func (m *GetSpecType) GetRetryPolicy() *ves_io_schema4.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *GetSpecType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *GetSpecType) GetTemporaryUserBlocking() *TemporaryUserBlockingType {
	if m != nil {
		return m.TemporaryUserBlocking
	}
	return nil
}

func (m *GetSpecType) GetState() VirtualHostState {
	if m != nil {
		return m.State
	}
	return VIRTUAL_HOST_READY
}

func (m *GetSpecType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *GetSpecType) GetDnsInfo() []*ves_io_schema_virtual_host_dns_info.DnsInfo {
	if m != nil {
		return m.DnsInfo
	}
	return nil
}

func (m *GetSpecType) GetAutoCertState() CertificationState {
	if m != nil {
		return m.AutoCertState
	}
	return AutoCertDisabled
}

func (m *GetSpecType) GetAutoCertInfo() *AutoCertInfoType {
	if m != nil {
		return m.AutoCertInfo
	}
	return nil
}

func (m *GetSpecType) GetDisableDnsResolve() bool {
	if m != nil {
		return m.DisableDnsResolve
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_NoChallenge)(nil),
		(*GetSpecType_JsChallenge)(nil),
		(*GetSpecType_CaptchaChallenge)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// challenge_type
	switch x := m.ChallengeType.(type) {
	case *GetSpecType_NoChallenge:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoChallenge); err != nil {
			return err
		}
	case *GetSpecType_JsChallenge:
		_ = b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JsChallenge); err != nil {
			return err
		}
	case *GetSpecType_CaptchaChallenge:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CaptchaChallenge); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.ChallengeType has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 31: // challenge_type.no_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &GetSpecType_NoChallenge{msg}
		return true, err
	case 24: // challenge_type.js_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JavascriptChallengeType)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &GetSpecType_JsChallenge{msg}
		return true, err
	case 29: // challenge_type.captcha_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CaptchaChallengeType)
		err := b.DecodeMessage(msg)
		m.ChallengeType = &GetSpecType_CaptchaChallenge{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// challenge_type
	switch x := m.ChallengeType.(type) {
	case *GetSpecType_NoChallenge:
		s := proto.Size(x.NoChallenge)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_JsChallenge:
		s := proto.Size(x.JsChallenge)
		n += proto.SizeVarint(24<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_CaptchaChallenge:
		s := proto.Size(x.CaptchaChallenge)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*JavaScriptConfigType)(nil), "ves.io.schema.virtual_host.JavaScriptConfigType")
	golang_proto.RegisterType((*JavaScriptConfigType)(nil), "ves.io.schema.virtual_host.JavaScriptConfigType")
	proto.RegisterType((*DynamicReverseProxyType)(nil), "ves.io.schema.virtual_host.DynamicReverseProxyType")
	golang_proto.RegisterType((*DynamicReverseProxyType)(nil), "ves.io.schema.virtual_host.DynamicReverseProxyType")
	proto.RegisterType((*CompressionType)(nil), "ves.io.schema.virtual_host.CompressionType")
	golang_proto.RegisterType((*CompressionType)(nil), "ves.io.schema.virtual_host.CompressionType")
	proto.RegisterType((*JavascriptChallengeType)(nil), "ves.io.schema.virtual_host.JavascriptChallengeType")
	golang_proto.RegisterType((*JavascriptChallengeType)(nil), "ves.io.schema.virtual_host.JavascriptChallengeType")
	proto.RegisterType((*CaptchaChallengeType)(nil), "ves.io.schema.virtual_host.CaptchaChallengeType")
	golang_proto.RegisterType((*CaptchaChallengeType)(nil), "ves.io.schema.virtual_host.CaptchaChallengeType")
	proto.RegisterType((*TemporaryUserBlockingType)(nil), "ves.io.schema.virtual_host.TemporaryUserBlockingType")
	golang_proto.RegisterType((*TemporaryUserBlockingType)(nil), "ves.io.schema.virtual_host.TemporaryUserBlockingType")
	proto.RegisterType((*AutoCertInfoType)(nil), "ves.io.schema.virtual_host.AutoCertInfoType")
	golang_proto.RegisterType((*AutoCertInfoType)(nil), "ves.io.schema.virtual_host.AutoCertInfoType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.virtual_host.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.virtual_host.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.virtual_host.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.virtual_host.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.virtual_host.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.virtual_host.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.virtual_host.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.virtual_host.GetSpecType")
	proto.RegisterEnum("ves.io.schema.virtual_host.VirtualHostType", VirtualHostType_name, VirtualHostType_value)
	golang_proto.RegisterEnum("ves.io.schema.virtual_host.VirtualHostType", VirtualHostType_name, VirtualHostType_value)
	proto.RegisterEnum("ves.io.schema.virtual_host.ProxyType", ProxyType_name, ProxyType_value)
	golang_proto.RegisterEnum("ves.io.schema.virtual_host.ProxyType", ProxyType_name, ProxyType_value)
	proto.RegisterEnum("ves.io.schema.virtual_host.VirtualHostState", VirtualHostState_name, VirtualHostState_value)
	golang_proto.RegisterEnum("ves.io.schema.virtual_host.VirtualHostState", VirtualHostState_name, VirtualHostState_value)
	proto.RegisterEnum("ves.io.schema.virtual_host.CertificationState", CertificationState_name, CertificationState_value)
	golang_proto.RegisterEnum("ves.io.schema.virtual_host.CertificationState", CertificationState_name, CertificationState_value)
}
func (x VirtualHostType) String() string {
	s, ok := VirtualHostType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ProxyType) String() string {
	s, ok := ProxyType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VirtualHostState) String() string {
	s, ok := VirtualHostState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CertificationState) String() string {
	s, ok := CertificationState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *JavaScriptConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptConfigType)
	if !ok {
		that2, ok := that.(JavaScriptConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CachePrefix != that1.CachePrefix {
		return false
	}
	if !this.ScriptConfig.Equal(that1.ScriptConfig) {
		return false
	}
	if this.CustomScriptUrl != that1.CustomScriptUrl {
		return false
	}
	return true
}
func (this *DynamicReverseProxyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DynamicReverseProxyType)
	if !ok {
		that2, ok := that.(DynamicReverseProxyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResolveEndpointDynamically != that1.ResolveEndpointDynamically {
		return false
	}
	if this.ResolutionNetworkType != that1.ResolutionNetworkType {
		return false
	}
	if len(this.ResolutionNetwork) != len(that1.ResolutionNetwork) {
		return false
	}
	for i := range this.ResolutionNetwork {
		if !this.ResolutionNetwork[i].Equal(that1.ResolutionNetwork[i]) {
			return false
		}
	}
	return true
}
func (this *CompressionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompressionType)
	if !ok {
		that2, ok := that.(CompressionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContentLength != that1.ContentLength {
		return false
	}
	if len(this.ContentType) != len(that1.ContentType) {
		return false
	}
	for i := range this.ContentType {
		if this.ContentType[i] != that1.ContentType[i] {
			return false
		}
	}
	if this.DisableOnEtagHeader != that1.DisableOnEtagHeader {
		return false
	}
	if this.RemoveAcceptEncodingHeader != that1.RemoveAcceptEncodingHeader {
		return false
	}
	return true
}
func (this *JavascriptChallengeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavascriptChallengeType)
	if !ok {
		that2, ok := that.(JavascriptChallengeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EnableJsChallenge != that1.EnableJsChallenge {
		return false
	}
	if this.JsScriptDelay != that1.JsScriptDelay {
		return false
	}
	if this.CookieExpiry != that1.CookieExpiry {
		return false
	}
	if this.CustomPage != that1.CustomPage {
		return false
	}
	return true
}
func (this *CaptchaChallengeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CaptchaChallengeType)
	if !ok {
		that2, ok := that.(CaptchaChallengeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EnableCaptchaChallenge != that1.EnableCaptchaChallenge {
		return false
	}
	if this.CookieExpiry != that1.CookieExpiry {
		return false
	}
	if this.CustomPage != that1.CustomPage {
		return false
	}
	return true
}
func (this *TemporaryUserBlockingType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TemporaryUserBlockingType)
	if !ok {
		that2, ok := that.(TemporaryUserBlockingType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomPage != that1.CustomPage {
		return false
	}
	return true
}
func (this *AutoCertInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AutoCertInfoType)
	if !ok {
		that2, ok := that.(AutoCertInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AutoCertState != that1.AutoCertState {
		return false
	}
	if !this.AutoCertExpiry.Equal(that1.AutoCertExpiry) {
		return false
	}
	if this.AutoCertSubject != that1.AutoCertSubject {
		return false
	}
	if this.AutoCertIssuer != that1.AutoCertIssuer {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if !this.JavascriptInfo.Equal(that1.JavascriptInfo) {
		return false
	}
	if len(this.AdvertisePolicies) != len(that1.AdvertisePolicies) {
		return false
	}
	for i := range this.AdvertisePolicies {
		if !this.AdvertisePolicies[i].Equal(that1.AdvertisePolicies[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if this.Proxy != that1.Proxy {
		return false
	}
	if len(this.Jwt) != len(that1.Jwt) {
		return false
	}
	for i := range this.Jwt {
		if !this.Jwt[i].Equal(that1.Jwt[i]) {
			return false
		}
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if !this.DynamicReverseProxy.Equal(that1.DynamicReverseProxy) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.CompressionParams.Equal(that1.CompressionParams) {
		return false
	}
	if len(this.CustomErrors) != len(that1.CustomErrors) {
		return false
	}
	for i := range this.CustomErrors {
		if this.CustomErrors[i] != that1.CustomErrors[i] {
			return false
		}
	}
	if this.DisableDefaultErrorPages != that1.DisableDefaultErrorPages {
		return false
	}
	if this.MaxRequestHeaderSize != that1.MaxRequestHeaderSize {
		return false
	}
	if that1.ChallengeType == nil {
		if this.ChallengeType != nil {
			return false
		}
	} else if this.ChallengeType == nil {
		return false
	} else if !this.ChallengeType.Equal(that1.ChallengeType) {
		return false
	}
	if len(this.UserIdentification) != len(that1.UserIdentification) {
		return false
	}
	for i := range this.UserIdentification {
		if !this.UserIdentification[i].Equal(that1.UserIdentification[i]) {
			return false
		}
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if len(this.RateLimiterAllowedPrefixes) != len(that1.RateLimiterAllowedPrefixes) {
		return false
	}
	for i := range this.RateLimiterAllowedPrefixes {
		if !this.RateLimiterAllowedPrefixes[i].Equal(that1.RateLimiterAllowedPrefixes[i]) {
			return false
		}
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if !this.TemporaryUserBlocking.Equal(that1.TemporaryUserBlocking) {
		return false
	}
	if len(this.MaliciousUserMitigation) != len(that1.MaliciousUserMitigation) {
		return false
	}
	for i := range this.MaliciousUserMitigation {
		if !this.MaliciousUserMitigation[i].Equal(that1.MaliciousUserMitigation[i]) {
			return false
		}
	}
	if !this.TlsIntercept.Equal(that1.TlsIntercept) {
		return false
	}
	if len(this.DnsDomains) != len(that1.DnsDomains) {
		return false
	}
	for i := range this.DnsDomains {
		if !this.DnsDomains[i].Equal(that1.DnsDomains[i]) {
			return false
		}
	}
	if this.AutoCert != that1.AutoCert {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if len(this.DnsInfo) != len(that1.DnsInfo) {
		return false
	}
	for i := range this.DnsInfo {
		if !this.DnsInfo[i].Equal(that1.DnsInfo[i]) {
			return false
		}
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if this.AutoCertState != that1.AutoCertState {
		return false
	}
	if !this.AutoCertInfo.Equal(that1.AutoCertInfo) {
		return false
	}
	if len(this.UserDomains) != len(that1.UserDomains) {
		return false
	}
	for i := range this.UserDomains {
		if this.UserDomains[i] != that1.UserDomains[i] {
			return false
		}
	}
	if this.DisableDnsResolve != that1.DisableDnsResolve {
		return false
	}
	if len(this.ServicePolicySet) != len(that1.ServicePolicySet) {
		return false
	}
	for i := range this.ServicePolicySet {
		if !this.ServicePolicySet[i].Equal(that1.ServicePolicySet[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_NoChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoChallenge)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChallenge.Equal(that1.NoChallenge) {
		return false
	}
	return true
}
func (this *GlobalSpecType_JsChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_JsChallenge)
	if !ok {
		that2, ok := that.(GlobalSpecType_JsChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsChallenge.Equal(that1.JsChallenge) {
		return false
	}
	return true
}
func (this *GlobalSpecType_CaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_CaptchaChallenge)
	if !ok {
		that2, ok := that.(GlobalSpecType_CaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CaptchaChallenge.Equal(that1.CaptchaChallenge) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if len(this.AdvertisePolicies) != len(that1.AdvertisePolicies) {
		return false
	}
	for i := range this.AdvertisePolicies {
		if !this.AdvertisePolicies[i].Equal(that1.AdvertisePolicies[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if this.Proxy != that1.Proxy {
		return false
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if !this.DynamicReverseProxy.Equal(that1.DynamicReverseProxy) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.CompressionParams.Equal(that1.CompressionParams) {
		return false
	}
	if len(this.CustomErrors) != len(that1.CustomErrors) {
		return false
	}
	for i := range this.CustomErrors {
		if this.CustomErrors[i] != that1.CustomErrors[i] {
			return false
		}
	}
	if this.DisableDefaultErrorPages != that1.DisableDefaultErrorPages {
		return false
	}
	if this.MaxRequestHeaderSize != that1.MaxRequestHeaderSize {
		return false
	}
	if that1.ChallengeType == nil {
		if this.ChallengeType != nil {
			return false
		}
	} else if this.ChallengeType == nil {
		return false
	} else if !this.ChallengeType.Equal(that1.ChallengeType) {
		return false
	}
	if len(this.UserIdentification) != len(that1.UserIdentification) {
		return false
	}
	for i := range this.UserIdentification {
		if !this.UserIdentification[i].Equal(that1.UserIdentification[i]) {
			return false
		}
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if len(this.RateLimiterAllowedPrefixes) != len(that1.RateLimiterAllowedPrefixes) {
		return false
	}
	for i := range this.RateLimiterAllowedPrefixes {
		if !this.RateLimiterAllowedPrefixes[i].Equal(that1.RateLimiterAllowedPrefixes[i]) {
			return false
		}
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if this.DisableDnsResolve != that1.DisableDnsResolve {
		return false
	}
	if !this.TemporaryUserBlocking.Equal(that1.TemporaryUserBlocking) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoChallenge)
	if !ok {
		that2, ok := that.(CreateSpecType_NoChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChallenge.Equal(that1.NoChallenge) {
		return false
	}
	return true
}
func (this *CreateSpecType_JsChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_JsChallenge)
	if !ok {
		that2, ok := that.(CreateSpecType_JsChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsChallenge.Equal(that1.JsChallenge) {
		return false
	}
	return true
}
func (this *CreateSpecType_CaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_CaptchaChallenge)
	if !ok {
		that2, ok := that.(CreateSpecType_CaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CaptchaChallenge.Equal(that1.CaptchaChallenge) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if len(this.AdvertisePolicies) != len(that1.AdvertisePolicies) {
		return false
	}
	for i := range this.AdvertisePolicies {
		if !this.AdvertisePolicies[i].Equal(that1.AdvertisePolicies[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if this.Proxy != that1.Proxy {
		return false
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if !this.DynamicReverseProxy.Equal(that1.DynamicReverseProxy) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.CompressionParams.Equal(that1.CompressionParams) {
		return false
	}
	if len(this.CustomErrors) != len(that1.CustomErrors) {
		return false
	}
	for i := range this.CustomErrors {
		if this.CustomErrors[i] != that1.CustomErrors[i] {
			return false
		}
	}
	if this.DisableDefaultErrorPages != that1.DisableDefaultErrorPages {
		return false
	}
	if this.MaxRequestHeaderSize != that1.MaxRequestHeaderSize {
		return false
	}
	if that1.ChallengeType == nil {
		if this.ChallengeType != nil {
			return false
		}
	} else if this.ChallengeType == nil {
		return false
	} else if !this.ChallengeType.Equal(that1.ChallengeType) {
		return false
	}
	if len(this.UserIdentification) != len(that1.UserIdentification) {
		return false
	}
	for i := range this.UserIdentification {
		if !this.UserIdentification[i].Equal(that1.UserIdentification[i]) {
			return false
		}
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if len(this.RateLimiterAllowedPrefixes) != len(that1.RateLimiterAllowedPrefixes) {
		return false
	}
	for i := range this.RateLimiterAllowedPrefixes {
		if !this.RateLimiterAllowedPrefixes[i].Equal(that1.RateLimiterAllowedPrefixes[i]) {
			return false
		}
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if this.DisableDnsResolve != that1.DisableDnsResolve {
		return false
	}
	if !this.TemporaryUserBlocking.Equal(that1.TemporaryUserBlocking) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoChallenge)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChallenge.Equal(that1.NoChallenge) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_JsChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_JsChallenge)
	if !ok {
		that2, ok := that.(ReplaceSpecType_JsChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsChallenge.Equal(that1.JsChallenge) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_CaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_CaptchaChallenge)
	if !ok {
		that2, ok := that.(ReplaceSpecType_CaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CaptchaChallenge.Equal(that1.CaptchaChallenge) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if len(this.AdvertisePolicies) != len(that1.AdvertisePolicies) {
		return false
	}
	for i := range this.AdvertisePolicies {
		if !this.AdvertisePolicies[i].Equal(that1.AdvertisePolicies[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if this.Proxy != that1.Proxy {
		return false
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if !this.DynamicReverseProxy.Equal(that1.DynamicReverseProxy) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.CompressionParams.Equal(that1.CompressionParams) {
		return false
	}
	if len(this.CustomErrors) != len(that1.CustomErrors) {
		return false
	}
	for i := range this.CustomErrors {
		if this.CustomErrors[i] != that1.CustomErrors[i] {
			return false
		}
	}
	if this.DisableDefaultErrorPages != that1.DisableDefaultErrorPages {
		return false
	}
	if this.MaxRequestHeaderSize != that1.MaxRequestHeaderSize {
		return false
	}
	if that1.ChallengeType == nil {
		if this.ChallengeType != nil {
			return false
		}
	} else if this.ChallengeType == nil {
		return false
	} else if !this.ChallengeType.Equal(that1.ChallengeType) {
		return false
	}
	if len(this.UserIdentification) != len(that1.UserIdentification) {
		return false
	}
	for i := range this.UserIdentification {
		if !this.UserIdentification[i].Equal(that1.UserIdentification[i]) {
			return false
		}
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if len(this.RateLimiterAllowedPrefixes) != len(that1.RateLimiterAllowedPrefixes) {
		return false
	}
	for i := range this.RateLimiterAllowedPrefixes {
		if !this.RateLimiterAllowedPrefixes[i].Equal(that1.RateLimiterAllowedPrefixes[i]) {
			return false
		}
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if !this.TemporaryUserBlocking.Equal(that1.TemporaryUserBlocking) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if len(this.DnsInfo) != len(that1.DnsInfo) {
		return false
	}
	for i := range this.DnsInfo {
		if !this.DnsInfo[i].Equal(that1.DnsInfo[i]) {
			return false
		}
	}
	if this.AutoCertState != that1.AutoCertState {
		return false
	}
	if !this.AutoCertInfo.Equal(that1.AutoCertInfo) {
		return false
	}
	if this.DisableDnsResolve != that1.DisableDnsResolve {
		return false
	}
	return true
}
func (this *GetSpecType_NoChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoChallenge)
	if !ok {
		that2, ok := that.(GetSpecType_NoChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChallenge.Equal(that1.NoChallenge) {
		return false
	}
	return true
}
func (this *GetSpecType_JsChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_JsChallenge)
	if !ok {
		that2, ok := that.(GetSpecType_JsChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsChallenge.Equal(that1.JsChallenge) {
		return false
	}
	return true
}
func (this *GetSpecType_CaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_CaptchaChallenge)
	if !ok {
		that2, ok := that.(GetSpecType_CaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CaptchaChallenge.Equal(that1.CaptchaChallenge) {
		return false
	}
	return true
}
func (this *JavaScriptConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&virtual_host.JavaScriptConfigType{")
	s = append(s, "CachePrefix: "+fmt.Sprintf("%#v", this.CachePrefix)+",\n")
	if this.ScriptConfig != nil {
		s = append(s, "ScriptConfig: "+fmt.Sprintf("%#v", this.ScriptConfig)+",\n")
	}
	s = append(s, "CustomScriptUrl: "+fmt.Sprintf("%#v", this.CustomScriptUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DynamicReverseProxyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&virtual_host.DynamicReverseProxyType{")
	s = append(s, "ResolveEndpointDynamically: "+fmt.Sprintf("%#v", this.ResolveEndpointDynamically)+",\n")
	s = append(s, "ResolutionNetworkType: "+fmt.Sprintf("%#v", this.ResolutionNetworkType)+",\n")
	if this.ResolutionNetwork != nil {
		s = append(s, "ResolutionNetwork: "+fmt.Sprintf("%#v", this.ResolutionNetwork)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CompressionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&virtual_host.CompressionType{")
	s = append(s, "ContentLength: "+fmt.Sprintf("%#v", this.ContentLength)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "DisableOnEtagHeader: "+fmt.Sprintf("%#v", this.DisableOnEtagHeader)+",\n")
	s = append(s, "RemoveAcceptEncodingHeader: "+fmt.Sprintf("%#v", this.RemoveAcceptEncodingHeader)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavascriptChallengeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&virtual_host.JavascriptChallengeType{")
	s = append(s, "EnableJsChallenge: "+fmt.Sprintf("%#v", this.EnableJsChallenge)+",\n")
	s = append(s, "JsScriptDelay: "+fmt.Sprintf("%#v", this.JsScriptDelay)+",\n")
	s = append(s, "CookieExpiry: "+fmt.Sprintf("%#v", this.CookieExpiry)+",\n")
	s = append(s, "CustomPage: "+fmt.Sprintf("%#v", this.CustomPage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CaptchaChallengeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&virtual_host.CaptchaChallengeType{")
	s = append(s, "EnableCaptchaChallenge: "+fmt.Sprintf("%#v", this.EnableCaptchaChallenge)+",\n")
	s = append(s, "CookieExpiry: "+fmt.Sprintf("%#v", this.CookieExpiry)+",\n")
	s = append(s, "CustomPage: "+fmt.Sprintf("%#v", this.CustomPage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TemporaryUserBlockingType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&virtual_host.TemporaryUserBlockingType{")
	s = append(s, "CustomPage: "+fmt.Sprintf("%#v", this.CustomPage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutoCertInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&virtual_host.AutoCertInfoType{")
	s = append(s, "AutoCertState: "+fmt.Sprintf("%#v", this.AutoCertState)+",\n")
	if this.AutoCertExpiry != nil {
		s = append(s, "AutoCertExpiry: "+fmt.Sprintf("%#v", this.AutoCertExpiry)+",\n")
	}
	s = append(s, "AutoCertSubject: "+fmt.Sprintf("%#v", this.AutoCertSubject)+",\n")
	s = append(s, "AutoCertIssuer: "+fmt.Sprintf("%#v", this.AutoCertIssuer)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 46)
	s = append(s, "&virtual_host.GlobalSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	if this.JavascriptInfo != nil {
		s = append(s, "JavascriptInfo: "+fmt.Sprintf("%#v", this.JavascriptInfo)+",\n")
	}
	if this.AdvertisePolicies != nil {
		s = append(s, "AdvertisePolicies: "+fmt.Sprintf("%#v", this.AdvertisePolicies)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	if this.Jwt != nil {
		s = append(s, "Jwt: "+fmt.Sprintf("%#v", this.Jwt)+",\n")
	}
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	if this.DynamicReverseProxy != nil {
		s = append(s, "DynamicReverseProxy: "+fmt.Sprintf("%#v", this.DynamicReverseProxy)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.CompressionParams != nil {
		s = append(s, "CompressionParams: "+fmt.Sprintf("%#v", this.CompressionParams)+",\n")
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%#v: %#v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	if this.CustomErrors != nil {
		s = append(s, "CustomErrors: "+mapStringForCustomErrors+",\n")
	}
	s = append(s, "DisableDefaultErrorPages: "+fmt.Sprintf("%#v", this.DisableDefaultErrorPages)+",\n")
	s = append(s, "MaxRequestHeaderSize: "+fmt.Sprintf("%#v", this.MaxRequestHeaderSize)+",\n")
	if this.ChallengeType != nil {
		s = append(s, "ChallengeType: "+fmt.Sprintf("%#v", this.ChallengeType)+",\n")
	}
	if this.UserIdentification != nil {
		s = append(s, "UserIdentification: "+fmt.Sprintf("%#v", this.UserIdentification)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.RateLimiterAllowedPrefixes != nil {
		s = append(s, "RateLimiterAllowedPrefixes: "+fmt.Sprintf("%#v", this.RateLimiterAllowedPrefixes)+",\n")
	}
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	if this.TemporaryUserBlocking != nil {
		s = append(s, "TemporaryUserBlocking: "+fmt.Sprintf("%#v", this.TemporaryUserBlocking)+",\n")
	}
	if this.MaliciousUserMitigation != nil {
		s = append(s, "MaliciousUserMitigation: "+fmt.Sprintf("%#v", this.MaliciousUserMitigation)+",\n")
	}
	if this.TlsIntercept != nil {
		s = append(s, "TlsIntercept: "+fmt.Sprintf("%#v", this.TlsIntercept)+",\n")
	}
	if this.DnsDomains != nil {
		s = append(s, "DnsDomains: "+fmt.Sprintf("%#v", this.DnsDomains)+",\n")
	}
	s = append(s, "AutoCert: "+fmt.Sprintf("%#v", this.AutoCert)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	if this.DnsInfo != nil {
		s = append(s, "DnsInfo: "+fmt.Sprintf("%#v", this.DnsInfo)+",\n")
	}
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	s = append(s, "AutoCertState: "+fmt.Sprintf("%#v", this.AutoCertState)+",\n")
	if this.AutoCertInfo != nil {
		s = append(s, "AutoCertInfo: "+fmt.Sprintf("%#v", this.AutoCertInfo)+",\n")
	}
	s = append(s, "UserDomains: "+fmt.Sprintf("%#v", this.UserDomains)+",\n")
	s = append(s, "DisableDnsResolve: "+fmt.Sprintf("%#v", this.DisableDnsResolve)+",\n")
	if this.ServicePolicySet != nil {
		s = append(s, "ServicePolicySet: "+fmt.Sprintf("%#v", this.ServicePolicySet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_NoChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_NoChallenge{` +
		`NoChallenge:` + fmt.Sprintf("%#v", this.NoChallenge) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_JsChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_JsChallenge{` +
		`JsChallenge:` + fmt.Sprintf("%#v", this.JsChallenge) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_CaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_CaptchaChallenge{` +
		`CaptchaChallenge:` + fmt.Sprintf("%#v", this.CaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 32)
	s = append(s, "&virtual_host.CreateSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	if this.AdvertisePolicies != nil {
		s = append(s, "AdvertisePolicies: "+fmt.Sprintf("%#v", this.AdvertisePolicies)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	if this.DynamicReverseProxy != nil {
		s = append(s, "DynamicReverseProxy: "+fmt.Sprintf("%#v", this.DynamicReverseProxy)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.CompressionParams != nil {
		s = append(s, "CompressionParams: "+fmt.Sprintf("%#v", this.CompressionParams)+",\n")
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%#v: %#v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	if this.CustomErrors != nil {
		s = append(s, "CustomErrors: "+mapStringForCustomErrors+",\n")
	}
	s = append(s, "DisableDefaultErrorPages: "+fmt.Sprintf("%#v", this.DisableDefaultErrorPages)+",\n")
	s = append(s, "MaxRequestHeaderSize: "+fmt.Sprintf("%#v", this.MaxRequestHeaderSize)+",\n")
	if this.ChallengeType != nil {
		s = append(s, "ChallengeType: "+fmt.Sprintf("%#v", this.ChallengeType)+",\n")
	}
	if this.UserIdentification != nil {
		s = append(s, "UserIdentification: "+fmt.Sprintf("%#v", this.UserIdentification)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.RateLimiterAllowedPrefixes != nil {
		s = append(s, "RateLimiterAllowedPrefixes: "+fmt.Sprintf("%#v", this.RateLimiterAllowedPrefixes)+",\n")
	}
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	s = append(s, "DisableDnsResolve: "+fmt.Sprintf("%#v", this.DisableDnsResolve)+",\n")
	if this.TemporaryUserBlocking != nil {
		s = append(s, "TemporaryUserBlocking: "+fmt.Sprintf("%#v", this.TemporaryUserBlocking)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_NoChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_NoChallenge{` +
		`NoChallenge:` + fmt.Sprintf("%#v", this.NoChallenge) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_JsChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_JsChallenge{` +
		`JsChallenge:` + fmt.Sprintf("%#v", this.JsChallenge) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_CaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_CaptchaChallenge{` +
		`CaptchaChallenge:` + fmt.Sprintf("%#v", this.CaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 32)
	s = append(s, "&virtual_host.ReplaceSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	if this.AdvertisePolicies != nil {
		s = append(s, "AdvertisePolicies: "+fmt.Sprintf("%#v", this.AdvertisePolicies)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	if this.DynamicReverseProxy != nil {
		s = append(s, "DynamicReverseProxy: "+fmt.Sprintf("%#v", this.DynamicReverseProxy)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.CompressionParams != nil {
		s = append(s, "CompressionParams: "+fmt.Sprintf("%#v", this.CompressionParams)+",\n")
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%#v: %#v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	if this.CustomErrors != nil {
		s = append(s, "CustomErrors: "+mapStringForCustomErrors+",\n")
	}
	s = append(s, "DisableDefaultErrorPages: "+fmt.Sprintf("%#v", this.DisableDefaultErrorPages)+",\n")
	s = append(s, "MaxRequestHeaderSize: "+fmt.Sprintf("%#v", this.MaxRequestHeaderSize)+",\n")
	if this.ChallengeType != nil {
		s = append(s, "ChallengeType: "+fmt.Sprintf("%#v", this.ChallengeType)+",\n")
	}
	if this.UserIdentification != nil {
		s = append(s, "UserIdentification: "+fmt.Sprintf("%#v", this.UserIdentification)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.RateLimiterAllowedPrefixes != nil {
		s = append(s, "RateLimiterAllowedPrefixes: "+fmt.Sprintf("%#v", this.RateLimiterAllowedPrefixes)+",\n")
	}
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	s = append(s, "DisableDnsResolve: "+fmt.Sprintf("%#v", this.DisableDnsResolve)+",\n")
	if this.TemporaryUserBlocking != nil {
		s = append(s, "TemporaryUserBlocking: "+fmt.Sprintf("%#v", this.TemporaryUserBlocking)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_NoChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_NoChallenge{` +
		`NoChallenge:` + fmt.Sprintf("%#v", this.NoChallenge) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_JsChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_JsChallenge{` +
		`JsChallenge:` + fmt.Sprintf("%#v", this.JsChallenge) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_CaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_CaptchaChallenge{` +
		`CaptchaChallenge:` + fmt.Sprintf("%#v", this.CaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 38)
	s = append(s, "&virtual_host.GetSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	if this.AdvertisePolicies != nil {
		s = append(s, "AdvertisePolicies: "+fmt.Sprintf("%#v", this.AdvertisePolicies)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	if this.DynamicReverseProxy != nil {
		s = append(s, "DynamicReverseProxy: "+fmt.Sprintf("%#v", this.DynamicReverseProxy)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.CompressionParams != nil {
		s = append(s, "CompressionParams: "+fmt.Sprintf("%#v", this.CompressionParams)+",\n")
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%#v: %#v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	if this.CustomErrors != nil {
		s = append(s, "CustomErrors: "+mapStringForCustomErrors+",\n")
	}
	s = append(s, "DisableDefaultErrorPages: "+fmt.Sprintf("%#v", this.DisableDefaultErrorPages)+",\n")
	s = append(s, "MaxRequestHeaderSize: "+fmt.Sprintf("%#v", this.MaxRequestHeaderSize)+",\n")
	if this.ChallengeType != nil {
		s = append(s, "ChallengeType: "+fmt.Sprintf("%#v", this.ChallengeType)+",\n")
	}
	if this.UserIdentification != nil {
		s = append(s, "UserIdentification: "+fmt.Sprintf("%#v", this.UserIdentification)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.RateLimiterAllowedPrefixes != nil {
		s = append(s, "RateLimiterAllowedPrefixes: "+fmt.Sprintf("%#v", this.RateLimiterAllowedPrefixes)+",\n")
	}
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	if this.TemporaryUserBlocking != nil {
		s = append(s, "TemporaryUserBlocking: "+fmt.Sprintf("%#v", this.TemporaryUserBlocking)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	if this.DnsInfo != nil {
		s = append(s, "DnsInfo: "+fmt.Sprintf("%#v", this.DnsInfo)+",\n")
	}
	s = append(s, "AutoCertState: "+fmt.Sprintf("%#v", this.AutoCertState)+",\n")
	if this.AutoCertInfo != nil {
		s = append(s, "AutoCertInfo: "+fmt.Sprintf("%#v", this.AutoCertInfo)+",\n")
	}
	s = append(s, "DisableDnsResolve: "+fmt.Sprintf("%#v", this.DisableDnsResolve)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_NoChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_NoChallenge{` +
		`NoChallenge:` + fmt.Sprintf("%#v", this.NoChallenge) + `}`}, ", ")
	return s
}
func (this *GetSpecType_JsChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_JsChallenge{` +
		`JsChallenge:` + fmt.Sprintf("%#v", this.JsChallenge) + `}`}, ", ")
	return s
}
func (this *GetSpecType_CaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_CaptchaChallenge{` +
		`CaptchaChallenge:` + fmt.Sprintf("%#v", this.CaptchaChallenge) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *JavaScriptConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaScriptConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CachePrefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CachePrefix)))
		i += copy(dAtA[i:], m.CachePrefix)
	}
	if m.ScriptConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ScriptConfig.Size()))
		n1, err := m.ScriptConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.CustomScriptUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomScriptUrl)))
		i += copy(dAtA[i:], m.CustomScriptUrl)
	}
	return i, nil
}

func (m *DynamicReverseProxyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicReverseProxyType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResolveEndpointDynamically {
		dAtA[i] = 0x8
		i++
		if m.ResolveEndpointDynamically {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ResolutionNetworkType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ResolutionNetworkType))
	}
	if len(m.ResolutionNetwork) > 0 {
		for _, msg := range m.ResolutionNetwork {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CompressionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompressionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContentLength != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ContentLength))
	}
	if len(m.ContentType) > 0 {
		for _, s := range m.ContentType {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DisableOnEtagHeader {
		dAtA[i] = 0x18
		i++
		if m.DisableOnEtagHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RemoveAcceptEncodingHeader {
		dAtA[i] = 0x20
		i++
		if m.RemoveAcceptEncodingHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *JavascriptChallengeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavascriptChallengeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnableJsChallenge {
		dAtA[i] = 0x8
		i++
		if m.EnableJsChallenge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.JsScriptDelay != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.JsScriptDelay))
	}
	if m.CookieExpiry != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieExpiry))
	}
	if len(m.CustomPage) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomPage)))
		i += copy(dAtA[i:], m.CustomPage)
	}
	return i, nil
}

func (m *CaptchaChallengeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptchaChallengeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnableCaptchaChallenge {
		dAtA[i] = 0x8
		i++
		if m.EnableCaptchaChallenge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CookieExpiry != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieExpiry))
	}
	if len(m.CustomPage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomPage)))
		i += copy(dAtA[i:], m.CustomPage)
	}
	return i, nil
}

func (m *TemporaryUserBlockingType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TemporaryUserBlockingType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CustomPage) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomPage)))
		i += copy(dAtA[i:], m.CustomPage)
	}
	return i, nil
}

func (m *AutoCertInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoCertInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AutoCertState != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertState))
	}
	if m.AutoCertExpiry != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertExpiry.Size()))
		n2, err := m.AutoCertExpiry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.AutoCertSubject) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AutoCertSubject)))
		i += copy(dAtA[i:], m.AutoCertSubject)
	}
	if len(m.AutoCertIssuer) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AutoCertIssuer)))
		i += copy(dAtA[i:], m.AutoCertIssuer)
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.JavascriptInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.JavascriptInfo.Size()))
		n3, err := m.JavascriptInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, msg := range m.AdvertisePolicies {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, msg := range m.RequestHeadersToAdd {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, msg := range m.ResponseHeadersToAdd {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TlsParameters != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsParameters.Size()))
		n4, err := m.TlsParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Type != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.BufferPolicy != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BufferPolicy.Size()))
		n5, err := m.BufferPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.CorsPolicy != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CorsPolicy.Size()))
		n6, err := m.CorsPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Proxy != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Proxy))
	}
	if len(m.Jwt) > 0 {
		for _, msg := range m.Jwt {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.WafType != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafType.Size()))
		n7, err := m.WafType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.DynamicReverseProxy != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DynamicReverseProxy.Size()))
		n8, err := m.DynamicReverseProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.AddLocation {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CompressionParams != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CompressionParams.Size()))
		n9, err := m.CompressionParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.CustomErrors) > 0 {
		keysForCustomErrors := make([]uint32, 0, len(m.CustomErrors))
		for k, _ := range m.CustomErrors {
			keysForCustomErrors = append(keysForCustomErrors, uint32(k))
		}
		sortkeys.Uint32s(keysForCustomErrors)
		for _, k := range keysForCustomErrors {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.CustomErrors[uint32(k)]
			mapSize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		nn10, err := m.ChallengeType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	if len(m.UserIdentification) > 0 {
		for _, msg := range m.UserIdentification {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, msg := range m.RateLimiter {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, msg := range m.RateLimiterAllowedPrefixes {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RetryPolicy != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RetryPolicy.Size()))
		n11, err := m.RetryPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.DisableDefaultErrorPages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableDnsResolve {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.DisableDnsResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TemporaryUserBlocking != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TemporaryUserBlocking.Size()))
		n12, err := m.TemporaryUserBlocking.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.MaliciousUserMitigation) > 0 {
		for _, msg := range m.MaliciousUserMitigation {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TlsIntercept != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsIntercept.Size()))
		n13, err := m.TlsIntercept.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.DnsDomains) > 0 {
		for _, msg := range m.DnsDomains {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x3e
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AutoCert {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x3e
		i++
		if m.AutoCert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.State != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
	}
	if len(m.HostName) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if len(m.DnsInfo) > 0 {
		for _, msg := range m.DnsInfo {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x3e
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AutoCertState != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertState))
	}
	if m.AutoCertInfo != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3f
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertInfo.Size()))
		n14, err := m.AutoCertInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.UserDomains) > 0 {
		for _, s := range m.UserDomains {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x3f
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ServicePolicySet) > 0 {
		for _, msg := range m.ServicePolicySet {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x3f
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GlobalSpecType_JsChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.JsChallenge != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.JsChallenge.Size()))
		n15, err := m.JsChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *GlobalSpecType_CaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CaptchaChallenge != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CaptchaChallenge.Size()))
		n16, err := m.CaptchaChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *GlobalSpecType_NoChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoChallenge != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoChallenge.Size()))
		n17, err := m.NoChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, msg := range m.AdvertisePolicies {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, msg := range m.RequestHeadersToAdd {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, msg := range m.ResponseHeadersToAdd {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TlsParameters != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsParameters.Size()))
		n18, err := m.TlsParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.BufferPolicy != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BufferPolicy.Size()))
		n19, err := m.BufferPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.CorsPolicy != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CorsPolicy.Size()))
		n20, err := m.CorsPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Proxy != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Proxy))
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.WafType != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafType.Size()))
		n21, err := m.WafType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.DynamicReverseProxy != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DynamicReverseProxy.Size()))
		n22, err := m.DynamicReverseProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.AddLocation {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CompressionParams != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CompressionParams.Size()))
		n23, err := m.CompressionParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.CustomErrors) > 0 {
		keysForCustomErrors := make([]uint32, 0, len(m.CustomErrors))
		for k, _ := range m.CustomErrors {
			keysForCustomErrors = append(keysForCustomErrors, uint32(k))
		}
		sortkeys.Uint32s(keysForCustomErrors)
		for _, k := range keysForCustomErrors {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.CustomErrors[uint32(k)]
			mapSize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		nn24, err := m.ChallengeType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	if len(m.UserIdentification) > 0 {
		for _, msg := range m.UserIdentification {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, msg := range m.RateLimiter {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, msg := range m.RateLimiterAllowedPrefixes {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RetryPolicy != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RetryPolicy.Size()))
		n25, err := m.RetryPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.DisableDefaultErrorPages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableDnsResolve {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.DisableDnsResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TemporaryUserBlocking != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TemporaryUserBlocking.Size()))
		n26, err := m.TemporaryUserBlocking.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *CreateSpecType_JsChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.JsChallenge != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.JsChallenge.Size()))
		n27, err := m.JsChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *CreateSpecType_CaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CaptchaChallenge != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CaptchaChallenge.Size()))
		n28, err := m.CaptchaChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *CreateSpecType_NoChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoChallenge != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoChallenge.Size()))
		n29, err := m.NoChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, msg := range m.AdvertisePolicies {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, msg := range m.RequestHeadersToAdd {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, msg := range m.ResponseHeadersToAdd {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TlsParameters != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsParameters.Size()))
		n30, err := m.TlsParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.BufferPolicy != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BufferPolicy.Size()))
		n31, err := m.BufferPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.CorsPolicy != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CorsPolicy.Size()))
		n32, err := m.CorsPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Proxy != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Proxy))
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.WafType != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafType.Size()))
		n33, err := m.WafType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.DynamicReverseProxy != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DynamicReverseProxy.Size()))
		n34, err := m.DynamicReverseProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.AddLocation {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CompressionParams != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CompressionParams.Size()))
		n35, err := m.CompressionParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if len(m.CustomErrors) > 0 {
		keysForCustomErrors := make([]uint32, 0, len(m.CustomErrors))
		for k, _ := range m.CustomErrors {
			keysForCustomErrors = append(keysForCustomErrors, uint32(k))
		}
		sortkeys.Uint32s(keysForCustomErrors)
		for _, k := range keysForCustomErrors {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.CustomErrors[uint32(k)]
			mapSize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		nn36, err := m.ChallengeType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn36
	}
	if len(m.UserIdentification) > 0 {
		for _, msg := range m.UserIdentification {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, msg := range m.RateLimiter {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, msg := range m.RateLimiterAllowedPrefixes {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RetryPolicy != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RetryPolicy.Size()))
		n37, err := m.RetryPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.DisableDefaultErrorPages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableDnsResolve {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.DisableDnsResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TemporaryUserBlocking != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TemporaryUserBlocking.Size()))
		n38, err := m.TemporaryUserBlocking.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *ReplaceSpecType_JsChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.JsChallenge != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.JsChallenge.Size()))
		n39, err := m.JsChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *ReplaceSpecType_CaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CaptchaChallenge != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CaptchaChallenge.Size()))
		n40, err := m.CaptchaChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *ReplaceSpecType_NoChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoChallenge != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoChallenge.Size()))
		n41, err := m.NoChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, msg := range m.AdvertisePolicies {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, msg := range m.RequestHeadersToAdd {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, msg := range m.ResponseHeadersToAdd {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TlsParameters != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsParameters.Size()))
		n42, err := m.TlsParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Type != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.BufferPolicy != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BufferPolicy.Size()))
		n43, err := m.BufferPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.CorsPolicy != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CorsPolicy.Size()))
		n44, err := m.CorsPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.Proxy != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Proxy))
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.WafType != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafType.Size()))
		n45, err := m.WafType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.DynamicReverseProxy != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DynamicReverseProxy.Size()))
		n46, err := m.DynamicReverseProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.AddLocation {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CompressionParams != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CompressionParams.Size()))
		n47, err := m.CompressionParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.CustomErrors) > 0 {
		keysForCustomErrors := make([]uint32, 0, len(m.CustomErrors))
		for k, _ := range m.CustomErrors {
			keysForCustomErrors = append(keysForCustomErrors, uint32(k))
		}
		sortkeys.Uint32s(keysForCustomErrors)
		for _, k := range keysForCustomErrors {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.CustomErrors[uint32(k)]
			mapSize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		nn48, err := m.ChallengeType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn48
	}
	if len(m.UserIdentification) > 0 {
		for _, msg := range m.UserIdentification {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, msg := range m.RateLimiter {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, msg := range m.RateLimiterAllowedPrefixes {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RetryPolicy != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RetryPolicy.Size()))
		n49, err := m.RetryPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.DisableDefaultErrorPages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableDnsResolve {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.DisableDnsResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TemporaryUserBlocking != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TemporaryUserBlocking.Size()))
		n50, err := m.TemporaryUserBlocking.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.State != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
	}
	if len(m.HostName) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if len(m.DnsInfo) > 0 {
		for _, msg := range m.DnsInfo {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x3e
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AutoCertState != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertState))
	}
	if m.AutoCertInfo != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3f
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertInfo.Size()))
		n51, err := m.AutoCertInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *GetSpecType_JsChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.JsChallenge != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.JsChallenge.Size()))
		n52, err := m.JsChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	return i, nil
}
func (m *GetSpecType_CaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CaptchaChallenge != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CaptchaChallenge.Size()))
		n53, err := m.CaptchaChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}
func (m *GetSpecType_NoChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoChallenge != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoChallenge.Size()))
		n54, err := m.NoChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedJavaScriptConfigType(r randyTypes, easy bool) *JavaScriptConfigType {
	this := &JavaScriptConfigType{}
	this.CachePrefix = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.ScriptConfig = google_protobuf3.NewPopulatedStruct(r, easy)
	}
	this.CustomScriptUrl = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDynamicReverseProxyType(r randyTypes, easy bool) *DynamicReverseProxyType {
	this := &DynamicReverseProxyType{}
	this.ResolveEndpointDynamically = bool(bool(r.Intn(2) == 0))
	this.ResolutionNetworkType = ves_io_schema3.VirtualNetworkType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.ResolutionNetwork = make([]*ves_io_schema4.ObjectRefType, v1)
		for i := 0; i < v1; i++ {
			this.ResolutionNetwork[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCompressionType(r randyTypes, easy bool) *CompressionType {
	this := &CompressionType{}
	this.ContentLength = uint32(r.Uint32())
	v2 := r.Intn(10)
	this.ContentType = make([]string, v2)
	for i := 0; i < v2; i++ {
		this.ContentType[i] = string(randStringTypes(r))
	}
	this.DisableOnEtagHeader = bool(bool(r.Intn(2) == 0))
	this.RemoveAcceptEncodingHeader = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedJavascriptChallengeType(r randyTypes, easy bool) *JavascriptChallengeType {
	this := &JavascriptChallengeType{}
	this.EnableJsChallenge = bool(bool(r.Intn(2) == 0))
	this.JsScriptDelay = uint32(r.Uint32())
	this.CookieExpiry = uint32(r.Uint32())
	this.CustomPage = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCaptchaChallengeType(r randyTypes, easy bool) *CaptchaChallengeType {
	this := &CaptchaChallengeType{}
	this.EnableCaptchaChallenge = bool(bool(r.Intn(2) == 0))
	this.CookieExpiry = uint32(r.Uint32())
	this.CustomPage = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTemporaryUserBlockingType(r randyTypes, easy bool) *TemporaryUserBlockingType {
	this := &TemporaryUserBlockingType{}
	this.CustomPage = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAutoCertInfoType(r randyTypes, easy bool) *AutoCertInfoType {
	this := &AutoCertInfoType{}
	this.AutoCertState = CertificationState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}[r.Intn(12)])
	if r.Intn(10) != 0 {
		this.AutoCertExpiry = google_protobuf1.NewPopulatedTimestamp(r, easy)
	}
	this.AutoCertSubject = string(randStringTypes(r))
	this.AutoCertIssuer = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	v3 := r.Intn(10)
	this.Domains = make([]string, v3)
	for i := 0; i < v3; i++ {
		this.Domains[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.Routes = make([]*ves_io_schema4.ObjectRefType, v4)
		for i := 0; i < v4; i++ {
			this.Routes[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.JavascriptInfo = NewPopulatedJavaScriptConfigType(r, easy)
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.AdvertisePolicies = make([]*ves_io_schema4.ObjectRefType, v5)
		for i := 0; i < v5; i++ {
			this.AdvertisePolicies[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.RequestHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v6)
		for i := 0; i < v6; i++ {
			this.RequestHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.ResponseHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v7)
		for i := 0; i < v7; i++ {
			this.ResponseHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	v8 := r.Intn(10)
	this.ResponseHeadersToRemove = make([]string, v8)
	for i := 0; i < v8; i++ {
		this.ResponseHeadersToRemove[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.TlsParameters = ves_io_schema4.NewPopulatedDownstreamTlsParamsType(r, easy)
	}
	this.Type = VirtualHostType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if r.Intn(10) != 0 {
		this.BufferPolicy = ves_io_schema4.NewPopulatedBufferConfigType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CorsPolicy = ves_io_schema4.NewPopulatedCorsPolicy(r, easy)
	}
	this.Proxy = ProxyType([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.Jwt = make([]*ves_io_schema4.ObjectRefType, v9)
		for i := 0; i < v9; i++ {
			this.Jwt[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	v10 := r.Intn(10)
	this.RequestHeadersToRemove = make([]string, v10)
	for i := 0; i < v10; i++ {
		this.RequestHeadersToRemove[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.WafType = ves_io_schema4.NewPopulatedWafType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DynamicReverseProxy = NewPopulatedDynamicReverseProxyType(r, easy)
	}
	this.AddLocation = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.CompressionParams = NewPopulatedCompressionType(r, easy)
	}
	if r.Intn(10) != 0 {
		v11 := r.Intn(10)
		this.CustomErrors = make(map[uint32]string)
		for i := 0; i < v11; i++ {
			this.CustomErrors[uint32(r.Uint32())] = randStringTypes(r)
		}
	}
	this.MaxRequestHeaderSize = uint32(r.Uint32())
	oneofNumber_ChallengeType := []int32{24, 29, 31}[r.Intn(3)]
	switch oneofNumber_ChallengeType {
	case 24:
		this.ChallengeType = NewPopulatedGlobalSpecType_JsChallenge(r, easy)
	case 29:
		this.ChallengeType = NewPopulatedGlobalSpecType_CaptchaChallenge(r, easy)
	case 31:
		this.ChallengeType = NewPopulatedGlobalSpecType_NoChallenge(r, easy)
	}
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.UserIdentification = make([]*ves_io_schema4.ObjectRefType, v12)
		for i := 0; i < v12; i++ {
			this.UserIdentification[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.RateLimiter = make([]*ves_io_schema4.ObjectRefType, v13)
		for i := 0; i < v13; i++ {
			this.RateLimiter[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v14 := r.Intn(5)
		this.RateLimiterAllowedPrefixes = make([]*ves_io_schema4.ObjectRefType, v14)
		for i := 0; i < v14; i++ {
			this.RateLimiterAllowedPrefixes[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.RetryPolicy = ves_io_schema4.NewPopulatedRetryPolicyType(r, easy)
	}
	this.IdleTimeout = uint32(r.Uint32())
	this.DisableDefaultErrorPages = bool(bool(r.Intn(2) == 0))
	this.DisableDnsResolve = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.TemporaryUserBlocking = NewPopulatedTemporaryUserBlockingType(r, easy)
	}
	if r.Intn(10) != 0 {
		v15 := r.Intn(5)
		this.MaliciousUserMitigation = make([]*ves_io_schema4.ObjectRefType, v15)
		for i := 0; i < v15; i++ {
			this.MaliciousUserMitigation[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.TlsIntercept = ves_io_schema4.NewPopulatedTlsInterceptionType(r, easy)
	}
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.DnsDomains = make([]*ves_io_schema4.ObjectRefType, v16)
		for i := 0; i < v16; i++ {
			this.DnsDomains[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	this.AutoCert = bool(bool(r.Intn(2) == 0))
	this.State = VirtualHostState([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	this.HostName = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v17 := r.Intn(5)
		this.DnsInfo = make([]*ves_io_schema_virtual_host_dns_info.DnsInfo, v17)
		for i := 0; i < v17; i++ {
			this.DnsInfo[i] = ves_io_schema_virtual_host_dns_info.NewPopulatedDnsInfo(r, easy)
		}
	}
	this.AutoCertState = CertificationState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}[r.Intn(12)])
	if r.Intn(10) != 0 {
		this.AutoCertInfo = NewPopulatedAutoCertInfoType(r, easy)
	}
	v18 := r.Intn(10)
	this.UserDomains = make([]string, v18)
	for i := 0; i < v18; i++ {
		this.UserDomains[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		v19 := r.Intn(5)
		this.ServicePolicySet = make([]*ves_io_schema4.ObjectRefType, v19)
		for i := 0; i < v19; i++ {
			this.ServicePolicySet[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType_JsChallenge(r randyTypes, easy bool) *GlobalSpecType_JsChallenge {
	this := &GlobalSpecType_JsChallenge{}
	this.JsChallenge = NewPopulatedJavascriptChallengeType(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_CaptchaChallenge(r randyTypes, easy bool) *GlobalSpecType_CaptchaChallenge {
	this := &GlobalSpecType_CaptchaChallenge{}
	this.CaptchaChallenge = NewPopulatedCaptchaChallengeType(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_NoChallenge(r randyTypes, easy bool) *GlobalSpecType_NoChallenge {
	this := &GlobalSpecType_NoChallenge{}
	this.NoChallenge = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	v20 := r.Intn(10)
	this.Domains = make([]string, v20)
	for i := 0; i < v20; i++ {
		this.Domains[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		v21 := r.Intn(5)
		this.Routes = make([]*ves_io_schema4.ObjectRefType, v21)
		for i := 0; i < v21; i++ {
			this.Routes[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v22 := r.Intn(5)
		this.AdvertisePolicies = make([]*ves_io_schema4.ObjectRefType, v22)
		for i := 0; i < v22; i++ {
			this.AdvertisePolicies[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(5)
		this.RequestHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v23)
		for i := 0; i < v23; i++ {
			this.RequestHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v24 := r.Intn(5)
		this.ResponseHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v24)
		for i := 0; i < v24; i++ {
			this.ResponseHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	v25 := r.Intn(10)
	this.ResponseHeadersToRemove = make([]string, v25)
	for i := 0; i < v25; i++ {
		this.ResponseHeadersToRemove[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.TlsParameters = ves_io_schema4.NewPopulatedDownstreamTlsParamsType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BufferPolicy = ves_io_schema4.NewPopulatedBufferConfigType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CorsPolicy = ves_io_schema4.NewPopulatedCorsPolicy(r, easy)
	}
	this.Proxy = ProxyType([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	v26 := r.Intn(10)
	this.RequestHeadersToRemove = make([]string, v26)
	for i := 0; i < v26; i++ {
		this.RequestHeadersToRemove[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.WafType = ves_io_schema4.NewPopulatedWafType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DynamicReverseProxy = NewPopulatedDynamicReverseProxyType(r, easy)
	}
	this.AddLocation = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.CompressionParams = NewPopulatedCompressionType(r, easy)
	}
	if r.Intn(10) != 0 {
		v27 := r.Intn(10)
		this.CustomErrors = make(map[uint32]string)
		for i := 0; i < v27; i++ {
			this.CustomErrors[uint32(r.Uint32())] = randStringTypes(r)
		}
	}
	this.MaxRequestHeaderSize = uint32(r.Uint32())
	oneofNumber_ChallengeType := []int32{24, 29, 31}[r.Intn(3)]
	switch oneofNumber_ChallengeType {
	case 24:
		this.ChallengeType = NewPopulatedCreateSpecType_JsChallenge(r, easy)
	case 29:
		this.ChallengeType = NewPopulatedCreateSpecType_CaptchaChallenge(r, easy)
	case 31:
		this.ChallengeType = NewPopulatedCreateSpecType_NoChallenge(r, easy)
	}
	if r.Intn(10) != 0 {
		v28 := r.Intn(5)
		this.UserIdentification = make([]*ves_io_schema4.ObjectRefType, v28)
		for i := 0; i < v28; i++ {
			this.UserIdentification[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v29 := r.Intn(5)
		this.RateLimiter = make([]*ves_io_schema4.ObjectRefType, v29)
		for i := 0; i < v29; i++ {
			this.RateLimiter[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v30 := r.Intn(5)
		this.RateLimiterAllowedPrefixes = make([]*ves_io_schema4.ObjectRefType, v30)
		for i := 0; i < v30; i++ {
			this.RateLimiterAllowedPrefixes[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.RetryPolicy = ves_io_schema4.NewPopulatedRetryPolicyType(r, easy)
	}
	this.IdleTimeout = uint32(r.Uint32())
	this.DisableDefaultErrorPages = bool(bool(r.Intn(2) == 0))
	this.DisableDnsResolve = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.TemporaryUserBlocking = NewPopulatedTemporaryUserBlockingType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType_JsChallenge(r randyTypes, easy bool) *CreateSpecType_JsChallenge {
	this := &CreateSpecType_JsChallenge{}
	this.JsChallenge = NewPopulatedJavascriptChallengeType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_CaptchaChallenge(r randyTypes, easy bool) *CreateSpecType_CaptchaChallenge {
	this := &CreateSpecType_CaptchaChallenge{}
	this.CaptchaChallenge = NewPopulatedCaptchaChallengeType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_NoChallenge(r randyTypes, easy bool) *CreateSpecType_NoChallenge {
	this := &CreateSpecType_NoChallenge{}
	this.NoChallenge = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	v31 := r.Intn(10)
	this.Domains = make([]string, v31)
	for i := 0; i < v31; i++ {
		this.Domains[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		v32 := r.Intn(5)
		this.Routes = make([]*ves_io_schema4.ObjectRefType, v32)
		for i := 0; i < v32; i++ {
			this.Routes[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v33 := r.Intn(5)
		this.AdvertisePolicies = make([]*ves_io_schema4.ObjectRefType, v33)
		for i := 0; i < v33; i++ {
			this.AdvertisePolicies[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v34 := r.Intn(5)
		this.RequestHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v34)
		for i := 0; i < v34; i++ {
			this.RequestHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v35 := r.Intn(5)
		this.ResponseHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v35)
		for i := 0; i < v35; i++ {
			this.ResponseHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	v36 := r.Intn(10)
	this.ResponseHeadersToRemove = make([]string, v36)
	for i := 0; i < v36; i++ {
		this.ResponseHeadersToRemove[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.TlsParameters = ves_io_schema4.NewPopulatedDownstreamTlsParamsType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BufferPolicy = ves_io_schema4.NewPopulatedBufferConfigType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CorsPolicy = ves_io_schema4.NewPopulatedCorsPolicy(r, easy)
	}
	this.Proxy = ProxyType([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	v37 := r.Intn(10)
	this.RequestHeadersToRemove = make([]string, v37)
	for i := 0; i < v37; i++ {
		this.RequestHeadersToRemove[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.WafType = ves_io_schema4.NewPopulatedWafType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DynamicReverseProxy = NewPopulatedDynamicReverseProxyType(r, easy)
	}
	this.AddLocation = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.CompressionParams = NewPopulatedCompressionType(r, easy)
	}
	if r.Intn(10) != 0 {
		v38 := r.Intn(10)
		this.CustomErrors = make(map[uint32]string)
		for i := 0; i < v38; i++ {
			this.CustomErrors[uint32(r.Uint32())] = randStringTypes(r)
		}
	}
	this.MaxRequestHeaderSize = uint32(r.Uint32())
	oneofNumber_ChallengeType := []int32{24, 29, 31}[r.Intn(3)]
	switch oneofNumber_ChallengeType {
	case 24:
		this.ChallengeType = NewPopulatedReplaceSpecType_JsChallenge(r, easy)
	case 29:
		this.ChallengeType = NewPopulatedReplaceSpecType_CaptchaChallenge(r, easy)
	case 31:
		this.ChallengeType = NewPopulatedReplaceSpecType_NoChallenge(r, easy)
	}
	if r.Intn(10) != 0 {
		v39 := r.Intn(5)
		this.UserIdentification = make([]*ves_io_schema4.ObjectRefType, v39)
		for i := 0; i < v39; i++ {
			this.UserIdentification[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v40 := r.Intn(5)
		this.RateLimiter = make([]*ves_io_schema4.ObjectRefType, v40)
		for i := 0; i < v40; i++ {
			this.RateLimiter[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v41 := r.Intn(5)
		this.RateLimiterAllowedPrefixes = make([]*ves_io_schema4.ObjectRefType, v41)
		for i := 0; i < v41; i++ {
			this.RateLimiterAllowedPrefixes[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.RetryPolicy = ves_io_schema4.NewPopulatedRetryPolicyType(r, easy)
	}
	this.IdleTimeout = uint32(r.Uint32())
	this.DisableDefaultErrorPages = bool(bool(r.Intn(2) == 0))
	this.DisableDnsResolve = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.TemporaryUserBlocking = NewPopulatedTemporaryUserBlockingType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType_JsChallenge(r randyTypes, easy bool) *ReplaceSpecType_JsChallenge {
	this := &ReplaceSpecType_JsChallenge{}
	this.JsChallenge = NewPopulatedJavascriptChallengeType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_CaptchaChallenge(r randyTypes, easy bool) *ReplaceSpecType_CaptchaChallenge {
	this := &ReplaceSpecType_CaptchaChallenge{}
	this.CaptchaChallenge = NewPopulatedCaptchaChallengeType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_NoChallenge(r randyTypes, easy bool) *ReplaceSpecType_NoChallenge {
	this := &ReplaceSpecType_NoChallenge{}
	this.NoChallenge = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	v42 := r.Intn(10)
	this.Domains = make([]string, v42)
	for i := 0; i < v42; i++ {
		this.Domains[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		v43 := r.Intn(5)
		this.Routes = make([]*ves_io_schema4.ObjectRefType, v43)
		for i := 0; i < v43; i++ {
			this.Routes[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v44 := r.Intn(5)
		this.AdvertisePolicies = make([]*ves_io_schema4.ObjectRefType, v44)
		for i := 0; i < v44; i++ {
			this.AdvertisePolicies[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v45 := r.Intn(5)
		this.RequestHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v45)
		for i := 0; i < v45; i++ {
			this.RequestHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v46 := r.Intn(5)
		this.ResponseHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v46)
		for i := 0; i < v46; i++ {
			this.ResponseHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	v47 := r.Intn(10)
	this.ResponseHeadersToRemove = make([]string, v47)
	for i := 0; i < v47; i++ {
		this.ResponseHeadersToRemove[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.TlsParameters = ves_io_schema4.NewPopulatedDownstreamTlsParamsType(r, easy)
	}
	this.Type = VirtualHostType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if r.Intn(10) != 0 {
		this.BufferPolicy = ves_io_schema4.NewPopulatedBufferConfigType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CorsPolicy = ves_io_schema4.NewPopulatedCorsPolicy(r, easy)
	}
	this.Proxy = ProxyType([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	v48 := r.Intn(10)
	this.RequestHeadersToRemove = make([]string, v48)
	for i := 0; i < v48; i++ {
		this.RequestHeadersToRemove[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.WafType = ves_io_schema4.NewPopulatedWafType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DynamicReverseProxy = NewPopulatedDynamicReverseProxyType(r, easy)
	}
	this.AddLocation = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.CompressionParams = NewPopulatedCompressionType(r, easy)
	}
	if r.Intn(10) != 0 {
		v49 := r.Intn(10)
		this.CustomErrors = make(map[uint32]string)
		for i := 0; i < v49; i++ {
			this.CustomErrors[uint32(r.Uint32())] = randStringTypes(r)
		}
	}
	this.MaxRequestHeaderSize = uint32(r.Uint32())
	oneofNumber_ChallengeType := []int32{24, 29, 31}[r.Intn(3)]
	switch oneofNumber_ChallengeType {
	case 24:
		this.ChallengeType = NewPopulatedGetSpecType_JsChallenge(r, easy)
	case 29:
		this.ChallengeType = NewPopulatedGetSpecType_CaptchaChallenge(r, easy)
	case 31:
		this.ChallengeType = NewPopulatedGetSpecType_NoChallenge(r, easy)
	}
	if r.Intn(10) != 0 {
		v50 := r.Intn(5)
		this.UserIdentification = make([]*ves_io_schema4.ObjectRefType, v50)
		for i := 0; i < v50; i++ {
			this.UserIdentification[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v51 := r.Intn(5)
		this.RateLimiter = make([]*ves_io_schema4.ObjectRefType, v51)
		for i := 0; i < v51; i++ {
			this.RateLimiter[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v52 := r.Intn(5)
		this.RateLimiterAllowedPrefixes = make([]*ves_io_schema4.ObjectRefType, v52)
		for i := 0; i < v52; i++ {
			this.RateLimiterAllowedPrefixes[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.RetryPolicy = ves_io_schema4.NewPopulatedRetryPolicyType(r, easy)
	}
	this.IdleTimeout = uint32(r.Uint32())
	this.DisableDefaultErrorPages = bool(bool(r.Intn(2) == 0))
	this.DisableDnsResolve = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.TemporaryUserBlocking = NewPopulatedTemporaryUserBlockingType(r, easy)
	}
	this.State = VirtualHostState([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	this.HostName = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v53 := r.Intn(5)
		this.DnsInfo = make([]*ves_io_schema_virtual_host_dns_info.DnsInfo, v53)
		for i := 0; i < v53; i++ {
			this.DnsInfo[i] = ves_io_schema_virtual_host_dns_info.NewPopulatedDnsInfo(r, easy)
		}
	}
	this.AutoCertState = CertificationState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}[r.Intn(12)])
	if r.Intn(10) != 0 {
		this.AutoCertInfo = NewPopulatedAutoCertInfoType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType_JsChallenge(r randyTypes, easy bool) *GetSpecType_JsChallenge {
	this := &GetSpecType_JsChallenge{}
	this.JsChallenge = NewPopulatedJavascriptChallengeType(r, easy)
	return this
}
func NewPopulatedGetSpecType_CaptchaChallenge(r randyTypes, easy bool) *GetSpecType_CaptchaChallenge {
	this := &GetSpecType_CaptchaChallenge{}
	this.CaptchaChallenge = NewPopulatedCaptchaChallengeType(r, easy)
	return this
}
func NewPopulatedGetSpecType_NoChallenge(r randyTypes, easy bool) *GetSpecType_NoChallenge {
	this := &GetSpecType_NoChallenge{}
	this.NoChallenge = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v54 := r.Intn(100)
	tmps := make([]rune, v54)
	for i := 0; i < v54; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v55 := r.Int63()
		if r.Intn(2) == 0 {
			v55 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v55))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *JavaScriptConfigType) Size() (n int) {
	var l int
	_ = l
	l = len(m.CachePrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ScriptConfig != nil {
		l = m.ScriptConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CustomScriptUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DynamicReverseProxyType) Size() (n int) {
	var l int
	_ = l
	if m.ResolveEndpointDynamically {
		n += 2
	}
	if m.ResolutionNetworkType != 0 {
		n += 1 + sovTypes(uint64(m.ResolutionNetworkType))
	}
	if len(m.ResolutionNetwork) > 0 {
		for _, e := range m.ResolutionNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CompressionType) Size() (n int) {
	var l int
	_ = l
	if m.ContentLength != 0 {
		n += 1 + sovTypes(uint64(m.ContentLength))
	}
	if len(m.ContentType) > 0 {
		for _, s := range m.ContentType {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DisableOnEtagHeader {
		n += 2
	}
	if m.RemoveAcceptEncodingHeader {
		n += 2
	}
	return n
}

func (m *JavascriptChallengeType) Size() (n int) {
	var l int
	_ = l
	if m.EnableJsChallenge {
		n += 2
	}
	if m.JsScriptDelay != 0 {
		n += 1 + sovTypes(uint64(m.JsScriptDelay))
	}
	if m.CookieExpiry != 0 {
		n += 1 + sovTypes(uint64(m.CookieExpiry))
	}
	l = len(m.CustomPage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CaptchaChallengeType) Size() (n int) {
	var l int
	_ = l
	if m.EnableCaptchaChallenge {
		n += 2
	}
	if m.CookieExpiry != 0 {
		n += 1 + sovTypes(uint64(m.CookieExpiry))
	}
	l = len(m.CustomPage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TemporaryUserBlockingType) Size() (n int) {
	var l int
	_ = l
	l = len(m.CustomPage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AutoCertInfoType) Size() (n int) {
	var l int
	_ = l
	if m.AutoCertState != 0 {
		n += 1 + sovTypes(uint64(m.AutoCertState))
	}
	if m.AutoCertExpiry != nil {
		l = m.AutoCertExpiry.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AutoCertSubject)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AutoCertIssuer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.JavascriptInfo != nil {
		l = m.JavascriptInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, e := range m.AdvertisePolicies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Proxy != 0 {
		n += 1 + sovTypes(uint64(m.Proxy))
	}
	if len(m.Jwt) > 0 {
		for _, e := range m.Jwt {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DynamicReverseProxy != nil {
		l = m.DynamicReverseProxy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AddLocation {
		n += 3
	}
	if m.CompressionParams != nil {
		l = m.CompressionParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.CustomErrors) > 0 {
		for k, v := range m.CustomErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		n += 2 + sovTypes(uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		n += m.ChallengeType.Size()
	}
	if len(m.UserIdentification) > 0 {
		for _, e := range m.UserIdentification {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, e := range m.RateLimiterAllowedPrefixes {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IdleTimeout != 0 {
		n += 2 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		n += 3
	}
	if m.DisableDnsResolve {
		n += 3
	}
	if m.TemporaryUserBlocking != nil {
		l = m.TemporaryUserBlocking.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.MaliciousUserMitigation) > 0 {
		for _, e := range m.MaliciousUserMitigation {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsIntercept != nil {
		l = m.TlsIntercept.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DnsDomains) > 0 {
		for _, e := range m.DnsDomains {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.AutoCert {
		n += 3
	}
	if m.State != 0 {
		n += 2 + sovTypes(uint64(m.State))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DnsInfo) > 0 {
		for _, e := range m.DnsInfo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.AutoCertState != 0 {
		n += 2 + sovTypes(uint64(m.AutoCertState))
	}
	if m.AutoCertInfo != nil {
		l = m.AutoCertInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.UserDomains) > 0 {
		for _, s := range m.UserDomains {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ServicePolicySet) > 0 {
		for _, e := range m.ServicePolicySet {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_JsChallenge) Size() (n int) {
	var l int
	_ = l
	if m.JsChallenge != nil {
		l = m.JsChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_CaptchaChallenge) Size() (n int) {
	var l int
	_ = l
	if m.CaptchaChallenge != nil {
		l = m.CaptchaChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoChallenge) Size() (n int) {
	var l int
	_ = l
	if m.NoChallenge != nil {
		l = m.NoChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, e := range m.AdvertisePolicies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Proxy != 0 {
		n += 1 + sovTypes(uint64(m.Proxy))
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DynamicReverseProxy != nil {
		l = m.DynamicReverseProxy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AddLocation {
		n += 3
	}
	if m.CompressionParams != nil {
		l = m.CompressionParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.CustomErrors) > 0 {
		for k, v := range m.CustomErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		n += 2 + sovTypes(uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		n += m.ChallengeType.Size()
	}
	if len(m.UserIdentification) > 0 {
		for _, e := range m.UserIdentification {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, e := range m.RateLimiterAllowedPrefixes {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IdleTimeout != 0 {
		n += 2 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		n += 3
	}
	if m.DisableDnsResolve {
		n += 3
	}
	if m.TemporaryUserBlocking != nil {
		l = m.TemporaryUserBlocking.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_JsChallenge) Size() (n int) {
	var l int
	_ = l
	if m.JsChallenge != nil {
		l = m.JsChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_CaptchaChallenge) Size() (n int) {
	var l int
	_ = l
	if m.CaptchaChallenge != nil {
		l = m.CaptchaChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoChallenge) Size() (n int) {
	var l int
	_ = l
	if m.NoChallenge != nil {
		l = m.NoChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, e := range m.AdvertisePolicies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Proxy != 0 {
		n += 1 + sovTypes(uint64(m.Proxy))
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DynamicReverseProxy != nil {
		l = m.DynamicReverseProxy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AddLocation {
		n += 3
	}
	if m.CompressionParams != nil {
		l = m.CompressionParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.CustomErrors) > 0 {
		for k, v := range m.CustomErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		n += 2 + sovTypes(uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		n += m.ChallengeType.Size()
	}
	if len(m.UserIdentification) > 0 {
		for _, e := range m.UserIdentification {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, e := range m.RateLimiterAllowedPrefixes {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IdleTimeout != 0 {
		n += 2 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		n += 3
	}
	if m.DisableDnsResolve {
		n += 3
	}
	if m.TemporaryUserBlocking != nil {
		l = m.TemporaryUserBlocking.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_JsChallenge) Size() (n int) {
	var l int
	_ = l
	if m.JsChallenge != nil {
		l = m.JsChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_CaptchaChallenge) Size() (n int) {
	var l int
	_ = l
	if m.CaptchaChallenge != nil {
		l = m.CaptchaChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoChallenge) Size() (n int) {
	var l int
	_ = l
	if m.NoChallenge != nil {
		l = m.NoChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, e := range m.AdvertisePolicies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Proxy != 0 {
		n += 1 + sovTypes(uint64(m.Proxy))
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DynamicReverseProxy != nil {
		l = m.DynamicReverseProxy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AddLocation {
		n += 3
	}
	if m.CompressionParams != nil {
		l = m.CompressionParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.CustomErrors) > 0 {
		for k, v := range m.CustomErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		n += 2 + sovTypes(uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		n += m.ChallengeType.Size()
	}
	if len(m.UserIdentification) > 0 {
		for _, e := range m.UserIdentification {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, e := range m.RateLimiterAllowedPrefixes {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IdleTimeout != 0 {
		n += 2 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		n += 3
	}
	if m.DisableDnsResolve {
		n += 3
	}
	if m.TemporaryUserBlocking != nil {
		l = m.TemporaryUserBlocking.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 2 + sovTypes(uint64(m.State))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DnsInfo) > 0 {
		for _, e := range m.DnsInfo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.AutoCertState != 0 {
		n += 2 + sovTypes(uint64(m.AutoCertState))
	}
	if m.AutoCertInfo != nil {
		l = m.AutoCertInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType_JsChallenge) Size() (n int) {
	var l int
	_ = l
	if m.JsChallenge != nil {
		l = m.JsChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_CaptchaChallenge) Size() (n int) {
	var l int
	_ = l
	if m.CaptchaChallenge != nil {
		l = m.CaptchaChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoChallenge) Size() (n int) {
	var l int
	_ = l
	if m.NoChallenge != nil {
		l = m.NoChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *JavaScriptConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptConfigType{`,
		`CachePrefix:` + fmt.Sprintf("%v", this.CachePrefix) + `,`,
		`ScriptConfig:` + strings.Replace(fmt.Sprintf("%v", this.ScriptConfig), "Struct", "google_protobuf3.Struct", 1) + `,`,
		`CustomScriptUrl:` + fmt.Sprintf("%v", this.CustomScriptUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DynamicReverseProxyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DynamicReverseProxyType{`,
		`ResolveEndpointDynamically:` + fmt.Sprintf("%v", this.ResolveEndpointDynamically) + `,`,
		`ResolutionNetworkType:` + fmt.Sprintf("%v", this.ResolutionNetworkType) + `,`,
		`ResolutionNetwork:` + strings.Replace(fmt.Sprintf("%v", this.ResolutionNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CompressionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CompressionType{`,
		`ContentLength:` + fmt.Sprintf("%v", this.ContentLength) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`DisableOnEtagHeader:` + fmt.Sprintf("%v", this.DisableOnEtagHeader) + `,`,
		`RemoveAcceptEncodingHeader:` + fmt.Sprintf("%v", this.RemoveAcceptEncodingHeader) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavascriptChallengeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavascriptChallengeType{`,
		`EnableJsChallenge:` + fmt.Sprintf("%v", this.EnableJsChallenge) + `,`,
		`JsScriptDelay:` + fmt.Sprintf("%v", this.JsScriptDelay) + `,`,
		`CookieExpiry:` + fmt.Sprintf("%v", this.CookieExpiry) + `,`,
		`CustomPage:` + fmt.Sprintf("%v", this.CustomPage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CaptchaChallengeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CaptchaChallengeType{`,
		`EnableCaptchaChallenge:` + fmt.Sprintf("%v", this.EnableCaptchaChallenge) + `,`,
		`CookieExpiry:` + fmt.Sprintf("%v", this.CookieExpiry) + `,`,
		`CustomPage:` + fmt.Sprintf("%v", this.CustomPage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TemporaryUserBlockingType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TemporaryUserBlockingType{`,
		`CustomPage:` + fmt.Sprintf("%v", this.CustomPage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutoCertInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AutoCertInfoType{`,
		`AutoCertState:` + fmt.Sprintf("%v", this.AutoCertState) + `,`,
		`AutoCertExpiry:` + strings.Replace(fmt.Sprintf("%v", this.AutoCertExpiry), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`AutoCertSubject:` + fmt.Sprintf("%v", this.AutoCertSubject) + `,`,
		`AutoCertIssuer:` + fmt.Sprintf("%v", this.AutoCertIssuer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%v: %v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`Routes:` + strings.Replace(fmt.Sprintf("%v", this.Routes), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`JavascriptInfo:` + strings.Replace(fmt.Sprintf("%v", this.JavascriptInfo), "JavaScriptConfigType", "JavaScriptConfigType", 1) + `,`,
		`AdvertisePolicies:` + strings.Replace(fmt.Sprintf("%v", this.AdvertisePolicies), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RequestHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.RequestHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`ResponseHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.ResponseHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "DownstreamTlsParamsType", "ves_io_schema4.DownstreamTlsParamsType", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "ves_io_schema4.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "ves_io_schema4.CorsPolicy", 1) + `,`,
		`Proxy:` + fmt.Sprintf("%v", this.Proxy) + `,`,
		`Jwt:` + strings.Replace(fmt.Sprintf("%v", this.Jwt), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "ves_io_schema4.WafType", 1) + `,`,
		`DynamicReverseProxy:` + strings.Replace(fmt.Sprintf("%v", this.DynamicReverseProxy), "DynamicReverseProxyType", "DynamicReverseProxyType", 1) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`CompressionParams:` + strings.Replace(fmt.Sprintf("%v", this.CompressionParams), "CompressionType", "CompressionType", 1) + `,`,
		`CustomErrors:` + mapStringForCustomErrors + `,`,
		`MaxRequestHeaderSize:` + fmt.Sprintf("%v", this.MaxRequestHeaderSize) + `,`,
		`ChallengeType:` + fmt.Sprintf("%v", this.ChallengeType) + `,`,
		`UserIdentification:` + strings.Replace(fmt.Sprintf("%v", this.UserIdentification), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiter), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RateLimiterAllowedPrefixes:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiterAllowedPrefixes), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "ves_io_schema4.RetryPolicyType", 1) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`DisableDefaultErrorPages:` + fmt.Sprintf("%v", this.DisableDefaultErrorPages) + `,`,
		`DisableDnsResolve:` + fmt.Sprintf("%v", this.DisableDnsResolve) + `,`,
		`TemporaryUserBlocking:` + strings.Replace(fmt.Sprintf("%v", this.TemporaryUserBlocking), "TemporaryUserBlockingType", "TemporaryUserBlockingType", 1) + `,`,
		`MaliciousUserMitigation:` + strings.Replace(fmt.Sprintf("%v", this.MaliciousUserMitigation), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`TlsIntercept:` + strings.Replace(fmt.Sprintf("%v", this.TlsIntercept), "TlsInterceptionType", "ves_io_schema4.TlsInterceptionType", 1) + `,`,
		`DnsDomains:` + strings.Replace(fmt.Sprintf("%v", this.DnsDomains), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`AutoCert:` + fmt.Sprintf("%v", this.AutoCert) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`DnsInfo:` + strings.Replace(fmt.Sprintf("%v", this.DnsInfo), "DnsInfo", "ves_io_schema_virtual_host_dns_info.DnsInfo", 1) + `,`,
		`AutoCertState:` + fmt.Sprintf("%v", this.AutoCertState) + `,`,
		`AutoCertInfo:` + strings.Replace(fmt.Sprintf("%v", this.AutoCertInfo), "AutoCertInfoType", "AutoCertInfoType", 1) + `,`,
		`UserDomains:` + fmt.Sprintf("%v", this.UserDomains) + `,`,
		`ServicePolicySet:` + strings.Replace(fmt.Sprintf("%v", this.ServicePolicySet), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_JsChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_JsChallenge{`,
		`JsChallenge:` + strings.Replace(fmt.Sprintf("%v", this.JsChallenge), "JavascriptChallengeType", "JavascriptChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_CaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_CaptchaChallenge{`,
		`CaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.CaptchaChallenge), "CaptchaChallengeType", "CaptchaChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoChallenge{`,
		`NoChallenge:` + strings.Replace(fmt.Sprintf("%v", this.NoChallenge), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%v: %v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`Routes:` + strings.Replace(fmt.Sprintf("%v", this.Routes), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`AdvertisePolicies:` + strings.Replace(fmt.Sprintf("%v", this.AdvertisePolicies), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RequestHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.RequestHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`ResponseHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.ResponseHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "DownstreamTlsParamsType", "ves_io_schema4.DownstreamTlsParamsType", 1) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "ves_io_schema4.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "ves_io_schema4.CorsPolicy", 1) + `,`,
		`Proxy:` + fmt.Sprintf("%v", this.Proxy) + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "ves_io_schema4.WafType", 1) + `,`,
		`DynamicReverseProxy:` + strings.Replace(fmt.Sprintf("%v", this.DynamicReverseProxy), "DynamicReverseProxyType", "DynamicReverseProxyType", 1) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`CompressionParams:` + strings.Replace(fmt.Sprintf("%v", this.CompressionParams), "CompressionType", "CompressionType", 1) + `,`,
		`CustomErrors:` + mapStringForCustomErrors + `,`,
		`MaxRequestHeaderSize:` + fmt.Sprintf("%v", this.MaxRequestHeaderSize) + `,`,
		`ChallengeType:` + fmt.Sprintf("%v", this.ChallengeType) + `,`,
		`UserIdentification:` + strings.Replace(fmt.Sprintf("%v", this.UserIdentification), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiter), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RateLimiterAllowedPrefixes:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiterAllowedPrefixes), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "ves_io_schema4.RetryPolicyType", 1) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`DisableDefaultErrorPages:` + fmt.Sprintf("%v", this.DisableDefaultErrorPages) + `,`,
		`DisableDnsResolve:` + fmt.Sprintf("%v", this.DisableDnsResolve) + `,`,
		`TemporaryUserBlocking:` + strings.Replace(fmt.Sprintf("%v", this.TemporaryUserBlocking), "TemporaryUserBlockingType", "TemporaryUserBlockingType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_JsChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_JsChallenge{`,
		`JsChallenge:` + strings.Replace(fmt.Sprintf("%v", this.JsChallenge), "JavascriptChallengeType", "JavascriptChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_CaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_CaptchaChallenge{`,
		`CaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.CaptchaChallenge), "CaptchaChallengeType", "CaptchaChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoChallenge{`,
		`NoChallenge:` + strings.Replace(fmt.Sprintf("%v", this.NoChallenge), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%v: %v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`Routes:` + strings.Replace(fmt.Sprintf("%v", this.Routes), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`AdvertisePolicies:` + strings.Replace(fmt.Sprintf("%v", this.AdvertisePolicies), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RequestHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.RequestHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`ResponseHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.ResponseHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "DownstreamTlsParamsType", "ves_io_schema4.DownstreamTlsParamsType", 1) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "ves_io_schema4.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "ves_io_schema4.CorsPolicy", 1) + `,`,
		`Proxy:` + fmt.Sprintf("%v", this.Proxy) + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "ves_io_schema4.WafType", 1) + `,`,
		`DynamicReverseProxy:` + strings.Replace(fmt.Sprintf("%v", this.DynamicReverseProxy), "DynamicReverseProxyType", "DynamicReverseProxyType", 1) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`CompressionParams:` + strings.Replace(fmt.Sprintf("%v", this.CompressionParams), "CompressionType", "CompressionType", 1) + `,`,
		`CustomErrors:` + mapStringForCustomErrors + `,`,
		`MaxRequestHeaderSize:` + fmt.Sprintf("%v", this.MaxRequestHeaderSize) + `,`,
		`ChallengeType:` + fmt.Sprintf("%v", this.ChallengeType) + `,`,
		`UserIdentification:` + strings.Replace(fmt.Sprintf("%v", this.UserIdentification), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiter), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RateLimiterAllowedPrefixes:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiterAllowedPrefixes), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "ves_io_schema4.RetryPolicyType", 1) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`DisableDefaultErrorPages:` + fmt.Sprintf("%v", this.DisableDefaultErrorPages) + `,`,
		`DisableDnsResolve:` + fmt.Sprintf("%v", this.DisableDnsResolve) + `,`,
		`TemporaryUserBlocking:` + strings.Replace(fmt.Sprintf("%v", this.TemporaryUserBlocking), "TemporaryUserBlockingType", "TemporaryUserBlockingType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_JsChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_JsChallenge{`,
		`JsChallenge:` + strings.Replace(fmt.Sprintf("%v", this.JsChallenge), "JavascriptChallengeType", "JavascriptChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_CaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_CaptchaChallenge{`,
		`CaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.CaptchaChallenge), "CaptchaChallengeType", "CaptchaChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoChallenge{`,
		`NoChallenge:` + strings.Replace(fmt.Sprintf("%v", this.NoChallenge), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%v: %v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`Routes:` + strings.Replace(fmt.Sprintf("%v", this.Routes), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`AdvertisePolicies:` + strings.Replace(fmt.Sprintf("%v", this.AdvertisePolicies), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RequestHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.RequestHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`ResponseHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.ResponseHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "DownstreamTlsParamsType", "ves_io_schema4.DownstreamTlsParamsType", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "ves_io_schema4.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "ves_io_schema4.CorsPolicy", 1) + `,`,
		`Proxy:` + fmt.Sprintf("%v", this.Proxy) + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "ves_io_schema4.WafType", 1) + `,`,
		`DynamicReverseProxy:` + strings.Replace(fmt.Sprintf("%v", this.DynamicReverseProxy), "DynamicReverseProxyType", "DynamicReverseProxyType", 1) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`CompressionParams:` + strings.Replace(fmt.Sprintf("%v", this.CompressionParams), "CompressionType", "CompressionType", 1) + `,`,
		`CustomErrors:` + mapStringForCustomErrors + `,`,
		`MaxRequestHeaderSize:` + fmt.Sprintf("%v", this.MaxRequestHeaderSize) + `,`,
		`ChallengeType:` + fmt.Sprintf("%v", this.ChallengeType) + `,`,
		`UserIdentification:` + strings.Replace(fmt.Sprintf("%v", this.UserIdentification), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiter), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RateLimiterAllowedPrefixes:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiterAllowedPrefixes), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "ves_io_schema4.RetryPolicyType", 1) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`DisableDefaultErrorPages:` + fmt.Sprintf("%v", this.DisableDefaultErrorPages) + `,`,
		`DisableDnsResolve:` + fmt.Sprintf("%v", this.DisableDnsResolve) + `,`,
		`TemporaryUserBlocking:` + strings.Replace(fmt.Sprintf("%v", this.TemporaryUserBlocking), "TemporaryUserBlockingType", "TemporaryUserBlockingType", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`DnsInfo:` + strings.Replace(fmt.Sprintf("%v", this.DnsInfo), "DnsInfo", "ves_io_schema_virtual_host_dns_info.DnsInfo", 1) + `,`,
		`AutoCertState:` + fmt.Sprintf("%v", this.AutoCertState) + `,`,
		`AutoCertInfo:` + strings.Replace(fmt.Sprintf("%v", this.AutoCertInfo), "AutoCertInfoType", "AutoCertInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_JsChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_JsChallenge{`,
		`JsChallenge:` + strings.Replace(fmt.Sprintf("%v", this.JsChallenge), "JavascriptChallengeType", "JavascriptChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_CaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_CaptchaChallenge{`,
		`CaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.CaptchaChallenge), "CaptchaChallengeType", "CaptchaChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoChallenge{`,
		`NoChallenge:` + strings.Replace(fmt.Sprintf("%v", this.NoChallenge), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *JavaScriptConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaScriptConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaScriptConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CachePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScriptConfig == nil {
				m.ScriptConfig = &google_protobuf3.Struct{}
			}
			if err := m.ScriptConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomScriptUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomScriptUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicReverseProxyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicReverseProxyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicReverseProxyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveEndpointDynamically", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResolveEndpointDynamically = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolutionNetworkType", wireType)
			}
			m.ResolutionNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolutionNetworkType |= (ves_io_schema3.VirtualNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolutionNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolutionNetwork = append(m.ResolutionNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.ResolutionNetwork[len(m.ResolutionNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompressionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompressionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompressionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentLength", wireType)
			}
			m.ContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentLength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = append(m.ContentType, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOnEtagHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableOnEtagHeader = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveAcceptEncodingHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveAcceptEncodingHeader = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavascriptChallengeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavascriptChallengeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavascriptChallengeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableJsChallenge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableJsChallenge = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsScriptDelay", wireType)
			}
			m.JsScriptDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JsScriptDelay |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieExpiry", wireType)
			}
			m.CookieExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieExpiry |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptchaChallengeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptchaChallengeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptchaChallengeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCaptchaChallenge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableCaptchaChallenge = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieExpiry", wireType)
			}
			m.CookieExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieExpiry |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TemporaryUserBlockingType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TemporaryUserBlockingType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TemporaryUserBlockingType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoCertInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoCertInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoCertInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertState", wireType)
			}
			m.AutoCertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoCertState |= (CertificationState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertExpiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertExpiry == nil {
				m.AutoCertExpiry = &google_protobuf1.Timestamp{}
			}
			if err := m.AutoCertExpiry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertSubject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoCertSubject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertIssuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoCertIssuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &ves_io_schema4.ObjectRefType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JavascriptInfo == nil {
				m.JavascriptInfo = &JavaScriptConfigType{}
			}
			if err := m.JavascriptInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisePolicies = append(m.AdvertisePolicies, &ves_io_schema4.ObjectRefType{})
			if err := m.AdvertisePolicies[len(m.AdvertisePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &ves_io_schema4.DownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (VirtualHostType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &ves_io_schema4.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &ves_io_schema4.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			m.Proxy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proxy |= (ProxyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jwt = append(m.Jwt, &ves_io_schema4.ObjectRefType{})
			if err := m.Jwt[len(m.Jwt)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &ves_io_schema4.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicReverseProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicReverseProxy == nil {
				m.DynamicReverseProxy = &DynamicReverseProxyType{}
			}
			if err := m.DynamicReverseProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompressionParams == nil {
				m.CompressionParams = &CompressionType{}
			}
			if err := m.CompressionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomErrors == nil {
				m.CustomErrors = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestHeaderSize", wireType)
			}
			m.MaxRequestHeaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestHeaderSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavascriptChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GlobalSpecType_JsChallenge{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdentification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdentification = append(m.UserIdentification, &ves_io_schema4.ObjectRefType{})
			if err := m.UserIdentification[len(m.UserIdentification)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterAllowedPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterAllowedPrefixes = append(m.RateLimiterAllowedPrefixes, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiterAllowedPrefixes[len(m.RateLimiterAllowedPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &ves_io_schema4.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CaptchaChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GlobalSpecType_CaptchaChallenge{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GlobalSpecType_NoChallenge{v}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDefaultErrorPages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDefaultErrorPages = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDnsResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDnsResolve = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryUserBlocking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryUserBlocking == nil {
				m.TemporaryUserBlocking = &TemporaryUserBlockingType{}
			}
			if err := m.TemporaryUserBlocking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaliciousUserMitigation = append(m.MaliciousUserMitigation, &ves_io_schema4.ObjectRefType{})
			if err := m.MaliciousUserMitigation[len(m.MaliciousUserMitigation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsIntercept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsIntercept == nil {
				m.TlsIntercept = &ves_io_schema4.TlsInterceptionType{}
			}
			if err := m.TlsIntercept.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsDomains = append(m.DnsDomains, &ves_io_schema4.ObjectRefType{})
			if err := m.DnsDomains[len(m.DnsDomains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1002:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoCert = bool(v != 0)
		case 1003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (VirtualHostState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1004:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1005:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsInfo = append(m.DnsInfo, &ves_io_schema_virtual_host_dns_info.DnsInfo{})
			if err := m.DnsInfo[len(m.DnsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1006:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertState", wireType)
			}
			m.AutoCertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoCertState |= (CertificationState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1010:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertInfo == nil {
				m.AutoCertInfo = &AutoCertInfoType{}
			}
			if err := m.AutoCertInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1011:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDomains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserDomains = append(m.UserDomains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 1012:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePolicySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicePolicySet = append(m.ServicePolicySet, &ves_io_schema4.ObjectRefType{})
			if err := m.ServicePolicySet[len(m.ServicePolicySet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &ves_io_schema4.ObjectRefType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisePolicies = append(m.AdvertisePolicies, &ves_io_schema4.ObjectRefType{})
			if err := m.AdvertisePolicies[len(m.AdvertisePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &ves_io_schema4.DownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &ves_io_schema4.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &ves_io_schema4.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			m.Proxy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proxy |= (ProxyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &ves_io_schema4.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicReverseProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicReverseProxy == nil {
				m.DynamicReverseProxy = &DynamicReverseProxyType{}
			}
			if err := m.DynamicReverseProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompressionParams == nil {
				m.CompressionParams = &CompressionType{}
			}
			if err := m.CompressionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomErrors == nil {
				m.CustomErrors = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestHeaderSize", wireType)
			}
			m.MaxRequestHeaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestHeaderSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavascriptChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &CreateSpecType_JsChallenge{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdentification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdentification = append(m.UserIdentification, &ves_io_schema4.ObjectRefType{})
			if err := m.UserIdentification[len(m.UserIdentification)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterAllowedPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterAllowedPrefixes = append(m.RateLimiterAllowedPrefixes, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiterAllowedPrefixes[len(m.RateLimiterAllowedPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &ves_io_schema4.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CaptchaChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &CreateSpecType_CaptchaChallenge{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &CreateSpecType_NoChallenge{v}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDefaultErrorPages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDefaultErrorPages = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDnsResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDnsResolve = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryUserBlocking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryUserBlocking == nil {
				m.TemporaryUserBlocking = &TemporaryUserBlockingType{}
			}
			if err := m.TemporaryUserBlocking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &ves_io_schema4.ObjectRefType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisePolicies = append(m.AdvertisePolicies, &ves_io_schema4.ObjectRefType{})
			if err := m.AdvertisePolicies[len(m.AdvertisePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &ves_io_schema4.DownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &ves_io_schema4.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &ves_io_schema4.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			m.Proxy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proxy |= (ProxyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &ves_io_schema4.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicReverseProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicReverseProxy == nil {
				m.DynamicReverseProxy = &DynamicReverseProxyType{}
			}
			if err := m.DynamicReverseProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompressionParams == nil {
				m.CompressionParams = &CompressionType{}
			}
			if err := m.CompressionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomErrors == nil {
				m.CustomErrors = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestHeaderSize", wireType)
			}
			m.MaxRequestHeaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestHeaderSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavascriptChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &ReplaceSpecType_JsChallenge{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdentification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdentification = append(m.UserIdentification, &ves_io_schema4.ObjectRefType{})
			if err := m.UserIdentification[len(m.UserIdentification)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterAllowedPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterAllowedPrefixes = append(m.RateLimiterAllowedPrefixes, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiterAllowedPrefixes[len(m.RateLimiterAllowedPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &ves_io_schema4.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CaptchaChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &ReplaceSpecType_CaptchaChallenge{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &ReplaceSpecType_NoChallenge{v}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDefaultErrorPages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDefaultErrorPages = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDnsResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDnsResolve = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryUserBlocking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryUserBlocking == nil {
				m.TemporaryUserBlocking = &TemporaryUserBlockingType{}
			}
			if err := m.TemporaryUserBlocking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &ves_io_schema4.ObjectRefType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisePolicies = append(m.AdvertisePolicies, &ves_io_schema4.ObjectRefType{})
			if err := m.AdvertisePolicies[len(m.AdvertisePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &ves_io_schema4.DownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (VirtualHostType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &ves_io_schema4.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &ves_io_schema4.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			m.Proxy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proxy |= (ProxyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &ves_io_schema4.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicReverseProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicReverseProxy == nil {
				m.DynamicReverseProxy = &DynamicReverseProxyType{}
			}
			if err := m.DynamicReverseProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompressionParams == nil {
				m.CompressionParams = &CompressionType{}
			}
			if err := m.CompressionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomErrors == nil {
				m.CustomErrors = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestHeaderSize", wireType)
			}
			m.MaxRequestHeaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestHeaderSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavascriptChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GetSpecType_JsChallenge{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdentification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdentification = append(m.UserIdentification, &ves_io_schema4.ObjectRefType{})
			if err := m.UserIdentification[len(m.UserIdentification)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterAllowedPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterAllowedPrefixes = append(m.RateLimiterAllowedPrefixes, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiterAllowedPrefixes[len(m.RateLimiterAllowedPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &ves_io_schema4.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CaptchaChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GetSpecType_CaptchaChallenge{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GetSpecType_NoChallenge{v}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDefaultErrorPages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDefaultErrorPages = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDnsResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDnsResolve = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryUserBlocking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryUserBlocking == nil {
				m.TemporaryUserBlocking = &TemporaryUserBlockingType{}
			}
			if err := m.TemporaryUserBlocking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (VirtualHostState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1004:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1005:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsInfo = append(m.DnsInfo, &ves_io_schema_virtual_host_dns_info.DnsInfo{})
			if err := m.DnsInfo[len(m.DnsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1006:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertState", wireType)
			}
			m.AutoCertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoCertState |= (CertificationState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1010:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertInfo == nil {
				m.AutoCertInfo = &AutoCertInfoType{}
			}
			if err := m.AutoCertInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/virtual_host/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/virtual_host/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 3351 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0x4b, 0x6c, 0x1b, 0x49,
	0x7a, 0x56, 0xf1, 0xa1, 0x47, 0x91, 0x94, 0x5a, 0x25, 0x59, 0x6a, 0xd1, 0x36, 0xdd, 0xa6, 0xd7,
	0x1e, 0xad, 0xb6, 0x4d, 0x49, 0xa4, 0x64, 0x5b, 0x9e, 0xf5, 0xcc, 0x90, 0x22, 0x2d, 0xd1, 0x90,
	0x25, 0xa1, 0x45, 0xcb, 0xeb, 0x09, 0xb2, 0xed, 0x56, 0x77, 0x89, 0x6a, 0xbb, 0xd9, 0x4d, 0x77,
	0x37, 0xf5, 0x98, 0x44, 0x81, 0x91, 0x43, 0x12, 0xf8, 0xb4, 0xf1, 0x2d, 0x83, 0xe4, 0xb4, 0x97,
	0x40, 0xf7, 0x20, 0x8b, 0xd0, 0x09, 0x8c, 0x01, 0x16, 0x58, 0xe4, 0xe4, 0x43, 0x82, 0x18, 0x39,
	0x8d, 0xb5, 0x97, 0xd9, 0xc9, 0x03, 0x8b, 0x4d, 0x0e, 0x46, 0x4e, 0x41, 0x55, 0x77, 0xf3, 0x25,
	0x5a, 0xab, 0xf5, 0x3c, 0x30, 0x5e, 0xf0, 0x22, 0xb0, 0xeb, 0x7f, 0x55, 0xd5, 0xff, 0xd7, 0x5f,
	0xdf, 0xd7, 0x22, 0xe1, 0xa5, 0x6d, 0x6c, 0x25, 0x54, 0x63, 0xd2, 0x92, 0xb7, 0x70, 0x49, 0x9a,
	0xdc, 0x56, 0x4d, 0xbb, 0x22, 0x69, 0xe2, 0x96, 0x61, 0xd9, 0x93, 0xf6, 0x5e, 0x19, 0x5b, 0x89,
	0xb2, 0x69, 0xd8, 0x06, 0x8a, 0x3a, 0x7a, 0x09, 0x47, 0x2f, 0xd1, 0xa8, 0x17, 0xbd, 0x5c, 0x54,
	0xed, 0xad, 0xca, 0x46, 0x42, 0x36, 0x4a, 0x93, 0x45, 0xa3, 0x68, 0x4c, 0x52, 0x93, 0x8d, 0xca,
	0x26, 0x7d, 0xa2, 0x0f, 0xf4, 0x93, 0xe3, 0x2a, 0x7a, 0xa6, 0x68, 0x18, 0x45, 0x0d, 0xd7, 0xb5,
	0x2c, 0xdb, 0xac, 0xc8, 0xb6, 0x2b, 0x3d, 0xd7, 0x2a, 0xb5, 0xd5, 0x12, 0xb6, 0x6c, 0xa9, 0x54,
	0x76, 0x15, 0x46, 0x9b, 0x67, 0xac, 0x63, 0xcf, 0xf2, 0x74, 0xb3, 0xc0, 0x28, 0xdb, 0xaa, 0xa1,
	0xbb, 0xf3, 0x8f, 0x8e, 0x35, 0x0b, 0x1b, 0x96, 0x16, 0x3d, 0xd3, 0xb2, 0x05, 0x92, 0xa6, 0x2a,
	0x92, 0x8d, 0x5d, 0x29, 0xd7, 0xba, 0x41, 0x78, 0x47, 0x6c, 0x76, 0x3d, 0xf5, 0xe6, 0x2d, 0x14,
	0x15, 0xdd, 0x12, 0x55, 0x7d, 0xd3, 0x98, 0x34, 0x36, 0x1e, 0x60, 0x6f, 0x8d, 0xf1, 0x9f, 0x02,
	0x38, 0x7c, 0x4b, 0xda, 0x96, 0xd6, 0x64, 0x53, 0x2d, 0xdb, 0xf3, 0x86, 0xbe, 0xa9, 0x16, 0x0b,
	0x7b, 0x65, 0x8c, 0xce, 0xc3, 0xb0, 0x2c, 0xc9, 0x5b, 0x58, 0x2c, 0x9b, 0x78, 0x53, 0xdd, 0x65,
	0x01, 0x07, 0xc6, 0xfb, 0x84, 0x10, 0x1d, 0x5b, 0xa5, 0x43, 0xe8, 0x87, 0x30, 0x62, 0x51, 0x33,
	0x51, 0xa6, 0x76, 0xac, 0x8f, 0x03, 0xe3, 0xa1, 0xe4, 0x68, 0xc2, 0xd9, 0xb7, 0x84, 0xb7, 0x6f,
	0x89, 0x35, 0xba, 0xab, 0x42, 0xd8, 0x6a, 0x08, 0x82, 0x26, 0xe0, 0xa0, 0x5c, 0xb1, 0x6c, 0xa3,
	0x24, 0xba, 0x4e, 0x2a, 0xa6, 0xc6, 0xfa, 0x69, 0x94, 0x01, 0x47, 0xe0, 0xcc, 0xe9, 0x8e, 0xa9,
	0xc5, 0xff, 0xc6, 0x07, 0x47, 0xb3, 0x7b, 0xba, 0x54, 0x52, 0x65, 0x01, 0x6f, 0x63, 0xd3, 0xc2,
	0xab, 0xa6, 0xb1, 0xbb, 0x47, 0x27, 0xfa, 0x11, 0x3c, 0x63, 0x62, 0xcb, 0xd0, 0xb6, 0xb1, 0x88,
	0x75, 0xa5, 0x6c, 0xa8, 0xba, 0x2d, 0x2a, 0x8e, 0xae, 0xa4, 0x69, 0x7b, 0x74, 0xe2, 0xbd, 0x42,
	0xd4, 0xd5, 0xc9, 0xb9, 0x2a, 0xd9, 0xba, 0x06, 0xba, 0x07, 0x47, 0xa9, 0xb4, 0x42, 0xb6, 0x52,
	0xd4, 0xb1, 0xbd, 0x63, 0x98, 0x0f, 0x45, 0x92, 0x17, 0xba, 0xa2, 0xfe, 0xe4, 0xf9, 0x44, 0x73,
	0xc9, 0xad, 0x3b, 0xfb, 0xba, 0xec, 0x68, 0x92, 0x59, 0x08, 0xa7, 0xea, 0x1e, 0x1a, 0x86, 0x91,
	0x08, 0xd1, 0x51, 0xd7, 0xac, 0x9f, 0xf3, 0x8f, 0x87, 0x92, 0x67, 0x5a, 0xbc, 0xae, 0xd0, 0xbc,
	0x08, 0x78, 0x93, 0x58, 0x66, 0xd0, 0xc1, 0xfe, 0x80, 0x97, 0x3f, 0xd7, 0x4e, 0x18, 0x3c, 0x12,
	0xe4, 0x56, 0xa0, 0x37, 0xc0, 0x04, 0xe3, 0x7f, 0xe9, 0x83, 0x03, 0xf3, 0x46, 0xa9, 0x6c, 0x62,
	0xcb, 0x52, 0x0d, 0x9d, 0x86, 0x9e, 0x82, 0xfd, 0xb2, 0xa1, 0xdb, 0x58, 0xb7, 0x45, 0x0d, 0xeb,
	0x45, 0x7b, 0x8b, 0xee, 0x44, 0x24, 0xd3, 0xf7, 0x0f, 0xbf, 0x7a, 0xee, 0x0f, 0x4c, 0xf8, 0xc6,
	0x63, 0x42, 0xc4, 0x55, 0x58, 0xa2, 0x72, 0x54, 0x80, 0x61, 0xcf, 0xc2, 0x5d, 0xbc, 0x7f, 0xbc,
	0x2f, 0x33, 0x4d, 0xf4, 0xe1, 0x53, 0xd0, 0x13, 0x0f, 0x9a, 0xfe, 0xf1, 0xc7, 0x3e, 0xf2, 0xd8,
	0xf7, 0x14, 0x74, 0xc7, 0x03, 0xa6, 0x8f, 0x03, 0xe4, 0x29, 0xf8, 0x14, 0xf8, 0x98, 0xa4, 0xf7,
	0x89, 0x05, 0x42, 0xc8, 0x75, 0x43, 0xe7, 0x91, 0x82, 0x23, 0x8a, 0x6a, 0x49, 0x1b, 0x1a, 0x16,
	0x0d, 0x5d, 0xc4, 0xb6, 0x54, 0x14, 0xb7, 0xb0, 0xa4, 0x60, 0x93, 0x26, 0xbb, 0x57, 0x18, 0x72,
	0xa5, 0x2b, 0x7a, 0xce, 0x96, 0x8a, 0x8b, 0x54, 0x84, 0xd2, 0xf0, 0xac, 0x89, 0x4b, 0xc6, 0x36,
	0x16, 0x25, 0x59, 0xc6, 0x65, 0x5b, 0xc4, 0xba, 0x6c, 0x28, 0xaa, 0x5e, 0xb3, 0x0d, 0x78, 0x59,
	0x25, 0x4a, 0x69, 0xaa, 0x93, 0x73, 0x55, 0x1c, 0x17, 0xf1, 0xbf, 0xf7, 0xc1, 0x51, 0x52, 0xd9,
	0x6e, 0xd1, 0x6d, 0x49, 0x1a, 0xd9, 0x06, 0x4c, 0xe7, 0x34, 0x07, 0x87, 0xb0, 0x4e, 0xa7, 0xf4,
	0xc0, 0x12, 0x65, 0x4f, 0xe4, 0x94, 0x4a, 0xa6, 0xef, 0xe5, 0x3e, 0xf8, 0xa2, 0x0a, 0x00, 0x0b,
	0x84, 0x41, 0x47, 0xeb, 0x96, 0x55, 0x33, 0x47, 0x1f, 0xc2, 0x81, 0x07, 0x96, 0x57, 0xb2, 0x0a,
	0xd6, 0xa4, 0x3d, 0x5a, 0x24, 0x91, 0xcc, 0xe8, 0xbf, 0x57, 0x41, 0x60, 0x76, 0x6a, 0x6a, 0xea,
	0x75, 0x15, 0x74, 0x91, 0xcd, 0xe8, 0x9e, 0x08, 0xb0, 0x9f, 0xff, 0x8b, 0x5f, 0x88, 0x3c, 0xb0,
	0x9c, 0x4a, 0xce, 0x12, 0x6d, 0x72, 0x6a, 0x64, 0xc3, 0x78, 0xa8, 0x62, 0x11, 0xef, 0x96, 0x55,
	0x73, 0x8f, 0x6e, 0x83, 0x6b, 0x9e, 0xba, 0xd2, 0x6c, 0xfe, 0xf8, 0xa7, 0x41, 0x21, 0xec, 0x68,
	0xe7, 0xa8, 0x32, 0x4a, 0xc2, 0x90, 0x7b, 0x6a, 0xca, 0x52, 0x11, 0xd3, 0x6d, 0xe8, 0xcb, 0x0c,
	0xbe, 0xae, 0x02, 0x3f, 0xb1, 0xe9, 0x35, 0xbb, 0xd9, 0xc7, 0x1f, 0xfd, 0x04, 0x00, 0x01, 0x3a,
	0x5a, 0xab, 0x52, 0x11, 0x5f, 0x4f, 0x7c, 0x56, 0x05, 0x13, 0x70, 0x1c, 0x9e, 0xab, 0x6f, 0x07,
	0x57, 0x5b, 0x10, 0xb7, 0x2a, 0x99, 0x52, 0x09, 0xdb, 0xd8, 0xb4, 0x50, 0x30, 0xc9, 0xa7, 0xf8,
	0x99, 0xf8, 0x6b, 0x00, 0x87, 0xe7, 0xa5, 0xb2, 0x2d, 0x6f, 0x49, 0xcd, 0xdb, 0x36, 0x0f, 0x59,
	0x77, 0xdb, 0x64, 0x47, 0x7c, 0xdc, 0xde, 0x8d, 0x38, 0xaa, 0xad, 0x8e, 0x8e, 0xae, 0xdf, 0xf7,
	0x15, 0xd6, 0xef, 0x3f, 0xc9, 0xfa, 0xbf, 0xff, 0x59, 0x15, 0x5c, 0x84, 0x17, 0xe0, 0x19, 0x77,
	0x2e, 0xed, 0x17, 0xef, 0x4f, 0xf2, 0xa9, 0xf8, 0x9f, 0xc0, 0xb1, 0x02, 0x2e, 0x95, 0x0d, 0x53,
	0x32, 0xf7, 0xee, 0x58, 0xd8, 0xcc, 0x68, 0x86, 0xfc, 0x50, 0xd5, 0x9d, 0x96, 0xd8, 0x12, 0x1b,
	0x9c, 0x24, 0xf6, 0xe5, 0xcf, 0xaa, 0xe0, 0xfb, 0xf0, 0x3d, 0x18, 0xaf, 0xb9, 0xe5, 0x88, 0x5f,
	0xce, 0x73, 0xdc, 0x38, 0x03, 0x30, 0x1d, 0xff, 0x33, 0x1f, 0x64, 0xd2, 0x15, 0xdb, 0x98, 0xc7,
	0xa6, 0x9d, 0xd7, 0x37, 0x0d, 0x1a, 0x77, 0x1d, 0x0e, 0x48, 0x15, 0xdb, 0x10, 0x65, 0x6c, 0xda,
	0xa2, 0x65, 0x4b, 0xb6, 0x13, 0xbb, 0x3f, 0x99, 0x48, 0xbc, 0xf9, 0x2a, 0x4c, 0x10, 0x17, 0xea,
	0xa6, 0x2a, 0x4b, 0xa4, 0x5d, 0xac, 0x11, 0x2b, 0x21, 0x22, 0xb9, 0xae, 0xe9, 0x23, 0xca, 0x42,
	0xa6, 0xee, 0xb7, 0x21, 0x19, 0xa1, 0x64, 0xf4, 0x48, 0x0b, 0x2f, 0x78, 0x57, 0x9f, 0xd0, 0xef,
	0x39, 0x71, 0x33, 0x32, 0x01, 0x07, 0x1b, 0x66, 0x57, 0xa1, 0x4d, 0xcc, 0xeb, 0xe3, 0xb5, 0x78,
	0xce, 0x30, 0x1a, 0x6f, 0x8c, 0xa8, 0x5a, 0x56, 0xc5, 0x3d, 0xc9, 0x7d, 0x75, 0xaf, 0x79, 0x3a,
	0x1a, 0xff, 0xeb, 0x18, 0xec, 0x5f, 0xd0, 0x8c, 0x0d, 0x49, 0x5b, 0x2b, 0x63, 0x99, 0x6e, 0xc3,
	0x0d, 0xd8, 0xa3, 0x18, 0x25, 0x49, 0xd5, 0x2d, 0xb7, 0x33, 0x5d, 0x68, 0xec, 0x4c, 0x7f, 0xe1,
	0xab, 0xf7, 0x22, 0xa6, 0xa1, 0x17, 0x79, 0x36, 0x28, 0x0f, 0xbb, 0x4d, 0xa3, 0x62, 0x63, 0xeb,
	0x44, 0xed, 0x77, 0xe8, 0x60, 0x3f, 0x48, 0xd5, 0x69, 0x29, 0x3e, 0x05, 0x7e, 0xe6, 0x31, 0x10,
	0x5c, 0x07, 0xe8, 0x1e, 0x1c, 0x78, 0x50, 0x3b, 0x4a, 0xf4, 0x52, 0xa5, 0xab, 0x08, 0x25, 0xa7,
	0x8e, 0x4b, 0x48, 0xbb, 0x6b, 0x56, 0xe8, 0xaf, 0x3b, 0x22, 0xf9, 0x46, 0xf7, 0x21, 0x92, 0x94,
	0x6d, 0x92, 0x3a, 0x0b, 0x8b, 0x65, 0x43, 0x53, 0x65, 0x15, 0x5b, 0x6c, 0xf0, 0x64, 0x33, 0x66,
	0x5a, 0x4c, 0xf7, 0x84, 0xc1, 0xda, 0xc8, 0xaa, 0xeb, 0x0b, 0xdd, 0x87, 0x23, 0x26, 0x7e, 0x54,
	0xc1, 0x96, 0xed, 0xf6, 0x52, 0x4b, 0xb4, 0x0d, 0x51, 0x52, 0x14, 0xb6, 0x9b, 0x46, 0xf9, 0x41,
	0x4b, 0x14, 0xa7, 0x9d, 0xde, 0x96, 0x74, 0xb5, 0x5c, 0xd1, 0x68, 0x31, 0xad, 0x50, 0xcc, 0x41,
	0xa7, 0x3f, 0xe4, 0xba, 0x72, 0x94, 0xac, 0x82, 0x91, 0x56, 0x14, 0xb4, 0x41, 0xef, 0xd3, 0xb2,
	0xa1, 0x5b, 0xb8, 0x35, 0x44, 0xcf, 0xef, 0x1e, 0x62, 0xd8, 0xf3, 0xd5, 0x14, 0xe3, 0x7d, 0x18,
	0x6d, 0x17, 0xc3, 0xb9, 0x0f, 0xd8, 0x5e, 0x52, 0x1f, 0xc2, 0xe8, 0x11, 0x4b, 0x81, 0x8a, 0xd1,
	0x6d, 0xd8, 0x6f, 0x6b, 0x96, 0x58, 0xae, 0x1d, 0x3d, 0xb6, 0x8f, 0xa6, 0xef, 0x52, 0xcb, 0xbc,
	0xb2, 0xc6, 0x8e, 0x6e, 0xd9, 0x26, 0x96, 0x4a, 0x05, 0xcd, 0xa2, 0x07, 0xd5, 0xa2, 0x53, 0x8a,
	0xd8, 0xee, 0xa3, 0x73, 0x6e, 0x3f, 0x84, 0x01, 0x7a, 0x5f, 0x42, 0x7a, 0x28, 0x7f, 0x70, 0x5c,
	0x0d, 0xb8, 0xc8, 0x61, 0xd1, 0xb0, 0xe8, 0xe5, 0x28, 0x50, 0x43, 0x94, 0x85, 0x91, 0x8d, 0xca,
	0xe6, 0x26, 0x36, 0xdd, 0xb4, 0xb1, 0x61, 0x3a, 0x9d, 0x73, 0x2d, 0x9e, 0x32, 0x54, 0xa7, 0xa1,
	0x78, 0xc2, 0x8e, 0x15, 0x4d, 0xed, 0x1e, 0xba, 0x0e, 0x43, 0xb2, 0x61, 0x5a, 0x9e, 0x8f, 0x08,
	0xf5, 0x31, 0xd6, 0xe2, 0x63, 0xde, 0x30, 0x2d, 0x47, 0x5f, 0x80, 0x72, 0xed, 0x33, 0x7a, 0x1f,
	0x06, 0xcb, 0x04, 0x51, 0xb1, 0x03, 0x74, 0x0d, 0x17, 0x8f, 0x5b, 0x43, 0x0d, 0x7a, 0x09, 0x8e,
	0x0d, 0xba, 0x02, 0xfd, 0x0f, 0x76, 0x6c, 0x96, 0x39, 0x41, 0x91, 0x76, 0x1f, 0xec, 0x13, 0x5d,
	0x81, 0xfc, 0x41, 0x73, 0x70, 0xac, 0x4d, 0x25, 0xba, 0x29, 0x1c, 0xa4, 0x29, 0x1c, 0x69, 0xad,
	0x2f, 0x37, 0x83, 0xd3, 0xb0, 0x77, 0x47, 0xda, 0x74, 0x60, 0x0a, 0xa2, 0x0b, 0x1d, 0x69, 0x89,
	0x7b, 0x57, 0xa2, 0x11, 0x85, 0x9e, 0x1d, 0xe7, 0x03, 0x2a, 0xc2, 0x53, 0x2e, 0x2c, 0x14, 0x4d,
	0x07, 0x43, 0x8a, 0xce, 0x92, 0x87, 0xa8, 0x7d, 0xea, 0xb8, 0x25, 0xbf, 0x01, 0x7b, 0x0a, 0x43,
	0xca, 0x51, 0x01, 0x41, 0xce, 0x92, 0xa2, 0x88, 0x9a, 0xe1, 0xb4, 0x5e, 0x76, 0x98, 0x42, 0x95,
	0x90, 0xa4, 0x28, 0x4b, 0xee, 0x10, 0xfa, 0x18, 0x22, 0xb9, 0x0e, 0xd7, 0x9c, 0x42, 0xb4, 0xd8,
	0x53, 0x74, 0x22, 0xc7, 0xd6, 0x4f, 0x0b, 0xc8, 0x13, 0x06, 0x1b, 0xdc, 0x38, 0x05, 0x8a, 0xfe,
	0x2a, 0x00, 0x23, 0xee, 0x35, 0x85, 0x4d, 0xd3, 0x30, 0x2d, 0x76, 0x84, 0x26, 0xe6, 0x87, 0xc7,
	0xf9, 0x6d, 0x6e, 0xb5, 0x89, 0x79, 0x6a, 0x9f, 0xa3, 0xe6, 0x39, 0xdd, 0x36, 0xf7, 0x32, 0x7f,
	0xe7, 0x7f, 0x51, 0x05, 0xb4, 0xc3, 0x86, 0x3f, 0x05, 0x7d, 0xf1, 0x9e, 0x89, 0x20, 0xfb, 0x6f,
	0x81, 0x71, 0x7a, 0xf1, 0x05, 0x3f, 0xf5, 0x5a, 0x6e, 0xe4, 0x53, 0x00, 0x27, 0x6a, 0xf7, 0xe0,
	0xe1, 0xe7, 0x3f, 0xf7, 0xff, 0x1c, 0x3c, 0x79, 0x06, 0x9e, 0x03, 0xf4, 0x8f, 0xe0, 0xcb, 0x2a,
	0xf8, 0x19, 0x58, 0x2c, 0x14, 0x56, 0x39, 0xea, 0x96, 0x93, 0x0d, 0x05, 0x73, 0xdb, 0x92, 0x56,
	0xc1, 0x5c, 0x8a, 0x9f, 0xe1, 0x67, 0x39, 0xc3, 0xe4, 0x36, 0xb0, 0xbd, 0x83, 0xb1, 0xce, 0xa5,
	0xa6, 0xa6, 0x38, 0x49, 0x57, 0xb8, 0xd9, 0xb9, 0xb9, 0x04, 0x97, 0x2b, 0x26, 0xb8, 0x75, 0xaa,
	0x37, 0xc3, 0xdd, 0xe0, 0x66, 0x76, 0x77, 0x89, 0xa6, 0xa4, 0x69, 0xdc, 0xcc, 0xd4, 0xd4, 0xe5,
	0x99, 0xb9, 0x39, 0x0e, 0xd7, 0xfc, 0x59, 0x3c, 0x37, 0xcb, 0xdd, 0xe0, 0x66, 0xeb, 0x3a, 0xb3,
	0x53, 0x53, 0x97, 0x67, 0x9b, 0x75, 0x12, 0xdc, 0x3d, 0xa3, 0xc2, 0xc9, 0x92, 0xce, 0x49, 0x9a,
	0x65, 0x70, 0x56, 0x19, 0xcb, 0xea, 0xe6, 0x1e, 0x27, 0xe9, 0x1c, 0xde, 0x95, 0x64, 0xbb, 0x41,
	0x95, 0xd3, 0xd4, 0x87, 0x98, 0x9b, 0x99, 0x9a, 0x49, 0x90, 0xa5, 0x0c, 0x3f, 0x79, 0x06, 0x18,
	0xd4, 0x7f, 0x58, 0x05, 0xd0, 0x59, 0xc1, 0xbc, 0xa1, 0x60, 0x22, 0x80, 0x4f, 0x9e, 0x81, 0x6e,
	0x14, 0xf8, 0x45, 0x15, 0x74, 0x91, 0xc7, 0xee, 0x27, 0xcf, 0x80, 0xaf, 0x97, 0xae, 0x3e, 0xfd,
	0xe4, 0x19, 0xb8, 0x11, 0x7d, 0xff, 0xcb, 0x2a, 0xb8, 0xba, 0x66, 0x9b, 0xe4, 0xb6, 0x37, 0x31,
	0xc9, 0x16, 0xd6, 0x6d, 0xf2, 0xe0, 0x44, 0xf2, 0x9a, 0x14, 0xcf, 0x55, 0xac, 0x0a, 0xe1, 0x23,
	0x9c, 0xc4, 0x6d, 0xd9, 0x25, 0x8d, 0x4e, 0x81, 0x78, 0x39, 0xfb, 0xe4, 0x19, 0x18, 0x8b, 0x8e,
	0x1e, 0x56, 0xc1, 0x90, 0x13, 0x58, 0x70, 0x2d, 0xb8, 0x8c, 0xa1, 0xec, 0xd5, 0x66, 0x10, 0x25,
	0x33, 0x08, 0x34, 0x3c, 0x3e, 0xaf, 0x02, 0x20, 0x84, 0xe5, 0x86, 0x54, 0xa2, 0x8f, 0xe0, 0x68,
	0x49, 0xda, 0x15, 0x9b, 0x4f, 0x9d, 0x68, 0xa9, 0x9f, 0x60, 0x76, 0xb4, 0x89, 0x1c, 0xb0, 0xf7,
	0x85, 0xe1, 0x92, 0xb4, 0x2b, 0x34, 0x9e, 0xbe, 0x35, 0xf5, 0x13, 0x8c, 0x7e, 0x0c, 0xc3, 0x4d,
	0x90, 0x99, 0xfd, 0xed, 0x87, 0xe7, 0x0d, 0x20, 0x3c, 0x13, 0x20, 0x15, 0xb5, 0xd8, 0x25, 0x84,
	0x1e, 0x34, 0xc0, 0x6b, 0x03, 0x0e, 0x55, 0x2c, 0x6c, 0x8a, 0xaa, 0x42, 0x36, 0xc9, 0x83, 0x2f,
	0xec, 0xd8, 0x09, 0x7a, 0x0b, 0x77, 0xb0, 0xdf, 0xce, 0xb6, 0x86, 0x0a, 0x80, 0x80, 0x88, 0x38,
	0xdf, 0x24, 0x45, 0x1f, 0xc3, 0xb0, 0x29, 0xd9, 0x58, 0xd4, 0xd4, 0x92, 0x6a, 0x63, 0x93, 0x8d,
	0x9e, 0x20, 0xd2, 0xd8, 0xc1, 0x7e, 0x93, 0x51, 0x43, 0x88, 0x10, 0x19, 0x5f, 0x72, 0x86, 0xd1,
	0x1f, 0xc1, 0xb3, 0x8d, 0x6a, 0xa2, 0xa4, 0x69, 0xc6, 0x0e, 0x56, 0x5c, 0x4a, 0x8d, 0x2d, 0xf6,
	0xf4, 0x09, 0x82, 0x45, 0x0f, 0xf6, 0x23, 0x6a, 0xd9, 0xb5, 0x11, 0x2d, 0x6c, 0xd7, 0xa2, 0x05,
	0x84, 0x68, 0x43, 0xb4, 0xb4, 0xe3, 0x7c, 0xd5, 0xf5, 0x8d, 0x16, 0x60, 0xd8, 0xc4, 0xb6, 0xb9,
	0xe7, 0xdd, 0x07, 0x67, 0x68, 0xa6, 0x62, 0x2d, 0xb1, 0x04, 0xa2, 0xe2, 0x5c, 0x02, 0xf5, 0xa4,
	0x08, 0x21, 0xb3, 0x3e, 0x8c, 0x30, 0x1c, 0x3c, 0x0a, 0xf7, 0xcf, 0xfe, 0x76, 0xbc, 0xd3, 0x8e,
	0x42, 0xd4, 0x92, 0xce, 0xc8, 0xad, 0xbc, 0x60, 0x0e, 0x86, 0x75, 0xa3, 0x21, 0xc2, 0x39, 0x1a,
	0x61, 0xb8, 0x25, 0x42, 0xae, 0x54, 0xb6, 0xf7, 0x48, 0xd1, 0xe8, 0x46, 0xdd, 0xf4, 0x3d, 0x18,
	0x56, 0x15, 0x0d, 0x8b, 0xb6, 0x5a, 0xc2, 0x46, 0xc5, 0x66, 0x39, 0x5a, 0xcb, 0x01, 0xc2, 0x24,
	0x84, 0x10, 0x91, 0x14, 0x1c, 0x01, 0xba, 0x01, 0x4f, 0x7b, 0x5c, 0x54, 0xc1, 0x9b, 0x52, 0x45,
	0xb3, 0x9d, 0x1e, 0x49, 0x01, 0xbd, 0xc5, 0x9e, 0xa7, 0x9d, 0x9a, 0x75, 0x55, 0xb2, 0x8e, 0x06,
	0x3d, 0x3a, 0x04, 0xcb, 0x5b, 0x28, 0x01, 0x87, 0x6a, 0xe6, 0xba, 0x25, 0xba, 0xaf, 0x14, 0xd8,
	0x38, 0x35, 0x1b, 0xf4, 0xcc, 0x74, 0x4b, 0x70, 0x04, 0xe8, 0x8f, 0xe1, 0xa8, 0xed, 0xc1, 0x7e,
	0x91, 0x96, 0xe6, 0x86, 0x0b, 0xfb, 0xd9, 0x0b, 0x74, 0x75, 0xb3, 0xc7, 0xed, 0xdf, 0x1b, 0x89,
	0x48, 0x26, 0xf2, 0x72, 0x1f, 0x90, 0x7d, 0x74, 0x99, 0xd6, 0x29, 0xbb, 0x9d, 0x26, 0xfa, 0x73,
	0x00, 0xc7, 0x4a, 0x12, 0x41, 0x7d, 0x46, 0xc5, 0x72, 0xc2, 0x97, 0x54, 0x5b, 0x2d, 0x3a, 0x27,
	0xea, 0x7b, 0x27, 0x28, 0xbd, 0xcb, 0x07, 0xfb, 0x6f, 0xf6, 0xe0, 0x32, 0xbd, 0x86, 0xda, 0x1f,
	0xad, 0xe9, 0x92, 0x79, 0xdc, 0xae, 0x69, 0xa2, 0x05, 0x48, 0x10, 0x93, 0xa8, 0xea, 0x36, 0x36,
	0x09, 0x53, 0x67, 0x2f, 0xd2, 0xd5, 0xc7, 0x5b, 0x82, 0x17, 0x34, 0x2b, 0xef, 0xa9, 0x78, 0x17,
	0x5c, 0xd8, 0x6e, 0x18, 0x44, 0x3f, 0x82, 0x21, 0xb2, 0xf1, 0x1e, 0x0d, 0xf8, 0x55, 0xcf, 0x09,
	0x16, 0xc1, 0x1e, 0xec, 0xc3, 0xba, 0x51, 0x1d, 0xce, 0xfb, 0x04, 0x32, 0x9c, 0x75, 0xd9, 0xc1,
	0x19, 0xd8, 0x57, 0x63, 0x26, 0xec, 0x97, 0x3d, 0x34, 0xa3, 0xbd, 0x1e, 0x27, 0x41, 0xf3, 0x30,
	0xe8, 0xf0, 0xae, 0xff, 0xe8, 0xa1, 0xf8, 0x88, 0x3f, 0x21, 0xc6, 0x73, 0x68, 0x97, 0x63, 0x4b,
	0x42, 0xd0, 0x17, 0x71, 0xba, 0x54, 0xc2, 0xec, 0x7f, 0xf6, 0x50, 0xda, 0xd3, 0x4b, 0x46, 0x96,
	0xa5, 0x12, 0x46, 0x8b, 0xb0, 0xd7, 0x7b, 0x43, 0xc7, 0xfe, 0x97, 0xb3, 0xae, 0xe3, 0xa2, 0xd4,
	0x5e, 0xe7, 0x25, 0xb2, 0xba, 0x45, 0x98, 0x83, 0xd0, 0xa3, 0x38, 0x1f, 0xd0, 0x1f, 0x1c, 0xa5,
	0x8b, 0xff, 0xdd, 0xf3, 0x36, 0x7c, 0x31, 0x43, 0xf8, 0x53, 0x0b, 0x67, 0x5c, 0x83, 0xfd, 0x0d,
	0x0c, 0x8e, 0x4c, 0xf6, 0x37, 0x3d, 0x34, 0x99, 0xc7, 0x6e, 0x49, 0x2b, 0xa5, 0x15, 0xc2, 0x52,
	0xc3, 0x08, 0xba, 0x09, 0xc3, 0xb4, 0xb8, 0xbc, 0xbc, 0xfe, 0x4f, 0x0f, 0xe5, 0x77, 0xf1, 0x37,
	0xbc, 0x6a, 0x6a, 0xa4, 0x77, 0x21, 0x62, 0xe8, 0x25, 0xd1, 0x82, 0xc8, 0xc2, 0xe6, 0xb6, 0x2a,
	0x7b, 0xfc, 0x87, 0xb4, 0x4b, 0xf6, 0x7f, 0x4f, 0x52, 0x25, 0x97, 0x0e, 0xf6, 0xdb, 0xd8, 0x1e,
	0xad, 0x71, 0xc6, 0x55, 0x72, 0x7a, 0xe3, 0x1a, 0xb6, 0xa3, 0x1f, 0xc2, 0xc1, 0x23, 0x70, 0x09,
	0x31, 0xd0, 0xff, 0x10, 0x3b, 0xef, 0x1e, 0x23, 0x02, 0xf9, 0x88, 0x86, 0x61, 0x90, 0xa2, 0x1d,
	0xca, 0xb0, 0xfb, 0x04, 0xe7, 0xe1, 0xba, 0xef, 0x1a, 0xc8, 0x5c, 0x82, 0xfd, 0xb5, 0xae, 0x47,
	0x11, 0x2d, 0x1a, 0x7e, 0x5e, 0x05, 0xe7, 0x5e, 0x54, 0x41, 0xec, 0xb0, 0x0a, 0x7a, 0x53, 0xd3,
	0x7c, 0x72, 0x86, 0x4f, 0xce, 0xdd, 0x0a, 0xf4, 0x02, 0xc6, 0x77, 0x2b, 0xd0, 0x1b, 0x63, 0xce,
	0xc5, 0x9f, 0x21, 0xd8, 0x3f, 0x6f, 0x62, 0xc9, 0xc6, 0x35, 0x7a, 0xcc, 0xb6, 0xd0, 0xe3, 0x3a,
	0xf3, 0xfd, 0xe0, 0x77, 0x62, 0xbe, 0xbd, 0x1e, 0xf3, 0xad, 0xd1, 0xdd, 0x0e, 0x27, 0x7d, 0xf7,
	0x38, 0xe9, 0x3b, 0x4e, 0x29, 0x3b, 0xd4, 0xf0, 0x9b, 0xa0, 0x86, 0xd2, 0x5b, 0x30, 0xc3, 0xe6,
	0x2e, 0x73, 0x94, 0x19, 0xbe, 0x73, 0x0c, 0x03, 0xbf, 0x3d, 0xc3, 0x18, 0x69, 0xcf, 0x30, 0xda,
	0xf2, 0x8a, 0xd5, 0xb7, 0xe0, 0x15, 0x03, 0x2d, 0xbc, 0xa2, 0x99, 0x4d, 0x3c, 0xfa, 0x3a, 0xd8,
	0x04, 0xd3, 0xca, 0x26, 0x3a, 0x1c, 0xe2, 0xbb, 0xcd, 0x21, 0xac, 0x6f, 0x88, 0x43, 0x38, 0x49,
	0x6a, 0x4f, 0x1d, 0xbe, 0x32, 0xa6, 0xb9, 0xfe, 0x87, 0xff, 0xfc, 0x41, 0xcb, 0xeb, 0xfb, 0xdf,
	0x7c, 0x90, 0x9f, 0x9e, 0xe5, 0x93, 0x7c, 0x8a, 0x9f, 0xe5, 0xe7, 0xf8, 0xe9, 0x6b, 0xfc, 0xf4,
	0x1c, 0x7f, 0x85, 0x9f, 0xbe, 0xca, 0x5f, 0xe5, 0xaf, 0xf1, 0xd3, 0x49, 0x7e, 0x3a, 0xc5, 0x27,
	0xa7, 0xf8, 0xe4, 0x35, 0x3e, 0x39, 0xcd, 0x27, 0x93, 0x7c, 0x2a, 0xc5, 0x27, 0x53, 0x0e, 0xf0,
	0xe1, 0x53, 0xb3, 0x7c, 0xf2, 0x0a, 0x9f, 0xbc, 0xca, 0x27, 0x67, 0xf9, 0x54, 0x92, 0x4f, 0xcd,
	0x64, 0xae, 0x1d, 0x81, 0x4c, 0x97, 0xda, 0x41, 0xa6, 0x3f, 0xfd, 0x3f, 0xd0, 0xa2, 0xe7, 0xc2,
	0xa7, 0x7f, 0x42, 0x70, 0x40, 0xc0, 0x65, 0x4d, 0x92, 0x3b, 0xf8, 0xa9, 0x83, 0x9f, 0x3a, 0xf8,
	0xa9, 0x83, 0x9f, 0x4e, 0x84, 0x9f, 0x36, 0xda, 0xe3, 0xa7, 0x1b, 0xc7, 0xb9, 0x6d, 0x69, 0x33,
	0x1d, 0x00, 0xd5, 0x01, 0x50, 0x1d, 0x00, 0xd5, 0x01, 0x50, 0xef, 0x38, 0x80, 0xfa, 0xd7, 0x53,
	0x30, 0xb4, 0x80, 0xed, 0x0e, 0x78, 0xea, 0x80, 0xa7, 0xce, 0x17, 0x22, 0x3a, 0xe8, 0xeb, 0x5b,
	0x41, 0x5f, 0x3f, 0x6e, 0x8f, 0xbe, 0xe6, 0x8e, 0xfd, 0x5e, 0x43, 0xbd, 0x47, 0x75, 0x90, 0x57,
	0x07, 0x79, 0x75, 0x90, 0xd7, 0xef, 0x3b, 0xf2, 0x7a, 0xb7, 0xfe, 0x55, 0x7b, 0xf7, 0xeb, 0xfa,
	0x57, 0xed, 0xb7, 0xf1, 0x6f, 0xda, 0xaf, 0x0e, 0x6a, 0xef, 0xb7, 0x01, 0xb5, 0x4b, 0xd3, 0x53,
	0xfc, 0x77, 0x06, 0xd7, 0x4e, 0x3c, 0x82, 0x03, 0x2d, 0x88, 0x04, 0x0d, 0xc1, 0x81, 0xf5, 0xbc,
	0x50, 0xb8, 0x93, 0x5e, 0x12, 0xd7, 0x72, 0xc2, 0x7a, 0x7e, 0x3e, 0xc7, 0x74, 0xa1, 0x11, 0x88,
	0x16, 0x0b, 0x85, 0x55, 0x71, 0x69, 0x25, 0x9d, 0x15, 0x33, 0xe9, 0xa5, 0xf4, 0xf2, 0x7c, 0x4e,
	0x60, 0x00, 0x1a, 0x80, 0xa1, 0xf4, 0x6a, 0x5e, 0x5c, 0x48, 0x17, 0x72, 0x77, 0xd3, 0xf7, 0x18,
	0x1f, 0x3a, 0x05, 0x07, 0x0b, 0xf3, 0xad, 0x7a, 0x7e, 0xd4, 0x07, 0x83, 0xab, 0xc2, 0xca, 0x8f,
	0xee, 0x31, 0x81, 0x89, 0x47, 0xb0, 0xaf, 0xfe, 0x63, 0x96, 0x7e, 0x08, 0xa9, 0x5f, 0x47, 0xd8,
	0x85, 0x22, 0xb0, 0x8f, 0x98, 0x3b, 0x8f, 0x80, 0x84, 0xad, 0x3d, 0x8a, 0x77, 0xf3, 0x85, 0x45,
	0x71, 0x6d, 0x39, 0xcf, 0xf8, 0x48, 0x58, 0x62, 0xb6, 0xe6, 0x2a, 0xfa, 0x89, 0xdd, 0x9d, 0xac,
	0x67, 0x17, 0x20, 0x8f, 0x6b, 0xb7, 0xd3, 0xee, 0x63, 0x70, 0xe2, 0x0b, 0x00, 0x99, 0xd6, 0xd2,
	0x27, 0xbe, 0xbd, 0x75, 0x2e, 0xae, 0xac, 0x15, 0x44, 0x21, 0x97, 0xce, 0x92, 0x29, 0x5c, 0x84,
	0xe7, 0x9b, 0xc6, 0x57, 0x73, 0xcb, 0xd9, 0xfc, 0xf2, 0x82, 0xb8, 0x9e, 0x13, 0xf2, 0x37, 0xf3,
	0xf3, 0xe9, 0x42, 0x7e, 0x65, 0x99, 0x01, 0xe8, 0x7b, 0x90, 0x6b, 0x52, 0x6b, 0x14, 0x8b, 0x37,
	0xd3, 0xf9, 0xa5, 0x5c, 0x96, 0xf1, 0xa1, 0xf7, 0xe0, 0x85, 0xb6, 0xce, 0xb2, 0xcb, 0x6b, 0x62,
	0x36, 0xb7, 0x94, 0x5b, 0x70, 0xdc, 0xf9, 0xd1, 0x79, 0x78, 0xb6, 0xad, 0x62, 0x5a, 0x14, 0x72,
	0xf3, 0x2b, 0x42, 0x96, 0x09, 0xa0, 0x0b, 0xf0, 0x5c, 0x93, 0x0a, 0xf1, 0xe1, 0x89, 0xc5, 0x74,
	0x36, 0x9b, 0xcb, 0x32, 0xc1, 0x89, 0xaa, 0x0f, 0xa2, 0xa3, 0xc7, 0x05, 0x0d, 0xd7, 0xbf, 0x66,
	0x9f, 0x75, 0xfa, 0x96, 0xc2, 0x74, 0xa1, 0x31, 0x78, 0x2a, 0xeb, 0x7d, 0x25, 0x64, 0x1d, 0x9b,
	0x35, 0x1b, 0x06, 0x90, 0x2a, 0x48, 0xd7, 0x4f, 0x98, 0x69, 0x63, 0x85, 0xf1, 0xa1, 0x28, 0x1c,
	0x71, 0x94, 0x6b, 0xbd, 0x78, 0x15, 0xeb, 0x8a, 0xaa, 0x17, 0x19, 0x3f, 0x3a, 0x0d, 0x47, 0x5b,
	0x64, 0x8e, 0x47, 0xac, 0x30, 0x81, 0xc6, 0xf0, 0x37, 0x55, 0x5d, 0xd2, 0xd4, 0x4f, 0x30, 0x13,
	0x24, 0x19, 0xa8, 0x4f, 0x15, 0xe7, 0x75, 0xfa, 0xf3, 0x2f, 0xa6, 0x9b, 0x68, 0x37, 0x8c, 0xaf,
	0xd3, 0xd1, 0x1e, 0x32, 0x59, 0xcf, 0xc7, 0xb2, 0x61, 0xa7, 0xcb, 0x65, 0x4d, 0x95, 0xc9, 0x42,
	0x98, 0x5e, 0x34, 0x0a, 0x87, 0x3c, 0x91, 0x50, 0xbb, 0x21, 0x15, 0xa6, 0x8f, 0x4c, 0xca, 0x13,
	0x2c, 0x60, 0x1d, 0x9b, 0x0e, 0x06, 0x20, 0x97, 0x1d, 0x03, 0xd1, 0x20, 0x8c, 0x78, 0x42, 0x7a,
	0xc0, 0x99, 0x50, 0xe6, 0x29, 0x78, 0xf1, 0x2a, 0xd6, 0xf5, 0xf2, 0x55, 0xac, 0xeb, 0xd7, 0xaf,
	0x62, 0xe0, 0xf5, 0xab, 0x18, 0x78, 0x7c, 0x18, 0x03, 0x7f, 0x7b, 0x18, 0x03, 0x3f, 0x3b, 0x8c,
	0x81, 0xe7, 0x87, 0x31, 0xf0, 0x8b, 0xc3, 0x18, 0x78, 0x71, 0x18, 0x03, 0x2f, 0x0f, 0x63, 0xe0,
	0xf3, 0xc3, 0x18, 0xf8, 0xe2, 0x30, 0xd6, 0xf5, 0xeb, 0xc3, 0x18, 0xf8, 0xc9, 0x2f, 0x63, 0x5d,
	0xcf, 0x7f, 0x19, 0x03, 0x1f, 0xaf, 0x16, 0x8d, 0xf2, 0xc3, 0x62, 0x62, 0xdb, 0xd0, 0x6c, 0x6c,
	0x9a, 0x52, 0xa2, 0x62, 0x4d, 0xd2, 0x0f, 0x9b, 0x86, 0x59, 0xba, 0x5c, 0x36, 0x8d, 0x6d, 0x55,
	0xc1, 0xe6, 0x65, 0x4f, 0x3c, 0x59, 0xde, 0x28, 0x1a, 0x93, 0x78, 0xd7, 0x76, 0x7f, 0xc1, 0xd6,
	0xe6, 0x87, 0x6c, 0x1b, 0xdd, 0xf4, 0x47, 0x09, 0xa9, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x36,
	0xba, 0xd0, 0xeb, 0x30, 0x38, 0x00, 0x00,
}

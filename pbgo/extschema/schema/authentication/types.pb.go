// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/authentication/types.proto

package authentication

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/gogo/protobuf/types"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type OIDCAuthParams struct {
	// Authorization Endpoint
	//
	// x-displayName: "Authorization Endpoint"
	// x-required
	// URL of the authorization server's authorization endpoint.
	AuthEndpointUrl string `protobuf:"bytes,1,opt,name=auth_endpoint_url,json=authEndpointUrl,proto3" json:"auth_endpoint_url,omitempty"`
	// Token Endpoint
	//
	// x-displayName: "Token Endpoint"
	// x-required
	// URL of the authorization server's Token endpoint.
	TokenEndpointUrl string `protobuf:"bytes,2,opt,name=token_endpoint_url,json=tokenEndpointUrl,proto3" json:"token_endpoint_url,omitempty"`
	// Logout Endpoint
	//
	// x-displayName: "Logout Endpoint"
	// x-required
	// URL of the authorization server's Logout endpoint.
	EndSessionEndpointUrl string `protobuf:"bytes,3,opt,name=end_session_endpoint_url,json=endSessionEndpointUrl,proto3" json:"end_session_endpoint_url,omitempty"`
}

func (m *OIDCAuthParams) Reset()                    { *m = OIDCAuthParams{} }
func (*OIDCAuthParams) ProtoMessage()               {}
func (*OIDCAuthParams) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *OIDCAuthParams) GetAuthEndpointUrl() string {
	if m != nil {
		return m.AuthEndpointUrl
	}
	return ""
}

func (m *OIDCAuthParams) GetTokenEndpointUrl() string {
	if m != nil {
		return m.TokenEndpointUrl
	}
	return ""
}

func (m *OIDCAuthParams) GetEndSessionEndpointUrl() string {
	if m != nil {
		return m.EndSessionEndpointUrl
	}
	return ""
}

type OIDCAuthType struct {
	// OIDC Endpoint Configuration
	//
	// x-displayName: "OIDC Endpoint Configuration"
	// x-required
	// Configure OIDC Endpoints
	//
	// Types that are valid to be assigned to AuthParamsChoice:
	//	*OIDCAuthType_OidcWellKnownConfigUrl
	//	*OIDCAuthType_OidcAuthParams
	AuthParamsChoice isOIDCAuthType_AuthParamsChoice `protobuf_oneof:"auth_params_choice"`
	// OIDC Client ID
	//
	// x-displayName: "OIDC Client ID"
	// x-required
	// Client ID used while sending the Authorization Request to OIDC server
	OidcClientId string `protobuf:"bytes,4,opt,name=oidc_client_id,json=oidcClientId,proto3" json:"oidc_client_id,omitempty"`
	// OIDC Client Secret
	//
	// x-displayName: "OIDC Client Secret"
	// x-required
	// Client secret used while sending token verification request to OIDC server
	ClientSecret *ves_io_schema4.SecretType `protobuf:"bytes,5,opt,name=client_secret,json=clientSecret" json:"client_secret,omitempty"`
}

func (m *OIDCAuthType) Reset()                    { *m = OIDCAuthType{} }
func (*OIDCAuthType) ProtoMessage()               {}
func (*OIDCAuthType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

type isOIDCAuthType_AuthParamsChoice interface {
	isOIDCAuthType_AuthParamsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type OIDCAuthType_OidcWellKnownConfigUrl struct {
	OidcWellKnownConfigUrl string `protobuf:"bytes,2,opt,name=oidc_well_known_config_url,json=oidcWellKnownConfigUrl,proto3,oneof"`
}
type OIDCAuthType_OidcAuthParams struct {
	OidcAuthParams *OIDCAuthParams `protobuf:"bytes,3,opt,name=oidc_auth_params,json=oidcAuthParams,oneof"`
}

func (*OIDCAuthType_OidcWellKnownConfigUrl) isOIDCAuthType_AuthParamsChoice() {}
func (*OIDCAuthType_OidcAuthParams) isOIDCAuthType_AuthParamsChoice()         {}

func (m *OIDCAuthType) GetAuthParamsChoice() isOIDCAuthType_AuthParamsChoice {
	if m != nil {
		return m.AuthParamsChoice
	}
	return nil
}

func (m *OIDCAuthType) GetOidcWellKnownConfigUrl() string {
	if x, ok := m.GetAuthParamsChoice().(*OIDCAuthType_OidcWellKnownConfigUrl); ok {
		return x.OidcWellKnownConfigUrl
	}
	return ""
}

func (m *OIDCAuthType) GetOidcAuthParams() *OIDCAuthParams {
	if x, ok := m.GetAuthParamsChoice().(*OIDCAuthType_OidcAuthParams); ok {
		return x.OidcAuthParams
	}
	return nil
}

func (m *OIDCAuthType) GetOidcClientId() string {
	if m != nil {
		return m.OidcClientId
	}
	return ""
}

func (m *OIDCAuthType) GetClientSecret() *ves_io_schema4.SecretType {
	if m != nil {
		return m.ClientSecret
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OIDCAuthType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OIDCAuthType_OneofMarshaler, _OIDCAuthType_OneofUnmarshaler, _OIDCAuthType_OneofSizer, []interface{}{
		(*OIDCAuthType_OidcWellKnownConfigUrl)(nil),
		(*OIDCAuthType_OidcAuthParams)(nil),
	}
}

func _OIDCAuthType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OIDCAuthType)
	// auth_params_choice
	switch x := m.AuthParamsChoice.(type) {
	case *OIDCAuthType_OidcWellKnownConfigUrl:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.OidcWellKnownConfigUrl)
	case *OIDCAuthType_OidcAuthParams:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OidcAuthParams); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OIDCAuthType.AuthParamsChoice has unexpected type %T", x)
	}
	return nil
}

func _OIDCAuthType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OIDCAuthType)
	switch tag {
	case 2: // auth_params_choice.oidc_well_known_config_url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AuthParamsChoice = &OIDCAuthType_OidcWellKnownConfigUrl{x}
		return true, err
	case 3: // auth_params_choice.oidc_auth_params
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OIDCAuthParams)
		err := b.DecodeMessage(msg)
		m.AuthParamsChoice = &OIDCAuthType_OidcAuthParams{msg}
		return true, err
	default:
		return false, nil
	}
}

func _OIDCAuthType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OIDCAuthType)
	// auth_params_choice
	switch x := m.AuthParamsChoice.(type) {
	case *OIDCAuthType_OidcWellKnownConfigUrl:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.OidcWellKnownConfigUrl)))
		n += len(x.OidcWellKnownConfigUrl)
	case *OIDCAuthType_OidcAuthParams:
		s := proto.Size(x.OidcAuthParams)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// HMAC Key Pair
//
// x-displayName: "HMAC Key Pair"
// HMAC primary and secondary keys to be used for hashing the Cookie.
// Each key also have an associated expiry timestamp, beyond which key is invalid.
type HMACKeyPair struct {
	// HMAC Primary Key
	//
	// x-displayName: "HMAC Primary Key"
	// x-required
	// Primary HMAC Key
	PrimKey *ves_io_schema4.SecretType `protobuf:"bytes,1,opt,name=prim_key,json=primKey" json:"prim_key,omitempty"`
	// HMAC Primary Key Expiry Time
	//
	// x-displayName: "HMAC Primary Key Expiry"
	// x-required
	// Primary HMAC Key Expiry time
	PrimKeyExpiry *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=prim_key_expiry,json=primKeyExpiry" json:"prim_key_expiry,omitempty"`
	// HMAC Secondary Key
	//
	// x-displayName: "HMAC Secondary Key"
	// x-required
	// Secondary HMAC Key
	SecKey *ves_io_schema4.SecretType `protobuf:"bytes,3,opt,name=sec_key,json=secKey" json:"sec_key,omitempty"`
	// HMAC Secondary Key Expiry Time
	//
	// x-displayName: "HMAC Secondary Key Expiry"
	// x-required
	// Secondary HMAC Key Expiry time
	SecKeyExpiry *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=sec_key_expiry,json=secKeyExpiry" json:"sec_key_expiry,omitempty"`
}

func (m *HMACKeyPair) Reset()                    { *m = HMACKeyPair{} }
func (*HMACKeyPair) ProtoMessage()               {}
func (*HMACKeyPair) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *HMACKeyPair) GetPrimKey() *ves_io_schema4.SecretType {
	if m != nil {
		return m.PrimKey
	}
	return nil
}

func (m *HMACKeyPair) GetPrimKeyExpiry() *google_protobuf1.Timestamp {
	if m != nil {
		return m.PrimKeyExpiry
	}
	return nil
}

func (m *HMACKeyPair) GetSecKey() *ves_io_schema4.SecretType {
	if m != nil {
		return m.SecKey
	}
	return nil
}

func (m *HMACKeyPair) GetSecKeyExpiry() *google_protobuf1.Timestamp {
	if m != nil {
		return m.SecKeyExpiry
	}
	return nil
}

// KMS Key Ref
//
// x-displayName: "KMS Key Reference"
// Reference to KMS Key Object
type KMSKeyRefType struct {
	// kms_key Reference
	//
	// x-displayName: "HMAC kms key reference"
	// HMAC configured using the KMS_KEY reference
	AuthHmacKms *ves_io_schema_views.ObjectRefType `protobuf:"bytes,1,opt,name=auth_hmac_kms,json=authHmacKms" json:"auth_hmac_kms,omitempty"`
}

func (m *KMSKeyRefType) Reset()                    { *m = KMSKeyRefType{} }
func (*KMSKeyRefType) ProtoMessage()               {}
func (*KMSKeyRefType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *KMSKeyRefType) GetAuthHmacKms() *ves_io_schema_views.ObjectRefType {
	if m != nil {
		return m.AuthHmacKms
	}
	return nil
}

// Cookie Parameters Config
//
// x-displayName: "Cookie Parameters"
// Specifies different cookie related config parameters for authentication
type CookieParams struct {
	// cookie refresh interval
	//
	// x-displayName: "Cookie Refresh Interval"
	// x-example: 3600
	// Specifies in seconds refresh interval for session cookie.
	// This is used to keep the active user active and reduce re-login.
	// When an incoming cookie's session expiry is still valid, and time to expire falls behind this interval,
	// re-issue a cookie with new expiry and with the same original session expiry.
	// Default refresh interval is 3000 seconds
	CookieRefreshInterval uint32 `protobuf:"varint,1,opt,name=cookie_refresh_interval,json=cookieRefreshInterval,proto3" json:"cookie_refresh_interval,omitempty"`
	// cookie expiry
	//
	// x-displayName: "Cookie Expiry duration"
	// x-example: 5000
	// specifies in seconds max duration of the allocated cookie. This maps to “Max-Age” attribute in the session cookie.
	// This will act as an expiry duration on the client side after which client will not  be setting the
	// cookie as part of the request.
	// Default cookie expiry is 3600 seconds
	CookieExpiry uint32 `protobuf:"varint,2,opt,name=cookie_expiry,json=cookieExpiry,proto3" json:"cookie_expiry,omitempty"`
	// session expiry
	//
	// x-displayName: "Session Expiry duration"
	// x-example: 36000
	// specifies in seconds max lifetime of an authenticated session after which the user will be forced to login again.
	// Default session expiry is 86400 seconds(24 hours).
	SessionExpiry uint32 `protobuf:"varint,3,opt,name=session_expiry,json=sessionExpiry,proto3" json:"session_expiry,omitempty"`
	// HMAC Choice
	//
	// x-displayName: "Select HMAC Type"
	// HMAC used to hash the cookie
	//
	// Types that are valid to be assigned to SecretChoice:
	//	*CookieParams_AuthHmac
	//	*CookieParams_KmsKeyHmac
	SecretChoice isCookieParams_SecretChoice `protobuf_oneof:"secret_choice"`
}

func (m *CookieParams) Reset()                    { *m = CookieParams{} }
func (*CookieParams) ProtoMessage()               {}
func (*CookieParams) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isCookieParams_SecretChoice interface {
	isCookieParams_SecretChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CookieParams_AuthHmac struct {
	AuthHmac *HMACKeyPair `protobuf:"bytes,5,opt,name=auth_hmac,json=authHmac,oneof"`
}
type CookieParams_KmsKeyHmac struct {
	KmsKeyHmac *KMSKeyRefType `protobuf:"bytes,6,opt,name=kms_key_hmac,json=kmsKeyHmac,oneof"`
}

func (*CookieParams_AuthHmac) isCookieParams_SecretChoice()   {}
func (*CookieParams_KmsKeyHmac) isCookieParams_SecretChoice() {}

func (m *CookieParams) GetSecretChoice() isCookieParams_SecretChoice {
	if m != nil {
		return m.SecretChoice
	}
	return nil
}

func (m *CookieParams) GetCookieRefreshInterval() uint32 {
	if m != nil {
		return m.CookieRefreshInterval
	}
	return 0
}

func (m *CookieParams) GetCookieExpiry() uint32 {
	if m != nil {
		return m.CookieExpiry
	}
	return 0
}

func (m *CookieParams) GetSessionExpiry() uint32 {
	if m != nil {
		return m.SessionExpiry
	}
	return 0
}

func (m *CookieParams) GetAuthHmac() *HMACKeyPair {
	if x, ok := m.GetSecretChoice().(*CookieParams_AuthHmac); ok {
		return x.AuthHmac
	}
	return nil
}

func (m *CookieParams) GetKmsKeyHmac() *KMSKeyRefType {
	if x, ok := m.GetSecretChoice().(*CookieParams_KmsKeyHmac); ok {
		return x.KmsKeyHmac
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CookieParams) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CookieParams_OneofMarshaler, _CookieParams_OneofUnmarshaler, _CookieParams_OneofSizer, []interface{}{
		(*CookieParams_AuthHmac)(nil),
		(*CookieParams_KmsKeyHmac)(nil),
	}
}

func _CookieParams_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CookieParams)
	// secret_choice
	switch x := m.SecretChoice.(type) {
	case *CookieParams_AuthHmac:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AuthHmac); err != nil {
			return err
		}
	case *CookieParams_KmsKeyHmac:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KmsKeyHmac); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CookieParams.SecretChoice has unexpected type %T", x)
	}
	return nil
}

func _CookieParams_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CookieParams)
	switch tag {
	case 5: // secret_choice.auth_hmac
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HMACKeyPair)
		err := b.DecodeMessage(msg)
		m.SecretChoice = &CookieParams_AuthHmac{msg}
		return true, err
	case 6: // secret_choice.kms_key_hmac
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KMSKeyRefType)
		err := b.DecodeMessage(msg)
		m.SecretChoice = &CookieParams_KmsKeyHmac{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CookieParams_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CookieParams)
	// secret_choice
	switch x := m.SecretChoice.(type) {
	case *CookieParams_AuthHmac:
		s := proto.Size(x.AuthHmac)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CookieParams_KmsKeyHmac:
		s := proto.Size(x.KmsKeyHmac)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GlobalSpecType
//
// x-displayName: "Authentication Specification"
// Shape of Authentication Object
type GlobalSpecType struct {
	// Authentication Type
	//
	// x-displayName: "Authentication Type"
	// x-required
	// Select Authentication Type
	//
	// Types that are valid to be assigned to AuthTypeChoice:
	//	*GlobalSpecType_OidcAuth
	AuthTypeChoice isGlobalSpecType_AuthTypeChoice `protobuf_oneof:"auth_type_choice"`
	// Cookie Configuration details
	//
	// x-displayName: "Cookie Configuration"
	// x-required
	// Cookie configuration details for this Object
	CookieParams *CookieParams `protobuf:"bytes,3,opt,name=cookie_params,json=cookieParams" json:"cookie_params,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

type isGlobalSpecType_AuthTypeChoice interface {
	isGlobalSpecType_AuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_OidcAuth struct {
	OidcAuth *OIDCAuthType `protobuf:"bytes,2,opt,name=oidc_auth,json=oidcAuth,oneof"`
}

func (*GlobalSpecType_OidcAuth) isGlobalSpecType_AuthTypeChoice() {}

func (m *GlobalSpecType) GetAuthTypeChoice() isGlobalSpecType_AuthTypeChoice {
	if m != nil {
		return m.AuthTypeChoice
	}
	return nil
}

func (m *GlobalSpecType) GetOidcAuth() *OIDCAuthType {
	if x, ok := m.GetAuthTypeChoice().(*GlobalSpecType_OidcAuth); ok {
		return x.OidcAuth
	}
	return nil
}

func (m *GlobalSpecType) GetCookieParams() *CookieParams {
	if m != nil {
		return m.CookieParams
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_OidcAuth)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// auth_type_choice
	switch x := m.AuthTypeChoice.(type) {
	case *GlobalSpecType_OidcAuth:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OidcAuth); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.AuthTypeChoice has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 2: // auth_type_choice.oidc_auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OIDCAuthType)
		err := b.DecodeMessage(msg)
		m.AuthTypeChoice = &GlobalSpecType_OidcAuth{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// auth_type_choice
	switch x := m.AuthTypeChoice.(type) {
	case *GlobalSpecType_OidcAuth:
		s := proto.Size(x.OidcAuth)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create Authentication Object
//
// x-displayName: "Create Authentication"
type CreateSpecType struct {
	// Types that are valid to be assigned to AuthTypeChoice:
	//	*CreateSpecType_OidcAuth
	AuthTypeChoice isCreateSpecType_AuthTypeChoice `protobuf_oneof:"auth_type_choice"`
	CookieParams   *CookieParams                   `protobuf:"bytes,3,opt,name=cookie_params,json=cookieParams" json:"cookie_params,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

type isCreateSpecType_AuthTypeChoice interface {
	isCreateSpecType_AuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_OidcAuth struct {
	OidcAuth *OIDCAuthType `protobuf:"bytes,2,opt,name=oidc_auth,json=oidcAuth,oneof"`
}

func (*CreateSpecType_OidcAuth) isCreateSpecType_AuthTypeChoice() {}

func (m *CreateSpecType) GetAuthTypeChoice() isCreateSpecType_AuthTypeChoice {
	if m != nil {
		return m.AuthTypeChoice
	}
	return nil
}

func (m *CreateSpecType) GetOidcAuth() *OIDCAuthType {
	if x, ok := m.GetAuthTypeChoice().(*CreateSpecType_OidcAuth); ok {
		return x.OidcAuth
	}
	return nil
}

func (m *CreateSpecType) GetCookieParams() *CookieParams {
	if m != nil {
		return m.CookieParams
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_OidcAuth)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// auth_type_choice
	switch x := m.AuthTypeChoice.(type) {
	case *CreateSpecType_OidcAuth:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OidcAuth); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.AuthTypeChoice has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 2: // auth_type_choice.oidc_auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OIDCAuthType)
		err := b.DecodeMessage(msg)
		m.AuthTypeChoice = &CreateSpecType_OidcAuth{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// auth_type_choice
	switch x := m.AuthTypeChoice.(type) {
	case *CreateSpecType_OidcAuth:
		s := proto.Size(x.OidcAuth)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace Authentication
//
// x-displayName: "Replace Authentication"
type ReplaceSpecType struct {
	// Types that are valid to be assigned to AuthTypeChoice:
	//	*ReplaceSpecType_OidcAuth
	AuthTypeChoice isReplaceSpecType_AuthTypeChoice `protobuf_oneof:"auth_type_choice"`
	CookieParams   *CookieParams                    `protobuf:"bytes,3,opt,name=cookie_params,json=cookieParams" json:"cookie_params,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

type isReplaceSpecType_AuthTypeChoice interface {
	isReplaceSpecType_AuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_OidcAuth struct {
	OidcAuth *OIDCAuthType `protobuf:"bytes,2,opt,name=oidc_auth,json=oidcAuth,oneof"`
}

func (*ReplaceSpecType_OidcAuth) isReplaceSpecType_AuthTypeChoice() {}

func (m *ReplaceSpecType) GetAuthTypeChoice() isReplaceSpecType_AuthTypeChoice {
	if m != nil {
		return m.AuthTypeChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetOidcAuth() *OIDCAuthType {
	if x, ok := m.GetAuthTypeChoice().(*ReplaceSpecType_OidcAuth); ok {
		return x.OidcAuth
	}
	return nil
}

func (m *ReplaceSpecType) GetCookieParams() *CookieParams {
	if m != nil {
		return m.CookieParams
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_OidcAuth)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// auth_type_choice
	switch x := m.AuthTypeChoice.(type) {
	case *ReplaceSpecType_OidcAuth:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OidcAuth); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.AuthTypeChoice has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 2: // auth_type_choice.oidc_auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OIDCAuthType)
		err := b.DecodeMessage(msg)
		m.AuthTypeChoice = &ReplaceSpecType_OidcAuth{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// auth_type_choice
	switch x := m.AuthTypeChoice.(type) {
	case *ReplaceSpecType_OidcAuth:
		s := proto.Size(x.OidcAuth)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get Authentication
//
// x-displayName: "Get Authentication"
type GetSpecType struct {
	// Types that are valid to be assigned to AuthTypeChoice:
	//	*GetSpecType_OidcAuth
	AuthTypeChoice isGetSpecType_AuthTypeChoice `protobuf_oneof:"auth_type_choice"`
	CookieParams   *CookieParams                `protobuf:"bytes,3,opt,name=cookie_params,json=cookieParams" json:"cookie_params,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

type isGetSpecType_AuthTypeChoice interface {
	isGetSpecType_AuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_OidcAuth struct {
	OidcAuth *OIDCAuthType `protobuf:"bytes,2,opt,name=oidc_auth,json=oidcAuth,oneof"`
}

func (*GetSpecType_OidcAuth) isGetSpecType_AuthTypeChoice() {}

func (m *GetSpecType) GetAuthTypeChoice() isGetSpecType_AuthTypeChoice {
	if m != nil {
		return m.AuthTypeChoice
	}
	return nil
}

func (m *GetSpecType) GetOidcAuth() *OIDCAuthType {
	if x, ok := m.GetAuthTypeChoice().(*GetSpecType_OidcAuth); ok {
		return x.OidcAuth
	}
	return nil
}

func (m *GetSpecType) GetCookieParams() *CookieParams {
	if m != nil {
		return m.CookieParams
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_OidcAuth)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// auth_type_choice
	switch x := m.AuthTypeChoice.(type) {
	case *GetSpecType_OidcAuth:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OidcAuth); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.AuthTypeChoice has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 2: // auth_type_choice.oidc_auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OIDCAuthType)
		err := b.DecodeMessage(msg)
		m.AuthTypeChoice = &GetSpecType_OidcAuth{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// auth_type_choice
	switch x := m.AuthTypeChoice.(type) {
	case *GetSpecType_OidcAuth:
		s := proto.Size(x.OidcAuth)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*OIDCAuthParams)(nil), "ves.io.schema.authentication.OIDCAuthParams")
	golang_proto.RegisterType((*OIDCAuthParams)(nil), "ves.io.schema.authentication.OIDCAuthParams")
	proto.RegisterType((*OIDCAuthType)(nil), "ves.io.schema.authentication.OIDCAuthType")
	golang_proto.RegisterType((*OIDCAuthType)(nil), "ves.io.schema.authentication.OIDCAuthType")
	proto.RegisterType((*HMACKeyPair)(nil), "ves.io.schema.authentication.HMACKeyPair")
	golang_proto.RegisterType((*HMACKeyPair)(nil), "ves.io.schema.authentication.HMACKeyPair")
	proto.RegisterType((*KMSKeyRefType)(nil), "ves.io.schema.authentication.KMSKeyRefType")
	golang_proto.RegisterType((*KMSKeyRefType)(nil), "ves.io.schema.authentication.KMSKeyRefType")
	proto.RegisterType((*CookieParams)(nil), "ves.io.schema.authentication.CookieParams")
	golang_proto.RegisterType((*CookieParams)(nil), "ves.io.schema.authentication.CookieParams")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.authentication.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.authentication.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.authentication.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.authentication.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.authentication.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.authentication.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.authentication.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.authentication.GetSpecType")
}
func (this *OIDCAuthParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCAuthParams)
	if !ok {
		that2, ok := that.(OIDCAuthParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AuthEndpointUrl != that1.AuthEndpointUrl {
		return false
	}
	if this.TokenEndpointUrl != that1.TokenEndpointUrl {
		return false
	}
	if this.EndSessionEndpointUrl != that1.EndSessionEndpointUrl {
		return false
	}
	return true
}
func (this *OIDCAuthType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCAuthType)
	if !ok {
		that2, ok := that.(OIDCAuthType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthParamsChoice == nil {
		if this.AuthParamsChoice != nil {
			return false
		}
	} else if this.AuthParamsChoice == nil {
		return false
	} else if !this.AuthParamsChoice.Equal(that1.AuthParamsChoice) {
		return false
	}
	if this.OidcClientId != that1.OidcClientId {
		return false
	}
	if !this.ClientSecret.Equal(that1.ClientSecret) {
		return false
	}
	return true
}
func (this *OIDCAuthType_OidcWellKnownConfigUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCAuthType_OidcWellKnownConfigUrl)
	if !ok {
		that2, ok := that.(OIDCAuthType_OidcWellKnownConfigUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OidcWellKnownConfigUrl != that1.OidcWellKnownConfigUrl {
		return false
	}
	return true
}
func (this *OIDCAuthType_OidcAuthParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCAuthType_OidcAuthParams)
	if !ok {
		that2, ok := that.(OIDCAuthType_OidcAuthParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuthParams.Equal(that1.OidcAuthParams) {
		return false
	}
	return true
}
func (this *HMACKeyPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HMACKeyPair)
	if !ok {
		that2, ok := that.(HMACKeyPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrimKey.Equal(that1.PrimKey) {
		return false
	}
	if !this.PrimKeyExpiry.Equal(that1.PrimKeyExpiry) {
		return false
	}
	if !this.SecKey.Equal(that1.SecKey) {
		return false
	}
	if !this.SecKeyExpiry.Equal(that1.SecKeyExpiry) {
		return false
	}
	return true
}
func (this *KMSKeyRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KMSKeyRefType)
	if !ok {
		that2, ok := that.(KMSKeyRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AuthHmacKms.Equal(that1.AuthHmacKms) {
		return false
	}
	return true
}
func (this *CookieParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieParams)
	if !ok {
		that2, ok := that.(CookieParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CookieRefreshInterval != that1.CookieRefreshInterval {
		return false
	}
	if this.CookieExpiry != that1.CookieExpiry {
		return false
	}
	if this.SessionExpiry != that1.SessionExpiry {
		return false
	}
	if that1.SecretChoice == nil {
		if this.SecretChoice != nil {
			return false
		}
	} else if this.SecretChoice == nil {
		return false
	} else if !this.SecretChoice.Equal(that1.SecretChoice) {
		return false
	}
	return true
}
func (this *CookieParams_AuthHmac) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieParams_AuthHmac)
	if !ok {
		that2, ok := that.(CookieParams_AuthHmac)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AuthHmac.Equal(that1.AuthHmac) {
		return false
	}
	return true
}
func (this *CookieParams_KmsKeyHmac) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieParams_KmsKeyHmac)
	if !ok {
		that2, ok := that.(CookieParams_KmsKeyHmac)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.KmsKeyHmac.Equal(that1.KmsKeyHmac) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthTypeChoice == nil {
		if this.AuthTypeChoice != nil {
			return false
		}
	} else if this.AuthTypeChoice == nil {
		return false
	} else if !this.AuthTypeChoice.Equal(that1.AuthTypeChoice) {
		return false
	}
	if !this.CookieParams.Equal(that1.CookieParams) {
		return false
	}
	return true
}
func (this *GlobalSpecType_OidcAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_OidcAuth)
	if !ok {
		that2, ok := that.(GlobalSpecType_OidcAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuth.Equal(that1.OidcAuth) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthTypeChoice == nil {
		if this.AuthTypeChoice != nil {
			return false
		}
	} else if this.AuthTypeChoice == nil {
		return false
	} else if !this.AuthTypeChoice.Equal(that1.AuthTypeChoice) {
		return false
	}
	if !this.CookieParams.Equal(that1.CookieParams) {
		return false
	}
	return true
}
func (this *CreateSpecType_OidcAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_OidcAuth)
	if !ok {
		that2, ok := that.(CreateSpecType_OidcAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuth.Equal(that1.OidcAuth) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthTypeChoice == nil {
		if this.AuthTypeChoice != nil {
			return false
		}
	} else if this.AuthTypeChoice == nil {
		return false
	} else if !this.AuthTypeChoice.Equal(that1.AuthTypeChoice) {
		return false
	}
	if !this.CookieParams.Equal(that1.CookieParams) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_OidcAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_OidcAuth)
	if !ok {
		that2, ok := that.(ReplaceSpecType_OidcAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuth.Equal(that1.OidcAuth) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthTypeChoice == nil {
		if this.AuthTypeChoice != nil {
			return false
		}
	} else if this.AuthTypeChoice == nil {
		return false
	} else if !this.AuthTypeChoice.Equal(that1.AuthTypeChoice) {
		return false
	}
	if !this.CookieParams.Equal(that1.CookieParams) {
		return false
	}
	return true
}
func (this *GetSpecType_OidcAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_OidcAuth)
	if !ok {
		that2, ok := that.(GetSpecType_OidcAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuth.Equal(that1.OidcAuth) {
		return false
	}
	return true
}
func (this *OIDCAuthParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authentication.OIDCAuthParams{")
	s = append(s, "AuthEndpointUrl: "+fmt.Sprintf("%#v", this.AuthEndpointUrl)+",\n")
	s = append(s, "TokenEndpointUrl: "+fmt.Sprintf("%#v", this.TokenEndpointUrl)+",\n")
	s = append(s, "EndSessionEndpointUrl: "+fmt.Sprintf("%#v", this.EndSessionEndpointUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OIDCAuthType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authentication.OIDCAuthType{")
	if this.AuthParamsChoice != nil {
		s = append(s, "AuthParamsChoice: "+fmt.Sprintf("%#v", this.AuthParamsChoice)+",\n")
	}
	s = append(s, "OidcClientId: "+fmt.Sprintf("%#v", this.OidcClientId)+",\n")
	if this.ClientSecret != nil {
		s = append(s, "ClientSecret: "+fmt.Sprintf("%#v", this.ClientSecret)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OIDCAuthType_OidcWellKnownConfigUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.OIDCAuthType_OidcWellKnownConfigUrl{` +
		`OidcWellKnownConfigUrl:` + fmt.Sprintf("%#v", this.OidcWellKnownConfigUrl) + `}`}, ", ")
	return s
}
func (this *OIDCAuthType_OidcAuthParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.OIDCAuthType_OidcAuthParams{` +
		`OidcAuthParams:` + fmt.Sprintf("%#v", this.OidcAuthParams) + `}`}, ", ")
	return s
}
func (this *HMACKeyPair) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authentication.HMACKeyPair{")
	if this.PrimKey != nil {
		s = append(s, "PrimKey: "+fmt.Sprintf("%#v", this.PrimKey)+",\n")
	}
	if this.PrimKeyExpiry != nil {
		s = append(s, "PrimKeyExpiry: "+fmt.Sprintf("%#v", this.PrimKeyExpiry)+",\n")
	}
	if this.SecKey != nil {
		s = append(s, "SecKey: "+fmt.Sprintf("%#v", this.SecKey)+",\n")
	}
	if this.SecKeyExpiry != nil {
		s = append(s, "SecKeyExpiry: "+fmt.Sprintf("%#v", this.SecKeyExpiry)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KMSKeyRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authentication.KMSKeyRefType{")
	if this.AuthHmacKms != nil {
		s = append(s, "AuthHmacKms: "+fmt.Sprintf("%#v", this.AuthHmacKms)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&authentication.CookieParams{")
	s = append(s, "CookieRefreshInterval: "+fmt.Sprintf("%#v", this.CookieRefreshInterval)+",\n")
	s = append(s, "CookieExpiry: "+fmt.Sprintf("%#v", this.CookieExpiry)+",\n")
	s = append(s, "SessionExpiry: "+fmt.Sprintf("%#v", this.SessionExpiry)+",\n")
	if this.SecretChoice != nil {
		s = append(s, "SecretChoice: "+fmt.Sprintf("%#v", this.SecretChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieParams_AuthHmac) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.CookieParams_AuthHmac{` +
		`AuthHmac:` + fmt.Sprintf("%#v", this.AuthHmac) + `}`}, ", ")
	return s
}
func (this *CookieParams_KmsKeyHmac) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.CookieParams_KmsKeyHmac{` +
		`KmsKeyHmac:` + fmt.Sprintf("%#v", this.KmsKeyHmac) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authentication.GlobalSpecType{")
	if this.AuthTypeChoice != nil {
		s = append(s, "AuthTypeChoice: "+fmt.Sprintf("%#v", this.AuthTypeChoice)+",\n")
	}
	if this.CookieParams != nil {
		s = append(s, "CookieParams: "+fmt.Sprintf("%#v", this.CookieParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_OidcAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.GlobalSpecType_OidcAuth{` +
		`OidcAuth:` + fmt.Sprintf("%#v", this.OidcAuth) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authentication.CreateSpecType{")
	if this.AuthTypeChoice != nil {
		s = append(s, "AuthTypeChoice: "+fmt.Sprintf("%#v", this.AuthTypeChoice)+",\n")
	}
	if this.CookieParams != nil {
		s = append(s, "CookieParams: "+fmt.Sprintf("%#v", this.CookieParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_OidcAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.CreateSpecType_OidcAuth{` +
		`OidcAuth:` + fmt.Sprintf("%#v", this.OidcAuth) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authentication.ReplaceSpecType{")
	if this.AuthTypeChoice != nil {
		s = append(s, "AuthTypeChoice: "+fmt.Sprintf("%#v", this.AuthTypeChoice)+",\n")
	}
	if this.CookieParams != nil {
		s = append(s, "CookieParams: "+fmt.Sprintf("%#v", this.CookieParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_OidcAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.ReplaceSpecType_OidcAuth{` +
		`OidcAuth:` + fmt.Sprintf("%#v", this.OidcAuth) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authentication.GetSpecType{")
	if this.AuthTypeChoice != nil {
		s = append(s, "AuthTypeChoice: "+fmt.Sprintf("%#v", this.AuthTypeChoice)+",\n")
	}
	if this.CookieParams != nil {
		s = append(s, "CookieParams: "+fmt.Sprintf("%#v", this.CookieParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_OidcAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.GetSpecType_OidcAuth{` +
		`OidcAuth:` + fmt.Sprintf("%#v", this.OidcAuth) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *OIDCAuthParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCAuthParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthEndpointUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthEndpointUrl)))
		i += copy(dAtA[i:], m.AuthEndpointUrl)
	}
	if len(m.TokenEndpointUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TokenEndpointUrl)))
		i += copy(dAtA[i:], m.TokenEndpointUrl)
	}
	if len(m.EndSessionEndpointUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndSessionEndpointUrl)))
		i += copy(dAtA[i:], m.EndSessionEndpointUrl)
	}
	return i, nil
}

func (m *OIDCAuthType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCAuthType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthParamsChoice != nil {
		nn1, err := m.AuthParamsChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if len(m.OidcClientId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OidcClientId)))
		i += copy(dAtA[i:], m.OidcClientId)
	}
	if m.ClientSecret != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientSecret.Size()))
		n2, err := m.ClientSecret.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *OIDCAuthType_OidcWellKnownConfigUrl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.OidcWellKnownConfigUrl)))
	i += copy(dAtA[i:], m.OidcWellKnownConfigUrl)
	return i, nil
}
func (m *OIDCAuthType_OidcAuthParams) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OidcAuthParams != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OidcAuthParams.Size()))
		n3, err := m.OidcAuthParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *HMACKeyPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HMACKeyPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PrimKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrimKey.Size()))
		n4, err := m.PrimKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.PrimKeyExpiry != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrimKeyExpiry.Size()))
		n5, err := m.PrimKeyExpiry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.SecKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SecKey.Size()))
		n6, err := m.SecKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.SecKeyExpiry != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SecKeyExpiry.Size()))
		n7, err := m.SecKeyExpiry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *KMSKeyRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KMSKeyRefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthHmacKms != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AuthHmacKms.Size()))
		n8, err := m.AuthHmacKms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *CookieParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CookieRefreshInterval != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieRefreshInterval))
	}
	if m.CookieExpiry != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieExpiry))
	}
	if m.SessionExpiry != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SessionExpiry))
	}
	if m.SecretChoice != nil {
		nn9, err := m.SecretChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	return i, nil
}

func (m *CookieParams_AuthHmac) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AuthHmac != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AuthHmac.Size()))
		n10, err := m.AuthHmac.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *CookieParams_KmsKeyHmac) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.KmsKeyHmac != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.KmsKeyHmac.Size()))
		n11, err := m.KmsKeyHmac.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		nn12, err := m.AuthTypeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	if m.CookieParams != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieParams.Size()))
		n13, err := m.CookieParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *GlobalSpecType_OidcAuth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OidcAuth != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OidcAuth.Size()))
		n14, err := m.OidcAuth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		nn15, err := m.AuthTypeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	if m.CookieParams != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieParams.Size()))
		n16, err := m.CookieParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *CreateSpecType_OidcAuth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OidcAuth != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OidcAuth.Size()))
		n17, err := m.OidcAuth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		nn18, err := m.AuthTypeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn18
	}
	if m.CookieParams != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieParams.Size()))
		n19, err := m.CookieParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *ReplaceSpecType_OidcAuth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OidcAuth != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OidcAuth.Size()))
		n20, err := m.OidcAuth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		nn21, err := m.AuthTypeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	if m.CookieParams != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieParams.Size()))
		n22, err := m.CookieParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *GetSpecType_OidcAuth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OidcAuth != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OidcAuth.Size()))
		n23, err := m.OidcAuth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedOIDCAuthParams(r randyTypes, easy bool) *OIDCAuthParams {
	this := &OIDCAuthParams{}
	this.AuthEndpointUrl = string(randStringTypes(r))
	this.TokenEndpointUrl = string(randStringTypes(r))
	this.EndSessionEndpointUrl = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOIDCAuthType(r randyTypes, easy bool) *OIDCAuthType {
	this := &OIDCAuthType{}
	oneofNumber_AuthParamsChoice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_AuthParamsChoice {
	case 2:
		this.AuthParamsChoice = NewPopulatedOIDCAuthType_OidcWellKnownConfigUrl(r, easy)
	case 3:
		this.AuthParamsChoice = NewPopulatedOIDCAuthType_OidcAuthParams(r, easy)
	}
	this.OidcClientId = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.ClientSecret = ves_io_schema4.NewPopulatedSecretType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOIDCAuthType_OidcWellKnownConfigUrl(r randyTypes, easy bool) *OIDCAuthType_OidcWellKnownConfigUrl {
	this := &OIDCAuthType_OidcWellKnownConfigUrl{}
	this.OidcWellKnownConfigUrl = string(randStringTypes(r))
	return this
}
func NewPopulatedOIDCAuthType_OidcAuthParams(r randyTypes, easy bool) *OIDCAuthType_OidcAuthParams {
	this := &OIDCAuthType_OidcAuthParams{}
	this.OidcAuthParams = NewPopulatedOIDCAuthParams(r, easy)
	return this
}
func NewPopulatedHMACKeyPair(r randyTypes, easy bool) *HMACKeyPair {
	this := &HMACKeyPair{}
	if r.Intn(10) != 0 {
		this.PrimKey = ves_io_schema4.NewPopulatedSecretType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.PrimKeyExpiry = google_protobuf1.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.SecKey = ves_io_schema4.NewPopulatedSecretType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.SecKeyExpiry = google_protobuf1.NewPopulatedTimestamp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedKMSKeyRefType(r randyTypes, easy bool) *KMSKeyRefType {
	this := &KMSKeyRefType{}
	if r.Intn(10) != 0 {
		this.AuthHmacKms = ves_io_schema_views.NewPopulatedObjectRefType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCookieParams(r randyTypes, easy bool) *CookieParams {
	this := &CookieParams{}
	this.CookieRefreshInterval = uint32(r.Uint32())
	this.CookieExpiry = uint32(r.Uint32())
	this.SessionExpiry = uint32(r.Uint32())
	oneofNumber_SecretChoice := []int32{5, 6}[r.Intn(2)]
	switch oneofNumber_SecretChoice {
	case 5:
		this.SecretChoice = NewPopulatedCookieParams_AuthHmac(r, easy)
	case 6:
		this.SecretChoice = NewPopulatedCookieParams_KmsKeyHmac(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCookieParams_AuthHmac(r randyTypes, easy bool) *CookieParams_AuthHmac {
	this := &CookieParams_AuthHmac{}
	this.AuthHmac = NewPopulatedHMACKeyPair(r, easy)
	return this
}
func NewPopulatedCookieParams_KmsKeyHmac(r randyTypes, easy bool) *CookieParams_KmsKeyHmac {
	this := &CookieParams_KmsKeyHmac{}
	this.KmsKeyHmac = NewPopulatedKMSKeyRefType(r, easy)
	return this
}
func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	oneofNumber_AuthTypeChoice := []int32{2}[r.Intn(1)]
	switch oneofNumber_AuthTypeChoice {
	case 2:
		this.AuthTypeChoice = NewPopulatedGlobalSpecType_OidcAuth(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CookieParams = NewPopulatedCookieParams(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType_OidcAuth(r randyTypes, easy bool) *GlobalSpecType_OidcAuth {
	this := &GlobalSpecType_OidcAuth{}
	this.OidcAuth = NewPopulatedOIDCAuthType(r, easy)
	return this
}
func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	oneofNumber_AuthTypeChoice := []int32{2}[r.Intn(1)]
	switch oneofNumber_AuthTypeChoice {
	case 2:
		this.AuthTypeChoice = NewPopulatedCreateSpecType_OidcAuth(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CookieParams = NewPopulatedCookieParams(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType_OidcAuth(r randyTypes, easy bool) *CreateSpecType_OidcAuth {
	this := &CreateSpecType_OidcAuth{}
	this.OidcAuth = NewPopulatedOIDCAuthType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	oneofNumber_AuthTypeChoice := []int32{2}[r.Intn(1)]
	switch oneofNumber_AuthTypeChoice {
	case 2:
		this.AuthTypeChoice = NewPopulatedReplaceSpecType_OidcAuth(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CookieParams = NewPopulatedCookieParams(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType_OidcAuth(r randyTypes, easy bool) *ReplaceSpecType_OidcAuth {
	this := &ReplaceSpecType_OidcAuth{}
	this.OidcAuth = NewPopulatedOIDCAuthType(r, easy)
	return this
}
func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	oneofNumber_AuthTypeChoice := []int32{2}[r.Intn(1)]
	switch oneofNumber_AuthTypeChoice {
	case 2:
		this.AuthTypeChoice = NewPopulatedGetSpecType_OidcAuth(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CookieParams = NewPopulatedCookieParams(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType_OidcAuth(r randyTypes, easy bool) *GetSpecType_OidcAuth {
	this := &GetSpecType_OidcAuth{}
	this.OidcAuth = NewPopulatedOIDCAuthType(r, easy)
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v1 := r.Intn(100)
	tmps := make([]rune, v1)
	for i := 0; i < v1; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v2 := r.Int63()
		if r.Intn(2) == 0 {
			v2 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v2))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *OIDCAuthParams) Size() (n int) {
	var l int
	_ = l
	l = len(m.AuthEndpointUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TokenEndpointUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EndSessionEndpointUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OIDCAuthType) Size() (n int) {
	var l int
	_ = l
	if m.AuthParamsChoice != nil {
		n += m.AuthParamsChoice.Size()
	}
	l = len(m.OidcClientId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientSecret != nil {
		l = m.ClientSecret.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OIDCAuthType_OidcWellKnownConfigUrl) Size() (n int) {
	var l int
	_ = l
	l = len(m.OidcWellKnownConfigUrl)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *OIDCAuthType_OidcAuthParams) Size() (n int) {
	var l int
	_ = l
	if m.OidcAuthParams != nil {
		l = m.OidcAuthParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HMACKeyPair) Size() (n int) {
	var l int
	_ = l
	if m.PrimKey != nil {
		l = m.PrimKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrimKeyExpiry != nil {
		l = m.PrimKeyExpiry.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SecKey != nil {
		l = m.SecKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SecKeyExpiry != nil {
		l = m.SecKeyExpiry.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *KMSKeyRefType) Size() (n int) {
	var l int
	_ = l
	if m.AuthHmacKms != nil {
		l = m.AuthHmacKms.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CookieParams) Size() (n int) {
	var l int
	_ = l
	if m.CookieRefreshInterval != 0 {
		n += 1 + sovTypes(uint64(m.CookieRefreshInterval))
	}
	if m.CookieExpiry != 0 {
		n += 1 + sovTypes(uint64(m.CookieExpiry))
	}
	if m.SessionExpiry != 0 {
		n += 1 + sovTypes(uint64(m.SessionExpiry))
	}
	if m.SecretChoice != nil {
		n += m.SecretChoice.Size()
	}
	return n
}

func (m *CookieParams_AuthHmac) Size() (n int) {
	var l int
	_ = l
	if m.AuthHmac != nil {
		l = m.AuthHmac.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieParams_KmsKeyHmac) Size() (n int) {
	var l int
	_ = l
	if m.KmsKeyHmac != nil {
		l = m.KmsKeyHmac.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		n += m.AuthTypeChoice.Size()
	}
	if m.CookieParams != nil {
		l = m.CookieParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_OidcAuth) Size() (n int) {
	var l int
	_ = l
	if m.OidcAuth != nil {
		l = m.OidcAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		n += m.AuthTypeChoice.Size()
	}
	if m.CookieParams != nil {
		l = m.CookieParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_OidcAuth) Size() (n int) {
	var l int
	_ = l
	if m.OidcAuth != nil {
		l = m.OidcAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		n += m.AuthTypeChoice.Size()
	}
	if m.CookieParams != nil {
		l = m.CookieParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_OidcAuth) Size() (n int) {
	var l int
	_ = l
	if m.OidcAuth != nil {
		l = m.OidcAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		n += m.AuthTypeChoice.Size()
	}
	if m.CookieParams != nil {
		l = m.CookieParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType_OidcAuth) Size() (n int) {
	var l int
	_ = l
	if m.OidcAuth != nil {
		l = m.OidcAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *OIDCAuthParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCAuthParams{`,
		`AuthEndpointUrl:` + fmt.Sprintf("%v", this.AuthEndpointUrl) + `,`,
		`TokenEndpointUrl:` + fmt.Sprintf("%v", this.TokenEndpointUrl) + `,`,
		`EndSessionEndpointUrl:` + fmt.Sprintf("%v", this.EndSessionEndpointUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCAuthType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCAuthType{`,
		`AuthParamsChoice:` + fmt.Sprintf("%v", this.AuthParamsChoice) + `,`,
		`OidcClientId:` + fmt.Sprintf("%v", this.OidcClientId) + `,`,
		`ClientSecret:` + strings.Replace(fmt.Sprintf("%v", this.ClientSecret), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCAuthType_OidcWellKnownConfigUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCAuthType_OidcWellKnownConfigUrl{`,
		`OidcWellKnownConfigUrl:` + fmt.Sprintf("%v", this.OidcWellKnownConfigUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCAuthType_OidcAuthParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCAuthType_OidcAuthParams{`,
		`OidcAuthParams:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuthParams), "OIDCAuthParams", "OIDCAuthParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HMACKeyPair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HMACKeyPair{`,
		`PrimKey:` + strings.Replace(fmt.Sprintf("%v", this.PrimKey), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`PrimKeyExpiry:` + strings.Replace(fmt.Sprintf("%v", this.PrimKeyExpiry), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`SecKey:` + strings.Replace(fmt.Sprintf("%v", this.SecKey), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`SecKeyExpiry:` + strings.Replace(fmt.Sprintf("%v", this.SecKeyExpiry), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KMSKeyRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KMSKeyRefType{`,
		`AuthHmacKms:` + strings.Replace(fmt.Sprintf("%v", this.AuthHmacKms), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieParams{`,
		`CookieRefreshInterval:` + fmt.Sprintf("%v", this.CookieRefreshInterval) + `,`,
		`CookieExpiry:` + fmt.Sprintf("%v", this.CookieExpiry) + `,`,
		`SessionExpiry:` + fmt.Sprintf("%v", this.SessionExpiry) + `,`,
		`SecretChoice:` + fmt.Sprintf("%v", this.SecretChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieParams_AuthHmac) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieParams_AuthHmac{`,
		`AuthHmac:` + strings.Replace(fmt.Sprintf("%v", this.AuthHmac), "HMACKeyPair", "HMACKeyPair", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieParams_KmsKeyHmac) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieParams_KmsKeyHmac{`,
		`KmsKeyHmac:` + strings.Replace(fmt.Sprintf("%v", this.KmsKeyHmac), "KMSKeyRefType", "KMSKeyRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`AuthTypeChoice:` + fmt.Sprintf("%v", this.AuthTypeChoice) + `,`,
		`CookieParams:` + strings.Replace(fmt.Sprintf("%v", this.CookieParams), "CookieParams", "CookieParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_OidcAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_OidcAuth{`,
		`OidcAuth:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuth), "OIDCAuthType", "OIDCAuthType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`AuthTypeChoice:` + fmt.Sprintf("%v", this.AuthTypeChoice) + `,`,
		`CookieParams:` + strings.Replace(fmt.Sprintf("%v", this.CookieParams), "CookieParams", "CookieParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_OidcAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_OidcAuth{`,
		`OidcAuth:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuth), "OIDCAuthType", "OIDCAuthType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`AuthTypeChoice:` + fmt.Sprintf("%v", this.AuthTypeChoice) + `,`,
		`CookieParams:` + strings.Replace(fmt.Sprintf("%v", this.CookieParams), "CookieParams", "CookieParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_OidcAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_OidcAuth{`,
		`OidcAuth:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuth), "OIDCAuthType", "OIDCAuthType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`AuthTypeChoice:` + fmt.Sprintf("%v", this.AuthTypeChoice) + `,`,
		`CookieParams:` + strings.Replace(fmt.Sprintf("%v", this.CookieParams), "CookieParams", "CookieParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_OidcAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_OidcAuth{`,
		`OidcAuth:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuth), "OIDCAuthType", "OIDCAuthType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *OIDCAuthParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCAuthParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCAuthParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthEndpointUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthEndpointUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenEndpointUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenEndpointUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndSessionEndpointUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndSessionEndpointUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCAuthType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCAuthType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCAuthType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcWellKnownConfigUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthParamsChoice = &OIDCAuthType_OidcWellKnownConfigUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuthParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParamsChoice = &OIDCAuthType_OidcAuthParams{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OidcClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientSecret == nil {
				m.ClientSecret = &ves_io_schema4.SecretType{}
			}
			if err := m.ClientSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HMACKeyPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HMACKeyPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HMACKeyPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimKey == nil {
				m.PrimKey = &ves_io_schema4.SecretType{}
			}
			if err := m.PrimKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimKeyExpiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimKeyExpiry == nil {
				m.PrimKeyExpiry = &google_protobuf1.Timestamp{}
			}
			if err := m.PrimKeyExpiry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecKey == nil {
				m.SecKey = &ves_io_schema4.SecretType{}
			}
			if err := m.SecKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecKeyExpiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecKeyExpiry == nil {
				m.SecKeyExpiry = &google_protobuf1.Timestamp{}
			}
			if err := m.SecKeyExpiry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KMSKeyRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KMSKeyRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KMSKeyRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthHmacKms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthHmacKms == nil {
				m.AuthHmacKms = &ves_io_schema_views.ObjectRefType{}
			}
			if err := m.AuthHmacKms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieRefreshInterval", wireType)
			}
			m.CookieRefreshInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieRefreshInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieExpiry", wireType)
			}
			m.CookieExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieExpiry |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionExpiry", wireType)
			}
			m.SessionExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionExpiry |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthHmac", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HMACKeyPair{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretChoice = &CookieParams_AuthHmac{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KmsKeyHmac", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KMSKeyRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretChoice = &CookieParams_KmsKeyHmac{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthTypeChoice = &GlobalSpecType_OidcAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CookieParams == nil {
				m.CookieParams = &CookieParams{}
			}
			if err := m.CookieParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthTypeChoice = &CreateSpecType_OidcAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CookieParams == nil {
				m.CookieParams = &CookieParams{}
			}
			if err := m.CookieParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthTypeChoice = &ReplaceSpecType_OidcAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CookieParams == nil {
				m.CookieParams = &CookieParams{}
			}
			if err := m.CookieParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthTypeChoice = &GetSpecType_OidcAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CookieParams == nil {
				m.CookieParams = &CookieParams{}
			}
			if err := m.CookieParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/authentication/types.proto", fileDescriptorTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/authentication/types.proto", fileDescriptorTypes)
}

var fileDescriptorTypes = []byte{
	// 1084 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x56, 0x4b, 0x6f, 0x1b, 0xd5,
	0x17, 0xf7, 0xf5, 0x23, 0x8f, 0xeb, 0x47, 0xdc, 0xf9, 0xff, 0x4b, 0x5c, 0x53, 0x4d, 0x53, 0x4b,
	0xa0, 0x50, 0x92, 0x71, 0x48, 0x4a, 0x84, 0x10, 0x14, 0x62, 0x53, 0xd5, 0xa9, 0x15, 0xb9, 0x9a,
	0x94, 0x87, 0xba, 0x19, 0x8d, 0xc7, 0x27, 0xf6, 0xe0, 0x99, 0xb9, 0xa3, 0x99, 0x6b, 0xa7, 0x5e,
	0x20, 0x45, 0xac, 0x41, 0xea, 0x82, 0x2f, 0x80, 0xd8, 0x20, 0x3e, 0x01, 0xc2, 0x9b, 0x88, 0x15,
	0x62, 0x95, 0x65, 0xd5, 0x15, 0x99, 0x6e, 0x8a, 0x84, 0x44, 0x36, 0x48, 0x11, 0x12, 0x12, 0x9a,
	0x3b, 0x77, 0xc2, 0x8c, 0x53, 0x25, 0x61, 0x89, 0xba, 0xbb, 0xf7, 0x9e, 0xf3, 0xfb, 0x9d, 0xf7,
	0x99, 0xc1, 0x8b, 0x43, 0x70, 0x25, 0x9d, 0x54, 0x5d, 0xad, 0x07, 0xa6, 0x5a, 0x55, 0x07, 0xb4,
	0x07, 0x16, 0xd5, 0x35, 0x95, 0xea, 0xc4, 0xaa, 0xd2, 0x91, 0x0d, 0xae, 0x64, 0x3b, 0x84, 0x12,
	0xe1, 0x6a, 0xa0, 0x29, 0x05, 0x9a, 0x52, 0x5c, 0xb3, 0xbc, 0xdc, 0xd5, 0x69, 0x6f, 0xd0, 0x96,
	0x34, 0x62, 0x56, 0xbb, 0xa4, 0x4b, 0xaa, 0x0c, 0xd4, 0x1e, 0xec, 0xb0, 0x1b, 0xbb, 0xb0, 0x53,
	0x40, 0x56, 0xbe, 0xd6, 0x25, 0xa4, 0x6b, 0xc0, 0x3f, 0x5a, 0x54, 0x37, 0xc1, 0xa5, 0xaa, 0x69,
	0x73, 0x85, 0xf9, 0xb8, 0x5f, 0x16, 0x50, 0x2e, 0x78, 0x39, 0x2e, 0x20, 0xb6, 0x6f, 0x9e, 0xfb,
	0x58, 0xbe, 0x12, 0x17, 0x46, 0xdc, 0x2f, 0x5f, 0x8d, 0x8b, 0x86, 0xaa, 0xa1, 0x77, 0x54, 0x0a,
	0x5c, 0xba, 0x30, 0x21, 0xd5, 0x61, 0x57, 0x89, 0x53, 0x5f, 0x3b, 0xad, 0xe1, 0x46, 0x0d, 0x54,
	0xbe, 0x48, 0xe2, 0x42, 0x6b, 0xf3, 0x83, 0xfa, 0xc6, 0x80, 0xf6, 0xee, 0xa9, 0x8e, 0x6a, 0xba,
	0xc2, 0x16, 0xbe, 0xe4, 0xa7, 0x49, 0x01, 0xab, 0x63, 0x13, 0xdd, 0xa2, 0xca, 0xc0, 0x31, 0x4a,
	0x68, 0x01, 0x2d, 0xce, 0xd6, 0xae, 0x1f, 0x8f, 0x51, 0xf2, 0x87, 0x5f, 0xf7, 0x53, 0x19, 0x27,
	0x55, 0xda, 0x43, 0xfe, 0x29, 0xed, 0x24, 0x8b, 0x88, 0x3f, 0x3d, 0x42, 0x48, 0x9e, 0xf3, 0xb1,
	0xb7, 0x39, 0xf4, 0x43, 0xc7, 0x10, 0x5a, 0x58, 0xa0, 0xa4, 0x0f, 0x56, 0x9c, 0x2f, 0x79, 0x51,
	0xbe, 0x22, 0x03, 0x47, 0x09, 0x1f, 0xe0, 0x12, 0x58, 0x1d, 0xc5, 0x05, 0xd7, 0xd5, 0xc9, 0x04,
	0x6d, 0xea, 0xa2, 0xb4, 0x97, 0xc1, 0xea, 0x6c, 0x07, 0x0c, 0x11, 0xee, 0xca, 0x1f, 0x49, 0x9c,
	0x0b, 0xd3, 0x71, 0x7f, 0x64, 0x83, 0xa0, 0xe0, 0x32, 0xd1, 0x3b, 0x9a, 0xb2, 0x0b, 0x86, 0xa1,
	0xf4, 0x2d, 0xb2, 0x6b, 0x29, 0x1a, 0xb1, 0x76, 0xf4, 0xee, 0xbf, 0x8a, 0xa2, 0x91, 0x90, 0x5f,
	0xf2, 0x69, 0x3e, 0x06, 0xc3, 0x68, 0xfa, 0x24, 0x75, 0xc6, 0xe1, 0x47, 0xf3, 0x09, 0x2e, 0x32,
	0x03, 0x2c, 0xe5, 0x36, 0xab, 0x00, 0x8b, 0x22, 0xbb, 0xba, 0x24, 0x9d, 0xd5, 0xbb, 0x52, 0xbc,
	0x6a, 0x8d, 0x84, 0x5c, 0xf0, 0x79, 0x22, 0x75, 0x7c, 0x17, 0xb3, 0x17, 0x45, 0x33, 0x74, 0xb0,
	0xa8, 0xa2, 0x77, 0x4a, 0x69, 0xe6, 0xee, 0x7c, 0xcc, 0xdd, 0xe4, 0x89, 0xbb, 0x72, 0xce, 0x57,
	0xaf, 0x33, 0xed, 0xcd, 0x8e, 0x70, 0x0b, 0xe7, 0x39, 0xd2, 0x05, 0xcd, 0x01, 0x5a, 0xca, 0x30,
	0xaf, 0xae, 0x4c, 0x78, 0xb5, 0xcd, 0x84, 0x7e, 0xae, 0xe4, 0x5c, 0xa0, 0x1f, 0xbc, 0xd4, 0x5e,
	0xc1, 0x42, 0x24, 0x26, 0x45, 0xeb, 0x11, 0x5d, 0x03, 0x61, 0x6e, 0x7f, 0x8c, 0x92, 0x07, 0x63,
	0x84, 0xbc, 0x31, 0x4a, 0xad, 0x2e, 0xad, 0xdd, 0x4d, 0xcf, 0xa0, 0x62, 0xb2, 0xf2, 0x17, 0xc2,
	0xd9, 0xc6, 0xd6, 0x46, 0xbd, 0x09, 0xa3, 0x7b, 0xaa, 0xee, 0x08, 0x37, 0xf1, 0x8c, 0xed, 0xe8,
	0xa6, 0xd2, 0x87, 0x11, 0x6b, 0xbd, 0x33, 0xed, 0x4e, 0xfb, 0xaa, 0x4d, 0x18, 0x09, 0x35, 0x3c,
	0x17, 0xa2, 0x14, 0x78, 0x68, 0xeb, 0xce, 0x88, 0x55, 0x28, 0xbb, 0x5a, 0x96, 0x82, 0xc9, 0x95,
	0xc2, 0xc9, 0x95, 0xee, 0x87, 0x93, 0x2b, 0xe7, 0x39, 0xfa, 0x36, 0x03, 0x08, 0xab, 0x78, 0xda,
	0x05, 0x8d, 0x19, 0x4e, 0x9d, 0x67, 0x78, 0xca, 0x05, 0xcd, 0xb7, 0xfb, 0x3e, 0x2e, 0x70, 0x4c,
	0x68, 0x36, 0x7d, 0xae, 0xd9, 0x5c, 0x80, 0x0d, 0xac, 0x56, 0xba, 0x38, 0xdf, 0xdc, 0xda, 0x6e,
	0xc2, 0x48, 0x86, 0x1d, 0xd6, 0x77, 0x1f, 0xe1, 0x3c, 0xcb, 0x5e, 0xcf, 0x54, 0x35, 0xa5, 0x6f,
	0xba, 0x3c, 0x0b, 0x95, 0x09, 0x67, 0xd8, 0x40, 0x4b, 0xad, 0xf6, 0xa7, 0xa0, 0x51, 0x0e, 0xad,
	0x15, 0xbe, 0xfb, 0x6c, 0xba, 0x6f, 0xba, 0xbe, 0x3b, 0xcf, 0xc6, 0x08, 0xc9, 0x59, 0x9f, 0xa8,
	0x61, 0xaa, 0x5a, 0xd3, 0x74, 0x2b, 0x5f, 0xa7, 0x70, 0xae, 0x4e, 0x48, 0x5f, 0x07, 0xde, 0x25,
	0x2d, 0x3c, 0xaf, 0xb1, 0xbb, 0xe2, 0xc0, 0x8e, 0x03, 0x6e, 0x4f, 0xd1, 0x2d, 0x0a, 0xce, 0x50,
	0x0d, 0x66, 0x3e, 0x5f, 0x9b, 0x7f, 0x32, 0x46, 0xe9, 0xb5, 0x95, 0x95, 0x95, 0xe3, 0x31, 0x4a,
	0xf8, 0xcd, 0x32, 0x75, 0x23, 0x5d, 0xda, 0xfb, 0x26, 0x23, 0x5f, 0x0e, 0x70, 0x72, 0x00, 0xdb,
	0xe4, 0x28, 0xe1, 0x1d, 0x9c, 0xe7, 0x84, 0x91, 0x12, 0x84, 0x34, 0xeb, 0xa7, 0x69, 0x72, 0x81,
	0x36, 0x4f, 0xff, 0x7b, 0x7e, 0x2a, 0xf9, 0x60, 0x07, 0xf0, 0x14, 0x83, 0x97, 0x9e, 0x8c, 0x51,
	0xe6, 0xad, 0xf5, 0x9b, 0x13, 0xf8, 0x2f, 0x5b, 0x72, 0x9e, 0xeb, 0x73, 0x82, 0x06, 0x9e, 0x3d,
	0x49, 0x1c, 0x6f, 0xd9, 0xd7, 0xce, 0x1e, 0xa4, 0x48, 0xdf, 0x35, 0x12, 0xf2, 0x4c, 0x98, 0x2d,
	0xa1, 0x85, 0x73, 0x3c, 0x8d, 0x01, 0xd9, 0x14, 0x23, 0x7b, 0xfd, 0x6c, 0xb2, 0x58, 0x15, 0x1b,
	0x09, 0x19, 0xf7, 0x4d, 0xb7, 0x09, 0x23, 0x9f, 0xb0, 0xb6, 0x80, 0xf3, 0xc1, 0x28, 0x45, 0x87,
	0x21, 0x73, 0x30, 0x46, 0x69, 0x7f, 0x18, 0xde, 0x5c, 0x5a, 0xbf, 0x9b, 0x9e, 0x49, 0x17, 0x33,
	0xfe, 0x30, 0x14, 0xee, 0x18, 0xa4, 0xad, 0x1a, 0xdb, 0x36, 0x68, 0xac, 0x1d, 0x36, 0xf1, 0xec,
	0xc9, 0x96, 0xe0, 0x3d, 0x7d, 0xe3, 0x62, 0xeb, 0x81, 0xfb, 0x31, 0x13, 0x2e, 0x07, 0xa1, 0x75,
	0x52, 0x9f, 0xd8, 0xb6, 0x39, 0x87, 0x2e, 0xda, 0x33, 0x61, 0xc9, 0x82, 0xdb, 0xdb, 0xaf, 0xfe,
	0x38, 0x46, 0x15, 0xfc, 0x3f, 0x5c, 0xd8, 0x88, 0x41, 0x04, 0xf4, 0x06, 0xce, 0xe2, 0xa9, 0x00,
	0x28, 0xa0, 0xb5, 0xda, 0x75, 0x5c, 0x64, 0x95, 0xf1, 0x3f, 0x3f, 0x61, 0x06, 0xf2, 0x91, 0x75,
	0x80, 0x56, 0xf9, 0x32, 0xf8, 0x1d, 0xe1, 0x42, 0xdd, 0x01, 0x95, 0xc2, 0x7f, 0x22, 0xfe, 0x4b,
	0x3f, 0xdf, 0x9a, 0x28, 0x57, 0x6d, 0xf1, 0x39, 0xa1, 0xfe, 0xff, 0xf3, 0x3f, 0xd1, 0xa9, 0x57,
	0x1e, 0xf1, 0x11, 0xc2, 0x73, 0x32, 0xd8, 0x86, 0xaa, 0xbd, 0x30, 0x21, 0xff, 0x86, 0x70, 0xf6,
	0x0e, 0xd0, 0x17, 0x24, 0xdc, 0xda, 0x57, 0xe8, 0xe0, 0x50, 0x4c, 0x3c, 0x3e, 0x14, 0x13, 0x47,
	0x87, 0x22, 0x3a, 0x3e, 0x14, 0xd1, 0x9e, 0x27, 0xa2, 0x6f, 0x3d, 0x11, 0x7d, 0xef, 0x89, 0x68,
	0xdf, 0x13, 0xd1, 0x4f, 0x9e, 0x88, 0x0e, 0x3c, 0x11, 0x3d, 0xf6, 0x44, 0xf4, 0x8b, 0x27, 0xa2,
	0x67, 0x9e, 0x98, 0x38, 0xf2, 0x44, 0xf4, 0xe8, 0xa9, 0x98, 0xd8, 0x7f, 0x2a, 0xa2, 0x07, 0x72,
	0x97, 0xd8, 0xfd, 0xae, 0x34, 0x24, 0x06, 0x05, 0xc7, 0x51, 0xa5, 0x81, 0x5b, 0x65, 0x87, 0x1d,
	0xe2, 0x98, 0xcb, 0xb6, 0x43, 0x86, 0x7a, 0x07, 0x9c, 0xe5, 0x50, 0x5c, 0xb5, 0xdb, 0x5d, 0x52,
	0x85, 0x87, 0x94, 0xff, 0xfa, 0x3d, 0xf7, 0x57, 0xb9, 0x3d, 0xc5, 0xbe, 0x4c, 0x6b, 0x7f, 0x07,
	0x00, 0x00, 0xff, 0xff, 0x6e, 0x2b, 0x8d, 0x0b, 0x51, 0x0b, 0x00, 0x00,
}

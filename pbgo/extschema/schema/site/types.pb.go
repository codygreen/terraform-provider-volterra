// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/site/types.proto

package site

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	google_protobuf1 "github.com/gogo/protobuf/types"

	ves_io_schema3 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema5 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	sortkeys "github.com/gogo/protobuf/sortkeys"

	binary "encoding/binary"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// SiteType
//
// x-displayName: "Site Type"
// Site Type which can either RE or CE
type SiteType int32

const (
	// x-displayName: "Invalid"
	// Invalid type of site
	INVALID SiteType = 0
	// x-displayName: "RE"
	// Regional Edge site
	REGIONAL_EDGE SiteType = 1
	// x-displayName: "CE"
	// Customer Edge site
	CUSTOMER_EDGE SiteType = 2
)

var SiteType_name = map[int32]string{
	0: "INVALID",
	1: "REGIONAL_EDGE",
	2: "CUSTOMER_EDGE",
}
var SiteType_value = map[string]int32{
	"INVALID":       0,
	"REGIONAL_EDGE": 1,
	"CUSTOMER_EDGE": 2,
}

func (SiteType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// SiteSubtype
//
// x-displayName: "Site Subtype"
// Sit Subtype
type SiteSubtype int32

const (
	// x-displayName: "No Subtype"
	// No Subtype
	NO_SUBTYPE SiteSubtype = 0
	// x-displayName: "ves-io USE Regional Edge"
	// Regional Edge for ves-io use only
	VES_IO_USE_RE SiteSubtype = 1
	// x-displayName: "CE running in Kubernetes"
	// CE running in Kubernetes
	VES_IO_CE_IN_K8S SiteSubtype = 2
)

var SiteSubtype_name = map[int32]string{
	0: "NO_SUBTYPE",
	1: "VES_IO_USE_RE",
	2: "VES_IO_CE_IN_K8S",
}
var SiteSubtype_value = map[string]int32{
	"NO_SUBTYPE":       0,
	"VES_IO_USE_RE":    1,
	"VES_IO_CE_IN_K8S": 2,
}

func (SiteSubtype) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// CeSiteMode
//
// x-displayName: "Customer Edge Site Mode"
// If Site is CE, it can be in followig modes
type CeSiteMode int32

const (
	// x-displayName: "Ingress and Egress Gateway"
	// Ingress Egress Gateway CE
	CE_SITE_MODE_INGRESS_EGRESS_GW CeSiteMode = 0
	// x-displayName: "Ingress Gateway"
	// Ingress Gateway CE
	CE_SITE_MODE_INGRESS_GW CeSiteMode = 1
	// x-displayName: "Egress Gateway"
	// Egress Gateway CE
	CE_SITE_MODE_EGRESS_GW CeSiteMode = 2
	// x-displayName: "DC Cloud Gateway"
	// DC Cloud Gateway CE
	CE_SITE_MODE_DC_CLOUD_GW CeSiteMode = 3
	// x-displayName: "CPE"
	// CPE CE
	CE_SITE_MODE_CPE CeSiteMode = 4
)

var CeSiteMode_name = map[int32]string{
	0: "CE_SITE_MODE_INGRESS_EGRESS_GW",
	1: "CE_SITE_MODE_INGRESS_GW",
	2: "CE_SITE_MODE_EGRESS_GW",
	3: "CE_SITE_MODE_DC_CLOUD_GW",
	4: "CE_SITE_MODE_CPE",
}
var CeSiteMode_value = map[string]int32{
	"CE_SITE_MODE_INGRESS_EGRESS_GW": 0,
	"CE_SITE_MODE_INGRESS_GW":        1,
	"CE_SITE_MODE_EGRESS_GW":         2,
	"CE_SITE_MODE_DC_CLOUD_GW":       3,
	"CE_SITE_MODE_CPE":               4,
}

func (CeSiteMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// IPSec State
//
// x-displayName: "IPSec State"
// IPSec Tunnel state connecting the site to other site
type IPSecState int32

const (
	// x-displayName: "Unknown"
	// Invalid state
	UNKNOWN_STATE IPSecState = 0
	// x-displayName: "Up"
	// Connection is up
	UP IPSecState = 1
	// x-displayName: "Down"
	// Connection is down
	DOWN IPSecState = 2
)

var IPSecState_name = map[int32]string{
	0: "UNKNOWN_STATE",
	1: "UP",
	2: "DOWN",
}
var IPSecState_value = map[string]int32{
	"UNKNOWN_STATE": 0,
	"UP":            1,
	"DOWN":          2,
}

func (IPSecState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// IPSecRole
//
// x-displayName: "IPSec Role"
// Role of VER in an IPSec connection
type IPSecRole int32

const (
	// x-displayName: "Unknown"
	// Invalid role
	UNKNOWN_ROLE IPSecRole = 0
	// x-displayName: "Initiator"
	// IPSec Client initiating the connection
	INITIATOR IPSecRole = 1
	// x-displayName: "Responder"
	// IPSec Server responding to the connection
	RESPONDER IPSecRole = 2
)

var IPSecRole_name = map[int32]string{
	0: "UNKNOWN_ROLE",
	1: "INITIATOR",
	2: "RESPONDER",
}
var IPSecRole_value = map[string]int32{
	"UNKNOWN_ROLE": 0,
	"INITIATOR":    1,
	"RESPONDER":    2,
}

func (IPSecRole) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

// Tunnel State
//
// x-displayName: "Tunnel State"
// Tunnel state connecting the site to remote
type TunnelState int32

const (
	// x-displayName: "Unknown Tunnel State"
	// Invalid Tunnel state
	UNKNOWN_TUNNEL_STATE TunnelState = 0
	// x-displayName: "Tunnel Up"
	// Tunnel Connection is up
	TUNNEL_UP TunnelState = 1
	// x-displayName: "Tunnel Down"
	// Tunnel Connection is down
	TUNNEL_DOWN TunnelState = 2
	// x-displayName: "Tunnel Disabled"
	// Tunnel is disabled
	TUNNEL_DISABLED TunnelState = 3
)

var TunnelState_name = map[int32]string{
	0: "UNKNOWN_TUNNEL_STATE",
	1: "TUNNEL_UP",
	2: "TUNNEL_DOWN",
	3: "TUNNEL_DISABLED",
}
var TunnelState_value = map[string]int32{
	"UNKNOWN_TUNNEL_STATE": 0,
	"TUNNEL_UP":            1,
	"TUNNEL_DOWN":          2,
	"TUNNEL_DISABLED":      3,
}

func (TunnelState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

// TunnelRole
//
// x-displayName: "Tunnel Role"
// Role of VER in a tunnel connection
type TunnelRole int32

const (
	// x-displayName: "Unknowni Tunnel Role"
	// Invalid role
	UNKNOWN_TUNNEL_ROLE TunnelRole = 0
	// x-displayName: "Tunnel Initiator"
	// Client initiating the connection
	TUNNEL_INITIATOR TunnelRole = 1
	// x-displayName: "Tunnel Responder"
	// Server responding to the connection
	TUNNEL_RESPONDER TunnelRole = 2
)

var TunnelRole_name = map[int32]string{
	0: "UNKNOWN_TUNNEL_ROLE",
	1: "TUNNEL_INITIATOR",
	2: "TUNNEL_RESPONDER",
}
var TunnelRole_value = map[string]int32{
	"UNKNOWN_TUNNEL_ROLE": 0,
	"TUNNEL_INITIATOR":    1,
	"TUNNEL_RESPONDER":    2,
}

func (TunnelRole) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

// VTRPState
//
// x-displayName: "VTRP State"
// State of VTRP connection between (VER control plane)Vega & (Volterra Fabric control)Ares
type VTRPState int32

const (
	// x-displayName: "Init"
	// Connection is initialized
	INIT VTRPState = 0
	// x-displayName: "Active"
	// VTRP connection is active
	ACTIVE VTRPState = 1
	// x-displayName: "Connecting"
	// Connecting to the server
	CONNECTING VTRPState = 2
	// x-displayName: "Connected"
	// TCP connection is up
	CONNECTED VTRPState = 3
	// x-displayName: "Established"
	// VTRP session established
	ESTABLISHED VTRPState = 4
	// x-displayName: "Deleted"
	// Connection is deleted
	DELETE VTRPState = 5
)

var VTRPState_name = map[int32]string{
	0: "INIT",
	1: "ACTIVE",
	2: "CONNECTING",
	3: "CONNECTED",
	4: "ESTABLISHED",
	5: "DELETE",
}
var VTRPState_value = map[string]int32{
	"INIT":        0,
	"ACTIVE":      1,
	"CONNECTING":  2,
	"CONNECTED":   3,
	"ESTABLISHED": 4,
	"DELETE":      5,
}

func (VTRPState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

// Active State
//
// x-displayName: "Active State"
// Active/Backup state for the interface
type ActiveState int32

const (
	// x-displayName: "Unknown State"
	// Unknown state
	STATE_UNKNOWN ActiveState = 0
	// x-displayName: "Active"
	// Interface in active state
	STATE_ACTIVE ActiveState = 1
	// x-displayName: "Backup"
	// Interface in backup state
	STATE_BACKUP ActiveState = 2
)

var ActiveState_name = map[int32]string{
	0: "STATE_UNKNOWN",
	1: "STATE_ACTIVE",
	2: "STATE_BACKUP",
}
var ActiveState_value = map[string]int32{
	"STATE_UNKNOWN": 0,
	"STATE_ACTIVE":  1,
	"STATE_BACKUP":  2,
}

func (ActiveState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

// Link quality
//
// x-displayName: "Link quality"
// Link quality determined by VER using different probes
type LinkQuality int32

const (
	// x-displayName: "Quality unknown"
	// Unknown quality
	QUALITY_UNKNOWN LinkQuality = 0
	// x-displayName: "Good"
	// Link quality is good
	QUALITY_GOOD LinkQuality = 1
	// x-displayName: "Poor"
	// Link quality is poor
	QUALITY_POOR LinkQuality = 2
	// Quality disabled
	QUALITY_DISABLED LinkQuality = 3
)

var LinkQuality_name = map[int32]string{
	0: "QUALITY_UNKNOWN",
	1: "QUALITY_GOOD",
	2: "QUALITY_POOR",
	3: "QUALITY_DISABLED",
}
var LinkQuality_value = map[string]int32{
	"QUALITY_UNKNOWN":  0,
	"QUALITY_GOOD":     1,
	"QUALITY_POOR":     2,
	"QUALITY_DISABLED": 3,
}

func (LinkQuality) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

// Link type
//
// x-displayName: "Link type"
// Link type of interface determined operationally
type LinkType int32

const (
	// x-displayName: "Unknown link type"
	// Link type unknown
	LINK_TYPE_UNKNOWN LinkType = 0
	// x-displayName: "Ethernet"
	// Link type ethernet
	LINK_TYPE_ETHERNET LinkType = 1
	// x-displayName: "802.11ac"
	// WiFi link of type 802.11ac
	LINK_TYPE_WIFI_802_11AC LinkType = 2
	// x-displayName: "802.11bgn"
	// WiFi link of type 802.11bgn
	LINK_TYPE_WIFI_802_11BGN LinkType = 3
	// x-displayName: "4G"
	// Link type 4G
	LINK_TYPE_4G LinkType = 4
)

var LinkType_name = map[int32]string{
	0: "LINK_TYPE_UNKNOWN",
	1: "LINK_TYPE_ETHERNET",
	2: "LINK_TYPE_WIFI_802_11AC",
	3: "LINK_TYPE_WIFI_802_11BGN",
	4: "LINK_TYPE_4G",
}
var LinkType_value = map[string]int32{
	"LINK_TYPE_UNKNOWN":        0,
	"LINK_TYPE_ETHERNET":       1,
	"LINK_TYPE_WIFI_802_11AC":  2,
	"LINK_TYPE_WIFI_802_11BGN": 3,
	"LINK_TYPE_4G":             4,
}

func (LinkType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

// Interface Address Mode
//
// x-displayName: "AddressMode"
// AddressMode identifies the mode of address assignment on an interface
type AddressMode int32

const (
	// Static
	//
	// x-displayName: "Static"
	// Interface Address is assigned statically
	STATIC AddressMode = 0
	// DHCP
	//
	// x-displayName: "DHCP"
	// Interface Address is obtained via DHCP
	DHCP AddressMode = 1
)

var AddressMode_name = map[int32]string{
	0: "STATIC",
	1: "DHCP",
}
var AddressMode_value = map[string]int32{
	"STATIC": 0,
	"DHCP":   1,
}

func (AddressMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

// SiteSoftwareOverrideType
//
// x-displayName: "Site Software Override Type"
// Decide which software version takes effect in case of conflict between site and fleet
type SiteSoftwareOverrideType int32

const (
	// x-displayName: "Site Version Overrides"
	// Software version in site will take precedence.
	SITE_SOFTWARE_OVERRIDE_SITE SiteSoftwareOverrideType = 0
	// x-displayName: "New Version Overrides"
	// Between site and fleet newer software version will take precedence.
	SITE_SOFTWARE_OVERRIDE_NEWER SiteSoftwareOverrideType = 1
	// x-displayName: "Fleet  Version Overrides"
	// Software version in fleet will take precedence.
	SITE_SOFTWARE_OVERRIDE_FLEET SiteSoftwareOverrideType = 2
)

var SiteSoftwareOverrideType_name = map[int32]string{
	0: "SITE_SOFTWARE_OVERRIDE_SITE",
	1: "SITE_SOFTWARE_OVERRIDE_NEWER",
	2: "SITE_SOFTWARE_OVERRIDE_FLEET",
}
var SiteSoftwareOverrideType_value = map[string]int32{
	"SITE_SOFTWARE_OVERRIDE_SITE":  0,
	"SITE_SOFTWARE_OVERRIDE_NEWER": 1,
	"SITE_SOFTWARE_OVERRIDE_FLEET": 2,
}

func (SiteSoftwareOverrideType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{12}
}

// SoftwareUpgradePhase
//
// x-displayName: "Software Upgrade Phase"
// State of Volterra Software or Operating System upgrade phase in site
type SoftwareUpgradePhase int32

const (
	// x-displayName: "Invalid"
	UPGRADE_INVALID SoftwareUpgradePhase = 0
	// x-displayName: "Scheduled"
	// Site Upgrade was triggered, but has not started yet
	UPGRADE_TRIGGERED SoftwareUpgradePhase = 1
	// x-displayName: "In Progress"
	// Site upgrade was fetched and it is in progress
	UPGRADE_IN_PROGRESS SoftwareUpgradePhase = 2
	// x-displayName: "Completed"
	// Site upgrade was completed
	UPGRADE_COMPLETED SoftwareUpgradePhase = 3
	// x-displayName: "Failed"
	// Site upgrade failed
	UPGRADE_FAILED SoftwareUpgradePhase = 4
)

var SoftwareUpgradePhase_name = map[int32]string{
	0: "UPGRADE_INVALID",
	1: "UPGRADE_TRIGGERED",
	2: "UPGRADE_IN_PROGRESS",
	3: "UPGRADE_COMPLETED",
	4: "UPGRADE_FAILED",
}
var SoftwareUpgradePhase_value = map[string]int32{
	"UPGRADE_INVALID":     0,
	"UPGRADE_TRIGGERED":   1,
	"UPGRADE_IN_PROGRESS": 2,
	"UPGRADE_COMPLETED":   3,
	"UPGRADE_FAILED":      4,
}

func (SoftwareUpgradePhase) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

// ScalingPhase
//
// x-displayName: "Scaling Phase"
// State of Scaling phase in site
type ScalingPhase int32

const (
	// x-displayName: "Invalid"
	// Invalid scaling phase
	SCALING_INVALID ScalingPhase = 0
	// x-displayName: "In Progress"
	// Site scaling is in progress
	SCALING_IN_PROGRESS ScalingPhase = 1
	// x-displayName: "Failed"
	// Site scaling failed
	SCALING_FAILED ScalingPhase = 2
	// x-displayName: "Done"
	// Site scaling is done. Site is in desired number of nodes
	SCALING_DONE ScalingPhase = 3
)

var ScalingPhase_name = map[int32]string{
	0: "SCALING_INVALID",
	1: "SCALING_IN_PROGRESS",
	2: "SCALING_FAILED",
	3: "SCALING_DONE",
}
var ScalingPhase_value = map[string]int32{
	"SCALING_INVALID":     0,
	"SCALING_IN_PROGRESS": 1,
	"SCALING_FAILED":      2,
	"SCALING_DONE":        3,
}

func (ScalingPhase) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

// SiteState
//
// x-displayName: "Site State"
// State of Site defines in which operational state site itself is.
type SiteState int32

const (
	// x-displayName: "Online"
	// Site is online and operational.
	ONLINE SiteState = 0
	// x-displayName: "Provisioning"
	// Site is in provisioning state. For instance during site deployment or switching to different connected Regional Edge.
	PROVISIONING SiteState = 1
	// x-displayName: "Upgrading"
	// Site is in process of upgrade. It transition to ONLINE or FAILED state.
	UPGRADING SiteState = 2
	// x-displayName: "Standby"
	// Site is in Standby before goes to ONLINE. This is mainly for Regional Edge sites to do their verification before they go to ONLINE state.
	STANDBY SiteState = 3
	// x-displayName: "Failed"
	// Site is in failed state. It failed during provisioning or upgrade phase. Site Status Objects contain more details.
	FAILED SiteState = 4
	// x-displayName: "Reregistraiton"
	// Reregistration was requested
	REREGISTRATION SiteState = 5
	// x-displayName: "Waiting for nodes"
	// Reregistration is in progress and maurice is waiting for nodes
	WAITINGNODES SiteState = 6
	// x-displayName: "Decommissioning"
	// Site deletion is in progress
	DECOMMISSIONING SiteState = 7
	// x-displayName: "Waiting for Registation"
	// Site is waiting for registration
	WAITING_FOR_REGISTRATION SiteState = 8
)

var SiteState_name = map[int32]string{
	0: "ONLINE",
	1: "PROVISIONING",
	2: "UPGRADING",
	3: "STANDBY",
	4: "FAILED",
	5: "REREGISTRATION",
	6: "WAITINGNODES",
	7: "DECOMMISSIONING",
	8: "WAITING_FOR_REGISTRATION",
}
var SiteState_value = map[string]int32{
	"ONLINE":                   0,
	"PROVISIONING":             1,
	"UPGRADING":                2,
	"STANDBY":                  3,
	"FAILED":                   4,
	"REREGISTRATION":           5,
	"WAITINGNODES":             6,
	"DECOMMISSIONING":          7,
	"WAITING_FOR_REGISTRATION": 8,
}

func (SiteState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

// SiteStatusMetricsField
//
// x-displayName: "Site Status Metrics Field"
// Lists the fields that can queried in the site status metrics request
type SiteStatusMetricsField int32

const (
	// x-displayName: "Active Flow Count"
	SITE_ACTIVE_FLOW_COUNT SiteStatusMetricsField = 0
	// x-displayName: "Flow Setup Rate"
	SITE_FLOW_SETUP_RATE SiteStatusMetricsField = 1
	// x-displayName: "In Throughput"
	SITE_IN_THROUGHPUT SiteStatusMetricsField = 2
	// x-displayName: "Out Throughput"
	SITE_OUT_THROUGHPUT SiteStatusMetricsField = 3
	// x-displayName: "System Active Pod Count"
	SITE_SYSTEM_ACTIVE_POD_COUNT SiteStatusMetricsField = 4
	// x-displayName: "vK8s Active Pod Count"
	SITE_VK8S_ACTIVE_POD_COUNT SiteStatusMetricsField = 5
	// x-displayName: "Traffic from RE"
	SITE_RE_IN_THROUGHPUT SiteStatusMetricsField = 6
	// x-displayName: "Traffic to RE"
	SITE_RE_OUT_THROUGHPUT SiteStatusMetricsField = 7
	// x-displayName: "Traffic from other CE site"
	SITE_SITE_IN_THROUGHPUT SiteStatusMetricsField = 8
	// x-displayName: "Traffic to other CE site"
	SITE_SITE_OUT_THROUGHPUT SiteStatusMetricsField = 9
	// x-displayName: "Node CPU Usage"
	SITE_NODE_CPU_USAGE SiteStatusMetricsField = 10
	// x-displayName: "Node Memory Usage"
	SITE_NODE_MEMORY_USAGE SiteStatusMetricsField = 11
	// x-displayName: "Node Disk Usage"
	SITE_NODE_DISK_USAGE SiteStatusMetricsField = 12
	// x-displayName: "Node Active Flow Count"
	SITE_NODE_ACTIVE_FLOW_COUNT SiteStatusMetricsField = 13
	// x-displayName: "Node Flow Setup Rate"
	SITE_NODE_FLOW_SETUP_RATE SiteStatusMetricsField = 14
	// x-displayName: "Node In Throughput"
	SITE_NODE_IN_THROUGHPUT SiteStatusMetricsField = 15
	// x-displayName: "Node Out Throughput"
	SITE_NODE_OUT_THROUGHPUT SiteStatusMetricsField = 16
	// x-displayName: "Node Interface In Throughput"
	SITE_NODE_IF_IN_THROUGHPUT SiteStatusMetricsField = 17
	// x-displayName: "Node Interface Out Throughput"
	SITE_NODE_IF_OUT_THROUGHPUT SiteStatusMetricsField = 18
)

var SiteStatusMetricsField_name = map[int32]string{
	0:  "SITE_ACTIVE_FLOW_COUNT",
	1:  "SITE_FLOW_SETUP_RATE",
	2:  "SITE_IN_THROUGHPUT",
	3:  "SITE_OUT_THROUGHPUT",
	4:  "SITE_SYSTEM_ACTIVE_POD_COUNT",
	5:  "SITE_VK8S_ACTIVE_POD_COUNT",
	6:  "SITE_RE_IN_THROUGHPUT",
	7:  "SITE_RE_OUT_THROUGHPUT",
	8:  "SITE_SITE_IN_THROUGHPUT",
	9:  "SITE_SITE_OUT_THROUGHPUT",
	10: "SITE_NODE_CPU_USAGE",
	11: "SITE_NODE_MEMORY_USAGE",
	12: "SITE_NODE_DISK_USAGE",
	13: "SITE_NODE_ACTIVE_FLOW_COUNT",
	14: "SITE_NODE_FLOW_SETUP_RATE",
	15: "SITE_NODE_IN_THROUGHPUT",
	16: "SITE_NODE_OUT_THROUGHPUT",
	17: "SITE_NODE_IF_IN_THROUGHPUT",
	18: "SITE_NODE_IF_OUT_THROUGHPUT",
}
var SiteStatusMetricsField_value = map[string]int32{
	"SITE_ACTIVE_FLOW_COUNT":       0,
	"SITE_FLOW_SETUP_RATE":         1,
	"SITE_IN_THROUGHPUT":           2,
	"SITE_OUT_THROUGHPUT":          3,
	"SITE_SYSTEM_ACTIVE_POD_COUNT": 4,
	"SITE_VK8S_ACTIVE_POD_COUNT":   5,
	"SITE_RE_IN_THROUGHPUT":        6,
	"SITE_RE_OUT_THROUGHPUT":       7,
	"SITE_SITE_IN_THROUGHPUT":      8,
	"SITE_SITE_OUT_THROUGHPUT":     9,
	"SITE_NODE_CPU_USAGE":          10,
	"SITE_NODE_MEMORY_USAGE":       11,
	"SITE_NODE_DISK_USAGE":         12,
	"SITE_NODE_ACTIVE_FLOW_COUNT":  13,
	"SITE_NODE_FLOW_SETUP_RATE":    14,
	"SITE_NODE_IN_THROUGHPUT":      15,
	"SITE_NODE_OUT_THROUGHPUT":     16,
	"SITE_NODE_IF_IN_THROUGHPUT":   17,
	"SITE_NODE_IF_OUT_THROUGHPUT":  18,
}

func (SiteStatusMetricsField) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

// Site Coordinates
//
// x-displayName: "Site Coordinates"
// Coordinates of the site which provides the site physical location
type Coordinates struct {
	// latitude
	//
	// x-displayName: "Latitude"
	// Latitude of the site location
	Latitude float32 `protobuf:"fixed32,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// longitude
	//
	// x-displayName: "Longitude"
	// longitude of site location
	Longitude float32 `protobuf:"fixed32,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
}

func (m *Coordinates) Reset()                    { *m = Coordinates{} }
func (*Coordinates) ProtoMessage()               {}
func (*Coordinates) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *Coordinates) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Coordinates) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

// K8sApiServer
//
// x-displayName: "K8s Api Server"
// Site's Physical Kubernetes API server. The location of this server is in site specification
type K8SApiServerParameters struct {
}

func (m *K8SApiServerParameters) Reset()                    { *m = K8SApiServerParameters{} }
func (*K8SApiServerParameters) ProtoMessage()               {}
func (*K8SApiServerParameters) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// Global Specification
//
// x-displayName: "Specification"
// Global specification of Site object
type GlobalSpecType struct {
	// site_type
	//
	// x-displayName: "Site Type"
	// Site type which specifies whether it is RE or CE
	SiteType SiteType `protobuf:"varint,1,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
	// site_subtype
	//
	// x-displayName: "Site Subtype"
	// Site subtype
	SiteSubtype SiteSubtype `protobuf:"varint,5,opt,name=site_subtype,json=siteSubtype,proto3,enum=ves.io.schema.site.SiteSubtype" json:"site_subtype,omitempty"`
	// address
	//
	// x-displayName: "Geographical Address"
	// x-example: "123 Street, city, country, postal code"
	// Site's geographical address that can be used determine its latitude and longitude.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// coordinates
	//
	// x-displayName: "Co-ordinates"
	// Site longitude and latitude co-ordinates
	Coordinates *Coordinates `protobuf:"bytes,3,opt,name=coordinates" json:"coordinates,omitempty"`
	// Connected REs
	//
	// x-displayName: "Connected REs"
	// x-required
	// Following fields are only for customer edge sites
	// List of REs to which to which this CE initiates IPSec/SSL connection to
	ConnectedRe []*ves_io_schema4.ObjectRefType `protobuf:"bytes,103,rep,name=connected_re,json=connectedRe" json:"connected_re,omitempty"`
	// connected_re_for_config
	//
	// x-displayName: "REs for Configuration"
	// x-required
	// This field is valid only for CE site object
	// List of REs which can send config to this CE site
	ConnectedReForConfig []*ves_io_schema4.ObjectRefType `protobuf:"bytes,104,rep,name=connected_re_for_config,json=connectedReForConfig" json:"connected_re_for_config,omitempty"`
	// vega
	//
	// x-displayName: "Vega Parameters"
	// Parameters to connect to this site {URL, type of TLS}
	Vega *ves_io_schema5.ServiceParameters `protobuf:"bytes,105,opt,name=vega" json:"vega,omitempty"`
	// ares_list
	//
	// x-displayName: "Ares Services"
	// List of Ares services in an RE site. This is used to create a full mesh of Ares services across all REs.
	AresList []*ves_io_schema5.ServiceParameters `protobuf:"bytes,106,rep,name=ares_list,json=aresList" json:"ares_list,omitempty"`
	// rakar
	//
	// x-displayName: "Rakar Parameters"
	// Rakar in the site
	Rakar *ves_io_schema5.ServiceParameters `protobuf:"bytes,107,opt,name=rakar" json:"rakar,omitempty"`
	// opera
	//
	// x-displayName: "opera Parameters"
	// opera in the site
	Opera *ves_io_schema5.ServiceParameters `protobuf:"bytes,133,opt,name=opera" json:"opera,omitempty"`
	// static_routes
	//
	// x-displayName: "Static Routes"
	// x-example: "10.1.1.0/24"
	// x-required
	// List of Fabric VN subnets/addresses in this site
	StaticRoutes []string `protobuf:"bytes,108,rep,name=static_routes,json=staticRoutes" json:"static_routes,omitempty"`
	// k8s_api_servers
	//
	// x-displayName: "Kubernetes API Servers"
	// physical kubernetes API servers on this site.
	// The index is kubernetes API server host name
	K8SApiServers map[string]*K8SApiServerParameters `protobuf:"bytes,109,rep,name=k8s_api_servers,json=k8sApiServers" json:"k8s_api_servers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// public_ip
	//
	// x-displayName: "Public IP"
	// x-example: "1.2.3.4"
	// VIP in the Public VN used for terminating IPSec/SSL tunnels
	// The automatic tunnels between regional-edges or between regional-edge and customer-edge sites use this VIP
	// Note: Tunnels can also be configured via SiteMeshGroup. Public IP is not used for SiteMeshGroup tunnels
	PublicIp string `protobuf:"bytes,110,opt,name=public_ip,json=publicIp,proto3" json:"public_ip,omitempty"`
	// cluster_ip
	//
	// x-displayName: "Cluster IP"
	// x-example: "1.2.3.4"
	// VIP in the Fabric VN for accessing Volterra services like Ares etc
	// constraint - used only in REs
	ClusterIp string `protobuf:"bytes,111,opt,name=cluster_ip,json=clusterIp,proto3" json:"cluster_ip,omitempty"`
	// ares_vtrp_list
	//
	// x-displayName: "Ares VTRP Services"
	// List of Ares services in an RE site for use with VTRP. This is used to choose a redundant pair of Ares services for VTRP clients.
	AresVtrpList []*ves_io_schema5.ServiceParameters `protobuf:"bytes,112,rep,name=ares_vtrp_list,json=aresVtrpList" json:"ares_vtrp_list,omitempty"`
	// volterra_software_version
	//
	// x-displayName: "Software Version"
	// x-example: "value"
	// Desired Volterra software version for this site, a string matching released set of software components.
	VolterraSoftwareVersion string `protobuf:"bytes,113,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	// inside_vip
	//
	// x-displayName: "Inside VIP"
	// x-example: "10.1.1.1"
	// Optional Virtual IP to be used as automatic VIP for site local inside network.
	// See documentation for "VIP" in advertise policy to see when Inside VIP is used.
	// When configured, this is used as VIP (depending on advertise policy configuration).
	// When not configured, site local inside interface ip will be used as VIP.
	InsideVip string `protobuf:"bytes,114,opt,name=inside_vip,json=insideVip,proto3" json:"inside_vip,omitempty"`
	// outside_vip
	//
	// x-displayName: "Outside VIP"
	// x-example: "10.1.1.1"
	// Optional Virtual IP to be used as automatic VIP for site local outside network.
	// See documentation for "VIP" in advertise policy to see when Outside VIP is used.
	// When configured, this is used as VIP (depending on advertise policy configuration).
	// When not configured, site local interface ip will be used as VIP.
	OutsideVip string `protobuf:"bytes,120,opt,name=outside_vip,json=outsideVip,proto3" json:"outside_vip,omitempty"`
	// vip_vrrp_mode
	//
	// x-displayName: "VIP Advertisement Mode"
	// Optional VIP VRRP advertisement mode. This controls the ARP behavior for "Outside VIP" and "Inside VIP"
	// addresses, when they are configured. When turned on, the Master VER would advertise gratuitous ARPs and
	// would respond to ARP queries for these addresses. When turned off, ARP responses are not given by VER.
	//
	// If BGP is configured, the Inside VIP and outside VIP addresses will be advertised by BGP. This is
	// irrespective of the vrrp mode.
	//
	// When Outside VIP / Inside VIP are configured, it is recommended to turn on vrrp and also configure BGP.
	VipVrrpMode ves_io_schema4.VipVrrpType `protobuf:"varint,121,opt,name=vip_vrrp_mode,json=vipVrrpMode,proto3,enum=ves.io.schema.VipVrrpType" json:"vip_vrrp_mode,omitempty"`
	// site_to_site_network_type
	//
	// x-displayName: "Site To Site Network Type"
	// Optional, virtual network type to be used for site to site tunnels created with SiteMeshGroup.
	// Must be specified for CE site mesh group configuration
	SiteToSiteNetworkType ves_io_schema3.VirtualNetworkType `protobuf:"varint,122,opt,name=site_to_site_network_type,json=siteToSiteNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"site_to_site_network_type,omitempty"`
	// site_to_site_tunnel_ip
	//
	// x-displayName: "Site To Site Tunnel IP"
	// x-example: "10.1.1.1"
	// Optionsl, VIP in the site_to_site_network_type configured above used for terminating IPSec/SSL tunnels created with SiteMeshGroup.
	SiteToSiteTunnelIp string `protobuf:"bytes,115,opt,name=site_to_site_tunnel_ip,json=siteToSiteTunnelIp,proto3" json:"site_to_site_tunnel_ip,omitempty"`
	// volterra_software_override
	//
	// x-displayName: "Site Software Version Override"
	// Policy to pick Volterra software version between verion given in site and corresponding fleet object.
	VolterraSoftwareOveride SiteSoftwareOverrideType `protobuf:"varint,116,opt,name=volterra_software_overide,json=volterraSoftwareOveride,proto3,enum=ves.io.schema.site.SiteSoftwareOverrideType" json:"volterra_software_overide,omitempty"`
	// bgp_router_id
	//
	// x-displayName: "BGP Router ID"
	// x-example: "10.1.1.1"
	// Optional bgp router id that can be used as parameter for BGP configuration when BGP is configurred to
	// fetch BGP router ID from site object. This can be used to change router id per site in a fleet.
	BgpRouterId string `protobuf:"bytes,117,opt,name=bgp_router_id,json=bgpRouterId,proto3" json:"bgp_router_id,omitempty"`
	// bgp_peer_address
	//
	// x-displayName: "BGP Peer Address"
	// x-example: "10.1.1.1"
	// Optional bgp peer address that can be used as parameter for BGP configuration when BGP is configured
	// to fetch BGP peer address from site Object. This can be used to change peer addres per site in fleet.
	BgpPeerAddress string `protobuf:"bytes,118,opt,name=bgp_peer_address,json=bgpPeerAddress,proto3" json:"bgp_peer_address,omitempty"`
	// template_parameters
	//
	// x-displayName: "Template Parameters"
	// x-example: "value"
	// Optional
	// Map of string keys and values that can be used to provide per site config parameters to various
	// configurations objects that configure features on set of sites
	// In the configuration object a key is provided and value for that key is provided in the
	// template_parameters
	TemplateParameters map[string]string `protobuf:"bytes,119,rep,name=template_parameters,json=templateParameters" json:"template_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// inside_nameserver
	//
	// x-displayName: "DNS Server for Inside Network"
	// x-example: "10.1.1.1"
	// Optional DNS server IP to be used for name resolution in inside network
	InsideNameserver string `protobuf:"bytes,123,opt,name=inside_nameserver,json=insideNameserver,proto3" json:"inside_nameserver,omitempty"`
	// outside_nameserver
	//
	// x-displayName: "DNS Server for Outside Network"
	// x-example: "10.1.1.1"
	// Optional DNS server IP to be used for name resolution in outside network
	OutsideNameserver string `protobuf:"bytes,124,opt,name=outside_nameserver,json=outsideNameserver,proto3" json:"outside_nameserver,omitempty"`
	// desired_pool_count
	//
	// x-displayName: "Desired Pool Count"
	// x-example: "0"
	// Desire pool count represent number of nodes in scaling group for manual scaling. It is valid only for K8s worker nodes
	// not masters. The desired count must be less than or equal to the maximum size of the group.
	// If new value for Desired is greater than Max, then Max must be updated in cloud provider configuration.
	DesiredPoolCount int32 `protobuf:"varint,125,opt,name=desired_pool_count,json=desiredPoolCount,proto3" json:"desired_pool_count,omitempty"`
	// Site to site tunnel type
	//
	// x-displayName: "Site Tunnel Type"
	// Tunnel type specifies type of tunnels enabled from this site. The tunnel type is used for automatic tunnels
	// created between regional-edge sites or between regional-edge and customer-edge sites
	//
	// A tunnel connects two sites. The tunnel types enabled for tunnel results from intersection of tunnel types
	// enabled for the two sites. IPSec gets priority over SSL when both are enabled
	//
	// Note: Tunnels can also be configured via SiteMeshGroup. Tunnel type is not used for SiteMeshGroup tunnels
	TunnelType ves_io_schema4.SiteToSiteTunnelType `protobuf:"varint,126,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
	// site_state
	//
	// x-displayName: "Site State"
	// Site state defines its state machine and in which operational phase it is. It is for both Regional Edge
	// as well as Customer Edge. Example flow is site is in PROVISIONING then goest to STANDBY and ONLINE. In case of
	// switching to different Connected RE it goes back to PROVISIONING and ONLINE. If any of phase failes then it
	// goest to FAILED.
	SiteState SiteState `protobuf:"varint,127,opt,name=site_state,json=siteState,proto3,enum=ves.io.schema.site.SiteState" json:"site_state,omitempty"`
	// operating_system_version
	//
	// x-displayName: "Operating System Version"
	// x-example: "value"
	// Desired Operating System version for this site.
	OperatingSystemVersion string `protobuf:"bytes,128,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	// mars_list
	//
	// x-displayName: "Mars Services"
	// List of Mars services in an RE site. This is used to create a full mesh of Mars services across all REs.
	MarsList []*ves_io_schema5.ServiceParameters `protobuf:"bytes,129,rep,name=mars_list,json=marsList" json:"mars_list,omitempty"`
	// mars_vtrp_list
	//
	// x-displayName: "Mars VTRP Services"
	// List of Mars services in an RE site for use with VTRP. This is used to choose a redundant pair of Mars services for VTRP clients.
	MarsVtrpList []*ves_io_schema5.ServiceParameters `protobuf:"bytes,130,rep,name=mars_vtrp_list,json=marsVtrpList" json:"mars_vtrp_list,omitempty"`
	// tunnel_dead_timeout
	//
	// x-displayName: "Tunnel Dead Timeout (msec)"
	// x-example: "0"
	// Time interval, in millisec, within which any ipsec / ssl connection from the site going down is detected.
	// When not set (== 0), a default value of 10000 msec will be used.
	TunnelDeadTimeout uint32 `protobuf:"varint,131,opt,name=tunnel_dead_timeout,json=tunnelDeadTimeout,proto3" json:"tunnel_dead_timeout,omitempty"`
	// region
	//
	// x-displayName: "Region"
	// x-example: "east-us-2"
	// Cloud Region. A region is a set of datacenters deployed within a latency-defined perimeter and connected through a dedicated regional low-latency network
	Region string `protobuf:"bytes,132,opt,name=region,proto3" json:"region,omitempty"`
	// CE Site Mode
	//
	// x-displayName: "CE Site Mode"
	// Customer Eddge Mode. Defines how the CE is being deployed. Invalid for RE Site
	CeSiteMode CeSiteMode `protobuf:"varint,134,opt,name=ce_site_mode,json=ceSiteMode,proto3,enum=ves.io.schema.site.CeSiteMode" json:"ce_site_mode,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *GlobalSpecType) GetSiteType() SiteType {
	if m != nil {
		return m.SiteType
	}
	return INVALID
}

func (m *GlobalSpecType) GetSiteSubtype() SiteSubtype {
	if m != nil {
		return m.SiteSubtype
	}
	return NO_SUBTYPE
}

func (m *GlobalSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GlobalSpecType) GetCoordinates() *Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *GlobalSpecType) GetConnectedRe() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ConnectedRe
	}
	return nil
}

func (m *GlobalSpecType) GetConnectedReForConfig() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ConnectedReForConfig
	}
	return nil
}

func (m *GlobalSpecType) GetVega() *ves_io_schema5.ServiceParameters {
	if m != nil {
		return m.Vega
	}
	return nil
}

func (m *GlobalSpecType) GetAresList() []*ves_io_schema5.ServiceParameters {
	if m != nil {
		return m.AresList
	}
	return nil
}

func (m *GlobalSpecType) GetRakar() *ves_io_schema5.ServiceParameters {
	if m != nil {
		return m.Rakar
	}
	return nil
}

func (m *GlobalSpecType) GetOpera() *ves_io_schema5.ServiceParameters {
	if m != nil {
		return m.Opera
	}
	return nil
}

func (m *GlobalSpecType) GetStaticRoutes() []string {
	if m != nil {
		return m.StaticRoutes
	}
	return nil
}

func (m *GlobalSpecType) GetK8SApiServers() map[string]*K8SApiServerParameters {
	if m != nil {
		return m.K8SApiServers
	}
	return nil
}

func (m *GlobalSpecType) GetPublicIp() string {
	if m != nil {
		return m.PublicIp
	}
	return ""
}

func (m *GlobalSpecType) GetClusterIp() string {
	if m != nil {
		return m.ClusterIp
	}
	return ""
}

func (m *GlobalSpecType) GetAresVtrpList() []*ves_io_schema5.ServiceParameters {
	if m != nil {
		return m.AresVtrpList
	}
	return nil
}

func (m *GlobalSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GlobalSpecType) GetInsideVip() string {
	if m != nil {
		return m.InsideVip
	}
	return ""
}

func (m *GlobalSpecType) GetOutsideVip() string {
	if m != nil {
		return m.OutsideVip
	}
	return ""
}

func (m *GlobalSpecType) GetVipVrrpMode() ves_io_schema4.VipVrrpType {
	if m != nil {
		return m.VipVrrpMode
	}
	return ves_io_schema4.VIP_VRRP_INVALID
}

func (m *GlobalSpecType) GetSiteToSiteNetworkType() ves_io_schema3.VirtualNetworkType {
	if m != nil {
		return m.SiteToSiteNetworkType
	}
	return ves_io_schema3.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *GlobalSpecType) GetSiteToSiteTunnelIp() string {
	if m != nil {
		return m.SiteToSiteTunnelIp
	}
	return ""
}

func (m *GlobalSpecType) GetVolterraSoftwareOveride() SiteSoftwareOverrideType {
	if m != nil {
		return m.VolterraSoftwareOveride
	}
	return SITE_SOFTWARE_OVERRIDE_SITE
}

func (m *GlobalSpecType) GetBgpRouterId() string {
	if m != nil {
		return m.BgpRouterId
	}
	return ""
}

func (m *GlobalSpecType) GetBgpPeerAddress() string {
	if m != nil {
		return m.BgpPeerAddress
	}
	return ""
}

func (m *GlobalSpecType) GetTemplateParameters() map[string]string {
	if m != nil {
		return m.TemplateParameters
	}
	return nil
}

func (m *GlobalSpecType) GetInsideNameserver() string {
	if m != nil {
		return m.InsideNameserver
	}
	return ""
}

func (m *GlobalSpecType) GetOutsideNameserver() string {
	if m != nil {
		return m.OutsideNameserver
	}
	return ""
}

func (m *GlobalSpecType) GetDesiredPoolCount() int32 {
	if m != nil {
		return m.DesiredPoolCount
	}
	return 0
}

func (m *GlobalSpecType) GetTunnelType() ves_io_schema4.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return ves_io_schema4.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

func (m *GlobalSpecType) GetSiteState() SiteState {
	if m != nil {
		return m.SiteState
	}
	return ONLINE
}

func (m *GlobalSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GlobalSpecType) GetMarsList() []*ves_io_schema5.ServiceParameters {
	if m != nil {
		return m.MarsList
	}
	return nil
}

func (m *GlobalSpecType) GetMarsVtrpList() []*ves_io_schema5.ServiceParameters {
	if m != nil {
		return m.MarsVtrpList
	}
	return nil
}

func (m *GlobalSpecType) GetTunnelDeadTimeout() uint32 {
	if m != nil {
		return m.TunnelDeadTimeout
	}
	return 0
}

func (m *GlobalSpecType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *GlobalSpecType) GetCeSiteMode() CeSiteMode {
	if m != nil {
		return m.CeSiteMode
	}
	return CE_SITE_MODE_INGRESS_EGRESS_GW
}

// Create Site
//
// x-displayName: "Create Specification"
// Sites are created automatically once user approves addition of sites in the system.
type CreateSpecType struct {
	SiteType                SiteType                            `protobuf:"varint,1,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
	Address                 string                              `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Coordinates             *Coordinates                        `protobuf:"bytes,3,opt,name=coordinates" json:"coordinates,omitempty"`
	InsideVip               string                              `protobuf:"bytes,114,opt,name=inside_vip,json=insideVip,proto3" json:"inside_vip,omitempty"`
	OutsideVip              string                              `protobuf:"bytes,120,opt,name=outside_vip,json=outsideVip,proto3" json:"outside_vip,omitempty"`
	VipVrrpMode             ves_io_schema4.VipVrrpType          `protobuf:"varint,121,opt,name=vip_vrrp_mode,json=vipVrrpMode,proto3,enum=ves.io.schema.VipVrrpType" json:"vip_vrrp_mode,omitempty"`
	SiteToSiteNetworkType   ves_io_schema3.VirtualNetworkType   `protobuf:"varint,122,opt,name=site_to_site_network_type,json=siteToSiteNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"site_to_site_network_type,omitempty"`
	SiteToSiteTunnelIp      string                              `protobuf:"bytes,115,opt,name=site_to_site_tunnel_ip,json=siteToSiteTunnelIp,proto3" json:"site_to_site_tunnel_ip,omitempty"`
	VolterraSoftwareOveride SiteSoftwareOverrideType            `protobuf:"varint,116,opt,name=volterra_software_overide,json=volterraSoftwareOveride,proto3,enum=ves.io.schema.site.SiteSoftwareOverrideType" json:"volterra_software_overide,omitempty"`
	BgpRouterId             string                              `protobuf:"bytes,117,opt,name=bgp_router_id,json=bgpRouterId,proto3" json:"bgp_router_id,omitempty"`
	BgpPeerAddress          string                              `protobuf:"bytes,118,opt,name=bgp_peer_address,json=bgpPeerAddress,proto3" json:"bgp_peer_address,omitempty"`
	InsideNameserver        string                              `protobuf:"bytes,123,opt,name=inside_nameserver,json=insideNameserver,proto3" json:"inside_nameserver,omitempty"`
	OutsideNameserver       string                              `protobuf:"bytes,124,opt,name=outside_nameserver,json=outsideNameserver,proto3" json:"outside_nameserver,omitempty"`
	DesiredPoolCount        int32                               `protobuf:"varint,125,opt,name=desired_pool_count,json=desiredPoolCount,proto3" json:"desired_pool_count,omitempty"`
	TunnelType              ves_io_schema4.SiteToSiteTunnelType `protobuf:"varint,126,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
	OperatingSystemVersion  string                              `protobuf:"bytes,127,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	TunnelDeadTimeout       uint32                              `protobuf:"varint,129,opt,name=tunnel_dead_timeout,json=tunnelDeadTimeout,proto3" json:"tunnel_dead_timeout,omitempty"`
	Region                  string                              `protobuf:"bytes,132,opt,name=region,proto3" json:"region,omitempty"`
	CeSiteMode              CeSiteMode                          `protobuf:"varint,134,opt,name=ce_site_mode,json=ceSiteMode,proto3,enum=ves.io.schema.site.CeSiteMode" json:"ce_site_mode,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *CreateSpecType) GetSiteType() SiteType {
	if m != nil {
		return m.SiteType
	}
	return INVALID
}

func (m *CreateSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CreateSpecType) GetCoordinates() *Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *CreateSpecType) GetInsideVip() string {
	if m != nil {
		return m.InsideVip
	}
	return ""
}

func (m *CreateSpecType) GetOutsideVip() string {
	if m != nil {
		return m.OutsideVip
	}
	return ""
}

func (m *CreateSpecType) GetVipVrrpMode() ves_io_schema4.VipVrrpType {
	if m != nil {
		return m.VipVrrpMode
	}
	return ves_io_schema4.VIP_VRRP_INVALID
}

func (m *CreateSpecType) GetSiteToSiteNetworkType() ves_io_schema3.VirtualNetworkType {
	if m != nil {
		return m.SiteToSiteNetworkType
	}
	return ves_io_schema3.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *CreateSpecType) GetSiteToSiteTunnelIp() string {
	if m != nil {
		return m.SiteToSiteTunnelIp
	}
	return ""
}

func (m *CreateSpecType) GetVolterraSoftwareOveride() SiteSoftwareOverrideType {
	if m != nil {
		return m.VolterraSoftwareOveride
	}
	return SITE_SOFTWARE_OVERRIDE_SITE
}

func (m *CreateSpecType) GetBgpRouterId() string {
	if m != nil {
		return m.BgpRouterId
	}
	return ""
}

func (m *CreateSpecType) GetBgpPeerAddress() string {
	if m != nil {
		return m.BgpPeerAddress
	}
	return ""
}

func (m *CreateSpecType) GetInsideNameserver() string {
	if m != nil {
		return m.InsideNameserver
	}
	return ""
}

func (m *CreateSpecType) GetOutsideNameserver() string {
	if m != nil {
		return m.OutsideNameserver
	}
	return ""
}

func (m *CreateSpecType) GetDesiredPoolCount() int32 {
	if m != nil {
		return m.DesiredPoolCount
	}
	return 0
}

func (m *CreateSpecType) GetTunnelType() ves_io_schema4.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return ves_io_schema4.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

func (m *CreateSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *CreateSpecType) GetTunnelDeadTimeout() uint32 {
	if m != nil {
		return m.TunnelDeadTimeout
	}
	return 0
}

func (m *CreateSpecType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *CreateSpecType) GetCeSiteMode() CeSiteMode {
	if m != nil {
		return m.CeSiteMode
	}
	return CE_SITE_MODE_INGRESS_EGRESS_GW
}

// Replace Site
//
// x-displayName: "Replace Specification"
// Replace Site will replace address, coordinates of site
type ReplaceSpecType struct {
	Address                 string                              `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Coordinates             *Coordinates                        `protobuf:"bytes,3,opt,name=coordinates" json:"coordinates,omitempty"`
	VolterraSoftwareVersion string                              `protobuf:"bytes,4,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	InsideVip               string                              `protobuf:"bytes,114,opt,name=inside_vip,json=insideVip,proto3" json:"inside_vip,omitempty"`
	OutsideVip              string                              `protobuf:"bytes,120,opt,name=outside_vip,json=outsideVip,proto3" json:"outside_vip,omitempty"`
	VipVrrpMode             ves_io_schema4.VipVrrpType          `protobuf:"varint,121,opt,name=vip_vrrp_mode,json=vipVrrpMode,proto3,enum=ves.io.schema.VipVrrpType" json:"vip_vrrp_mode,omitempty"`
	SiteToSiteNetworkType   ves_io_schema3.VirtualNetworkType   `protobuf:"varint,122,opt,name=site_to_site_network_type,json=siteToSiteNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"site_to_site_network_type,omitempty"`
	SiteToSiteTunnelIp      string                              `protobuf:"bytes,115,opt,name=site_to_site_tunnel_ip,json=siteToSiteTunnelIp,proto3" json:"site_to_site_tunnel_ip,omitempty"`
	VolterraSoftwareOveride SiteSoftwareOverrideType            `protobuf:"varint,116,opt,name=volterra_software_overide,json=volterraSoftwareOveride,proto3,enum=ves.io.schema.site.SiteSoftwareOverrideType" json:"volterra_software_overide,omitempty"`
	BgpRouterId             string                              `protobuf:"bytes,117,opt,name=bgp_router_id,json=bgpRouterId,proto3" json:"bgp_router_id,omitempty"`
	BgpPeerAddress          string                              `protobuf:"bytes,118,opt,name=bgp_peer_address,json=bgpPeerAddress,proto3" json:"bgp_peer_address,omitempty"`
	InsideNameserver        string                              `protobuf:"bytes,123,opt,name=inside_nameserver,json=insideNameserver,proto3" json:"inside_nameserver,omitempty"`
	OutsideNameserver       string                              `protobuf:"bytes,124,opt,name=outside_nameserver,json=outsideNameserver,proto3" json:"outside_nameserver,omitempty"`
	DesiredPoolCount        int32                               `protobuf:"varint,125,opt,name=desired_pool_count,json=desiredPoolCount,proto3" json:"desired_pool_count,omitempty"`
	TunnelType              ves_io_schema4.SiteToSiteTunnelType `protobuf:"varint,126,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
	OperatingSystemVersion  string                              `protobuf:"bytes,127,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	TunnelDeadTimeout       uint32                              `protobuf:"varint,129,opt,name=tunnel_dead_timeout,json=tunnelDeadTimeout,proto3" json:"tunnel_dead_timeout,omitempty"`
	Region                  string                              `protobuf:"bytes,132,opt,name=region,proto3" json:"region,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *ReplaceSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ReplaceSpecType) GetCoordinates() *Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *ReplaceSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *ReplaceSpecType) GetInsideVip() string {
	if m != nil {
		return m.InsideVip
	}
	return ""
}

func (m *ReplaceSpecType) GetOutsideVip() string {
	if m != nil {
		return m.OutsideVip
	}
	return ""
}

func (m *ReplaceSpecType) GetVipVrrpMode() ves_io_schema4.VipVrrpType {
	if m != nil {
		return m.VipVrrpMode
	}
	return ves_io_schema4.VIP_VRRP_INVALID
}

func (m *ReplaceSpecType) GetSiteToSiteNetworkType() ves_io_schema3.VirtualNetworkType {
	if m != nil {
		return m.SiteToSiteNetworkType
	}
	return ves_io_schema3.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *ReplaceSpecType) GetSiteToSiteTunnelIp() string {
	if m != nil {
		return m.SiteToSiteTunnelIp
	}
	return ""
}

func (m *ReplaceSpecType) GetVolterraSoftwareOveride() SiteSoftwareOverrideType {
	if m != nil {
		return m.VolterraSoftwareOveride
	}
	return SITE_SOFTWARE_OVERRIDE_SITE
}

func (m *ReplaceSpecType) GetBgpRouterId() string {
	if m != nil {
		return m.BgpRouterId
	}
	return ""
}

func (m *ReplaceSpecType) GetBgpPeerAddress() string {
	if m != nil {
		return m.BgpPeerAddress
	}
	return ""
}

func (m *ReplaceSpecType) GetInsideNameserver() string {
	if m != nil {
		return m.InsideNameserver
	}
	return ""
}

func (m *ReplaceSpecType) GetOutsideNameserver() string {
	if m != nil {
		return m.OutsideNameserver
	}
	return ""
}

func (m *ReplaceSpecType) GetDesiredPoolCount() int32 {
	if m != nil {
		return m.DesiredPoolCount
	}
	return 0
}

func (m *ReplaceSpecType) GetTunnelType() ves_io_schema4.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return ves_io_schema4.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

func (m *ReplaceSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *ReplaceSpecType) GetTunnelDeadTimeout() uint32 {
	if m != nil {
		return m.TunnelDeadTimeout
	}
	return 0
}

func (m *ReplaceSpecType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

// Get Site
//
// x-displayName: "Get Specification"
// Get of site
type GetSpecType struct {
	SiteType                SiteType                            `protobuf:"varint,1,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
	Address                 string                              `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Coordinates             *Coordinates                        `protobuf:"bytes,3,opt,name=coordinates" json:"coordinates,omitempty"`
	VolterraSoftwareVersion string                              `protobuf:"bytes,4,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	ConnectedRe             []*ves_io_schema4.ObjectRefType     `protobuf:"bytes,103,rep,name=connected_re,json=connectedRe" json:"connected_re,omitempty"`
	ConnectedReForConfig    []*ves_io_schema4.ObjectRefType     `protobuf:"bytes,104,rep,name=connected_re_for_config,json=connectedReForConfig" json:"connected_re_for_config,omitempty"`
	InsideVip               string                              `protobuf:"bytes,114,opt,name=inside_vip,json=insideVip,proto3" json:"inside_vip,omitempty"`
	OutsideVip              string                              `protobuf:"bytes,120,opt,name=outside_vip,json=outsideVip,proto3" json:"outside_vip,omitempty"`
	VipVrrpMode             ves_io_schema4.VipVrrpType          `protobuf:"varint,121,opt,name=vip_vrrp_mode,json=vipVrrpMode,proto3,enum=ves.io.schema.VipVrrpType" json:"vip_vrrp_mode,omitempty"`
	SiteToSiteNetworkType   ves_io_schema3.VirtualNetworkType   `protobuf:"varint,122,opt,name=site_to_site_network_type,json=siteToSiteNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"site_to_site_network_type,omitempty"`
	SiteToSiteTunnelIp      string                              `protobuf:"bytes,115,opt,name=site_to_site_tunnel_ip,json=siteToSiteTunnelIp,proto3" json:"site_to_site_tunnel_ip,omitempty"`
	VolterraSoftwareOveride SiteSoftwareOverrideType            `protobuf:"varint,116,opt,name=volterra_software_overide,json=volterraSoftwareOveride,proto3,enum=ves.io.schema.site.SiteSoftwareOverrideType" json:"volterra_software_overide,omitempty"`
	BgpRouterId             string                              `protobuf:"bytes,117,opt,name=bgp_router_id,json=bgpRouterId,proto3" json:"bgp_router_id,omitempty"`
	BgpPeerAddress          string                              `protobuf:"bytes,118,opt,name=bgp_peer_address,json=bgpPeerAddress,proto3" json:"bgp_peer_address,omitempty"`
	InsideNameserver        string                              `protobuf:"bytes,123,opt,name=inside_nameserver,json=insideNameserver,proto3" json:"inside_nameserver,omitempty"`
	OutsideNameserver       string                              `protobuf:"bytes,124,opt,name=outside_nameserver,json=outsideNameserver,proto3" json:"outside_nameserver,omitempty"`
	DesiredPoolCount        int32                               `protobuf:"varint,125,opt,name=desired_pool_count,json=desiredPoolCount,proto3" json:"desired_pool_count,omitempty"`
	TunnelType              ves_io_schema4.SiteToSiteTunnelType `protobuf:"varint,126,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
	OperatingSystemVersion  string                              `protobuf:"bytes,127,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	SiteState               SiteState                           `protobuf:"varint,128,opt,name=site_state,json=siteState,proto3,enum=ves.io.schema.site.SiteState" json:"site_state,omitempty"`
	TunnelDeadTimeout       uint32                              `protobuf:"varint,129,opt,name=tunnel_dead_timeout,json=tunnelDeadTimeout,proto3" json:"tunnel_dead_timeout,omitempty"`
	Region                  string                              `protobuf:"bytes,132,opt,name=region,proto3" json:"region,omitempty"`
	CeSiteMode              CeSiteMode                          `protobuf:"varint,134,opt,name=ce_site_mode,json=ceSiteMode,proto3,enum=ves.io.schema.site.CeSiteMode" json:"ce_site_mode,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *GetSpecType) GetSiteType() SiteType {
	if m != nil {
		return m.SiteType
	}
	return INVALID
}

func (m *GetSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GetSpecType) GetCoordinates() *Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *GetSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GetSpecType) GetConnectedRe() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ConnectedRe
	}
	return nil
}

func (m *GetSpecType) GetConnectedReForConfig() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ConnectedReForConfig
	}
	return nil
}

func (m *GetSpecType) GetInsideVip() string {
	if m != nil {
		return m.InsideVip
	}
	return ""
}

func (m *GetSpecType) GetOutsideVip() string {
	if m != nil {
		return m.OutsideVip
	}
	return ""
}

func (m *GetSpecType) GetVipVrrpMode() ves_io_schema4.VipVrrpType {
	if m != nil {
		return m.VipVrrpMode
	}
	return ves_io_schema4.VIP_VRRP_INVALID
}

func (m *GetSpecType) GetSiteToSiteNetworkType() ves_io_schema3.VirtualNetworkType {
	if m != nil {
		return m.SiteToSiteNetworkType
	}
	return ves_io_schema3.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *GetSpecType) GetSiteToSiteTunnelIp() string {
	if m != nil {
		return m.SiteToSiteTunnelIp
	}
	return ""
}

func (m *GetSpecType) GetVolterraSoftwareOveride() SiteSoftwareOverrideType {
	if m != nil {
		return m.VolterraSoftwareOveride
	}
	return SITE_SOFTWARE_OVERRIDE_SITE
}

func (m *GetSpecType) GetBgpRouterId() string {
	if m != nil {
		return m.BgpRouterId
	}
	return ""
}

func (m *GetSpecType) GetBgpPeerAddress() string {
	if m != nil {
		return m.BgpPeerAddress
	}
	return ""
}

func (m *GetSpecType) GetInsideNameserver() string {
	if m != nil {
		return m.InsideNameserver
	}
	return ""
}

func (m *GetSpecType) GetOutsideNameserver() string {
	if m != nil {
		return m.OutsideNameserver
	}
	return ""
}

func (m *GetSpecType) GetDesiredPoolCount() int32 {
	if m != nil {
		return m.DesiredPoolCount
	}
	return 0
}

func (m *GetSpecType) GetTunnelType() ves_io_schema4.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return ves_io_schema4.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

func (m *GetSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GetSpecType) GetSiteState() SiteState {
	if m != nil {
		return m.SiteState
	}
	return ONLINE
}

func (m *GetSpecType) GetTunnelDeadTimeout() uint32 {
	if m != nil {
		return m.TunnelDeadTimeout
	}
	return 0
}

func (m *GetSpecType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *GetSpecType) GetCeSiteMode() CeSiteMode {
	if m != nil {
		return m.CeSiteMode
	}
	return CE_SITE_MODE_INGRESS_EGRESS_GW
}

// VerStatus
//
// x-displayName: "Ver Status"
// Ver details in the site that has generated the site status object
type VerStatusType struct {
	// ver_instance_name
	//
	// x-displayName: "VER Instance"
	// name of the ver instance that created this site status
	VerInstanceName string `protobuf:"bytes,1,opt,name=ver_instance_name,json=verInstanceName,proto3" json:"ver_instance_name,omitempty"`
	// ipsec_status
	//
	// x-displayName: "IPSec Status"
	// Status/details of every ipsec connection this Ver is terminating/originating
	IpsecStatus []*IpsecConnectionStatus `protobuf:"bytes,2,rep,name=ipsec_status,json=ipsecStatus" json:"ipsec_status,omitempty"`
	// ares_status
	//
	// x-displayName: "Ares Status"
	// Status of every Ares connections this Ver is connecting to for routes
	AresStatus []*AresConnectionStatus `protobuf:"bytes,3,rep,name=ares_status,json=aresStatus" json:"ares_status,omitempty"`
	// interface_status
	//
	// x-displayName: "Interface Status"
	// Status of every inside or outside interface present in this VER
	IntfStatus []*InterfaceStatus `protobuf:"bytes,4,rep,name=intf_status,json=intfStatus" json:"intf_status,omitempty"`
	// configured_tunnel_connection_status
	//
	// x-displayName: "Configured Tunnel Connection Status"
	// Status/details of every configured connection this Ver is originating
	ConfiguredTunnelStatus []*TunnelConnectionStatus `protobuf:"bytes,5,rep,name=configured_tunnel_status,json=configuredTunnelStatus" json:"configured_tunnel_status,omitempty"`
	// site_tunnel_status
	//
	// x-displayName: "Site Tunnel Status"
	// Status/details of every site connection this Ver is originating/ terminating
	SiteTunnelStatus []*TunnelConnectionStatus `protobuf:"bytes,6,rep,name=site_tunnel_status,json=siteTunnelStatus" json:"site_tunnel_status,omitempty"`
}

func (m *VerStatusType) Reset()                    { *m = VerStatusType{} }
func (*VerStatusType) ProtoMessage()               {}
func (*VerStatusType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *VerStatusType) GetVerInstanceName() string {
	if m != nil {
		return m.VerInstanceName
	}
	return ""
}

func (m *VerStatusType) GetIpsecStatus() []*IpsecConnectionStatus {
	if m != nil {
		return m.IpsecStatus
	}
	return nil
}

func (m *VerStatusType) GetAresStatus() []*AresConnectionStatus {
	if m != nil {
		return m.AresStatus
	}
	return nil
}

func (m *VerStatusType) GetIntfStatus() []*InterfaceStatus {
	if m != nil {
		return m.IntfStatus
	}
	return nil
}

func (m *VerStatusType) GetConfiguredTunnelStatus() []*TunnelConnectionStatus {
	if m != nil {
		return m.ConfiguredTunnelStatus
	}
	return nil
}

func (m *VerStatusType) GetSiteTunnelStatus() []*TunnelConnectionStatus {
	if m != nil {
		return m.SiteTunnelStatus
	}
	return nil
}

// VerMasterStatus
//
// x-displayName: "Ver Master Status"
// Info of the Master Ver of the site
type VerMasterStatusType struct {
	// Master Ver Node Name
	//
	// x-displayName: "Master Ver Node Name"
	// Instance name of Master VER in the Cluster
	VerName string `protobuf:"bytes,1,opt,name=ver_name,json=verName,proto3" json:"ver_name,omitempty"`
	// Master Ver UID
	//
	// x-displayName: "Master Ver UID"
	// UID of Master VER in the Cluster
	Ver_UID string `protobuf:"bytes,2,opt,name=ver_UID,json=verUID,proto3" json:"ver_UID,omitempty"`
	// Mastership Transition TimeStamp
	//
	// x-displayName: "Mastership Transition TimeStamp"
	// Timestamp at which the VER became cluster master
	TransitionTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=transition_timestamp,json=transitionTimestamp" json:"transition_timestamp,omitempty"`
}

func (m *VerMasterStatusType) Reset()                    { *m = VerMasterStatusType{} }
func (*VerMasterStatusType) ProtoMessage()               {}
func (*VerMasterStatusType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *VerMasterStatusType) GetVerName() string {
	if m != nil {
		return m.VerName
	}
	return ""
}

func (m *VerMasterStatusType) GetVer_UID() string {
	if m != nil {
		return m.Ver_UID
	}
	return ""
}

func (m *VerMasterStatusType) GetTransitionTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.TransitionTimestamp
	}
	return nil
}

// IPSecConnection Status
//
// x-displayName: "IPSec Connection Status"
// Status of IPSec connection that a Ver has originated / terminated
type IpsecConnectionStatus struct {
	// url
	//
	// x-displayName: "URL"
	// url identifies the other end of the Ver for IPSec tunnel origination/termination
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// state
	//
	// x-displayName: "Connection State"
	// connection state which identifies whether an IPSec connection is UP/DOWN
	State IPSecState `protobuf:"varint,2,opt,name=state,proto3,enum=ves.io.schema.site.IPSecState" json:"state,omitempty"`
	// role
	//
	// x-displayName: "Role"
	// indicates whether the ver is client/Originator or server/responder in ipsec tunnel
	Role IPSecRole `protobuf:"varint,3,opt,name=role,proto3,enum=ves.io.schema.site.IPSecRole" json:"role,omitempty"`
	// remoteAddress
	//
	// x-displayName: "Remote Address"
	// IP address of the remote end
	RemoteAddress string `protobuf:"bytes,4,opt,name=remoteAddress,proto3" json:"remoteAddress,omitempty"`
	// isLocal
	//
	// x-displayName: "Local"
	// Identifies if the ipsec connection is local to the ver node or not
	IsLocal bool `protobuf:"varint,5,opt,name=isLocal,proto3" json:"isLocal,omitempty"`
	// verNodeName
	//
	// x-displayName: "VER Node Name"
	// The VER node in the local site from which the connection is setup
	VerNodeName string `protobuf:"bytes,6,opt,name=verNodeName,proto3" json:"verNodeName,omitempty"`
}

func (m *IpsecConnectionStatus) Reset()                    { *m = IpsecConnectionStatus{} }
func (*IpsecConnectionStatus) ProtoMessage()               {}
func (*IpsecConnectionStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *IpsecConnectionStatus) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *IpsecConnectionStatus) GetState() IPSecState {
	if m != nil {
		return m.State
	}
	return UNKNOWN_STATE
}

func (m *IpsecConnectionStatus) GetRole() IPSecRole {
	if m != nil {
		return m.Role
	}
	return UNKNOWN_ROLE
}

func (m *IpsecConnectionStatus) GetRemoteAddress() string {
	if m != nil {
		return m.RemoteAddress
	}
	return ""
}

func (m *IpsecConnectionStatus) GetIsLocal() bool {
	if m != nil {
		return m.IsLocal
	}
	return false
}

func (m *IpsecConnectionStatus) GetVerNodeName() string {
	if m != nil {
		return m.VerNodeName
	}
	return ""
}

// Ares Connection Status
//
// x-displayName: "Ares Connection Status"
// Status of Ares Connection
type AresConnectionStatus struct {
	// url
	//
	// x-displayName: "URL"
	// url identifies the Ares server
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// state
	//
	// x-displayName: "State"
	// status of the connection to the server
	State VTRPState `protobuf:"varint,2,opt,name=state,proto3,enum=ves.io.schema.site.VTRPState" json:"state,omitempty"`
}

func (m *AresConnectionStatus) Reset()                    { *m = AresConnectionStatus{} }
func (*AresConnectionStatus) ProtoMessage()               {}
func (*AresConnectionStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *AresConnectionStatus) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *AresConnectionStatus) GetState() VTRPState {
	if m != nil {
		return m.State
	}
	return INIT
}

// Interface Status
//
// x-displayName: "Interface Status"
// Status of Interfaces in ver
type InterfaceStatus struct {
	// IP subnet
	//
	// x-displayName: "IP Subnet"
	// IP address of interface
	Ip *ves_io_schema3.IpSubnetType `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	// Mac Address
	//
	// x-displayName: "Mac Address"
	// Mac Address of interface
	Mac string `protobuf:"bytes,2,opt,name=mac,proto3" json:"mac,omitempty"`
	// Virtual Network Type
	//
	// x-displayName: "Virtual Network Type"
	// Virtual Network Type of interface
	NetworkType ves_io_schema3.VirtualNetworkType `protobuf:"varint,3,opt,name=network_type,json=networkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"network_type,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// Name of interface
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// IP Mode
	//
	// x-displayName: "IP Mode"
	// Mode of address assignment on the interface
	IpMode AddressMode `protobuf:"varint,5,opt,name=ip_mode,json=ipMode,proto3,enum=ves.io.schema.site.AddressMode" json:"ip_mode,omitempty"`
	// DHCP Server
	//
	// x-displayName: "DHCP Server"
	// Indicate if DHCP server is configured on the interface
	DhcpServer bool `protobuf:"varint,6,opt,name=dhcp_server,json=dhcpServer,proto3" json:"dhcp_server,omitempty"`
	// Virtual Network Name
	//
	// x-displayName: "Virtual Network Name"
	// Name of Virtual Network to which the interface belongs
	NetworkName string `protobuf:"bytes,8,opt,name=network_name,json=networkName,proto3" json:"network_name,omitempty"`
	// Link State
	// x-displayName: "Link State"
	// Link State for the interface
	LinkState bool `protobuf:"varint,9,opt,name=link_state,json=linkState,proto3" json:"link_state,omitempty"`
	// Active-Backup status
	// x-displayName: "Active/Backup status"
	// Active state for the interface
	ActiveState ActiveState `protobuf:"varint,10,opt,name=active_state,json=activeState,proto3,enum=ves.io.schema.site.ActiveState" json:"active_state,omitempty"`
	// Link quality status
	// x-displayName: "Link Quality"
	// Link quality for the interface
	LinkQuality LinkQuality `protobuf:"varint,11,opt,name=link_quality,json=linkQuality,proto3,enum=ves.io.schema.site.LinkQuality" json:"link_quality,omitempty"`
	// Link type
	// x-displayName: "Link type"
	// Link type for the interface
	LinkType LinkType `protobuf:"varint,12,opt,name=link_type,json=linkType,proto3,enum=ves.io.schema.site.LinkType" json:"link_type,omitempty"`
}

func (m *InterfaceStatus) Reset()                    { *m = InterfaceStatus{} }
func (*InterfaceStatus) ProtoMessage()               {}
func (*InterfaceStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *InterfaceStatus) GetIp() *ves_io_schema3.IpSubnetType {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *InterfaceStatus) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *InterfaceStatus) GetNetworkType() ves_io_schema3.VirtualNetworkType {
	if m != nil {
		return m.NetworkType
	}
	return ves_io_schema3.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *InterfaceStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InterfaceStatus) GetIpMode() AddressMode {
	if m != nil {
		return m.IpMode
	}
	return STATIC
}

func (m *InterfaceStatus) GetDhcpServer() bool {
	if m != nil {
		return m.DhcpServer
	}
	return false
}

func (m *InterfaceStatus) GetNetworkName() string {
	if m != nil {
		return m.NetworkName
	}
	return ""
}

func (m *InterfaceStatus) GetLinkState() bool {
	if m != nil {
		return m.LinkState
	}
	return false
}

func (m *InterfaceStatus) GetActiveState() ActiveState {
	if m != nil {
		return m.ActiveState
	}
	return STATE_UNKNOWN
}

func (m *InterfaceStatus) GetLinkQuality() LinkQuality {
	if m != nil {
		return m.LinkQuality
	}
	return QUALITY_UNKNOWN
}

func (m *InterfaceStatus) GetLinkType() LinkType {
	if m != nil {
		return m.LinkType
	}
	return LINK_TYPE_UNKNOWN
}

// Tunnel Connection Status
//
// x-displayName: "Tunnel Connection Status"
// Status of tunnel connection that a Ver has originated / terminated
type TunnelConnectionStatus struct {
	// url
	//
	// x-displayName: "URL"
	// url identifies the other end of the Ver for tunnel origination/termination
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// state
	//
	// x-displayName: "Connection State"
	// connection state which identifies whether connection is UP/DOWN
	State TunnelState `protobuf:"varint,2,opt,name=state,proto3,enum=ves.io.schema.site.TunnelState" json:"state,omitempty"`
	// role
	//
	// x-displayName: "Role"
	// indicates whether the ver is client/Originator or server/responder in tunnel
	Role TunnelRole `protobuf:"varint,3,opt,name=role,proto3,enum=ves.io.schema.site.TunnelRole" json:"role,omitempty"`
	// remoteAddress
	//
	// x-displayName: "Remote Address"
	// IP address of the remote end
	RemoteAddress string `protobuf:"bytes,4,opt,name=remoteAddress,proto3" json:"remoteAddress,omitempty"`
	// encap
	//
	// x-displayName: "Encapsulation Type"
	// Encapsulation type of tunnel
	Encap ves_io_schema4.TunnelEncapsulationType `protobuf:"varint,5,opt,name=encap,proto3,enum=ves.io.schema.TunnelEncapsulationType" json:"encap,omitempty"`
	// isLocal
	//
	// x-displayName: "Local"
	// Identifies if the ipsec connection is local to the ver node or not
	IsLocal bool `protobuf:"varint,6,opt,name=isLocal,proto3" json:"isLocal,omitempty"`
	// verNodeName
	//
	// x-displayName: "VER Node Name"
	// The VER node in the local site from which the connection is setup
	VerNodeName string `protobuf:"bytes,7,opt,name=verNodeName,proto3" json:"verNodeName,omitempty"`
	// tunnelName
	//
	// x-displayName: "Tunnel Name"
	// Tunnel name
	TunnelName string `protobuf:"bytes,8,opt,name=tunnelName,proto3" json:"tunnelName,omitempty"`
}

func (m *TunnelConnectionStatus) Reset()                    { *m = TunnelConnectionStatus{} }
func (*TunnelConnectionStatus) ProtoMessage()               {}
func (*TunnelConnectionStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *TunnelConnectionStatus) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *TunnelConnectionStatus) GetState() TunnelState {
	if m != nil {
		return m.State
	}
	return UNKNOWN_TUNNEL_STATE
}

func (m *TunnelConnectionStatus) GetRole() TunnelRole {
	if m != nil {
		return m.Role
	}
	return UNKNOWN_TUNNEL_ROLE
}

func (m *TunnelConnectionStatus) GetRemoteAddress() string {
	if m != nil {
		return m.RemoteAddress
	}
	return ""
}

func (m *TunnelConnectionStatus) GetEncap() ves_io_schema4.TunnelEncapsulationType {
	if m != nil {
		return m.Encap
	}
	return ves_io_schema4.IPSEC_PKI
}

func (m *TunnelConnectionStatus) GetIsLocal() bool {
	if m != nil {
		return m.IsLocal
	}
	return false
}

func (m *TunnelConnectionStatus) GetVerNodeName() string {
	if m != nil {
		return m.VerNodeName
	}
	return ""
}

func (m *TunnelConnectionStatus) GetTunnelName() string {
	if m != nil {
		return m.TunnelName
	}
	return ""
}

// Volterra Software Status
//
// x-displayName: "Volterra Software Status"
// Volterra software version running in the site
type VolterraSoftwareStatus struct {
	// available_version
	//
	// x-displayName: "Available Version"
	// available version represent volterra software version ready to be upgraded in the site.
	AvailableVersion string `protobuf:"bytes,1,opt,name=available_version,json=availableVersion,proto3" json:"available_version,omitempty"`
	// deployment_state
	//
	// x-displayName: "Deployment State"
	// deployment state shows status of last applied deployment in the site
	DeploymentState *DeploymentState `protobuf:"bytes,2,opt,name=deployment_state,json=deploymentState" json:"deployment_state,omitempty"`
}

func (m *VolterraSoftwareStatus) Reset()                    { *m = VolterraSoftwareStatus{} }
func (*VolterraSoftwareStatus) ProtoMessage()               {}
func (*VolterraSoftwareStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

func (m *VolterraSoftwareStatus) GetAvailableVersion() string {
	if m != nil {
		return m.AvailableVersion
	}
	return ""
}

func (m *VolterraSoftwareStatus) GetDeploymentState() *DeploymentState {
	if m != nil {
		return m.DeploymentState
	}
	return nil
}

// Volterra Operating system Status
//
// x-displayName: "Volterra Operating System Status"
// Volterra operating system version running in the site
type OperatingSystemStatus struct {
	// available_version
	//
	// x-displayName: "Available Version"
	// available version represent volterra operating system version ready to be upgraded in the site.
	AvailableVersion string `protobuf:"bytes,1,opt,name=available_version,json=availableVersion,proto3" json:"available_version,omitempty"`
	// deployment_state
	//
	// x-displayName: "Deployment State"
	// deployment state shows status of last applied deployment in the site
	DeploymentState *DeploymentState `protobuf:"bytes,2,opt,name=deployment_state,json=deploymentState" json:"deployment_state,omitempty"`
}

func (m *OperatingSystemStatus) Reset()                    { *m = OperatingSystemStatus{} }
func (*OperatingSystemStatus) ProtoMessage()               {}
func (*OperatingSystemStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *OperatingSystemStatus) GetAvailableVersion() string {
	if m != nil {
		return m.AvailableVersion
	}
	return ""
}

func (m *OperatingSystemStatus) GetDeploymentState() *DeploymentState {
	if m != nil {
		return m.DeploymentState
	}
	return nil
}

// Deployment State
//
// x-displayName: "Deployment State"
// Details of Deployment
type DeploymentState struct {
	// version
	//
	// x-displayName: "Version"
	// Version name for this deployment state.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// modification_timestamp
	//
	// x-displayName: "Modified At"
	// ModificationTimestamp is a timestamp representing the server time when deployment state was
	// last modified.
	ModificationTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=modification_timestamp,json=modificationTimestamp" json:"modification_timestamp,omitempty"`
	// result
	//
	// x-displayName: "Result"
	// Result of the deployment, one of Success, Failure, Unknown
	Result string `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	// message
	//
	// x-displayName: "Message"
	// A verbose human readable explanation of the reason
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	// Phase
	//
	// x-displayName: "Phase"
	// Phase of last deployment upgrade with options upgrade triggered, upgrade in-progress and upgrade completed
	Phase SoftwareUpgradePhase `protobuf:"varint,5,opt,name=phase,proto3,enum=ves.io.schema.site.SoftwareUpgradePhase" json:"phase,omitempty"`
}

func (m *DeploymentState) Reset()                    { *m = DeploymentState{} }
func (*DeploymentState) ProtoMessage()               {}
func (*DeploymentState) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *DeploymentState) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DeploymentState) GetModificationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *DeploymentState) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *DeploymentState) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *DeploymentState) GetPhase() SoftwareUpgradePhase {
	if m != nil {
		return m.Phase
	}
	return UPGRADE_INVALID
}

// Scaling Status
//
// x-displayName: "Scaling Status"
// Details of Scaling
type ScalingStatus struct {
	// Scaling phase
	//
	// x-displayName: "Phase"
	// Phase of scaling action with options scaling, failed, done
	Phase ScalingPhase `protobuf:"varint,1,opt,name=phase,proto3,enum=ves.io.schema.site.ScalingPhase" json:"phase,omitempty"`
	// Message
	//
	// x-displayName: "Message"
	// provides description of scaling action, eg. "scaled to 3 nodes"
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// Current pool node count
	//
	// x-displayName: "Current Pool Count"
	// Current number of pool nodes in cluster
	PoolNodeCountCurrent int32 `protobuf:"varint,3,opt,name=pool_node_count_current,json=poolNodeCountCurrent,proto3" json:"pool_node_count_current,omitempty"`
	// Desired pool node count
	//
	// x-displayName: "Desired Pool Count"
	// Desired pool node count defines how many nodes should be in a cluster after scaling
	PoolNodeCountTarget int32 `protobuf:"varint,4,opt,name=pool_node_count_target,json=poolNodeCountTarget,proto3" json:"pool_node_count_target,omitempty"`
}

func (m *ScalingStatus) Reset()                    { *m = ScalingStatus{} }
func (*ScalingStatus) ProtoMessage()               {}
func (*ScalingStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *ScalingStatus) GetPhase() ScalingPhase {
	if m != nil {
		return m.Phase
	}
	return SCALING_INVALID
}

func (m *ScalingStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ScalingStatus) GetPoolNodeCountCurrent() int32 {
	if m != nil {
		return m.PoolNodeCountCurrent
	}
	return 0
}

func (m *ScalingStatus) GetPoolNodeCountTarget() int32 {
	if m != nil {
		return m.PoolNodeCountTarget
	}
	return 0
}

type NodeInfo struct {
	// Hostname
	//
	// x-displayName: "Hostname"
	// Hostname of the node
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Role
	//
	// x-displayName: "Node Role"
	// x-example: "k8s-master, k8s-minion"
	// Role of registered node. Roles are used by system to determine what control services they should enforce.
	// k8s-master represents Kubernetes Master
	Role []string `protobuf:"bytes,2,rep,name=role" json:"role,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

func (m *NodeInfo) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *NodeInfo) GetRole() []string {
	if m != nil {
		return m.Role
	}
	return nil
}

// OsInfo
//
// x-displayName: "Os Info"
// OsInfo holds information about host OS and HW
type OsInfo struct {
	// os
	//
	// x-displayName: "Operating System"
	// os holds all general OS information
	Os *OS `protobuf:"bytes,1,opt,name=os" json:"os,omitempty"`
	// product
	//
	// x-displayName: "Product"
	// HW product information
	Product *Product `protobuf:"bytes,2,opt,name=product" json:"product,omitempty"`
	// board
	//
	// x-displayName: "Board"
	// HW board information
	Board *Board `protobuf:"bytes,3,opt,name=board" json:"board,omitempty"`
	// chassis
	//
	// x-displayName: "Chassis"
	// HW chassis information
	Chassis *Chassis `protobuf:"bytes,4,opt,name=chassis" json:"chassis,omitempty"`
	//  bios
	//
	// x-displayName: "BIOS"
	// Information about bios
	Bios *Bios `protobuf:"bytes,5,opt,name=bios" json:"bios,omitempty"`
	// cpu
	//
	// x-displayName: "CPU"
	// HW CPU information
	Cpu *Cpu `protobuf:"bytes,6,opt,name=cpu" json:"cpu,omitempty"`
	// memory
	//
	// x-displayName: "Memory"
	// HW memory information
	Memory *Memory `protobuf:"bytes,7,opt,name=memory" json:"memory,omitempty"`
	// storage
	//
	// x-displayName: "Storage"
	// List of storage devices in server
	Storage []*StorageDevice `protobuf:"bytes,8,rep,name=storage" json:"storage,omitempty"`
	// network
	//
	// x-displayName: "Network"
	// List of network devices in server
	Network []*NetworkDevice `protobuf:"bytes,9,rep,name=network" json:"network,omitempty"`
	// kernel
	//
	// x-displayName: "Kernel"
	// kernel information
	Kernel *Kernel `protobuf:"bytes,10,opt,name=kernel" json:"kernel,omitempty"`
	// USBDevice
	//
	// x-displayName: "USB devices"
	// List of USB devices in server
	Usb []*USBDevice `protobuf:"bytes,11,rep,name=usb" json:"usb,omitempty"`
}

func (m *OsInfo) Reset()                    { *m = OsInfo{} }
func (*OsInfo) ProtoMessage()               {}
func (*OsInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

func (m *OsInfo) GetOs() *OS {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *OsInfo) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *OsInfo) GetBoard() *Board {
	if m != nil {
		return m.Board
	}
	return nil
}

func (m *OsInfo) GetChassis() *Chassis {
	if m != nil {
		return m.Chassis
	}
	return nil
}

func (m *OsInfo) GetBios() *Bios {
	if m != nil {
		return m.Bios
	}
	return nil
}

func (m *OsInfo) GetCpu() *Cpu {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *OsInfo) GetMemory() *Memory {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *OsInfo) GetStorage() []*StorageDevice {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *OsInfo) GetNetwork() []*NetworkDevice {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *OsInfo) GetKernel() *Kernel {
	if m != nil {
		return m.Kernel
	}
	return nil
}

func (m *OsInfo) GetUsb() []*USBDevice {
	if m != nil {
		return m.Usb
	}
	return nil
}

// OS
//
// x-displayName: "OS"
// Details of Operating System
type OS struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "Container Linux by CoreOS 1855.4.0 (Rhyolite)"
	// Name of OS
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// x-example: "coreos"
	// Vendor of OS
	Vendor string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// x-example: "1855.4.0"
	// Version of OS
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// release
	//
	// x-displayName: "Release"
	// x-example: "20.04"
	// Release of the OS
	Release string `protobuf:"bytes,4,opt,name=release,proto3" json:"release,omitempty"`
	// architecture
	//
	// x-displayName: "Architecture"
	// x-example: "amd64"
	// Architecture of OS
	Architecture string `protobuf:"bytes,5,opt,name=architecture,proto3" json:"architecture,omitempty"`
}

func (m *OS) Reset()                    { *m = OS{} }
func (*OS) ProtoMessage()               {}
func (*OS) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

func (m *OS) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OS) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *OS) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *OS) GetRelease() string {
	if m != nil {
		return m.Release
	}
	return ""
}

func (m *OS) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

// Kernel Information
//
// x-displayName: "Kernel"
// Kernel information
type Kernel struct {
	// release
	//
	// x-displayName: "Release"
	// kernel release
	Release string `protobuf:"bytes,1,opt,name=release,proto3" json:"release,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// kernel version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// architecture
	//
	// x-displayName: "Architecture"
	// kernel architecture
	Architecture string `protobuf:"bytes,3,opt,name=architecture,proto3" json:"architecture,omitempty"`
}

func (m *Kernel) Reset()                    { *m = Kernel{} }
func (*Kernel) ProtoMessage()               {}
func (*Kernel) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

func (m *Kernel) GetRelease() string {
	if m != nil {
		return m.Release
	}
	return ""
}

func (m *Kernel) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Kernel) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

// Product Information
//
// x-displayName: "Product Information"
// Product information
type Product struct {
	// name
	//
	// x-displayName: "Name"
	// product name, eg. for aws m5a.xlarge. Info taken from /sys/class/dmi/id/product_name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// vendor name, eg. for aws Amazon EC2. Info taken from /sys/class/dmi/id/product_vendor
	Vendor string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// version name. Info taken from /sys/class/dmi/id/product_version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// serial
	//
	// x-displayName: "Serial Number"
	// serial number, eg. for aws ec254b6d-9676-1a51-8b10-21370dbdc3e5. Info taken from /sys/class/dmi/id/product_serial
	Serial string `protobuf:"bytes,4,opt,name=serial,proto3" json:"serial,omitempty"`
}

func (m *Product) Reset()                    { *m = Product{} }
func (*Product) ProtoMessage()               {}
func (*Product) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20} }

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Product) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Product) GetSerial() string {
	if m != nil {
		return m.Serial
	}
	return ""
}

// Board Details
//
// x-displayName: "Board Details"
// Board information
type Board struct {
	// name
	//
	// x-displayName: "Name"
	// information from /sys/class/dmi/id/board_name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// information from /sys/class/dmi/id/board_vendor
	Vendor string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// information from /sys/class/dmi/id/board_version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// serial
	//
	// x-displayName: "Serial Number"
	// information from /sys/class/dmi/id/board_serial
	Serial string `protobuf:"bytes,4,opt,name=serial,proto3" json:"serial,omitempty"`
	// asset_tag
	//
	// x-displayName: "Asset Tag"
	// information from /sys/class/dmi/id/board_asset_tag
	AssetTag string `protobuf:"bytes,5,opt,name=asset_tag,json=assetTag,proto3" json:"asset_tag,omitempty"`
}

func (m *Board) Reset()                    { *m = Board{} }
func (*Board) ProtoMessage()               {}
func (*Board) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{21} }

func (m *Board) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Board) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Board) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Board) GetSerial() string {
	if m != nil {
		return m.Serial
	}
	return ""
}

func (m *Board) GetAssetTag() string {
	if m != nil {
		return m.AssetTag
	}
	return ""
}

// Chassis Details
//
// x-displayName: "Chassis Details"
// Chassis information.
type Chassis struct {
	// type
	//
	// x-displayName: "Type"
	// information from /sys/class/dmi/id/chassis_type
	Type uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// information from /sys/class/dmi/id/chassis_vendor
	Vendor string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// information from /sys/class/dmi/id/chassis_version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// serial
	//
	// x-displayName: "Serial Number"
	// information from /sys/class/dmi/id/chassis_serial
	Serial string `protobuf:"bytes,4,opt,name=serial,proto3" json:"serial,omitempty"`
	// asset_tag
	//
	// x-displayName: "Asset Tag"
	// information from /sys/class/dmi/id/chassis_asset_tag
	AssetTag string `protobuf:"bytes,5,opt,name=asset_tag,json=assetTag,proto3" json:"asset_tag,omitempty"`
}

func (m *Chassis) Reset()                    { *m = Chassis{} }
func (*Chassis) ProtoMessage()               {}
func (*Chassis) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{22} }

func (m *Chassis) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Chassis) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Chassis) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Chassis) GetSerial() string {
	if m != nil {
		return m.Serial
	}
	return ""
}

func (m *Chassis) GetAssetTag() string {
	if m != nil {
		return m.AssetTag
	}
	return ""
}

// Bios Data
//
// x-displayName: "Bios Data"
// BIOS information.
type Bios struct {
	// vendor
	//
	// x-displayName: "Vendor"
	// information from /sys/class/dmi/id/bios_vendor
	Vendor string `protobuf:"bytes,1,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// information from /sys/class/dmi/id/bios_version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// date
	//
	// x-displayName: "Date"
	// information from /sys/class/dmi/id/bios_date
	Date string `protobuf:"bytes,3,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *Bios) Reset()                    { *m = Bios{} }
func (*Bios) ProtoMessage()               {}
func (*Bios) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{23} }

func (m *Bios) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Bios) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Bios) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

// Cpu information
//
// x-displayName: "Cpu Information"
// CPU information
type Cpu struct {
	// vendor
	//
	// x-displayName: "Vendor"
	// CPU vendor
	Vendor string `protobuf:"bytes,1,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// model
	//
	// x-displayName: "Model"
	// CPU model
	Model string `protobuf:"bytes,2,opt,name=model,proto3" json:"model,omitempty"`
	// speed
	//
	// x-displayName: "Speed"
	// CPU clock rate in MHz
	Speed uint32 `protobuf:"varint,3,opt,name=speed,proto3" json:"speed,omitempty"`
	// cache
	//
	// x-displayName: "Cache"
	// CPU cache size in KB
	Cache uint32 `protobuf:"varint,4,opt,name=cache,proto3" json:"cache,omitempty"`
	// cpus
	//
	// x-displayName: "CPUs"
	// number of physical CPUs
	Cpus uint32 `protobuf:"varint,5,opt,name=cpus,proto3" json:"cpus,omitempty"`
	// cores
	//
	// x-displayName: "Cores"
	// number of physical CPU cores
	Cores uint32 `protobuf:"varint,6,opt,name=cores,proto3" json:"cores,omitempty"`
	// threads
	//
	// x-displayName: "Threads"
	// number of logical (HT) CPU cores
	Threads uint32 `protobuf:"varint,7,opt,name=threads,proto3" json:"threads,omitempty"`
}

func (m *Cpu) Reset()                    { *m = Cpu{} }
func (*Cpu) ProtoMessage()               {}
func (*Cpu) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{24} }

func (m *Cpu) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Cpu) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *Cpu) GetSpeed() uint32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *Cpu) GetCache() uint32 {
	if m != nil {
		return m.Cache
	}
	return 0
}

func (m *Cpu) GetCpus() uint32 {
	if m != nil {
		return m.Cpus
	}
	return 0
}

func (m *Cpu) GetCores() uint32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *Cpu) GetThreads() uint32 {
	if m != nil {
		return m.Threads
	}
	return 0
}

// Memory Information
//
// x-displayName: "Memory Information"
// Memory information.
type Memory struct {
	// type
	//
	// x-displayName: "Type"
	// type of memory, eg. DDR4
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// speed
	//
	// x-displayName: "Speed"
	// RAM data rate in MT/s
	Speed uint32 `protobuf:"varint,2,opt,name=speed,proto3" json:"speed,omitempty"`
	// size_mb
	//
	// x-displayName: "RAM"
	// RAM size in MB
	SizeMb uint32 `protobuf:"varint,3,opt,name=size_mb,json=sizeMb,proto3" json:"size_mb,omitempty"`
}

func (m *Memory) Reset()                    { *m = Memory{} }
func (*Memory) ProtoMessage()               {}
func (*Memory) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{25} }

func (m *Memory) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Memory) GetSpeed() uint32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *Memory) GetSizeMb() uint32 {
	if m != nil {
		return m.SizeMb
	}
	return 0
}

// Storage Information
//
// x-displayName: "Storage Information"
// StorageDevice information.
type StorageDevice struct {
	// name
	//
	// x-displayName: "Name"
	// name of device, eg. nvme0n1
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// driver
	//
	// x-displayName: "Driver"
	// driver of device
	Driver string `protobuf:"bytes,2,opt,name=driver,proto3" json:"driver,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// vendor of device
	Vendor string `protobuf:"bytes,3,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// model
	//
	// x-displayName: "Model"
	// model of device
	Model string `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	// serial
	//
	// x-displayName: "Serial Number"
	// serial of device
	Serial string `protobuf:"bytes,5,opt,name=serial,proto3" json:"serial,omitempty"`
	// size_gb
	//
	// x-displayName: "Size(GB)"
	// device size in GB
	SizeGb uint32 `protobuf:"varint,6,opt,name=size_gb,json=sizeGb,proto3" json:"size_gb,omitempty"`
}

func (m *StorageDevice) Reset()                    { *m = StorageDevice{} }
func (*StorageDevice) ProtoMessage()               {}
func (*StorageDevice) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{26} }

func (m *StorageDevice) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StorageDevice) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *StorageDevice) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *StorageDevice) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *StorageDevice) GetSerial() string {
	if m != nil {
		return m.Serial
	}
	return ""
}

func (m *StorageDevice) GetSizeGb() uint32 {
	if m != nil {
		return m.SizeGb
	}
	return 0
}

// Network Device Information
//
// x-displayName: "Network Device Information"
// NetworkDevice information.
type NetworkDevice struct {
	// name
	//
	// x-displayName: "Name"
	// name of device, eg. eth0
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// driver
	//
	// x-displayName: "Driver"
	// driver of device, eg. e1000e
	Driver string `protobuf:"bytes,2,opt,name=driver,proto3" json:"driver,omitempty"`
	// ip_address
	//
	// x-displayName: "IP Address"
	// ip address on interface
	IpAddress []string `protobuf:"bytes,3,rep,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	// mac_address
	//
	// x-displayName: "MAC Address"
	// mac address on interface
	MacAddress string `protobuf:"bytes,4,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// port
	//
	// x-displayName: "Port"
	// used port, eg. tp
	Port string `protobuf:"bytes,5,opt,name=port,proto3" json:"port,omitempty"`
	// speed
	//
	// x-displayName: "Speed"
	// device max supported speed in Mbps
	Speed uint32 `protobuf:"varint,6,opt,name=speed,proto3" json:"speed,omitempty"`
	// Link quality status
	// x-displayName: "Link Quality"
	// Link quality for the interface
	LinkQuality LinkQuality `protobuf:"varint,7,opt,name=link_quality,json=linkQuality,proto3,enum=ves.io.schema.site.LinkQuality" json:"link_quality,omitempty"`
	// Link type
	// x-displayName: "Link type"
	// Link type for the interface
	LinkType LinkType `protobuf:"varint,8,opt,name=link_type,json=linkType,proto3,enum=ves.io.schema.site.LinkType" json:"link_type,omitempty"`
}

func (m *NetworkDevice) Reset()                    { *m = NetworkDevice{} }
func (*NetworkDevice) ProtoMessage()               {}
func (*NetworkDevice) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{27} }

func (m *NetworkDevice) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkDevice) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *NetworkDevice) GetIpAddress() []string {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *NetworkDevice) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *NetworkDevice) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *NetworkDevice) GetSpeed() uint32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *NetworkDevice) GetLinkQuality() LinkQuality {
	if m != nil {
		return m.LinkQuality
	}
	return QUALITY_UNKNOWN
}

func (m *NetworkDevice) GetLinkType() LinkType {
	if m != nil {
		return m.LinkType
	}
	return LINK_TYPE_UNKNOWN
}

// USB device
//
// x-displayName: "USB Device informaton"
// Information about USB device
type USBDevice struct {
	// bus
	//
	// x-displayName: "Bus"
	// x-example: "1"
	// The bus on which the device was detected in decimal
	Bus uint32 `protobuf:"varint,1,opt,name=bus,proto3" json:"bus,omitempty"`
	// address
	//
	// x-displayName: "Address"
	// x-example: "4"
	// Address of the device on the bus in decimal
	Address uint32 `protobuf:"varint,2,opt,name=address,proto3" json:"address,omitempty"`
	// port
	//
	// x-displayName: "Port"
	// x-example: "3"
	// Port on which the device was detected in decimal
	Port uint32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "NetVista Full Width Keyboard (IBM Corp.)"
	// Device description
	Description string `protobuf:"bytes,9,opt,name=description,proto3" json:"description,omitempty"`
	// vendor_name
	//
	// x-displayName: "Vendor name"
	// x-example: "IBM Corp."
	// Vendor ID translated to name (if available)
	VendorName string `protobuf:"bytes,10,opt,name=vendor_name,json=vendorName,proto3" json:"vendor_name,omitempty"`
	// product_name
	//
	// x-displayName: "Product name"
	// x-example: "NetVista Full Width Keyboard"
	// Product ID translated to name (if available)
	ProductName string `protobuf:"bytes,11,opt,name=product_name,json=productName,proto3" json:"product_name,omitempty"`
	// i_serial_number
	//
	// x-displayName: "iSerialNumber"
	// x-example: "0000:00:14.0"
	// Index of Serial Number String Descriptor
	ISerial string `protobuf:"bytes,14,opt,name=i_serial,json=iSerial,proto3" json:"i_serial,omitempty"`
	// id_vendor
	//
	// x-displayName: "Vendor ID"
	// x-example: "0x1d6b"
	// Vendor ID (Assigned by USB Org) in hex
	IdVendor string `protobuf:"bytes,15,opt,name=id_vendor,json=idVendor,proto3" json:"id_vendor,omitempty"`
	// id_product
	//
	// x-displayName: "Product ID"
	// x-example: "0x0002"
	// Product ID (Assigned by Manufacturer) in hex
	IdProduct string `protobuf:"bytes,16,opt,name=id_product,json=idProduct,proto3" json:"id_product,omitempty"`
	// i_manufacturer
	//
	// x-displayName: "Manufacturer"
	// x-example: "Voltera"
	// Manufacturer name
	IManufacturer string `protobuf:"bytes,17,opt,name=i_manufacturer,json=iManufacturer,proto3" json:"i_manufacturer,omitempty"`
	// speed
	//
	// x-displayName: "Speed"
	// x-example: "high"
	// The negotiated operating speed for the device
	Speed string `protobuf:"bytes,18,opt,name=speed,proto3" json:"speed,omitempty"`
	// bcd_usb
	//
	// x-displayName: "BCD Spec"
	// x-example: "2.0"
	// USB Specification Release Number
	BcdUsb string `protobuf:"bytes,19,opt,name=bcd_usb,json=bcdUsb,proto3" json:"bcd_usb,omitempty"`
	// bcd_device
	//
	// x-displayName: "BCD Device"
	// x-example: "5.05"
	// The device version
	BcdDevice string `protobuf:"bytes,20,opt,name=bcd_device,json=bcdDevice,proto3" json:"bcd_device,omitempty"`
	// b_device_class
	//
	// x-displayName: "Class"
	// x-example: "hub"
	// The class of this device
	BDeviceClass string `protobuf:"bytes,21,opt,name=b_device_class,json=bDeviceClass,proto3" json:"b_device_class,omitempty"`
	// b_device_sub_class
	//
	// x-displayName: "Subclass"
	// x-example: "hub"
	// The sub-class (within the class) of this device
	BDeviceSubClass string `protobuf:"bytes,22,opt,name=b_device_sub_class,json=bDeviceSubClass,proto3" json:"b_device_sub_class,omitempty"`
	// b_device_protocol
	//
	// x-displayName: "Protocol"
	// x-example: "0002"
	// The protocol (within the sub-class) of this device
	BDeviceProtocol string `protobuf:"bytes,23,opt,name=b_device_protocol,json=bDeviceProtocol,proto3" json:"b_device_protocol,omitempty"`
	// b_max_packet_size
	//
	// x-displayName: "Max packet size"
	// x-example: "64"
	// Maximum size of the control transfer
	BMaxPacketSize uint32 `protobuf:"varint,24,opt,name=b_max_packet_size,json=bMaxPacketSize,proto3" json:"b_max_packet_size,omitempty"`
	// i_product
	//
	// x-displayName: "Device product"
	// x-example: "xHCI Host Controller"
	// Product name reported by device
	IProduct string `protobuf:"bytes,25,opt,name=i_product,json=iProduct,proto3" json:"i_product,omitempty"`
}

func (m *USBDevice) Reset()                    { *m = USBDevice{} }
func (*USBDevice) ProtoMessage()               {}
func (*USBDevice) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{28} }

func (m *USBDevice) GetBus() uint32 {
	if m != nil {
		return m.Bus
	}
	return 0
}

func (m *USBDevice) GetAddress() uint32 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *USBDevice) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *USBDevice) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *USBDevice) GetVendorName() string {
	if m != nil {
		return m.VendorName
	}
	return ""
}

func (m *USBDevice) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *USBDevice) GetISerial() string {
	if m != nil {
		return m.ISerial
	}
	return ""
}

func (m *USBDevice) GetIdVendor() string {
	if m != nil {
		return m.IdVendor
	}
	return ""
}

func (m *USBDevice) GetIdProduct() string {
	if m != nil {
		return m.IdProduct
	}
	return ""
}

func (m *USBDevice) GetIManufacturer() string {
	if m != nil {
		return m.IManufacturer
	}
	return ""
}

func (m *USBDevice) GetSpeed() string {
	if m != nil {
		return m.Speed
	}
	return ""
}

func (m *USBDevice) GetBcdUsb() string {
	if m != nil {
		return m.BcdUsb
	}
	return ""
}

func (m *USBDevice) GetBcdDevice() string {
	if m != nil {
		return m.BcdDevice
	}
	return ""
}

func (m *USBDevice) GetBDeviceClass() string {
	if m != nil {
		return m.BDeviceClass
	}
	return ""
}

func (m *USBDevice) GetBDeviceSubClass() string {
	if m != nil {
		return m.BDeviceSubClass
	}
	return ""
}

func (m *USBDevice) GetBDeviceProtocol() string {
	if m != nil {
		return m.BDeviceProtocol
	}
	return ""
}

func (m *USBDevice) GetBMaxPacketSize() uint32 {
	if m != nil {
		return m.BMaxPacketSize
	}
	return 0
}

func (m *USBDevice) GetIProduct() string {
	if m != nil {
		return m.IProduct
	}
	return ""
}

// SiteStatusMetricsFieldData
//
// x-displayName: "Site Status Metrics Field Data"
// Site Status Field Data contains key/value pair for a field
type SiteStatusMetricsFieldData struct {
	// Key
	//
	// x-displayName: "Key"
	// Key contains name/value pair.
	// For SITE_RE_IN_THROUGHPUT, the key will be "name": "<RE-name>"
	// For SITE_NODE_IF_IN_THROUGHPUT, the key will be "name": "<Interface-name>"
	Key map[string]string `protobuf:"bytes,1,rep,name=key" json:"key,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Value
	//
	// x-displayName: "Value"
	// List of metric values
	Value []*ves_io_schema4.MetricValue `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
}

func (m *SiteStatusMetricsFieldData) Reset()      { *m = SiteStatusMetricsFieldData{} }
func (*SiteStatusMetricsFieldData) ProtoMessage() {}
func (*SiteStatusMetricsFieldData) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{29}
}

func (m *SiteStatusMetricsFieldData) GetKey() map[string]string {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SiteStatusMetricsFieldData) GetValue() []*ves_io_schema4.MetricValue {
	if m != nil {
		return m.Value
	}
	return nil
}

// SiteStatusMetricsData
//
// x-displayName: "Site Status Metrics Data"
// Site Status Data contains name of the field and the corresponding data
type SiteStatusMetricsData struct {
	// Field
	//
	// x-displayName: "Field"
	// Site Status Metrics Field
	Field SiteStatusMetricsField `protobuf:"varint,1,opt,name=field,proto3,enum=ves.io.schema.site.SiteStatusMetricsField" json:"field,omitempty"`
	// Data
	//
	// x-displayName: "Data"
	// List of metric data
	Data []*SiteStatusMetricsFieldData `protobuf:"bytes,2,rep,name=data" json:"data,omitempty"`
}

func (m *SiteStatusMetricsData) Reset()                    { *m = SiteStatusMetricsData{} }
func (*SiteStatusMetricsData) ProtoMessage()               {}
func (*SiteStatusMetricsData) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{30} }

func (m *SiteStatusMetricsData) GetField() SiteStatusMetricsField {
	if m != nil {
		return m.Field
	}
	return SITE_ACTIVE_FLOW_COUNT
}

func (m *SiteStatusMetricsData) GetData() []*SiteStatusMetricsFieldData {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*Coordinates)(nil), "ves.io.schema.site.Coordinates")
	golang_proto.RegisterType((*Coordinates)(nil), "ves.io.schema.site.Coordinates")
	proto.RegisterType((*K8SApiServerParameters)(nil), "ves.io.schema.site.K8SApiServerParameters")
	golang_proto.RegisterType((*K8SApiServerParameters)(nil), "ves.io.schema.site.K8SApiServerParameters")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.site.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.site.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.site.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.site.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.site.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.site.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.site.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.site.GetSpecType")
	proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.site.VerStatusType")
	golang_proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.site.VerStatusType")
	proto.RegisterType((*VerMasterStatusType)(nil), "ves.io.schema.site.VerMasterStatusType")
	golang_proto.RegisterType((*VerMasterStatusType)(nil), "ves.io.schema.site.VerMasterStatusType")
	proto.RegisterType((*IpsecConnectionStatus)(nil), "ves.io.schema.site.IpsecConnectionStatus")
	golang_proto.RegisterType((*IpsecConnectionStatus)(nil), "ves.io.schema.site.IpsecConnectionStatus")
	proto.RegisterType((*AresConnectionStatus)(nil), "ves.io.schema.site.AresConnectionStatus")
	golang_proto.RegisterType((*AresConnectionStatus)(nil), "ves.io.schema.site.AresConnectionStatus")
	proto.RegisterType((*InterfaceStatus)(nil), "ves.io.schema.site.InterfaceStatus")
	golang_proto.RegisterType((*InterfaceStatus)(nil), "ves.io.schema.site.InterfaceStatus")
	proto.RegisterType((*TunnelConnectionStatus)(nil), "ves.io.schema.site.TunnelConnectionStatus")
	golang_proto.RegisterType((*TunnelConnectionStatus)(nil), "ves.io.schema.site.TunnelConnectionStatus")
	proto.RegisterType((*VolterraSoftwareStatus)(nil), "ves.io.schema.site.VolterraSoftwareStatus")
	golang_proto.RegisterType((*VolterraSoftwareStatus)(nil), "ves.io.schema.site.VolterraSoftwareStatus")
	proto.RegisterType((*OperatingSystemStatus)(nil), "ves.io.schema.site.OperatingSystemStatus")
	golang_proto.RegisterType((*OperatingSystemStatus)(nil), "ves.io.schema.site.OperatingSystemStatus")
	proto.RegisterType((*DeploymentState)(nil), "ves.io.schema.site.DeploymentState")
	golang_proto.RegisterType((*DeploymentState)(nil), "ves.io.schema.site.DeploymentState")
	proto.RegisterType((*ScalingStatus)(nil), "ves.io.schema.site.ScalingStatus")
	golang_proto.RegisterType((*ScalingStatus)(nil), "ves.io.schema.site.ScalingStatus")
	proto.RegisterType((*NodeInfo)(nil), "ves.io.schema.site.NodeInfo")
	golang_proto.RegisterType((*NodeInfo)(nil), "ves.io.schema.site.NodeInfo")
	proto.RegisterType((*OsInfo)(nil), "ves.io.schema.site.OsInfo")
	golang_proto.RegisterType((*OsInfo)(nil), "ves.io.schema.site.OsInfo")
	proto.RegisterType((*OS)(nil), "ves.io.schema.site.OS")
	golang_proto.RegisterType((*OS)(nil), "ves.io.schema.site.OS")
	proto.RegisterType((*Kernel)(nil), "ves.io.schema.site.Kernel")
	golang_proto.RegisterType((*Kernel)(nil), "ves.io.schema.site.Kernel")
	proto.RegisterType((*Product)(nil), "ves.io.schema.site.Product")
	golang_proto.RegisterType((*Product)(nil), "ves.io.schema.site.Product")
	proto.RegisterType((*Board)(nil), "ves.io.schema.site.Board")
	golang_proto.RegisterType((*Board)(nil), "ves.io.schema.site.Board")
	proto.RegisterType((*Chassis)(nil), "ves.io.schema.site.Chassis")
	golang_proto.RegisterType((*Chassis)(nil), "ves.io.schema.site.Chassis")
	proto.RegisterType((*Bios)(nil), "ves.io.schema.site.Bios")
	golang_proto.RegisterType((*Bios)(nil), "ves.io.schema.site.Bios")
	proto.RegisterType((*Cpu)(nil), "ves.io.schema.site.Cpu")
	golang_proto.RegisterType((*Cpu)(nil), "ves.io.schema.site.Cpu")
	proto.RegisterType((*Memory)(nil), "ves.io.schema.site.Memory")
	golang_proto.RegisterType((*Memory)(nil), "ves.io.schema.site.Memory")
	proto.RegisterType((*StorageDevice)(nil), "ves.io.schema.site.StorageDevice")
	golang_proto.RegisterType((*StorageDevice)(nil), "ves.io.schema.site.StorageDevice")
	proto.RegisterType((*NetworkDevice)(nil), "ves.io.schema.site.NetworkDevice")
	golang_proto.RegisterType((*NetworkDevice)(nil), "ves.io.schema.site.NetworkDevice")
	proto.RegisterType((*USBDevice)(nil), "ves.io.schema.site.USBDevice")
	golang_proto.RegisterType((*USBDevice)(nil), "ves.io.schema.site.USBDevice")
	proto.RegisterType((*SiteStatusMetricsFieldData)(nil), "ves.io.schema.site.SiteStatusMetricsFieldData")
	golang_proto.RegisterType((*SiteStatusMetricsFieldData)(nil), "ves.io.schema.site.SiteStatusMetricsFieldData")
	proto.RegisterType((*SiteStatusMetricsData)(nil), "ves.io.schema.site.SiteStatusMetricsData")
	golang_proto.RegisterType((*SiteStatusMetricsData)(nil), "ves.io.schema.site.SiteStatusMetricsData")
	proto.RegisterEnum("ves.io.schema.site.SiteType", SiteType_name, SiteType_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteType", SiteType_name, SiteType_value)
	proto.RegisterEnum("ves.io.schema.site.SiteSubtype", SiteSubtype_name, SiteSubtype_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteSubtype", SiteSubtype_name, SiteSubtype_value)
	proto.RegisterEnum("ves.io.schema.site.CeSiteMode", CeSiteMode_name, CeSiteMode_value)
	golang_proto.RegisterEnum("ves.io.schema.site.CeSiteMode", CeSiteMode_name, CeSiteMode_value)
	proto.RegisterEnum("ves.io.schema.site.IPSecState", IPSecState_name, IPSecState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.IPSecState", IPSecState_name, IPSecState_value)
	proto.RegisterEnum("ves.io.schema.site.IPSecRole", IPSecRole_name, IPSecRole_value)
	golang_proto.RegisterEnum("ves.io.schema.site.IPSecRole", IPSecRole_name, IPSecRole_value)
	proto.RegisterEnum("ves.io.schema.site.TunnelState", TunnelState_name, TunnelState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.TunnelState", TunnelState_name, TunnelState_value)
	proto.RegisterEnum("ves.io.schema.site.TunnelRole", TunnelRole_name, TunnelRole_value)
	golang_proto.RegisterEnum("ves.io.schema.site.TunnelRole", TunnelRole_name, TunnelRole_value)
	proto.RegisterEnum("ves.io.schema.site.VTRPState", VTRPState_name, VTRPState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.VTRPState", VTRPState_name, VTRPState_value)
	proto.RegisterEnum("ves.io.schema.site.ActiveState", ActiveState_name, ActiveState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.ActiveState", ActiveState_name, ActiveState_value)
	proto.RegisterEnum("ves.io.schema.site.LinkQuality", LinkQuality_name, LinkQuality_value)
	golang_proto.RegisterEnum("ves.io.schema.site.LinkQuality", LinkQuality_name, LinkQuality_value)
	proto.RegisterEnum("ves.io.schema.site.LinkType", LinkType_name, LinkType_value)
	golang_proto.RegisterEnum("ves.io.schema.site.LinkType", LinkType_name, LinkType_value)
	proto.RegisterEnum("ves.io.schema.site.AddressMode", AddressMode_name, AddressMode_value)
	golang_proto.RegisterEnum("ves.io.schema.site.AddressMode", AddressMode_name, AddressMode_value)
	proto.RegisterEnum("ves.io.schema.site.SiteSoftwareOverrideType", SiteSoftwareOverrideType_name, SiteSoftwareOverrideType_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteSoftwareOverrideType", SiteSoftwareOverrideType_name, SiteSoftwareOverrideType_value)
	proto.RegisterEnum("ves.io.schema.site.SoftwareUpgradePhase", SoftwareUpgradePhase_name, SoftwareUpgradePhase_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SoftwareUpgradePhase", SoftwareUpgradePhase_name, SoftwareUpgradePhase_value)
	proto.RegisterEnum("ves.io.schema.site.ScalingPhase", ScalingPhase_name, ScalingPhase_value)
	golang_proto.RegisterEnum("ves.io.schema.site.ScalingPhase", ScalingPhase_name, ScalingPhase_value)
	proto.RegisterEnum("ves.io.schema.site.SiteState", SiteState_name, SiteState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteState", SiteState_name, SiteState_value)
	proto.RegisterEnum("ves.io.schema.site.SiteStatusMetricsField", SiteStatusMetricsField_name, SiteStatusMetricsField_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteStatusMetricsField", SiteStatusMetricsField_name, SiteStatusMetricsField_value)
}
func (x SiteType) String() string {
	s, ok := SiteType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteSubtype) String() string {
	s, ok := SiteSubtype_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CeSiteMode) String() string {
	s, ok := CeSiteMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x IPSecState) String() string {
	s, ok := IPSecState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x IPSecRole) String() string {
	s, ok := IPSecRole_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TunnelState) String() string {
	s, ok := TunnelState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TunnelRole) String() string {
	s, ok := TunnelRole_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VTRPState) String() string {
	s, ok := VTRPState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ActiveState) String() string {
	s, ok := ActiveState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LinkQuality) String() string {
	s, ok := LinkQuality_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LinkType) String() string {
	s, ok := LinkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AddressMode) String() string {
	s, ok := AddressMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteSoftwareOverrideType) String() string {
	s, ok := SiteSoftwareOverrideType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SoftwareUpgradePhase) String() string {
	s, ok := SoftwareUpgradePhase_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ScalingPhase) String() string {
	s, ok := ScalingPhase_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteState) String() string {
	s, ok := SiteState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteStatusMetricsField) String() string {
	s, ok := SiteStatusMetricsField_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Coordinates) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Coordinates)
	if !ok {
		that2, ok := that.(Coordinates)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	return true
}
func (this *K8SApiServerParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SApiServerParameters)
	if !ok {
		that2, ok := that.(K8SApiServerParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	if this.SiteSubtype != that1.SiteSubtype {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if len(this.ConnectedRe) != len(that1.ConnectedRe) {
		return false
	}
	for i := range this.ConnectedRe {
		if !this.ConnectedRe[i].Equal(that1.ConnectedRe[i]) {
			return false
		}
	}
	if len(this.ConnectedReForConfig) != len(that1.ConnectedReForConfig) {
		return false
	}
	for i := range this.ConnectedReForConfig {
		if !this.ConnectedReForConfig[i].Equal(that1.ConnectedReForConfig[i]) {
			return false
		}
	}
	if !this.Vega.Equal(that1.Vega) {
		return false
	}
	if len(this.AresList) != len(that1.AresList) {
		return false
	}
	for i := range this.AresList {
		if !this.AresList[i].Equal(that1.AresList[i]) {
			return false
		}
	}
	if !this.Rakar.Equal(that1.Rakar) {
		return false
	}
	if !this.Opera.Equal(that1.Opera) {
		return false
	}
	if len(this.StaticRoutes) != len(that1.StaticRoutes) {
		return false
	}
	for i := range this.StaticRoutes {
		if this.StaticRoutes[i] != that1.StaticRoutes[i] {
			return false
		}
	}
	if len(this.K8SApiServers) != len(that1.K8SApiServers) {
		return false
	}
	for i := range this.K8SApiServers {
		if !this.K8SApiServers[i].Equal(that1.K8SApiServers[i]) {
			return false
		}
	}
	if this.PublicIp != that1.PublicIp {
		return false
	}
	if this.ClusterIp != that1.ClusterIp {
		return false
	}
	if len(this.AresVtrpList) != len(that1.AresVtrpList) {
		return false
	}
	for i := range this.AresVtrpList {
		if !this.AresVtrpList[i].Equal(that1.AresVtrpList[i]) {
			return false
		}
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if this.InsideVip != that1.InsideVip {
		return false
	}
	if this.OutsideVip != that1.OutsideVip {
		return false
	}
	if this.VipVrrpMode != that1.VipVrrpMode {
		return false
	}
	if this.SiteToSiteNetworkType != that1.SiteToSiteNetworkType {
		return false
	}
	if this.SiteToSiteTunnelIp != that1.SiteToSiteTunnelIp {
		return false
	}
	if this.VolterraSoftwareOveride != that1.VolterraSoftwareOveride {
		return false
	}
	if this.BgpRouterId != that1.BgpRouterId {
		return false
	}
	if this.BgpPeerAddress != that1.BgpPeerAddress {
		return false
	}
	if len(this.TemplateParameters) != len(that1.TemplateParameters) {
		return false
	}
	for i := range this.TemplateParameters {
		if this.TemplateParameters[i] != that1.TemplateParameters[i] {
			return false
		}
	}
	if this.InsideNameserver != that1.InsideNameserver {
		return false
	}
	if this.OutsideNameserver != that1.OutsideNameserver {
		return false
	}
	if this.DesiredPoolCount != that1.DesiredPoolCount {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if this.SiteState != that1.SiteState {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.MarsList) != len(that1.MarsList) {
		return false
	}
	for i := range this.MarsList {
		if !this.MarsList[i].Equal(that1.MarsList[i]) {
			return false
		}
	}
	if len(this.MarsVtrpList) != len(that1.MarsVtrpList) {
		return false
	}
	for i := range this.MarsVtrpList {
		if !this.MarsVtrpList[i].Equal(that1.MarsVtrpList[i]) {
			return false
		}
	}
	if this.TunnelDeadTimeout != that1.TunnelDeadTimeout {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.CeSiteMode != that1.CeSiteMode {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if this.InsideVip != that1.InsideVip {
		return false
	}
	if this.OutsideVip != that1.OutsideVip {
		return false
	}
	if this.VipVrrpMode != that1.VipVrrpMode {
		return false
	}
	if this.SiteToSiteNetworkType != that1.SiteToSiteNetworkType {
		return false
	}
	if this.SiteToSiteTunnelIp != that1.SiteToSiteTunnelIp {
		return false
	}
	if this.VolterraSoftwareOveride != that1.VolterraSoftwareOveride {
		return false
	}
	if this.BgpRouterId != that1.BgpRouterId {
		return false
	}
	if this.BgpPeerAddress != that1.BgpPeerAddress {
		return false
	}
	if this.InsideNameserver != that1.InsideNameserver {
		return false
	}
	if this.OutsideNameserver != that1.OutsideNameserver {
		return false
	}
	if this.DesiredPoolCount != that1.DesiredPoolCount {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if this.TunnelDeadTimeout != that1.TunnelDeadTimeout {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.CeSiteMode != that1.CeSiteMode {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if this.InsideVip != that1.InsideVip {
		return false
	}
	if this.OutsideVip != that1.OutsideVip {
		return false
	}
	if this.VipVrrpMode != that1.VipVrrpMode {
		return false
	}
	if this.SiteToSiteNetworkType != that1.SiteToSiteNetworkType {
		return false
	}
	if this.SiteToSiteTunnelIp != that1.SiteToSiteTunnelIp {
		return false
	}
	if this.VolterraSoftwareOveride != that1.VolterraSoftwareOveride {
		return false
	}
	if this.BgpRouterId != that1.BgpRouterId {
		return false
	}
	if this.BgpPeerAddress != that1.BgpPeerAddress {
		return false
	}
	if this.InsideNameserver != that1.InsideNameserver {
		return false
	}
	if this.OutsideNameserver != that1.OutsideNameserver {
		return false
	}
	if this.DesiredPoolCount != that1.DesiredPoolCount {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if this.TunnelDeadTimeout != that1.TunnelDeadTimeout {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.ConnectedRe) != len(that1.ConnectedRe) {
		return false
	}
	for i := range this.ConnectedRe {
		if !this.ConnectedRe[i].Equal(that1.ConnectedRe[i]) {
			return false
		}
	}
	if len(this.ConnectedReForConfig) != len(that1.ConnectedReForConfig) {
		return false
	}
	for i := range this.ConnectedReForConfig {
		if !this.ConnectedReForConfig[i].Equal(that1.ConnectedReForConfig[i]) {
			return false
		}
	}
	if this.InsideVip != that1.InsideVip {
		return false
	}
	if this.OutsideVip != that1.OutsideVip {
		return false
	}
	if this.VipVrrpMode != that1.VipVrrpMode {
		return false
	}
	if this.SiteToSiteNetworkType != that1.SiteToSiteNetworkType {
		return false
	}
	if this.SiteToSiteTunnelIp != that1.SiteToSiteTunnelIp {
		return false
	}
	if this.VolterraSoftwareOveride != that1.VolterraSoftwareOveride {
		return false
	}
	if this.BgpRouterId != that1.BgpRouterId {
		return false
	}
	if this.BgpPeerAddress != that1.BgpPeerAddress {
		return false
	}
	if this.InsideNameserver != that1.InsideNameserver {
		return false
	}
	if this.OutsideNameserver != that1.OutsideNameserver {
		return false
	}
	if this.DesiredPoolCount != that1.DesiredPoolCount {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if this.SiteState != that1.SiteState {
		return false
	}
	if this.TunnelDeadTimeout != that1.TunnelDeadTimeout {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.CeSiteMode != that1.CeSiteMode {
		return false
	}
	return true
}
func (this *VerStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerStatusType)
	if !ok {
		that2, ok := that.(VerStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VerInstanceName != that1.VerInstanceName {
		return false
	}
	if len(this.IpsecStatus) != len(that1.IpsecStatus) {
		return false
	}
	for i := range this.IpsecStatus {
		if !this.IpsecStatus[i].Equal(that1.IpsecStatus[i]) {
			return false
		}
	}
	if len(this.AresStatus) != len(that1.AresStatus) {
		return false
	}
	for i := range this.AresStatus {
		if !this.AresStatus[i].Equal(that1.AresStatus[i]) {
			return false
		}
	}
	if len(this.IntfStatus) != len(that1.IntfStatus) {
		return false
	}
	for i := range this.IntfStatus {
		if !this.IntfStatus[i].Equal(that1.IntfStatus[i]) {
			return false
		}
	}
	if len(this.ConfiguredTunnelStatus) != len(that1.ConfiguredTunnelStatus) {
		return false
	}
	for i := range this.ConfiguredTunnelStatus {
		if !this.ConfiguredTunnelStatus[i].Equal(that1.ConfiguredTunnelStatus[i]) {
			return false
		}
	}
	if len(this.SiteTunnelStatus) != len(that1.SiteTunnelStatus) {
		return false
	}
	for i := range this.SiteTunnelStatus {
		if !this.SiteTunnelStatus[i].Equal(that1.SiteTunnelStatus[i]) {
			return false
		}
	}
	return true
}
func (this *VerMasterStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerMasterStatusType)
	if !ok {
		that2, ok := that.(VerMasterStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VerName != that1.VerName {
		return false
	}
	if this.Ver_UID != that1.Ver_UID {
		return false
	}
	if !this.TransitionTimestamp.Equal(that1.TransitionTimestamp) {
		return false
	}
	return true
}
func (this *IpsecConnectionStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpsecConnectionStatus)
	if !ok {
		that2, ok := that.(IpsecConnectionStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.RemoteAddress != that1.RemoteAddress {
		return false
	}
	if this.IsLocal != that1.IsLocal {
		return false
	}
	if this.VerNodeName != that1.VerNodeName {
		return false
	}
	return true
}
func (this *AresConnectionStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AresConnectionStatus)
	if !ok {
		that2, ok := that.(AresConnectionStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *InterfaceStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceStatus)
	if !ok {
		that2, ok := that.(InterfaceStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ip.Equal(that1.Ip) {
		return false
	}
	if this.Mac != that1.Mac {
		return false
	}
	if this.NetworkType != that1.NetworkType {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.IpMode != that1.IpMode {
		return false
	}
	if this.DhcpServer != that1.DhcpServer {
		return false
	}
	if this.NetworkName != that1.NetworkName {
		return false
	}
	if this.LinkState != that1.LinkState {
		return false
	}
	if this.ActiveState != that1.ActiveState {
		return false
	}
	if this.LinkQuality != that1.LinkQuality {
		return false
	}
	if this.LinkType != that1.LinkType {
		return false
	}
	return true
}
func (this *TunnelConnectionStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelConnectionStatus)
	if !ok {
		that2, ok := that.(TunnelConnectionStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.RemoteAddress != that1.RemoteAddress {
		return false
	}
	if this.Encap != that1.Encap {
		return false
	}
	if this.IsLocal != that1.IsLocal {
		return false
	}
	if this.VerNodeName != that1.VerNodeName {
		return false
	}
	if this.TunnelName != that1.TunnelName {
		return false
	}
	return true
}
func (this *VolterraSoftwareStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSoftwareStatus)
	if !ok {
		that2, ok := that.(VolterraSoftwareStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AvailableVersion != that1.AvailableVersion {
		return false
	}
	if !this.DeploymentState.Equal(that1.DeploymentState) {
		return false
	}
	return true
}
func (this *OperatingSystemStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OperatingSystemStatus)
	if !ok {
		that2, ok := that.(OperatingSystemStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AvailableVersion != that1.AvailableVersion {
		return false
	}
	if !this.DeploymentState.Equal(that1.DeploymentState) {
		return false
	}
	return true
}
func (this *DeploymentState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeploymentState)
	if !ok {
		that2, ok := that.(DeploymentState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if this.Phase != that1.Phase {
		return false
	}
	return true
}
func (this *ScalingStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalingStatus)
	if !ok {
		that2, ok := that.(ScalingStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Phase != that1.Phase {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if this.PoolNodeCountCurrent != that1.PoolNodeCountCurrent {
		return false
	}
	if this.PoolNodeCountTarget != that1.PoolNodeCountTarget {
		return false
	}
	return true
}
func (this *NodeInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInfo)
	if !ok {
		that2, ok := that.(NodeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if len(this.Role) != len(that1.Role) {
		return false
	}
	for i := range this.Role {
		if this.Role[i] != that1.Role[i] {
			return false
		}
	}
	return true
}
func (this *OsInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OsInfo)
	if !ok {
		that2, ok := that.(OsInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Os.Equal(that1.Os) {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	if !this.Board.Equal(that1.Board) {
		return false
	}
	if !this.Chassis.Equal(that1.Chassis) {
		return false
	}
	if !this.Bios.Equal(that1.Bios) {
		return false
	}
	if !this.Cpu.Equal(that1.Cpu) {
		return false
	}
	if !this.Memory.Equal(that1.Memory) {
		return false
	}
	if len(this.Storage) != len(that1.Storage) {
		return false
	}
	for i := range this.Storage {
		if !this.Storage[i].Equal(that1.Storage[i]) {
			return false
		}
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if !this.Kernel.Equal(that1.Kernel) {
		return false
	}
	if len(this.Usb) != len(that1.Usb) {
		return false
	}
	for i := range this.Usb {
		if !this.Usb[i].Equal(that1.Usb[i]) {
			return false
		}
	}
	return true
}
func (this *OS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OS)
	if !ok {
		that2, ok := that.(OS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Release != that1.Release {
		return false
	}
	if this.Architecture != that1.Architecture {
		return false
	}
	return true
}
func (this *Kernel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Kernel)
	if !ok {
		that2, ok := that.(Kernel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Release != that1.Release {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Architecture != that1.Architecture {
		return false
	}
	return true
}
func (this *Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Product)
	if !ok {
		that2, ok := that.(Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Serial != that1.Serial {
		return false
	}
	return true
}
func (this *Board) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Board)
	if !ok {
		that2, ok := that.(Board)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Serial != that1.Serial {
		return false
	}
	if this.AssetTag != that1.AssetTag {
		return false
	}
	return true
}
func (this *Chassis) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Chassis)
	if !ok {
		that2, ok := that.(Chassis)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Serial != that1.Serial {
		return false
	}
	if this.AssetTag != that1.AssetTag {
		return false
	}
	return true
}
func (this *Bios) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Bios)
	if !ok {
		that2, ok := that.(Bios)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *Cpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Cpu)
	if !ok {
		that2, ok := that.(Cpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.Speed != that1.Speed {
		return false
	}
	if this.Cache != that1.Cache {
		return false
	}
	if this.Cpus != that1.Cpus {
		return false
	}
	if this.Cores != that1.Cores {
		return false
	}
	if this.Threads != that1.Threads {
		return false
	}
	return true
}
func (this *Memory) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Memory)
	if !ok {
		that2, ok := that.(Memory)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Speed != that1.Speed {
		return false
	}
	if this.SizeMb != that1.SizeMb {
		return false
	}
	return true
}
func (this *StorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDevice)
	if !ok {
		that2, ok := that.(StorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Driver != that1.Driver {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.Serial != that1.Serial {
		return false
	}
	if this.SizeGb != that1.SizeGb {
		return false
	}
	return true
}
func (this *NetworkDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkDevice)
	if !ok {
		that2, ok := that.(NetworkDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Driver != that1.Driver {
		return false
	}
	if len(this.IpAddress) != len(that1.IpAddress) {
		return false
	}
	for i := range this.IpAddress {
		if this.IpAddress[i] != that1.IpAddress[i] {
			return false
		}
	}
	if this.MacAddress != that1.MacAddress {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Speed != that1.Speed {
		return false
	}
	if this.LinkQuality != that1.LinkQuality {
		return false
	}
	if this.LinkType != that1.LinkType {
		return false
	}
	return true
}
func (this *USBDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*USBDevice)
	if !ok {
		that2, ok := that.(USBDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bus != that1.Bus {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.VendorName != that1.VendorName {
		return false
	}
	if this.ProductName != that1.ProductName {
		return false
	}
	if this.ISerial != that1.ISerial {
		return false
	}
	if this.IdVendor != that1.IdVendor {
		return false
	}
	if this.IdProduct != that1.IdProduct {
		return false
	}
	if this.IManufacturer != that1.IManufacturer {
		return false
	}
	if this.Speed != that1.Speed {
		return false
	}
	if this.BcdUsb != that1.BcdUsb {
		return false
	}
	if this.BcdDevice != that1.BcdDevice {
		return false
	}
	if this.BDeviceClass != that1.BDeviceClass {
		return false
	}
	if this.BDeviceSubClass != that1.BDeviceSubClass {
		return false
	}
	if this.BDeviceProtocol != that1.BDeviceProtocol {
		return false
	}
	if this.BMaxPacketSize != that1.BMaxPacketSize {
		return false
	}
	if this.IProduct != that1.IProduct {
		return false
	}
	return true
}
func (this *SiteStatusMetricsFieldData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStatusMetricsFieldData)
	if !ok {
		that2, ok := that.(SiteStatusMetricsFieldData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Key) != len(that1.Key) {
		return false
	}
	for i := range this.Key {
		if this.Key[i] != that1.Key[i] {
			return false
		}
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if !this.Value[i].Equal(that1.Value[i]) {
			return false
		}
	}
	return true
}
func (this *SiteStatusMetricsData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStatusMetricsData)
	if !ok {
		that2, ok := that.(SiteStatusMetricsData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Field != that1.Field {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	return true
}
func (this *Coordinates) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.Coordinates{")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SApiServerParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&site.K8SApiServerParameters{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 40)
	s = append(s, "&site.GlobalSpecType{")
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	s = append(s, "SiteSubtype: "+fmt.Sprintf("%#v", this.SiteSubtype)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	if this.ConnectedRe != nil {
		s = append(s, "ConnectedRe: "+fmt.Sprintf("%#v", this.ConnectedRe)+",\n")
	}
	if this.ConnectedReForConfig != nil {
		s = append(s, "ConnectedReForConfig: "+fmt.Sprintf("%#v", this.ConnectedReForConfig)+",\n")
	}
	if this.Vega != nil {
		s = append(s, "Vega: "+fmt.Sprintf("%#v", this.Vega)+",\n")
	}
	if this.AresList != nil {
		s = append(s, "AresList: "+fmt.Sprintf("%#v", this.AresList)+",\n")
	}
	if this.Rakar != nil {
		s = append(s, "Rakar: "+fmt.Sprintf("%#v", this.Rakar)+",\n")
	}
	if this.Opera != nil {
		s = append(s, "Opera: "+fmt.Sprintf("%#v", this.Opera)+",\n")
	}
	s = append(s, "StaticRoutes: "+fmt.Sprintf("%#v", this.StaticRoutes)+",\n")
	keysForK8SApiServers := make([]string, 0, len(this.K8SApiServers))
	for k, _ := range this.K8SApiServers {
		keysForK8SApiServers = append(keysForK8SApiServers, k)
	}
	sortkeys.Strings(keysForK8SApiServers)
	mapStringForK8SApiServers := "map[string]*K8SApiServerParameters{"
	for _, k := range keysForK8SApiServers {
		mapStringForK8SApiServers += fmt.Sprintf("%#v: %#v,", k, this.K8SApiServers[k])
	}
	mapStringForK8SApiServers += "}"
	if this.K8SApiServers != nil {
		s = append(s, "K8SApiServers: "+mapStringForK8SApiServers+",\n")
	}
	s = append(s, "PublicIp: "+fmt.Sprintf("%#v", this.PublicIp)+",\n")
	s = append(s, "ClusterIp: "+fmt.Sprintf("%#v", this.ClusterIp)+",\n")
	if this.AresVtrpList != nil {
		s = append(s, "AresVtrpList: "+fmt.Sprintf("%#v", this.AresVtrpList)+",\n")
	}
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	s = append(s, "InsideVip: "+fmt.Sprintf("%#v", this.InsideVip)+",\n")
	s = append(s, "OutsideVip: "+fmt.Sprintf("%#v", this.OutsideVip)+",\n")
	s = append(s, "VipVrrpMode: "+fmt.Sprintf("%#v", this.VipVrrpMode)+",\n")
	s = append(s, "SiteToSiteNetworkType: "+fmt.Sprintf("%#v", this.SiteToSiteNetworkType)+",\n")
	s = append(s, "SiteToSiteTunnelIp: "+fmt.Sprintf("%#v", this.SiteToSiteTunnelIp)+",\n")
	s = append(s, "VolterraSoftwareOveride: "+fmt.Sprintf("%#v", this.VolterraSoftwareOveride)+",\n")
	s = append(s, "BgpRouterId: "+fmt.Sprintf("%#v", this.BgpRouterId)+",\n")
	s = append(s, "BgpPeerAddress: "+fmt.Sprintf("%#v", this.BgpPeerAddress)+",\n")
	keysForTemplateParameters := make([]string, 0, len(this.TemplateParameters))
	for k, _ := range this.TemplateParameters {
		keysForTemplateParameters = append(keysForTemplateParameters, k)
	}
	sortkeys.Strings(keysForTemplateParameters)
	mapStringForTemplateParameters := "map[string]string{"
	for _, k := range keysForTemplateParameters {
		mapStringForTemplateParameters += fmt.Sprintf("%#v: %#v,", k, this.TemplateParameters[k])
	}
	mapStringForTemplateParameters += "}"
	if this.TemplateParameters != nil {
		s = append(s, "TemplateParameters: "+mapStringForTemplateParameters+",\n")
	}
	s = append(s, "InsideNameserver: "+fmt.Sprintf("%#v", this.InsideNameserver)+",\n")
	s = append(s, "OutsideNameserver: "+fmt.Sprintf("%#v", this.OutsideNameserver)+",\n")
	s = append(s, "DesiredPoolCount: "+fmt.Sprintf("%#v", this.DesiredPoolCount)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "SiteState: "+fmt.Sprintf("%#v", this.SiteState)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.MarsList != nil {
		s = append(s, "MarsList: "+fmt.Sprintf("%#v", this.MarsList)+",\n")
	}
	if this.MarsVtrpList != nil {
		s = append(s, "MarsVtrpList: "+fmt.Sprintf("%#v", this.MarsVtrpList)+",\n")
	}
	s = append(s, "TunnelDeadTimeout: "+fmt.Sprintf("%#v", this.TunnelDeadTimeout)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "CeSiteMode: "+fmt.Sprintf("%#v", this.CeSiteMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&site.CreateSpecType{")
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	s = append(s, "InsideVip: "+fmt.Sprintf("%#v", this.InsideVip)+",\n")
	s = append(s, "OutsideVip: "+fmt.Sprintf("%#v", this.OutsideVip)+",\n")
	s = append(s, "VipVrrpMode: "+fmt.Sprintf("%#v", this.VipVrrpMode)+",\n")
	s = append(s, "SiteToSiteNetworkType: "+fmt.Sprintf("%#v", this.SiteToSiteNetworkType)+",\n")
	s = append(s, "SiteToSiteTunnelIp: "+fmt.Sprintf("%#v", this.SiteToSiteTunnelIp)+",\n")
	s = append(s, "VolterraSoftwareOveride: "+fmt.Sprintf("%#v", this.VolterraSoftwareOveride)+",\n")
	s = append(s, "BgpRouterId: "+fmt.Sprintf("%#v", this.BgpRouterId)+",\n")
	s = append(s, "BgpPeerAddress: "+fmt.Sprintf("%#v", this.BgpPeerAddress)+",\n")
	s = append(s, "InsideNameserver: "+fmt.Sprintf("%#v", this.InsideNameserver)+",\n")
	s = append(s, "OutsideNameserver: "+fmt.Sprintf("%#v", this.OutsideNameserver)+",\n")
	s = append(s, "DesiredPoolCount: "+fmt.Sprintf("%#v", this.DesiredPoolCount)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	s = append(s, "TunnelDeadTimeout: "+fmt.Sprintf("%#v", this.TunnelDeadTimeout)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "CeSiteMode: "+fmt.Sprintf("%#v", this.CeSiteMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&site.ReplaceSpecType{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	s = append(s, "InsideVip: "+fmt.Sprintf("%#v", this.InsideVip)+",\n")
	s = append(s, "OutsideVip: "+fmt.Sprintf("%#v", this.OutsideVip)+",\n")
	s = append(s, "VipVrrpMode: "+fmt.Sprintf("%#v", this.VipVrrpMode)+",\n")
	s = append(s, "SiteToSiteNetworkType: "+fmt.Sprintf("%#v", this.SiteToSiteNetworkType)+",\n")
	s = append(s, "SiteToSiteTunnelIp: "+fmt.Sprintf("%#v", this.SiteToSiteTunnelIp)+",\n")
	s = append(s, "VolterraSoftwareOveride: "+fmt.Sprintf("%#v", this.VolterraSoftwareOveride)+",\n")
	s = append(s, "BgpRouterId: "+fmt.Sprintf("%#v", this.BgpRouterId)+",\n")
	s = append(s, "BgpPeerAddress: "+fmt.Sprintf("%#v", this.BgpPeerAddress)+",\n")
	s = append(s, "InsideNameserver: "+fmt.Sprintf("%#v", this.InsideNameserver)+",\n")
	s = append(s, "OutsideNameserver: "+fmt.Sprintf("%#v", this.OutsideNameserver)+",\n")
	s = append(s, "DesiredPoolCount: "+fmt.Sprintf("%#v", this.DesiredPoolCount)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	s = append(s, "TunnelDeadTimeout: "+fmt.Sprintf("%#v", this.TunnelDeadTimeout)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 27)
	s = append(s, "&site.GetSpecType{")
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.ConnectedRe != nil {
		s = append(s, "ConnectedRe: "+fmt.Sprintf("%#v", this.ConnectedRe)+",\n")
	}
	if this.ConnectedReForConfig != nil {
		s = append(s, "ConnectedReForConfig: "+fmt.Sprintf("%#v", this.ConnectedReForConfig)+",\n")
	}
	s = append(s, "InsideVip: "+fmt.Sprintf("%#v", this.InsideVip)+",\n")
	s = append(s, "OutsideVip: "+fmt.Sprintf("%#v", this.OutsideVip)+",\n")
	s = append(s, "VipVrrpMode: "+fmt.Sprintf("%#v", this.VipVrrpMode)+",\n")
	s = append(s, "SiteToSiteNetworkType: "+fmt.Sprintf("%#v", this.SiteToSiteNetworkType)+",\n")
	s = append(s, "SiteToSiteTunnelIp: "+fmt.Sprintf("%#v", this.SiteToSiteTunnelIp)+",\n")
	s = append(s, "VolterraSoftwareOveride: "+fmt.Sprintf("%#v", this.VolterraSoftwareOveride)+",\n")
	s = append(s, "BgpRouterId: "+fmt.Sprintf("%#v", this.BgpRouterId)+",\n")
	s = append(s, "BgpPeerAddress: "+fmt.Sprintf("%#v", this.BgpPeerAddress)+",\n")
	s = append(s, "InsideNameserver: "+fmt.Sprintf("%#v", this.InsideNameserver)+",\n")
	s = append(s, "OutsideNameserver: "+fmt.Sprintf("%#v", this.OutsideNameserver)+",\n")
	s = append(s, "DesiredPoolCount: "+fmt.Sprintf("%#v", this.DesiredPoolCount)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	s = append(s, "SiteState: "+fmt.Sprintf("%#v", this.SiteState)+",\n")
	s = append(s, "TunnelDeadTimeout: "+fmt.Sprintf("%#v", this.TunnelDeadTimeout)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "CeSiteMode: "+fmt.Sprintf("%#v", this.CeSiteMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VerStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&site.VerStatusType{")
	s = append(s, "VerInstanceName: "+fmt.Sprintf("%#v", this.VerInstanceName)+",\n")
	if this.IpsecStatus != nil {
		s = append(s, "IpsecStatus: "+fmt.Sprintf("%#v", this.IpsecStatus)+",\n")
	}
	if this.AresStatus != nil {
		s = append(s, "AresStatus: "+fmt.Sprintf("%#v", this.AresStatus)+",\n")
	}
	if this.IntfStatus != nil {
		s = append(s, "IntfStatus: "+fmt.Sprintf("%#v", this.IntfStatus)+",\n")
	}
	if this.ConfiguredTunnelStatus != nil {
		s = append(s, "ConfiguredTunnelStatus: "+fmt.Sprintf("%#v", this.ConfiguredTunnelStatus)+",\n")
	}
	if this.SiteTunnelStatus != nil {
		s = append(s, "SiteTunnelStatus: "+fmt.Sprintf("%#v", this.SiteTunnelStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VerMasterStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.VerMasterStatusType{")
	s = append(s, "VerName: "+fmt.Sprintf("%#v", this.VerName)+",\n")
	s = append(s, "Ver_UID: "+fmt.Sprintf("%#v", this.Ver_UID)+",\n")
	if this.TransitionTimestamp != nil {
		s = append(s, "TransitionTimestamp: "+fmt.Sprintf("%#v", this.TransitionTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpsecConnectionStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&site.IpsecConnectionStatus{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "RemoteAddress: "+fmt.Sprintf("%#v", this.RemoteAddress)+",\n")
	s = append(s, "IsLocal: "+fmt.Sprintf("%#v", this.IsLocal)+",\n")
	s = append(s, "VerNodeName: "+fmt.Sprintf("%#v", this.VerNodeName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AresConnectionStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.AresConnectionStatus{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InterfaceStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&site.InterfaceStatus{")
	if this.Ip != nil {
		s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	}
	s = append(s, "Mac: "+fmt.Sprintf("%#v", this.Mac)+",\n")
	s = append(s, "NetworkType: "+fmt.Sprintf("%#v", this.NetworkType)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "IpMode: "+fmt.Sprintf("%#v", this.IpMode)+",\n")
	s = append(s, "DhcpServer: "+fmt.Sprintf("%#v", this.DhcpServer)+",\n")
	s = append(s, "NetworkName: "+fmt.Sprintf("%#v", this.NetworkName)+",\n")
	s = append(s, "LinkState: "+fmt.Sprintf("%#v", this.LinkState)+",\n")
	s = append(s, "ActiveState: "+fmt.Sprintf("%#v", this.ActiveState)+",\n")
	s = append(s, "LinkQuality: "+fmt.Sprintf("%#v", this.LinkQuality)+",\n")
	s = append(s, "LinkType: "+fmt.Sprintf("%#v", this.LinkType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelConnectionStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&site.TunnelConnectionStatus{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "RemoteAddress: "+fmt.Sprintf("%#v", this.RemoteAddress)+",\n")
	s = append(s, "Encap: "+fmt.Sprintf("%#v", this.Encap)+",\n")
	s = append(s, "IsLocal: "+fmt.Sprintf("%#v", this.IsLocal)+",\n")
	s = append(s, "VerNodeName: "+fmt.Sprintf("%#v", this.VerNodeName)+",\n")
	s = append(s, "TunnelName: "+fmt.Sprintf("%#v", this.TunnelName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolterraSoftwareStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.VolterraSoftwareStatus{")
	s = append(s, "AvailableVersion: "+fmt.Sprintf("%#v", this.AvailableVersion)+",\n")
	if this.DeploymentState != nil {
		s = append(s, "DeploymentState: "+fmt.Sprintf("%#v", this.DeploymentState)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OperatingSystemStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.OperatingSystemStatus{")
	s = append(s, "AvailableVersion: "+fmt.Sprintf("%#v", this.AvailableVersion)+",\n")
	if this.DeploymentState != nil {
		s = append(s, "DeploymentState: "+fmt.Sprintf("%#v", this.DeploymentState)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeploymentState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.DeploymentState{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "Phase: "+fmt.Sprintf("%#v", this.Phase)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScalingStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&site.ScalingStatus{")
	s = append(s, "Phase: "+fmt.Sprintf("%#v", this.Phase)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "PoolNodeCountCurrent: "+fmt.Sprintf("%#v", this.PoolNodeCountCurrent)+",\n")
	s = append(s, "PoolNodeCountTarget: "+fmt.Sprintf("%#v", this.PoolNodeCountTarget)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.NodeInfo{")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OsInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&site.OsInfo{")
	if this.Os != nil {
		s = append(s, "Os: "+fmt.Sprintf("%#v", this.Os)+",\n")
	}
	if this.Product != nil {
		s = append(s, "Product: "+fmt.Sprintf("%#v", this.Product)+",\n")
	}
	if this.Board != nil {
		s = append(s, "Board: "+fmt.Sprintf("%#v", this.Board)+",\n")
	}
	if this.Chassis != nil {
		s = append(s, "Chassis: "+fmt.Sprintf("%#v", this.Chassis)+",\n")
	}
	if this.Bios != nil {
		s = append(s, "Bios: "+fmt.Sprintf("%#v", this.Bios)+",\n")
	}
	if this.Cpu != nil {
		s = append(s, "Cpu: "+fmt.Sprintf("%#v", this.Cpu)+",\n")
	}
	if this.Memory != nil {
		s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	}
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Kernel != nil {
		s = append(s, "Kernel: "+fmt.Sprintf("%#v", this.Kernel)+",\n")
	}
	if this.Usb != nil {
		s = append(s, "Usb: "+fmt.Sprintf("%#v", this.Usb)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.OS{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Release: "+fmt.Sprintf("%#v", this.Release)+",\n")
	s = append(s, "Architecture: "+fmt.Sprintf("%#v", this.Architecture)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Kernel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.Kernel{")
	s = append(s, "Release: "+fmt.Sprintf("%#v", this.Release)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Architecture: "+fmt.Sprintf("%#v", this.Architecture)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&site.Product{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Board) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.Board{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	s = append(s, "AssetTag: "+fmt.Sprintf("%#v", this.AssetTag)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Chassis) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.Chassis{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	s = append(s, "AssetTag: "+fmt.Sprintf("%#v", this.AssetTag)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Bios) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.Bios{")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Cpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&site.Cpu{")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "Speed: "+fmt.Sprintf("%#v", this.Speed)+",\n")
	s = append(s, "Cache: "+fmt.Sprintf("%#v", this.Cache)+",\n")
	s = append(s, "Cpus: "+fmt.Sprintf("%#v", this.Cpus)+",\n")
	s = append(s, "Cores: "+fmt.Sprintf("%#v", this.Cores)+",\n")
	s = append(s, "Threads: "+fmt.Sprintf("%#v", this.Threads)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Memory) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.Memory{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Speed: "+fmt.Sprintf("%#v", this.Speed)+",\n")
	s = append(s, "SizeMb: "+fmt.Sprintf("%#v", this.SizeMb)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&site.StorageDevice{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Driver: "+fmt.Sprintf("%#v", this.Driver)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	s = append(s, "SizeGb: "+fmt.Sprintf("%#v", this.SizeGb)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&site.NetworkDevice{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Driver: "+fmt.Sprintf("%#v", this.Driver)+",\n")
	s = append(s, "IpAddress: "+fmt.Sprintf("%#v", this.IpAddress)+",\n")
	s = append(s, "MacAddress: "+fmt.Sprintf("%#v", this.MacAddress)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Speed: "+fmt.Sprintf("%#v", this.Speed)+",\n")
	s = append(s, "LinkQuality: "+fmt.Sprintf("%#v", this.LinkQuality)+",\n")
	s = append(s, "LinkType: "+fmt.Sprintf("%#v", this.LinkType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *USBDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&site.USBDevice{")
	s = append(s, "Bus: "+fmt.Sprintf("%#v", this.Bus)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "VendorName: "+fmt.Sprintf("%#v", this.VendorName)+",\n")
	s = append(s, "ProductName: "+fmt.Sprintf("%#v", this.ProductName)+",\n")
	s = append(s, "ISerial: "+fmt.Sprintf("%#v", this.ISerial)+",\n")
	s = append(s, "IdVendor: "+fmt.Sprintf("%#v", this.IdVendor)+",\n")
	s = append(s, "IdProduct: "+fmt.Sprintf("%#v", this.IdProduct)+",\n")
	s = append(s, "IManufacturer: "+fmt.Sprintf("%#v", this.IManufacturer)+",\n")
	s = append(s, "Speed: "+fmt.Sprintf("%#v", this.Speed)+",\n")
	s = append(s, "BcdUsb: "+fmt.Sprintf("%#v", this.BcdUsb)+",\n")
	s = append(s, "BcdDevice: "+fmt.Sprintf("%#v", this.BcdDevice)+",\n")
	s = append(s, "BDeviceClass: "+fmt.Sprintf("%#v", this.BDeviceClass)+",\n")
	s = append(s, "BDeviceSubClass: "+fmt.Sprintf("%#v", this.BDeviceSubClass)+",\n")
	s = append(s, "BDeviceProtocol: "+fmt.Sprintf("%#v", this.BDeviceProtocol)+",\n")
	s = append(s, "BMaxPacketSize: "+fmt.Sprintf("%#v", this.BMaxPacketSize)+",\n")
	s = append(s, "IProduct: "+fmt.Sprintf("%#v", this.IProduct)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteStatusMetricsFieldData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.SiteStatusMetricsFieldData{")
	keysForKey := make([]string, 0, len(this.Key))
	for k, _ := range this.Key {
		keysForKey = append(keysForKey, k)
	}
	sortkeys.Strings(keysForKey)
	mapStringForKey := "map[string]string{"
	for _, k := range keysForKey {
		mapStringForKey += fmt.Sprintf("%#v: %#v,", k, this.Key[k])
	}
	mapStringForKey += "}"
	if this.Key != nil {
		s = append(s, "Key: "+mapStringForKey+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteStatusMetricsData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.SiteStatusMetricsData{")
	s = append(s, "Field: "+fmt.Sprintf("%#v", this.Field)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Coordinates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Coordinates) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Latitude != 0 {
		dAtA[i] = 0xd
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i += 4
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i += 4
	}
	return i, nil
}

func (m *K8SApiServerParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SApiServerParameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SiteType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Coordinates != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Coordinates.Size()))
		n1, err := m.Coordinates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.SiteSubtype != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteSubtype))
	}
	if len(m.ConnectedRe) > 0 {
		for _, msg := range m.ConnectedRe {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConnectedReForConfig) > 0 {
		for _, msg := range m.ConnectedReForConfig {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Vega != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Vega.Size()))
		n2, err := m.Vega.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.AresList) > 0 {
		for _, msg := range m.AresList {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Rakar != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Rakar.Size()))
		n3, err := m.Rakar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.StaticRoutes) > 0 {
		for _, s := range m.StaticRoutes {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x6
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.K8SApiServers) > 0 {
		keysForK8SApiServers := make([]string, 0, len(m.K8SApiServers))
		for k, _ := range m.K8SApiServers {
			keysForK8SApiServers = append(keysForK8SApiServers, string(k))
		}
		sortkeys.Strings(keysForK8SApiServers)
		for _, k := range keysForK8SApiServers {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x6
			i++
			v := m.K8SApiServers[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if len(m.PublicIp) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicIp)))
		i += copy(dAtA[i:], m.PublicIp)
	}
	if len(m.ClusterIp) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterIp)))
		i += copy(dAtA[i:], m.ClusterIp)
	}
	if len(m.AresVtrpList) > 0 {
		for _, msg := range m.AresVtrpList {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x7
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	}
	if len(m.InsideVip) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVip)))
		i += copy(dAtA[i:], m.InsideVip)
	}
	if len(m.SiteToSiteTunnelIp) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SiteToSiteTunnelIp)))
		i += copy(dAtA[i:], m.SiteToSiteTunnelIp)
	}
	if m.VolterraSoftwareOveride != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSoftwareOveride))
	}
	if len(m.BgpRouterId) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpRouterId)))
		i += copy(dAtA[i:], m.BgpRouterId)
	}
	if len(m.BgpPeerAddress) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpPeerAddress)))
		i += copy(dAtA[i:], m.BgpPeerAddress)
	}
	if len(m.TemplateParameters) > 0 {
		keysForTemplateParameters := make([]string, 0, len(m.TemplateParameters))
		for k, _ := range m.TemplateParameters {
			keysForTemplateParameters = append(keysForTemplateParameters, string(k))
		}
		sortkeys.Strings(keysForTemplateParameters)
		for _, k := range keysForTemplateParameters {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x7
			i++
			v := m.TemplateParameters[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.OutsideVip) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVip)))
		i += copy(dAtA[i:], m.OutsideVip)
	}
	if m.VipVrrpMode != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteToSiteNetworkType))
	}
	if len(m.InsideNameserver) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideNameserver)))
		i += copy(dAtA[i:], m.InsideNameserver)
	}
	if len(m.OutsideNameserver) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideNameserver)))
		i += copy(dAtA[i:], m.OutsideNameserver)
	}
	if m.DesiredPoolCount != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
	}
	if m.SiteState != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteState))
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if len(m.MarsList) > 0 {
		for _, msg := range m.MarsList {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MarsVtrpList) > 0 {
		for _, msg := range m.MarsVtrpList {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TunnelDeadTimeout != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelDeadTimeout))
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if m.Opera != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Opera.Size()))
		n5, err := m.Opera.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.CeSiteMode != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CeSiteMode))
	}
	return i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SiteType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Coordinates != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Coordinates.Size()))
		n6, err := m.Coordinates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.InsideVip) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVip)))
		i += copy(dAtA[i:], m.InsideVip)
	}
	if len(m.SiteToSiteTunnelIp) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SiteToSiteTunnelIp)))
		i += copy(dAtA[i:], m.SiteToSiteTunnelIp)
	}
	if m.VolterraSoftwareOveride != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSoftwareOveride))
	}
	if len(m.BgpRouterId) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpRouterId)))
		i += copy(dAtA[i:], m.BgpRouterId)
	}
	if len(m.BgpPeerAddress) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpPeerAddress)))
		i += copy(dAtA[i:], m.BgpPeerAddress)
	}
	if len(m.OutsideVip) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVip)))
		i += copy(dAtA[i:], m.OutsideVip)
	}
	if m.VipVrrpMode != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteToSiteNetworkType))
	}
	if len(m.InsideNameserver) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideNameserver)))
		i += copy(dAtA[i:], m.InsideNameserver)
	}
	if len(m.OutsideNameserver) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideNameserver)))
		i += copy(dAtA[i:], m.OutsideNameserver)
	}
	if m.DesiredPoolCount != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if m.TunnelDeadTimeout != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelDeadTimeout))
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if m.CeSiteMode != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CeSiteMode))
	}
	return i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Coordinates != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Coordinates.Size()))
		n7, err := m.Coordinates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	}
	if len(m.InsideVip) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVip)))
		i += copy(dAtA[i:], m.InsideVip)
	}
	if len(m.SiteToSiteTunnelIp) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SiteToSiteTunnelIp)))
		i += copy(dAtA[i:], m.SiteToSiteTunnelIp)
	}
	if m.VolterraSoftwareOveride != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSoftwareOveride))
	}
	if len(m.BgpRouterId) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpRouterId)))
		i += copy(dAtA[i:], m.BgpRouterId)
	}
	if len(m.BgpPeerAddress) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpPeerAddress)))
		i += copy(dAtA[i:], m.BgpPeerAddress)
	}
	if len(m.OutsideVip) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVip)))
		i += copy(dAtA[i:], m.OutsideVip)
	}
	if m.VipVrrpMode != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteToSiteNetworkType))
	}
	if len(m.InsideNameserver) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideNameserver)))
		i += copy(dAtA[i:], m.InsideNameserver)
	}
	if len(m.OutsideNameserver) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideNameserver)))
		i += copy(dAtA[i:], m.OutsideNameserver)
	}
	if m.DesiredPoolCount != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if m.TunnelDeadTimeout != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelDeadTimeout))
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	return i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SiteType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Coordinates != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Coordinates.Size()))
		n8, err := m.Coordinates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	}
	if len(m.ConnectedRe) > 0 {
		for _, msg := range m.ConnectedRe {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConnectedReForConfig) > 0 {
		for _, msg := range m.ConnectedReForConfig {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InsideVip) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVip)))
		i += copy(dAtA[i:], m.InsideVip)
	}
	if len(m.SiteToSiteTunnelIp) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SiteToSiteTunnelIp)))
		i += copy(dAtA[i:], m.SiteToSiteTunnelIp)
	}
	if m.VolterraSoftwareOveride != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSoftwareOveride))
	}
	if len(m.BgpRouterId) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpRouterId)))
		i += copy(dAtA[i:], m.BgpRouterId)
	}
	if len(m.BgpPeerAddress) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpPeerAddress)))
		i += copy(dAtA[i:], m.BgpPeerAddress)
	}
	if len(m.OutsideVip) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVip)))
		i += copy(dAtA[i:], m.OutsideVip)
	}
	if m.VipVrrpMode != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteToSiteNetworkType))
	}
	if len(m.InsideNameserver) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideNameserver)))
		i += copy(dAtA[i:], m.InsideNameserver)
	}
	if len(m.OutsideNameserver) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideNameserver)))
		i += copy(dAtA[i:], m.OutsideNameserver)
	}
	if m.DesiredPoolCount != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if m.SiteState != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteState))
	}
	if m.TunnelDeadTimeout != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelDeadTimeout))
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if m.CeSiteMode != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CeSiteMode))
	}
	return i, nil
}

func (m *VerStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerStatusType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VerInstanceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerInstanceName)))
		i += copy(dAtA[i:], m.VerInstanceName)
	}
	if len(m.IpsecStatus) > 0 {
		for _, msg := range m.IpsecStatus {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AresStatus) > 0 {
		for _, msg := range m.AresStatus {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IntfStatus) > 0 {
		for _, msg := range m.IntfStatus {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConfiguredTunnelStatus) > 0 {
		for _, msg := range m.ConfiguredTunnelStatus {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SiteTunnelStatus) > 0 {
		for _, msg := range m.SiteTunnelStatus {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VerMasterStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerMasterStatusType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VerName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerName)))
		i += copy(dAtA[i:], m.VerName)
	}
	if len(m.Ver_UID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ver_UID)))
		i += copy(dAtA[i:], m.Ver_UID)
	}
	if m.TransitionTimestamp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TransitionTimestamp.Size()))
		n9, err := m.TransitionTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *IpsecConnectionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecConnectionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
	}
	if m.Role != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Role))
	}
	if len(m.RemoteAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RemoteAddress)))
		i += copy(dAtA[i:], m.RemoteAddress)
	}
	if m.IsLocal {
		dAtA[i] = 0x28
		i++
		if m.IsLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VerNodeName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerNodeName)))
		i += copy(dAtA[i:], m.VerNodeName)
	}
	return i, nil
}

func (m *AresConnectionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AresConnectionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *InterfaceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ip != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ip.Size()))
		n10, err := m.Ip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Mac) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Mac)))
		i += copy(dAtA[i:], m.Mac)
	}
	if m.NetworkType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkType))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.IpMode != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpMode))
	}
	if m.DhcpServer {
		dAtA[i] = 0x30
		i++
		if m.DhcpServer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.NetworkName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkName)))
		i += copy(dAtA[i:], m.NetworkName)
	}
	if m.LinkState {
		dAtA[i] = 0x48
		i++
		if m.LinkState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ActiveState != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ActiveState))
	}
	if m.LinkQuality != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkQuality))
	}
	if m.LinkType != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkType))
	}
	return i, nil
}

func (m *TunnelConnectionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelConnectionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
	}
	if m.Role != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Role))
	}
	if len(m.RemoteAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RemoteAddress)))
		i += copy(dAtA[i:], m.RemoteAddress)
	}
	if m.Encap != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Encap))
	}
	if m.IsLocal {
		dAtA[i] = 0x30
		i++
		if m.IsLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VerNodeName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerNodeName)))
		i += copy(dAtA[i:], m.VerNodeName)
	}
	if len(m.TunnelName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TunnelName)))
		i += copy(dAtA[i:], m.TunnelName)
	}
	return i, nil
}

func (m *VolterraSoftwareStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolterraSoftwareStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AvailableVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailableVersion)))
		i += copy(dAtA[i:], m.AvailableVersion)
	}
	if m.DeploymentState != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DeploymentState.Size()))
		n11, err := m.DeploymentState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *OperatingSystemStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatingSystemStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AvailableVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailableVersion)))
		i += copy(dAtA[i:], m.AvailableVersion)
	}
	if m.DeploymentState != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DeploymentState.Size()))
		n12, err := m.DeploymentState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *DeploymentState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ModificationTimestamp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ModificationTimestamp.Size()))
		n13, err := m.ModificationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Result) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Phase != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Phase))
	}
	return i, nil
}

func (m *ScalingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScalingStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Phase != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Phase))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.PoolNodeCountCurrent != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PoolNodeCountCurrent))
	}
	if m.PoolNodeCountTarget != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PoolNodeCountTarget))
	}
	return i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hostname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.Role) > 0 {
		for _, s := range m.Role {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *OsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Os != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Os.Size()))
		n14, err := m.Os.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Product != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Product.Size()))
		n15, err := m.Product.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Board != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Board.Size()))
		n16, err := m.Board.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Chassis != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Chassis.Size()))
		n17, err := m.Chassis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Bios != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Bios.Size()))
		n18, err := m.Bios.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Cpu != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Cpu.Size()))
		n19, err := m.Cpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Memory != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Memory.Size()))
		n20, err := m.Memory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Storage) > 0 {
		for _, msg := range m.Storage {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Network) > 0 {
		for _, msg := range m.Network {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Kernel != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Kernel.Size()))
		n21, err := m.Kernel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Usb) > 0 {
		for _, msg := range m.Usb {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Vendor) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Release) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Release)))
		i += copy(dAtA[i:], m.Release)
	}
	if len(m.Architecture) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Architecture)))
		i += copy(dAtA[i:], m.Architecture)
	}
	return i, nil
}

func (m *Kernel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kernel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Release) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Release)))
		i += copy(dAtA[i:], m.Release)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Architecture) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Architecture)))
		i += copy(dAtA[i:], m.Architecture)
	}
	return i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Vendor) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Serial) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Serial)))
		i += copy(dAtA[i:], m.Serial)
	}
	return i, nil
}

func (m *Board) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Board) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Vendor) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Serial) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Serial)))
		i += copy(dAtA[i:], m.Serial)
	}
	if len(m.AssetTag) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssetTag)))
		i += copy(dAtA[i:], m.AssetTag)
	}
	return i, nil
}

func (m *Chassis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chassis) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if len(m.Vendor) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Serial) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Serial)))
		i += copy(dAtA[i:], m.Serial)
	}
	if len(m.AssetTag) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssetTag)))
		i += copy(dAtA[i:], m.AssetTag)
	}
	return i, nil
}

func (m *Bios) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bios) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vendor) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Date) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	return i, nil
}

func (m *Cpu) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cpu) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vendor) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Model) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	if m.Speed != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Speed))
	}
	if m.Cache != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Cache))
	}
	if m.Cpus != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Cpus))
	}
	if m.Cores != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Cores))
	}
	if m.Threads != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Threads))
	}
	return i, nil
}

func (m *Memory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Memory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Speed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Speed))
	}
	if m.SizeMb != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SizeMb))
	}
	return i, nil
}

func (m *StorageDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if len(m.Vendor) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Model) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	if len(m.Serial) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Serial)))
		i += copy(dAtA[i:], m.Serial)
	}
	if m.SizeGb != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SizeGb))
	}
	return i, nil
}

func (m *NetworkDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if len(m.IpAddress) > 0 {
		for _, s := range m.IpAddress {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if m.Speed != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Speed))
	}
	if m.LinkQuality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkQuality))
	}
	if m.LinkType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkType))
	}
	return i, nil
}

func (m *USBDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *USBDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Bus))
	}
	if m.Address != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Address))
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VendorName)))
		i += copy(dAtA[i:], m.VendorName)
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if len(m.ISerial) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ISerial)))
		i += copy(dAtA[i:], m.ISerial)
	}
	if len(m.IdVendor) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IdVendor)))
		i += copy(dAtA[i:], m.IdVendor)
	}
	if len(m.IdProduct) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IdProduct)))
		i += copy(dAtA[i:], m.IdProduct)
	}
	if len(m.IManufacturer) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IManufacturer)))
		i += copy(dAtA[i:], m.IManufacturer)
	}
	if len(m.Speed) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Speed)))
		i += copy(dAtA[i:], m.Speed)
	}
	if len(m.BcdUsb) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BcdUsb)))
		i += copy(dAtA[i:], m.BcdUsb)
	}
	if len(m.BcdDevice) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BcdDevice)))
		i += copy(dAtA[i:], m.BcdDevice)
	}
	if len(m.BDeviceClass) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BDeviceClass)))
		i += copy(dAtA[i:], m.BDeviceClass)
	}
	if len(m.BDeviceSubClass) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BDeviceSubClass)))
		i += copy(dAtA[i:], m.BDeviceSubClass)
	}
	if len(m.BDeviceProtocol) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BDeviceProtocol)))
		i += copy(dAtA[i:], m.BDeviceProtocol)
	}
	if m.BMaxPacketSize != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BMaxPacketSize))
	}
	if len(m.IProduct) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IProduct)))
		i += copy(dAtA[i:], m.IProduct)
	}
	return i, nil
}

func (m *SiteStatusMetricsFieldData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStatusMetricsFieldData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		keysForKey := make([]string, 0, len(m.Key))
		for k, _ := range m.Key {
			keysForKey = append(keysForKey, string(k))
		}
		sortkeys.Strings(keysForKey)
		for _, k := range keysForKey {
			dAtA[i] = 0xa
			i++
			v := m.Key[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Value) > 0 {
		for _, msg := range m.Value {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SiteStatusMetricsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStatusMetricsData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Field))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedCoordinates(r randyTypes, easy bool) *Coordinates {
	this := &Coordinates{}
	this.Latitude = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Latitude *= -1
	}
	this.Longitude = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Longitude *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedK8SApiServerParameters(r randyTypes, easy bool) *K8SApiServerParameters {
	this := &K8SApiServerParameters{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	this.SiteType = SiteType([]int32{0, 1, 2}[r.Intn(3)])
	this.Address = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.Coordinates = NewPopulatedCoordinates(r, easy)
	}
	this.SiteSubtype = SiteSubtype([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.ConnectedRe = make([]*ves_io_schema4.ObjectRefType, v1)
		for i := 0; i < v1; i++ {
			this.ConnectedRe[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.ConnectedReForConfig = make([]*ves_io_schema4.ObjectRefType, v2)
		for i := 0; i < v2; i++ {
			this.ConnectedReForConfig[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Vega = ves_io_schema5.NewPopulatedServiceParameters(r, easy)
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.AresList = make([]*ves_io_schema5.ServiceParameters, v3)
		for i := 0; i < v3; i++ {
			this.AresList[i] = ves_io_schema5.NewPopulatedServiceParameters(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Rakar = ves_io_schema5.NewPopulatedServiceParameters(r, easy)
	}
	v4 := r.Intn(10)
	this.StaticRoutes = make([]string, v4)
	for i := 0; i < v4; i++ {
		this.StaticRoutes[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.K8SApiServers = make(map[string]*K8SApiServerParameters)
		for i := 0; i < v5; i++ {
			this.K8SApiServers[randStringTypes(r)] = NewPopulatedK8SApiServerParameters(r, easy)
		}
	}
	this.PublicIp = string(randStringTypes(r))
	this.ClusterIp = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.AresVtrpList = make([]*ves_io_schema5.ServiceParameters, v6)
		for i := 0; i < v6; i++ {
			this.AresVtrpList[i] = ves_io_schema5.NewPopulatedServiceParameters(r, easy)
		}
	}
	this.VolterraSoftwareVersion = string(randStringTypes(r))
	this.InsideVip = string(randStringTypes(r))
	this.SiteToSiteTunnelIp = string(randStringTypes(r))
	this.VolterraSoftwareOveride = SiteSoftwareOverrideType([]int32{0, 1, 2}[r.Intn(3)])
	this.BgpRouterId = string(randStringTypes(r))
	this.BgpPeerAddress = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.TemplateParameters = make(map[string]string)
		for i := 0; i < v7; i++ {
			this.TemplateParameters[randStringTypes(r)] = randStringTypes(r)
		}
	}
	this.OutsideVip = string(randStringTypes(r))
	this.VipVrrpMode = ves_io_schema4.VipVrrpType([]int32{0, 1, 2}[r.Intn(3)])
	this.SiteToSiteNetworkType = ves_io_schema3.VirtualNetworkType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	this.InsideNameserver = string(randStringTypes(r))
	this.OutsideNameserver = string(randStringTypes(r))
	this.DesiredPoolCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.DesiredPoolCount *= -1
	}
	this.TunnelType = ves_io_schema4.SiteToSiteTunnelType([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.SiteState = SiteState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	this.OperatingSystemVersion = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.MarsList = make([]*ves_io_schema5.ServiceParameters, v8)
		for i := 0; i < v8; i++ {
			this.MarsList[i] = ves_io_schema5.NewPopulatedServiceParameters(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.MarsVtrpList = make([]*ves_io_schema5.ServiceParameters, v9)
		for i := 0; i < v9; i++ {
			this.MarsVtrpList[i] = ves_io_schema5.NewPopulatedServiceParameters(r, easy)
		}
	}
	this.TunnelDeadTimeout = uint32(r.Uint32())
	this.Region = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.Opera = ves_io_schema5.NewPopulatedServiceParameters(r, easy)
	}
	this.CeSiteMode = CeSiteMode([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	this.SiteType = SiteType([]int32{0, 1, 2}[r.Intn(3)])
	this.Address = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.Coordinates = NewPopulatedCoordinates(r, easy)
	}
	this.InsideVip = string(randStringTypes(r))
	this.SiteToSiteTunnelIp = string(randStringTypes(r))
	this.VolterraSoftwareOveride = SiteSoftwareOverrideType([]int32{0, 1, 2}[r.Intn(3)])
	this.BgpRouterId = string(randStringTypes(r))
	this.BgpPeerAddress = string(randStringTypes(r))
	this.OutsideVip = string(randStringTypes(r))
	this.VipVrrpMode = ves_io_schema4.VipVrrpType([]int32{0, 1, 2}[r.Intn(3)])
	this.SiteToSiteNetworkType = ves_io_schema3.VirtualNetworkType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	this.InsideNameserver = string(randStringTypes(r))
	this.OutsideNameserver = string(randStringTypes(r))
	this.DesiredPoolCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.DesiredPoolCount *= -1
	}
	this.TunnelType = ves_io_schema4.SiteToSiteTunnelType([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.OperatingSystemVersion = string(randStringTypes(r))
	this.TunnelDeadTimeout = uint32(r.Uint32())
	this.Region = string(randStringTypes(r))
	this.CeSiteMode = CeSiteMode([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	this.Address = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.Coordinates = NewPopulatedCoordinates(r, easy)
	}
	this.VolterraSoftwareVersion = string(randStringTypes(r))
	this.InsideVip = string(randStringTypes(r))
	this.SiteToSiteTunnelIp = string(randStringTypes(r))
	this.VolterraSoftwareOveride = SiteSoftwareOverrideType([]int32{0, 1, 2}[r.Intn(3)])
	this.BgpRouterId = string(randStringTypes(r))
	this.BgpPeerAddress = string(randStringTypes(r))
	this.OutsideVip = string(randStringTypes(r))
	this.VipVrrpMode = ves_io_schema4.VipVrrpType([]int32{0, 1, 2}[r.Intn(3)])
	this.SiteToSiteNetworkType = ves_io_schema3.VirtualNetworkType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	this.InsideNameserver = string(randStringTypes(r))
	this.OutsideNameserver = string(randStringTypes(r))
	this.DesiredPoolCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.DesiredPoolCount *= -1
	}
	this.TunnelType = ves_io_schema4.SiteToSiteTunnelType([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.OperatingSystemVersion = string(randStringTypes(r))
	this.TunnelDeadTimeout = uint32(r.Uint32())
	this.Region = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	this.SiteType = SiteType([]int32{0, 1, 2}[r.Intn(3)])
	this.Address = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.Coordinates = NewPopulatedCoordinates(r, easy)
	}
	this.VolterraSoftwareVersion = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.ConnectedRe = make([]*ves_io_schema4.ObjectRefType, v10)
		for i := 0; i < v10; i++ {
			this.ConnectedRe[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v11 := r.Intn(5)
		this.ConnectedReForConfig = make([]*ves_io_schema4.ObjectRefType, v11)
		for i := 0; i < v11; i++ {
			this.ConnectedReForConfig[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	this.InsideVip = string(randStringTypes(r))
	this.SiteToSiteTunnelIp = string(randStringTypes(r))
	this.VolterraSoftwareOveride = SiteSoftwareOverrideType([]int32{0, 1, 2}[r.Intn(3)])
	this.BgpRouterId = string(randStringTypes(r))
	this.BgpPeerAddress = string(randStringTypes(r))
	this.OutsideVip = string(randStringTypes(r))
	this.VipVrrpMode = ves_io_schema4.VipVrrpType([]int32{0, 1, 2}[r.Intn(3)])
	this.SiteToSiteNetworkType = ves_io_schema3.VirtualNetworkType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	this.InsideNameserver = string(randStringTypes(r))
	this.OutsideNameserver = string(randStringTypes(r))
	this.DesiredPoolCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.DesiredPoolCount *= -1
	}
	this.TunnelType = ves_io_schema4.SiteToSiteTunnelType([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.OperatingSystemVersion = string(randStringTypes(r))
	this.SiteState = SiteState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	this.TunnelDeadTimeout = uint32(r.Uint32())
	this.Region = string(randStringTypes(r))
	this.CeSiteMode = CeSiteMode([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVerStatusType(r randyTypes, easy bool) *VerStatusType {
	this := &VerStatusType{}
	this.VerInstanceName = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.IpsecStatus = make([]*IpsecConnectionStatus, v12)
		for i := 0; i < v12; i++ {
			this.IpsecStatus[i] = NewPopulatedIpsecConnectionStatus(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.AresStatus = make([]*AresConnectionStatus, v13)
		for i := 0; i < v13; i++ {
			this.AresStatus[i] = NewPopulatedAresConnectionStatus(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v14 := r.Intn(5)
		this.IntfStatus = make([]*InterfaceStatus, v14)
		for i := 0; i < v14; i++ {
			this.IntfStatus[i] = NewPopulatedInterfaceStatus(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v15 := r.Intn(5)
		this.ConfiguredTunnelStatus = make([]*TunnelConnectionStatus, v15)
		for i := 0; i < v15; i++ {
			this.ConfiguredTunnelStatus[i] = NewPopulatedTunnelConnectionStatus(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.SiteTunnelStatus = make([]*TunnelConnectionStatus, v16)
		for i := 0; i < v16; i++ {
			this.SiteTunnelStatus[i] = NewPopulatedTunnelConnectionStatus(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVerMasterStatusType(r randyTypes, easy bool) *VerMasterStatusType {
	this := &VerMasterStatusType{}
	this.VerName = string(randStringTypes(r))
	this.Ver_UID = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.TransitionTimestamp = google_protobuf1.NewPopulatedTimestamp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpsecConnectionStatus(r randyTypes, easy bool) *IpsecConnectionStatus {
	this := &IpsecConnectionStatus{}
	this.Url = string(randStringTypes(r))
	this.State = IPSecState([]int32{0, 1, 2}[r.Intn(3)])
	this.Role = IPSecRole([]int32{0, 1, 2}[r.Intn(3)])
	this.RemoteAddress = string(randStringTypes(r))
	this.IsLocal = bool(bool(r.Intn(2) == 0))
	this.VerNodeName = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAresConnectionStatus(r randyTypes, easy bool) *AresConnectionStatus {
	this := &AresConnectionStatus{}
	this.Url = string(randStringTypes(r))
	this.State = VTRPState([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedInterfaceStatus(r randyTypes, easy bool) *InterfaceStatus {
	this := &InterfaceStatus{}
	if r.Intn(10) != 0 {
		this.Ip = ves_io_schema3.NewPopulatedIpSubnetType(r, easy)
	}
	this.Mac = string(randStringTypes(r))
	this.NetworkType = ves_io_schema3.VirtualNetworkType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	this.Name = string(randStringTypes(r))
	this.IpMode = AddressMode([]int32{0, 1}[r.Intn(2)])
	this.DhcpServer = bool(bool(r.Intn(2) == 0))
	this.NetworkName = string(randStringTypes(r))
	this.LinkState = bool(bool(r.Intn(2) == 0))
	this.ActiveState = ActiveState([]int32{0, 1, 2}[r.Intn(3)])
	this.LinkQuality = LinkQuality([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.LinkType = LinkType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTunnelConnectionStatus(r randyTypes, easy bool) *TunnelConnectionStatus {
	this := &TunnelConnectionStatus{}
	this.Url = string(randStringTypes(r))
	this.State = TunnelState([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.Role = TunnelRole([]int32{0, 1, 2}[r.Intn(3)])
	this.RemoteAddress = string(randStringTypes(r))
	this.Encap = ves_io_schema4.TunnelEncapsulationType([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.IsLocal = bool(bool(r.Intn(2) == 0))
	this.VerNodeName = string(randStringTypes(r))
	this.TunnelName = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVolterraSoftwareStatus(r randyTypes, easy bool) *VolterraSoftwareStatus {
	this := &VolterraSoftwareStatus{}
	this.AvailableVersion = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.DeploymentState = NewPopulatedDeploymentState(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOperatingSystemStatus(r randyTypes, easy bool) *OperatingSystemStatus {
	this := &OperatingSystemStatus{}
	this.AvailableVersion = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.DeploymentState = NewPopulatedDeploymentState(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeploymentState(r randyTypes, easy bool) *DeploymentState {
	this := &DeploymentState{}
	this.Version = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		this.ModificationTimestamp = google_protobuf1.NewPopulatedTimestamp(r, easy)
	}
	this.Result = string(randStringTypes(r))
	this.Message = string(randStringTypes(r))
	this.Phase = SoftwareUpgradePhase([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedScalingStatus(r randyTypes, easy bool) *ScalingStatus {
	this := &ScalingStatus{}
	this.Phase = ScalingPhase([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.Message = string(randStringTypes(r))
	this.PoolNodeCountCurrent = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.PoolNodeCountCurrent *= -1
	}
	this.PoolNodeCountTarget = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.PoolNodeCountTarget *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNodeInfo(r randyTypes, easy bool) *NodeInfo {
	this := &NodeInfo{}
	this.Hostname = string(randStringTypes(r))
	v17 := r.Intn(10)
	this.Role = make([]string, v17)
	for i := 0; i < v17; i++ {
		this.Role[i] = string(randStringTypes(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOsInfo(r randyTypes, easy bool) *OsInfo {
	this := &OsInfo{}
	if r.Intn(10) != 0 {
		this.Os = NewPopulatedOS(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Product = NewPopulatedProduct(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Board = NewPopulatedBoard(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Chassis = NewPopulatedChassis(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Bios = NewPopulatedBios(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Cpu = NewPopulatedCpu(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Memory = NewPopulatedMemory(r, easy)
	}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.Storage = make([]*StorageDevice, v18)
		for i := 0; i < v18; i++ {
			this.Storage[i] = NewPopulatedStorageDevice(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v19 := r.Intn(5)
		this.Network = make([]*NetworkDevice, v19)
		for i := 0; i < v19; i++ {
			this.Network[i] = NewPopulatedNetworkDevice(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Kernel = NewPopulatedKernel(r, easy)
	}
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.Usb = make([]*USBDevice, v20)
		for i := 0; i < v20; i++ {
			this.Usb[i] = NewPopulatedUSBDevice(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOS(r randyTypes, easy bool) *OS {
	this := &OS{}
	this.Name = string(randStringTypes(r))
	this.Vendor = string(randStringTypes(r))
	this.Version = string(randStringTypes(r))
	this.Release = string(randStringTypes(r))
	this.Architecture = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedKernel(r randyTypes, easy bool) *Kernel {
	this := &Kernel{}
	this.Release = string(randStringTypes(r))
	this.Version = string(randStringTypes(r))
	this.Architecture = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProduct(r randyTypes, easy bool) *Product {
	this := &Product{}
	this.Name = string(randStringTypes(r))
	this.Vendor = string(randStringTypes(r))
	this.Version = string(randStringTypes(r))
	this.Serial = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBoard(r randyTypes, easy bool) *Board {
	this := &Board{}
	this.Name = string(randStringTypes(r))
	this.Vendor = string(randStringTypes(r))
	this.Version = string(randStringTypes(r))
	this.Serial = string(randStringTypes(r))
	this.AssetTag = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedChassis(r randyTypes, easy bool) *Chassis {
	this := &Chassis{}
	this.Type = uint32(r.Uint32())
	this.Vendor = string(randStringTypes(r))
	this.Version = string(randStringTypes(r))
	this.Serial = string(randStringTypes(r))
	this.AssetTag = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBios(r randyTypes, easy bool) *Bios {
	this := &Bios{}
	this.Vendor = string(randStringTypes(r))
	this.Version = string(randStringTypes(r))
	this.Date = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCpu(r randyTypes, easy bool) *Cpu {
	this := &Cpu{}
	this.Vendor = string(randStringTypes(r))
	this.Model = string(randStringTypes(r))
	this.Speed = uint32(r.Uint32())
	this.Cache = uint32(r.Uint32())
	this.Cpus = uint32(r.Uint32())
	this.Cores = uint32(r.Uint32())
	this.Threads = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMemory(r randyTypes, easy bool) *Memory {
	this := &Memory{}
	this.Type = string(randStringTypes(r))
	this.Speed = uint32(r.Uint32())
	this.SizeMb = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStorageDevice(r randyTypes, easy bool) *StorageDevice {
	this := &StorageDevice{}
	this.Name = string(randStringTypes(r))
	this.Driver = string(randStringTypes(r))
	this.Vendor = string(randStringTypes(r))
	this.Model = string(randStringTypes(r))
	this.Serial = string(randStringTypes(r))
	this.SizeGb = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNetworkDevice(r randyTypes, easy bool) *NetworkDevice {
	this := &NetworkDevice{}
	this.Name = string(randStringTypes(r))
	this.Driver = string(randStringTypes(r))
	v21 := r.Intn(10)
	this.IpAddress = make([]string, v21)
	for i := 0; i < v21; i++ {
		this.IpAddress[i] = string(randStringTypes(r))
	}
	this.MacAddress = string(randStringTypes(r))
	this.Port = string(randStringTypes(r))
	this.Speed = uint32(r.Uint32())
	this.LinkQuality = LinkQuality([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.LinkType = LinkType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUSBDevice(r randyTypes, easy bool) *USBDevice {
	this := &USBDevice{}
	this.Bus = uint32(r.Uint32())
	this.Address = uint32(r.Uint32())
	this.Port = uint32(r.Uint32())
	this.Description = string(randStringTypes(r))
	this.VendorName = string(randStringTypes(r))
	this.ProductName = string(randStringTypes(r))
	this.ISerial = string(randStringTypes(r))
	this.IdVendor = string(randStringTypes(r))
	this.IdProduct = string(randStringTypes(r))
	this.IManufacturer = string(randStringTypes(r))
	this.Speed = string(randStringTypes(r))
	this.BcdUsb = string(randStringTypes(r))
	this.BcdDevice = string(randStringTypes(r))
	this.BDeviceClass = string(randStringTypes(r))
	this.BDeviceSubClass = string(randStringTypes(r))
	this.BDeviceProtocol = string(randStringTypes(r))
	this.BMaxPacketSize = uint32(r.Uint32())
	this.IProduct = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSiteStatusMetricsFieldData(r randyTypes, easy bool) *SiteStatusMetricsFieldData {
	this := &SiteStatusMetricsFieldData{}
	if r.Intn(10) != 0 {
		v22 := r.Intn(10)
		this.Key = make(map[string]string)
		for i := 0; i < v22; i++ {
			this.Key[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(5)
		this.Value = make([]*ves_io_schema4.MetricValue, v23)
		for i := 0; i < v23; i++ {
			this.Value[i] = ves_io_schema4.NewPopulatedMetricValue(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSiteStatusMetricsData(r randyTypes, easy bool) *SiteStatusMetricsData {
	this := &SiteStatusMetricsData{}
	this.Field = SiteStatusMetricsField([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}[r.Intn(19)])
	if r.Intn(10) != 0 {
		v24 := r.Intn(5)
		this.Data = make([]*SiteStatusMetricsFieldData, v24)
		for i := 0; i < v24; i++ {
			this.Data[i] = NewPopulatedSiteStatusMetricsFieldData(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v25 := r.Intn(100)
	tmps := make([]rune, v25)
	for i := 0; i < v25; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v26 := r.Int63()
		if r.Intn(2) == 0 {
			v26 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v26))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Coordinates) Size() (n int) {
	var l int
	_ = l
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	return n
}

func (m *K8SApiServerParameters) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SiteSubtype != 0 {
		n += 1 + sovTypes(uint64(m.SiteSubtype))
	}
	if len(m.ConnectedRe) > 0 {
		for _, e := range m.ConnectedRe {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ConnectedReForConfig) > 0 {
		for _, e := range m.ConnectedReForConfig {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Vega != nil {
		l = m.Vega.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.AresList) > 0 {
		for _, e := range m.AresList {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Rakar != nil {
		l = m.Rakar.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.StaticRoutes) > 0 {
		for _, s := range m.StaticRoutes {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.K8SApiServers) > 0 {
		for k, v := range m.K8SApiServers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.PublicIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.AresVtrpList) > 0 {
		for _, e := range m.AresVtrpList {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SiteToSiteTunnelIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolterraSoftwareOveride != 0 {
		n += 2 + sovTypes(uint64(m.VolterraSoftwareOveride))
	}
	l = len(m.BgpRouterId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpPeerAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.TemplateParameters) > 0 {
		for k, v := range m.TemplateParameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.OutsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VipVrrpMode != 0 {
		n += 2 + sovTypes(uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		n += 2 + sovTypes(uint64(m.SiteToSiteNetworkType))
	}
	l = len(m.InsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DesiredPoolCount != 0 {
		n += 2 + sovTypes(uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		n += 2 + sovTypes(uint64(m.TunnelType))
	}
	if m.SiteState != 0 {
		n += 2 + sovTypes(uint64(m.SiteState))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.MarsList) > 0 {
		for _, e := range m.MarsList {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.MarsVtrpList) > 0 {
		for _, e := range m.MarsVtrpList {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.TunnelDeadTimeout != 0 {
		n += 2 + sovTypes(uint64(m.TunnelDeadTimeout))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Opera != nil {
		l = m.Opera.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CeSiteMode != 0 {
		n += 2 + sovTypes(uint64(m.CeSiteMode))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SiteToSiteTunnelIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolterraSoftwareOveride != 0 {
		n += 2 + sovTypes(uint64(m.VolterraSoftwareOveride))
	}
	l = len(m.BgpRouterId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpPeerAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VipVrrpMode != 0 {
		n += 2 + sovTypes(uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		n += 2 + sovTypes(uint64(m.SiteToSiteNetworkType))
	}
	l = len(m.InsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DesiredPoolCount != 0 {
		n += 2 + sovTypes(uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		n += 2 + sovTypes(uint64(m.TunnelType))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TunnelDeadTimeout != 0 {
		n += 2 + sovTypes(uint64(m.TunnelDeadTimeout))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CeSiteMode != 0 {
		n += 2 + sovTypes(uint64(m.CeSiteMode))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SiteToSiteTunnelIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolterraSoftwareOveride != 0 {
		n += 2 + sovTypes(uint64(m.VolterraSoftwareOveride))
	}
	l = len(m.BgpRouterId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpPeerAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VipVrrpMode != 0 {
		n += 2 + sovTypes(uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		n += 2 + sovTypes(uint64(m.SiteToSiteNetworkType))
	}
	l = len(m.InsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DesiredPoolCount != 0 {
		n += 2 + sovTypes(uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		n += 2 + sovTypes(uint64(m.TunnelType))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TunnelDeadTimeout != 0 {
		n += 2 + sovTypes(uint64(m.TunnelDeadTimeout))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ConnectedRe) > 0 {
		for _, e := range m.ConnectedRe {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ConnectedReForConfig) > 0 {
		for _, e := range m.ConnectedReForConfig {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.InsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SiteToSiteTunnelIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolterraSoftwareOveride != 0 {
		n += 2 + sovTypes(uint64(m.VolterraSoftwareOveride))
	}
	l = len(m.BgpRouterId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpPeerAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VipVrrpMode != 0 {
		n += 2 + sovTypes(uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		n += 2 + sovTypes(uint64(m.SiteToSiteNetworkType))
	}
	l = len(m.InsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DesiredPoolCount != 0 {
		n += 2 + sovTypes(uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		n += 2 + sovTypes(uint64(m.TunnelType))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.SiteState != 0 {
		n += 2 + sovTypes(uint64(m.SiteState))
	}
	if m.TunnelDeadTimeout != 0 {
		n += 2 + sovTypes(uint64(m.TunnelDeadTimeout))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CeSiteMode != 0 {
		n += 2 + sovTypes(uint64(m.CeSiteMode))
	}
	return n
}

func (m *VerStatusType) Size() (n int) {
	var l int
	_ = l
	l = len(m.VerInstanceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.IpsecStatus) > 0 {
		for _, e := range m.IpsecStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AresStatus) > 0 {
		for _, e := range m.AresStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.IntfStatus) > 0 {
		for _, e := range m.IntfStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ConfiguredTunnelStatus) > 0 {
		for _, e := range m.ConfiguredTunnelStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SiteTunnelStatus) > 0 {
		for _, e := range m.SiteTunnelStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VerMasterStatusType) Size() (n int) {
	var l int
	_ = l
	l = len(m.VerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ver_UID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TransitionTimestamp != nil {
		l = m.TransitionTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IpsecConnectionStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.Role != 0 {
		n += 1 + sovTypes(uint64(m.Role))
	}
	l = len(m.RemoteAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IsLocal {
		n += 2
	}
	l = len(m.VerNodeName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AresConnectionStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	return n
}

func (m *InterfaceStatus) Size() (n int) {
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NetworkType != 0 {
		n += 1 + sovTypes(uint64(m.NetworkType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpMode != 0 {
		n += 1 + sovTypes(uint64(m.IpMode))
	}
	if m.DhcpServer {
		n += 2
	}
	l = len(m.NetworkName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LinkState {
		n += 2
	}
	if m.ActiveState != 0 {
		n += 1 + sovTypes(uint64(m.ActiveState))
	}
	if m.LinkQuality != 0 {
		n += 1 + sovTypes(uint64(m.LinkQuality))
	}
	if m.LinkType != 0 {
		n += 1 + sovTypes(uint64(m.LinkType))
	}
	return n
}

func (m *TunnelConnectionStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.Role != 0 {
		n += 1 + sovTypes(uint64(m.Role))
	}
	l = len(m.RemoteAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Encap != 0 {
		n += 1 + sovTypes(uint64(m.Encap))
	}
	if m.IsLocal {
		n += 2
	}
	l = len(m.VerNodeName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TunnelName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VolterraSoftwareStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.AvailableVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeploymentState != nil {
		l = m.DeploymentState.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OperatingSystemStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.AvailableVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeploymentState != nil {
		l = m.DeploymentState.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DeploymentState) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Phase != 0 {
		n += 1 + sovTypes(uint64(m.Phase))
	}
	return n
}

func (m *ScalingStatus) Size() (n int) {
	var l int
	_ = l
	if m.Phase != 0 {
		n += 1 + sovTypes(uint64(m.Phase))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PoolNodeCountCurrent != 0 {
		n += 1 + sovTypes(uint64(m.PoolNodeCountCurrent))
	}
	if m.PoolNodeCountTarget != 0 {
		n += 1 + sovTypes(uint64(m.PoolNodeCountTarget))
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Role) > 0 {
		for _, s := range m.Role {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *OsInfo) Size() (n int) {
	var l int
	_ = l
	if m.Os != nil {
		l = m.Os.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Board != nil {
		l = m.Board.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Chassis != nil {
		l = m.Chassis.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Bios != nil {
		l = m.Bios.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Kernel != nil {
		l = m.Kernel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Usb) > 0 {
		for _, e := range m.Usb {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *OS) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Release)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Kernel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Release)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Product) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Serial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Board) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Serial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AssetTag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Chassis) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Serial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AssetTag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Bios) Size() (n int) {
	var l int
	_ = l
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Cpu) Size() (n int) {
	var l int
	_ = l
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Speed != 0 {
		n += 1 + sovTypes(uint64(m.Speed))
	}
	if m.Cache != 0 {
		n += 1 + sovTypes(uint64(m.Cache))
	}
	if m.Cpus != 0 {
		n += 1 + sovTypes(uint64(m.Cpus))
	}
	if m.Cores != 0 {
		n += 1 + sovTypes(uint64(m.Cores))
	}
	if m.Threads != 0 {
		n += 1 + sovTypes(uint64(m.Threads))
	}
	return n
}

func (m *Memory) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Speed != 0 {
		n += 1 + sovTypes(uint64(m.Speed))
	}
	if m.SizeMb != 0 {
		n += 1 + sovTypes(uint64(m.SizeMb))
	}
	return n
}

func (m *StorageDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Serial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SizeGb != 0 {
		n += 1 + sovTypes(uint64(m.SizeGb))
	}
	return n
}

func (m *NetworkDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.IpAddress) > 0 {
		for _, s := range m.IpAddress {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Speed != 0 {
		n += 1 + sovTypes(uint64(m.Speed))
	}
	if m.LinkQuality != 0 {
		n += 1 + sovTypes(uint64(m.LinkQuality))
	}
	if m.LinkType != 0 {
		n += 1 + sovTypes(uint64(m.LinkType))
	}
	return n
}

func (m *USBDevice) Size() (n int) {
	var l int
	_ = l
	if m.Bus != 0 {
		n += 1 + sovTypes(uint64(m.Bus))
	}
	if m.Address != 0 {
		n += 1 + sovTypes(uint64(m.Address))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VendorName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ISerial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IdVendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IdProduct)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.IManufacturer)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.Speed)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BcdUsb)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BcdDevice)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BDeviceClass)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BDeviceSubClass)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BDeviceProtocol)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BMaxPacketSize != 0 {
		n += 2 + sovTypes(uint64(m.BMaxPacketSize))
	}
	l = len(m.IProduct)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SiteStatusMetricsFieldData) Size() (n int) {
	var l int
	_ = l
	if len(m.Key) > 0 {
		for k, v := range m.Key {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteStatusMetricsData) Size() (n int) {
	var l int
	_ = l
	if m.Field != 0 {
		n += 1 + sovTypes(uint64(m.Field))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Coordinates) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Coordinates{`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SApiServerParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SApiServerParameters{`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	keysForK8SApiServers := make([]string, 0, len(this.K8SApiServers))
	for k, _ := range this.K8SApiServers {
		keysForK8SApiServers = append(keysForK8SApiServers, k)
	}
	sortkeys.Strings(keysForK8SApiServers)
	mapStringForK8SApiServers := "map[string]*K8SApiServerParameters{"
	for _, k := range keysForK8SApiServers {
		mapStringForK8SApiServers += fmt.Sprintf("%v: %v,", k, this.K8SApiServers[k])
	}
	mapStringForK8SApiServers += "}"
	keysForTemplateParameters := make([]string, 0, len(this.TemplateParameters))
	for k, _ := range this.TemplateParameters {
		keysForTemplateParameters = append(keysForTemplateParameters, k)
	}
	sortkeys.Strings(keysForTemplateParameters)
	mapStringForTemplateParameters := "map[string]string{"
	for _, k := range keysForTemplateParameters {
		mapStringForTemplateParameters += fmt.Sprintf("%v: %v,", k, this.TemplateParameters[k])
	}
	mapStringForTemplateParameters += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "Coordinates", 1) + `,`,
		`SiteSubtype:` + fmt.Sprintf("%v", this.SiteSubtype) + `,`,
		`ConnectedRe:` + strings.Replace(fmt.Sprintf("%v", this.ConnectedRe), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`ConnectedReForConfig:` + strings.Replace(fmt.Sprintf("%v", this.ConnectedReForConfig), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`Vega:` + strings.Replace(fmt.Sprintf("%v", this.Vega), "ServiceParameters", "ves_io_schema5.ServiceParameters", 1) + `,`,
		`AresList:` + strings.Replace(fmt.Sprintf("%v", this.AresList), "ServiceParameters", "ves_io_schema5.ServiceParameters", 1) + `,`,
		`Rakar:` + strings.Replace(fmt.Sprintf("%v", this.Rakar), "ServiceParameters", "ves_io_schema5.ServiceParameters", 1) + `,`,
		`StaticRoutes:` + fmt.Sprintf("%v", this.StaticRoutes) + `,`,
		`K8SApiServers:` + mapStringForK8SApiServers + `,`,
		`PublicIp:` + fmt.Sprintf("%v", this.PublicIp) + `,`,
		`ClusterIp:` + fmt.Sprintf("%v", this.ClusterIp) + `,`,
		`AresVtrpList:` + strings.Replace(fmt.Sprintf("%v", this.AresVtrpList), "ServiceParameters", "ves_io_schema5.ServiceParameters", 1) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`InsideVip:` + fmt.Sprintf("%v", this.InsideVip) + `,`,
		`SiteToSiteTunnelIp:` + fmt.Sprintf("%v", this.SiteToSiteTunnelIp) + `,`,
		`VolterraSoftwareOveride:` + fmt.Sprintf("%v", this.VolterraSoftwareOveride) + `,`,
		`BgpRouterId:` + fmt.Sprintf("%v", this.BgpRouterId) + `,`,
		`BgpPeerAddress:` + fmt.Sprintf("%v", this.BgpPeerAddress) + `,`,
		`TemplateParameters:` + mapStringForTemplateParameters + `,`,
		`OutsideVip:` + fmt.Sprintf("%v", this.OutsideVip) + `,`,
		`VipVrrpMode:` + fmt.Sprintf("%v", this.VipVrrpMode) + `,`,
		`SiteToSiteNetworkType:` + fmt.Sprintf("%v", this.SiteToSiteNetworkType) + `,`,
		`InsideNameserver:` + fmt.Sprintf("%v", this.InsideNameserver) + `,`,
		`OutsideNameserver:` + fmt.Sprintf("%v", this.OutsideNameserver) + `,`,
		`DesiredPoolCount:` + fmt.Sprintf("%v", this.DesiredPoolCount) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`SiteState:` + fmt.Sprintf("%v", this.SiteState) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`MarsList:` + strings.Replace(fmt.Sprintf("%v", this.MarsList), "ServiceParameters", "ves_io_schema5.ServiceParameters", 1) + `,`,
		`MarsVtrpList:` + strings.Replace(fmt.Sprintf("%v", this.MarsVtrpList), "ServiceParameters", "ves_io_schema5.ServiceParameters", 1) + `,`,
		`TunnelDeadTimeout:` + fmt.Sprintf("%v", this.TunnelDeadTimeout) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Opera:` + strings.Replace(fmt.Sprintf("%v", this.Opera), "ServiceParameters", "ves_io_schema5.ServiceParameters", 1) + `,`,
		`CeSiteMode:` + fmt.Sprintf("%v", this.CeSiteMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "Coordinates", 1) + `,`,
		`InsideVip:` + fmt.Sprintf("%v", this.InsideVip) + `,`,
		`SiteToSiteTunnelIp:` + fmt.Sprintf("%v", this.SiteToSiteTunnelIp) + `,`,
		`VolterraSoftwareOveride:` + fmt.Sprintf("%v", this.VolterraSoftwareOveride) + `,`,
		`BgpRouterId:` + fmt.Sprintf("%v", this.BgpRouterId) + `,`,
		`BgpPeerAddress:` + fmt.Sprintf("%v", this.BgpPeerAddress) + `,`,
		`OutsideVip:` + fmt.Sprintf("%v", this.OutsideVip) + `,`,
		`VipVrrpMode:` + fmt.Sprintf("%v", this.VipVrrpMode) + `,`,
		`SiteToSiteNetworkType:` + fmt.Sprintf("%v", this.SiteToSiteNetworkType) + `,`,
		`InsideNameserver:` + fmt.Sprintf("%v", this.InsideNameserver) + `,`,
		`OutsideNameserver:` + fmt.Sprintf("%v", this.OutsideNameserver) + `,`,
		`DesiredPoolCount:` + fmt.Sprintf("%v", this.DesiredPoolCount) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`TunnelDeadTimeout:` + fmt.Sprintf("%v", this.TunnelDeadTimeout) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`CeSiteMode:` + fmt.Sprintf("%v", this.CeSiteMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "Coordinates", 1) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`InsideVip:` + fmt.Sprintf("%v", this.InsideVip) + `,`,
		`SiteToSiteTunnelIp:` + fmt.Sprintf("%v", this.SiteToSiteTunnelIp) + `,`,
		`VolterraSoftwareOveride:` + fmt.Sprintf("%v", this.VolterraSoftwareOveride) + `,`,
		`BgpRouterId:` + fmt.Sprintf("%v", this.BgpRouterId) + `,`,
		`BgpPeerAddress:` + fmt.Sprintf("%v", this.BgpPeerAddress) + `,`,
		`OutsideVip:` + fmt.Sprintf("%v", this.OutsideVip) + `,`,
		`VipVrrpMode:` + fmt.Sprintf("%v", this.VipVrrpMode) + `,`,
		`SiteToSiteNetworkType:` + fmt.Sprintf("%v", this.SiteToSiteNetworkType) + `,`,
		`InsideNameserver:` + fmt.Sprintf("%v", this.InsideNameserver) + `,`,
		`OutsideNameserver:` + fmt.Sprintf("%v", this.OutsideNameserver) + `,`,
		`DesiredPoolCount:` + fmt.Sprintf("%v", this.DesiredPoolCount) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`TunnelDeadTimeout:` + fmt.Sprintf("%v", this.TunnelDeadTimeout) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "Coordinates", 1) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`ConnectedRe:` + strings.Replace(fmt.Sprintf("%v", this.ConnectedRe), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`ConnectedReForConfig:` + strings.Replace(fmt.Sprintf("%v", this.ConnectedReForConfig), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InsideVip:` + fmt.Sprintf("%v", this.InsideVip) + `,`,
		`SiteToSiteTunnelIp:` + fmt.Sprintf("%v", this.SiteToSiteTunnelIp) + `,`,
		`VolterraSoftwareOveride:` + fmt.Sprintf("%v", this.VolterraSoftwareOveride) + `,`,
		`BgpRouterId:` + fmt.Sprintf("%v", this.BgpRouterId) + `,`,
		`BgpPeerAddress:` + fmt.Sprintf("%v", this.BgpPeerAddress) + `,`,
		`OutsideVip:` + fmt.Sprintf("%v", this.OutsideVip) + `,`,
		`VipVrrpMode:` + fmt.Sprintf("%v", this.VipVrrpMode) + `,`,
		`SiteToSiteNetworkType:` + fmt.Sprintf("%v", this.SiteToSiteNetworkType) + `,`,
		`InsideNameserver:` + fmt.Sprintf("%v", this.InsideNameserver) + `,`,
		`OutsideNameserver:` + fmt.Sprintf("%v", this.OutsideNameserver) + `,`,
		`DesiredPoolCount:` + fmt.Sprintf("%v", this.DesiredPoolCount) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`SiteState:` + fmt.Sprintf("%v", this.SiteState) + `,`,
		`TunnelDeadTimeout:` + fmt.Sprintf("%v", this.TunnelDeadTimeout) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`CeSiteMode:` + fmt.Sprintf("%v", this.CeSiteMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VerStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VerStatusType{`,
		`VerInstanceName:` + fmt.Sprintf("%v", this.VerInstanceName) + `,`,
		`IpsecStatus:` + strings.Replace(fmt.Sprintf("%v", this.IpsecStatus), "IpsecConnectionStatus", "IpsecConnectionStatus", 1) + `,`,
		`AresStatus:` + strings.Replace(fmt.Sprintf("%v", this.AresStatus), "AresConnectionStatus", "AresConnectionStatus", 1) + `,`,
		`IntfStatus:` + strings.Replace(fmt.Sprintf("%v", this.IntfStatus), "InterfaceStatus", "InterfaceStatus", 1) + `,`,
		`ConfiguredTunnelStatus:` + strings.Replace(fmt.Sprintf("%v", this.ConfiguredTunnelStatus), "TunnelConnectionStatus", "TunnelConnectionStatus", 1) + `,`,
		`SiteTunnelStatus:` + strings.Replace(fmt.Sprintf("%v", this.SiteTunnelStatus), "TunnelConnectionStatus", "TunnelConnectionStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VerMasterStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VerMasterStatusType{`,
		`VerName:` + fmt.Sprintf("%v", this.VerName) + `,`,
		`Ver_UID:` + fmt.Sprintf("%v", this.Ver_UID) + `,`,
		`TransitionTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.TransitionTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpsecConnectionStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpsecConnectionStatus{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`RemoteAddress:` + fmt.Sprintf("%v", this.RemoteAddress) + `,`,
		`IsLocal:` + fmt.Sprintf("%v", this.IsLocal) + `,`,
		`VerNodeName:` + fmt.Sprintf("%v", this.VerNodeName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AresConnectionStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AresConnectionStatus{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceStatus{`,
		`Ip:` + strings.Replace(fmt.Sprintf("%v", this.Ip), "IpSubnetType", "ves_io_schema3.IpSubnetType", 1) + `,`,
		`Mac:` + fmt.Sprintf("%v", this.Mac) + `,`,
		`NetworkType:` + fmt.Sprintf("%v", this.NetworkType) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`IpMode:` + fmt.Sprintf("%v", this.IpMode) + `,`,
		`DhcpServer:` + fmt.Sprintf("%v", this.DhcpServer) + `,`,
		`NetworkName:` + fmt.Sprintf("%v", this.NetworkName) + `,`,
		`LinkState:` + fmt.Sprintf("%v", this.LinkState) + `,`,
		`ActiveState:` + fmt.Sprintf("%v", this.ActiveState) + `,`,
		`LinkQuality:` + fmt.Sprintf("%v", this.LinkQuality) + `,`,
		`LinkType:` + fmt.Sprintf("%v", this.LinkType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelConnectionStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelConnectionStatus{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`RemoteAddress:` + fmt.Sprintf("%v", this.RemoteAddress) + `,`,
		`Encap:` + fmt.Sprintf("%v", this.Encap) + `,`,
		`IsLocal:` + fmt.Sprintf("%v", this.IsLocal) + `,`,
		`VerNodeName:` + fmt.Sprintf("%v", this.VerNodeName) + `,`,
		`TunnelName:` + fmt.Sprintf("%v", this.TunnelName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSoftwareStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSoftwareStatus{`,
		`AvailableVersion:` + fmt.Sprintf("%v", this.AvailableVersion) + `,`,
		`DeploymentState:` + strings.Replace(fmt.Sprintf("%v", this.DeploymentState), "DeploymentState", "DeploymentState", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OperatingSystemStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OperatingSystemStatus{`,
		`AvailableVersion:` + fmt.Sprintf("%v", this.AvailableVersion) + `,`,
		`DeploymentState:` + strings.Replace(fmt.Sprintf("%v", this.DeploymentState), "DeploymentState", "DeploymentState", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeploymentState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeploymentState{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalingStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalingStatus{`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`PoolNodeCountCurrent:` + fmt.Sprintf("%v", this.PoolNodeCountCurrent) + `,`,
		`PoolNodeCountTarget:` + fmt.Sprintf("%v", this.PoolNodeCountTarget) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInfo{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OsInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OsInfo{`,
		`Os:` + strings.Replace(fmt.Sprintf("%v", this.Os), "OS", "OS", 1) + `,`,
		`Product:` + strings.Replace(fmt.Sprintf("%v", this.Product), "Product", "Product", 1) + `,`,
		`Board:` + strings.Replace(fmt.Sprintf("%v", this.Board), "Board", "Board", 1) + `,`,
		`Chassis:` + strings.Replace(fmt.Sprintf("%v", this.Chassis), "Chassis", "Chassis", 1) + `,`,
		`Bios:` + strings.Replace(fmt.Sprintf("%v", this.Bios), "Bios", "Bios", 1) + `,`,
		`Cpu:` + strings.Replace(fmt.Sprintf("%v", this.Cpu), "Cpu", "Cpu", 1) + `,`,
		`Memory:` + strings.Replace(fmt.Sprintf("%v", this.Memory), "Memory", "Memory", 1) + `,`,
		`Storage:` + strings.Replace(fmt.Sprintf("%v", this.Storage), "StorageDevice", "StorageDevice", 1) + `,`,
		`Network:` + strings.Replace(fmt.Sprintf("%v", this.Network), "NetworkDevice", "NetworkDevice", 1) + `,`,
		`Kernel:` + strings.Replace(fmt.Sprintf("%v", this.Kernel), "Kernel", "Kernel", 1) + `,`,
		`Usb:` + strings.Replace(fmt.Sprintf("%v", this.Usb), "USBDevice", "USBDevice", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OS{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Release:` + fmt.Sprintf("%v", this.Release) + `,`,
		`Architecture:` + fmt.Sprintf("%v", this.Architecture) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Kernel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Kernel{`,
		`Release:` + fmt.Sprintf("%v", this.Release) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Architecture:` + fmt.Sprintf("%v", this.Architecture) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Product) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Product{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Serial:` + fmt.Sprintf("%v", this.Serial) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Board) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Board{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Serial:` + fmt.Sprintf("%v", this.Serial) + `,`,
		`AssetTag:` + fmt.Sprintf("%v", this.AssetTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Chassis) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Chassis{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Serial:` + fmt.Sprintf("%v", this.Serial) + `,`,
		`AssetTag:` + fmt.Sprintf("%v", this.AssetTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Bios) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Bios{`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Cpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Cpu{`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`Speed:` + fmt.Sprintf("%v", this.Speed) + `,`,
		`Cache:` + fmt.Sprintf("%v", this.Cache) + `,`,
		`Cpus:` + fmt.Sprintf("%v", this.Cpus) + `,`,
		`Cores:` + fmt.Sprintf("%v", this.Cores) + `,`,
		`Threads:` + fmt.Sprintf("%v", this.Threads) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Memory) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Memory{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Speed:` + fmt.Sprintf("%v", this.Speed) + `,`,
		`SizeMb:` + fmt.Sprintf("%v", this.SizeMb) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDevice{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Driver:` + fmt.Sprintf("%v", this.Driver) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`Serial:` + fmt.Sprintf("%v", this.Serial) + `,`,
		`SizeGb:` + fmt.Sprintf("%v", this.SizeGb) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkDevice{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Driver:` + fmt.Sprintf("%v", this.Driver) + `,`,
		`IpAddress:` + fmt.Sprintf("%v", this.IpAddress) + `,`,
		`MacAddress:` + fmt.Sprintf("%v", this.MacAddress) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Speed:` + fmt.Sprintf("%v", this.Speed) + `,`,
		`LinkQuality:` + fmt.Sprintf("%v", this.LinkQuality) + `,`,
		`LinkType:` + fmt.Sprintf("%v", this.LinkType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *USBDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&USBDevice{`,
		`Bus:` + fmt.Sprintf("%v", this.Bus) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`VendorName:` + fmt.Sprintf("%v", this.VendorName) + `,`,
		`ProductName:` + fmt.Sprintf("%v", this.ProductName) + `,`,
		`ISerial:` + fmt.Sprintf("%v", this.ISerial) + `,`,
		`IdVendor:` + fmt.Sprintf("%v", this.IdVendor) + `,`,
		`IdProduct:` + fmt.Sprintf("%v", this.IdProduct) + `,`,
		`IManufacturer:` + fmt.Sprintf("%v", this.IManufacturer) + `,`,
		`Speed:` + fmt.Sprintf("%v", this.Speed) + `,`,
		`BcdUsb:` + fmt.Sprintf("%v", this.BcdUsb) + `,`,
		`BcdDevice:` + fmt.Sprintf("%v", this.BcdDevice) + `,`,
		`BDeviceClass:` + fmt.Sprintf("%v", this.BDeviceClass) + `,`,
		`BDeviceSubClass:` + fmt.Sprintf("%v", this.BDeviceSubClass) + `,`,
		`BDeviceProtocol:` + fmt.Sprintf("%v", this.BDeviceProtocol) + `,`,
		`BMaxPacketSize:` + fmt.Sprintf("%v", this.BMaxPacketSize) + `,`,
		`IProduct:` + fmt.Sprintf("%v", this.IProduct) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStatusMetricsFieldData) String() string {
	if this == nil {
		return "nil"
	}
	keysForKey := make([]string, 0, len(this.Key))
	for k, _ := range this.Key {
		keysForKey = append(keysForKey, k)
	}
	sortkeys.Strings(keysForKey)
	mapStringForKey := "map[string]string{"
	for _, k := range keysForKey {
		mapStringForKey += fmt.Sprintf("%v: %v,", k, this.Key[k])
	}
	mapStringForKey += "}"
	s := strings.Join([]string{`&SiteStatusMetricsFieldData{`,
		`Key:` + mapStringForKey + `,`,
		`Value:` + strings.Replace(fmt.Sprintf("%v", this.Value), "MetricValue", "ves_io_schema4.MetricValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStatusMetricsData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStatusMetricsData{`,
		`Field:` + fmt.Sprintf("%v", this.Field) + `,`,
		`Data:` + strings.Replace(fmt.Sprintf("%v", this.Data), "SiteStatusMetricsFieldData", "SiteStatusMetricsFieldData", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Coordinates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coordinates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coordinates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SApiServerParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SApiServerParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SApiServerParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= (SiteType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteSubtype", wireType)
			}
			m.SiteSubtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteSubtype |= (SiteSubtype(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedRe = append(m.ConnectedRe, &ves_io_schema4.ObjectRefType{})
			if err := m.ConnectedRe[len(m.ConnectedRe)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedReForConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedReForConfig = append(m.ConnectedReForConfig, &ves_io_schema4.ObjectRefType{})
			if err := m.ConnectedReForConfig[len(m.ConnectedReForConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vega", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vega == nil {
				m.Vega = &ves_io_schema5.ServiceParameters{}
			}
			if err := m.Vega.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AresList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AresList = append(m.AresList, &ves_io_schema5.ServiceParameters{})
			if err := m.AresList[len(m.AresList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rakar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rakar == nil {
				m.Rakar = &ves_io_schema5.ServiceParameters{}
			}
			if err := m.Rakar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRoutes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRoutes = append(m.StaticRoutes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 109:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SApiServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8SApiServers == nil {
				m.K8SApiServers = make(map[string]*K8SApiServerParameters)
			}
			var mapkey string
			var mapvalue *K8SApiServerParameters
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &K8SApiServerParameters{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.K8SApiServers[mapkey] = mapvalue
			iNdEx = postIndex
		case 110:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 111:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AresVtrpList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AresVtrpList = append(m.AresVtrpList, &ves_io_schema5.ServiceParameters{})
			if err := m.AresVtrpList[len(m.AresVtrpList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteTunnelIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteToSiteTunnelIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareOveride", wireType)
			}
			m.VolterraSoftwareOveride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSoftwareOveride |= (SiteSoftwareOverrideType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 118:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 119:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemplateParameters == nil {
				m.TemplateParameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TemplateParameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipVrrpMode", wireType)
			}
			m.VipVrrpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipVrrpMode |= (ves_io_schema4.VipVrrpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteNetworkType", wireType)
			}
			m.SiteToSiteNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteToSiteNetworkType |= (ves_io_schema3.VirtualNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 123:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 124:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredPoolCount", wireType)
			}
			m.DesiredPoolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredPoolCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (ves_io_schema4.SiteToSiteTunnelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteState", wireType)
			}
			m.SiteState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteState |= (SiteState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 128:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 129:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarsList = append(m.MarsList, &ves_io_schema5.ServiceParameters{})
			if err := m.MarsList[len(m.MarsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 130:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarsVtrpList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarsVtrpList = append(m.MarsVtrpList, &ves_io_schema5.ServiceParameters{})
			if err := m.MarsVtrpList[len(m.MarsVtrpList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 131:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelDeadTimeout", wireType)
			}
			m.TunnelDeadTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelDeadTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 133:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opera", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opera == nil {
				m.Opera = &ves_io_schema5.ServiceParameters{}
			}
			if err := m.Opera.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 134:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CeSiteMode", wireType)
			}
			m.CeSiteMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CeSiteMode |= (CeSiteMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= (SiteType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteTunnelIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteToSiteTunnelIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareOveride", wireType)
			}
			m.VolterraSoftwareOveride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSoftwareOveride |= (SiteSoftwareOverrideType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 118:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipVrrpMode", wireType)
			}
			m.VipVrrpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipVrrpMode |= (ves_io_schema4.VipVrrpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteNetworkType", wireType)
			}
			m.SiteToSiteNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteToSiteNetworkType |= (ves_io_schema3.VirtualNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 123:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 124:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredPoolCount", wireType)
			}
			m.DesiredPoolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredPoolCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (ves_io_schema4.SiteToSiteTunnelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 129:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelDeadTimeout", wireType)
			}
			m.TunnelDeadTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelDeadTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 134:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CeSiteMode", wireType)
			}
			m.CeSiteMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CeSiteMode |= (CeSiteMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteTunnelIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteToSiteTunnelIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareOveride", wireType)
			}
			m.VolterraSoftwareOveride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSoftwareOveride |= (SiteSoftwareOverrideType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 118:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipVrrpMode", wireType)
			}
			m.VipVrrpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipVrrpMode |= (ves_io_schema4.VipVrrpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteNetworkType", wireType)
			}
			m.SiteToSiteNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteToSiteNetworkType |= (ves_io_schema3.VirtualNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 123:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 124:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredPoolCount", wireType)
			}
			m.DesiredPoolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredPoolCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (ves_io_schema4.SiteToSiteTunnelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 129:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelDeadTimeout", wireType)
			}
			m.TunnelDeadTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelDeadTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= (SiteType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedRe = append(m.ConnectedRe, &ves_io_schema4.ObjectRefType{})
			if err := m.ConnectedRe[len(m.ConnectedRe)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedReForConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedReForConfig = append(m.ConnectedReForConfig, &ves_io_schema4.ObjectRefType{})
			if err := m.ConnectedReForConfig[len(m.ConnectedReForConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteTunnelIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteToSiteTunnelIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareOveride", wireType)
			}
			m.VolterraSoftwareOveride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSoftwareOveride |= (SiteSoftwareOverrideType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 118:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipVrrpMode", wireType)
			}
			m.VipVrrpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipVrrpMode |= (ves_io_schema4.VipVrrpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteNetworkType", wireType)
			}
			m.SiteToSiteNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteToSiteNetworkType |= (ves_io_schema3.VirtualNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 123:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 124:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredPoolCount", wireType)
			}
			m.DesiredPoolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredPoolCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (ves_io_schema4.SiteToSiteTunnelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 128:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteState", wireType)
			}
			m.SiteState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteState |= (SiteState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 129:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelDeadTimeout", wireType)
			}
			m.TunnelDeadTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelDeadTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 134:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CeSiteMode", wireType)
			}
			m.CeSiteMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CeSiteMode |= (CeSiteMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerInstanceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerInstanceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpsecStatus = append(m.IpsecStatus, &IpsecConnectionStatus{})
			if err := m.IpsecStatus[len(m.IpsecStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AresStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AresStatus = append(m.AresStatus, &AresConnectionStatus{})
			if err := m.AresStatus[len(m.AresStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntfStatus = append(m.IntfStatus, &InterfaceStatus{})
			if err := m.IntfStatus[len(m.IntfStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfiguredTunnelStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfiguredTunnelStatus = append(m.ConfiguredTunnelStatus, &TunnelConnectionStatus{})
			if err := m.ConfiguredTunnelStatus[len(m.ConfiguredTunnelStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteTunnelStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteTunnelStatus = append(m.SiteTunnelStatus, &TunnelConnectionStatus{})
			if err := m.SiteTunnelStatus[len(m.SiteTunnelStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerMasterStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerMasterStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerMasterStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver_UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver_UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransitionTimestamp == nil {
				m.TransitionTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.TransitionTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecConnectionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecConnectionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecConnectionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (IPSecState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (IPSecRole(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocal = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerNodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerNodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AresConnectionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AresConnectionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AresConnectionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (VTRPState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &ves_io_schema3.IpSubnetType{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			m.NetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkType |= (ves_io_schema3.VirtualNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMode", wireType)
			}
			m.IpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpMode |= (AddressMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpServer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DhcpServer = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LinkState = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveState", wireType)
			}
			m.ActiveState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveState |= (ActiveState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkQuality", wireType)
			}
			m.LinkQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkQuality |= (LinkQuality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkType", wireType)
			}
			m.LinkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkType |= (LinkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelConnectionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelConnectionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelConnectionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (TunnelState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (TunnelRole(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			m.Encap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encap |= (ves_io_schema4.TunnelEncapsulationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocal = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerNodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerNodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TunnelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolterraSoftwareStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolterraSoftwareStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolterraSoftwareStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentState == nil {
				m.DeploymentState = &DeploymentState{}
			}
			if err := m.DeploymentState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatingSystemStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatingSystemStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatingSystemStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentState == nil {
				m.DeploymentState = &DeploymentState{}
			}
			if err := m.DeploymentState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= (SoftwareUpgradePhase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScalingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScalingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScalingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= (ScalingPhase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolNodeCountCurrent", wireType)
			}
			m.PoolNodeCountCurrent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolNodeCountCurrent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolNodeCountTarget", wireType)
			}
			m.PoolNodeCountTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolNodeCountTarget |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = append(m.Role, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &OS{}
			}
			if err := m.Os.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Board", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Board == nil {
				m.Board = &Board{}
			}
			if err := m.Board.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chassis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chassis == nil {
				m.Chassis = &Chassis{}
			}
			if err := m.Chassis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bios", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bios == nil {
				m.Bios = &Bios{}
			}
			if err := m.Bios.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &Cpu{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &Memory{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &StorageDevice{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &NetworkDevice{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kernel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kernel == nil {
				m.Kernel = &Kernel{}
			}
			if err := m.Kernel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usb = append(m.Usb, &USBDevice{})
			if err := m.Usb[len(m.Usb)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Release", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Release = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kernel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kernel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kernel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Release", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Release = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Board) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Board: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Board: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chassis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chassis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chassis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bios) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bios: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bios: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cpu) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cpu: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cpu: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			m.Cache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cache |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			m.Cpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cores |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			m.Threads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threads |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Memory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Memory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Memory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeMb", wireType)
			}
			m.SizeMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeMb |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeGb", wireType)
			}
			m.SizeGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeGb |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = append(m.IpAddress, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkQuality", wireType)
			}
			m.LinkQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkQuality |= (LinkQuality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkType", wireType)
			}
			m.LinkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkType |= (LinkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *USBDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: USBDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: USBDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bus", wireType)
			}
			m.Bus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			m.Address = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Address |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ISerial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ISerial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdVendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdVendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdProduct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdProduct = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IManufacturer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IManufacturer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BcdUsb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BcdUsb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BcdDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BcdDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BDeviceClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BDeviceClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BDeviceSubClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BDeviceSubClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BDeviceProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BDeviceProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BMaxPacketSize", wireType)
			}
			m.BMaxPacketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BMaxPacketSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IProduct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IProduct = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStatusMetricsFieldData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStatusMetricsFieldData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStatusMetricsFieldData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Key[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &ves_io_schema4.MetricValue{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStatusMetricsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStatusMetricsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStatusMetricsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			m.Field = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field |= (SiteStatusMetricsField(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &SiteStatusMetricsFieldData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/site/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/site/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 4465 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7b, 0x4d, 0x6c, 0x23, 0xd7,
	0x7d, 0xb8, 0x86, 0x5f, 0x22, 0x7f, 0xd4, 0xc7, 0xe8, 0xad, 0x56, 0x9a, 0xd5, 0x7a, 0xb9, 0x32,
	0xed, 0xbf, 0xb1, 0x56, 0xb4, 0x92, 0x25, 0xef, 0xda, 0xca, 0xc6, 0x36, 0x42, 0x91, 0x23, 0xed,
	0xac, 0x24, 0x0e, 0x3d, 0x43, 0x6a, 0xff, 0x6e, 0x63, 0x4c, 0x87, 0xc3, 0x27, 0x6a, 0x22, 0x92,
	0x33, 0x99, 0x19, 0x72, 0xbd, 0x6e, 0x53, 0x3b, 0x6e, 0x1a, 0x04, 0x3d, 0x05, 0x45, 0x0b, 0x14,
	0x05, 0x02, 0x14, 0x68, 0x0f, 0x45, 0xce, 0x39, 0x14, 0x0d, 0x50, 0x18, 0xed, 0xa5, 0x28, 0x50,
	0x20, 0x3d, 0x14, 0x08, 0x7a, 0x8a, 0x37, 0x68, 0x91, 0x5e, 0x0a, 0xa3, 0xe8, 0x21, 0xa7, 0xa2,
	0x78, 0x1f, 0x33, 0x1c, 0x52, 0xd4, 0x66, 0x37, 0x4e, 0x52, 0x17, 0xd8, 0x93, 0xe6, 0xfd, 0xbe,
	0xdf, 0xef, 0xeb, 0xfd, 0xe6, 0x71, 0x04, 0x85, 0x01, 0xf6, 0x37, 0x6c, 0x67, 0xd3, 0xb7, 0x4e,
	0x71, 0xd7, 0xdc, 0xf4, 0xed, 0x00, 0x6f, 0x06, 0x0f, 0x5d, 0xec, 0x6f, 0xb8, 0x9e, 0x13, 0x38,
	0x08, 0x31, 0xfc, 0x06, 0xc3, 0x6f, 0x10, 0xfc, 0xca, 0xcd, 0xb6, 0x1d, 0x9c, 0xf6, 0x9b, 0x1b,
	0x96, 0xd3, 0xdd, 0x6c, 0x3b, 0x6d, 0x67, 0x93, 0x92, 0x36, 0xfb, 0x27, 0x74, 0x45, 0x17, 0xf4,
	0x89, 0x89, 0x58, 0xb9, 0xde, 0x76, 0x9c, 0x76, 0x07, 0x0f, 0xa9, 0x02, 0xbb, 0x8b, 0xfd, 0xc0,
	0xec, 0xba, 0x9c, 0x60, 0x79, 0xd4, 0x86, 0x1e, 0x0e, 0x38, 0xe2, 0xea, 0x28, 0xc2, 0x71, 0x03,
	0xdb, 0xe9, 0x71, 0xcb, 0x56, 0xae, 0x8d, 0x22, 0xdd, 0x41, 0x60, 0xc4, 0x0c, 0x5f, 0xb9, 0x32,
	0x8a, 0x8e, 0xa3, 0x9e, 0x1b, 0x45, 0x0d, 0xcc, 0x8e, 0xdd, 0x32, 0x03, 0xcc, 0xb1, 0xab, 0x63,
	0x58, 0x1b, 0x3f, 0x30, 0x46, 0x34, 0x17, 0xbb, 0x90, 0x2f, 0x3b, 0x8e, 0xd7, 0xb2, 0x7b, 0x66,
	0x80, 0x7d, 0x74, 0x13, 0xb2, 0x1d, 0x33, 0xb0, 0x83, 0x7e, 0x0b, 0x4b, 0xc2, 0xaa, 0x70, 0x23,
	0xb1, 0xbb, 0xf0, 0xd7, 0xff, 0xfe, 0x71, 0x72, 0x06, 0xe0, 0xda, 0xd4, 0xd4, 0xf7, 0x77, 0x6f,
	0x4e, 0x4d, 0x7d, 0xff, 0x6f, 0xb5, 0x88, 0x04, 0x6d, 0x42, 0xae, 0xe3, 0xf4, 0xda, 0x8c, 0x3e,
	0x31, 0x4e, 0x7f, 0xab, 0x7c, 0x73, 0x6a, 0xea, 0xd6, 0xdf, 0x69, 0x43, 0x9a, 0x62, 0x01, 0x96,
	0x0e, 0x76, 0xf4, 0x92, 0x6b, 0xeb, 0xd8, 0x1b, 0x60, 0xaf, 0x66, 0x7a, 0x66, 0x17, 0x07, 0xd8,
	0xf3, 0xef, 0xa5, 0xb2, 0x82, 0x98, 0x28, 0xfe, 0xf8, 0x12, 0xcc, 0xed, 0x77, 0x9c, 0xa6, 0xd9,
	0xd1, 0x5d, 0x6c, 0xd5, 0x1f, 0xba, 0x18, 0xc9, 0x90, 0x23, 0x91, 0xa2, 0x0e, 0xa1, 0x36, 0xcd,
	0x6d, 0x3f, 0xb7, 0x71, 0x3e, 0x92, 0x1b, 0xba, 0x1d, 0x60, 0xc2, 0xb0, 0x0b, 0xc4, 0x82, 0xf4,
	0x47, 0x42, 0x62, 0x75, 0x4a, 0xcb, 0xfa, 0x1c, 0x8a, 0x5e, 0x84, 0x69, 0xb3, 0xd5, 0xf2, 0xb0,
	0xef, 0x53, 0x43, 0x73, 0x9c, 0xcc, 0x4b, 0x4a, 0x1f, 0x26, 0xb4, 0x10, 0x85, 0x4a, 0x90, 0xb7,
	0x86, 0xee, 0x90, 0x92, 0xab, 0xc2, 0x8d, 0xfc, 0xf6, 0xf5, 0x49, 0xea, 0x62, 0x5e, 0xd3, 0xe2,
	0x3c, 0x68, 0x17, 0x66, 0xa8, 0xbd, 0x7e, 0xbf, 0x49, 0x4d, 0x4e, 0x53, 0x93, 0xaf, 0x5f, 0x64,
	0xb2, 0xce, 0xc8, 0xb4, 0xbc, 0x3f, 0x5c, 0xa0, 0xbb, 0x30, 0x63, 0x39, 0xbd, 0x1e, 0xb6, 0x02,
	0xdc, 0x32, 0x3c, 0x2c, 0xb5, 0x57, 0x93, 0x37, 0xf2, 0xe7, 0xb6, 0xad, 0x36, 0xbf, 0x8a, 0xad,
	0x40, 0xc3, 0x27, 0x74, 0xdb, 0xd3, 0xdf, 0xfb, 0x7a, 0x8a, 0xc8, 0x20, 0xd6, 0x70, 0x56, 0x0d,
	0xa3, 0xaf, 0xc0, 0x72, 0x5c, 0x92, 0x71, 0xe2, 0x78, 0x86, 0xe5, 0xf4, 0x4e, 0xec, 0xb6, 0x74,
	0xfa, 0x34, 0x42, 0x17, 0x63, 0x42, 0xf7, 0x1c, 0xaf, 0x4c, 0x45, 0xa0, 0x5b, 0x90, 0x1a, 0xe0,
	0xb6, 0x29, 0xd9, 0xd4, 0x4f, 0xab, 0x63, 0xa2, 0x48, 0x8c, 0x6d, 0x0b, 0x0f, 0x83, 0xac, 0x51,
	0x6a, 0xf4, 0x26, 0xe4, 0x4c, 0x0f, 0xfb, 0x46, 0xc7, 0xf6, 0x03, 0xe9, 0xab, 0xd4, 0x8a, 0x9f,
	0xcf, 0x9a, 0x25, 0x2c, 0x87, 0xb6, 0x1f, 0xa0, 0xd7, 0x20, 0xed, 0x99, 0x67, 0xa6, 0x27, 0x9d,
	0x3d, 0xa1, 0x56, 0x46, 0x8e, 0x6e, 0xc1, 0xac, 0x1f, 0x98, 0x81, 0x6d, 0x19, 0x9e, 0xd3, 0x27,
	0xd1, 0xed, 0xac, 0x26, 0x6f, 0xe4, 0x76, 0xe7, 0x49, 0x1e, 0xc0, 0x1f, 0x0a, 0xd3, 0xc5, 0xb4,
	0x97, 0xfc, 0x99, 0x20, 0x68, 0x33, 0x8c, 0x4a, 0xa3, 0x44, 0xe8, 0x5d, 0x98, 0x3f, 0xdb, 0xf1,
	0x0d, 0xd3, 0xb5, 0x0d, 0x9f, 0xe6, 0xac, 0x2f, 0x75, 0xa9, 0xc9, 0xb7, 0x27, 0x45, 0x74, 0x34,
	0x77, 0x37, 0x0e, 0x76, 0xfc, 0x28, 0xd7, 0x7d, 0xb9, 0x17, 0x78, 0x0f, 0xb5, 0xd9, 0xb3, 0x38,
	0x0c, 0xbd, 0x04, 0x39, 0xb7, 0xdf, 0xec, 0xd8, 0x96, 0x61, 0xbb, 0x52, 0x8f, 0x26, 0x66, 0x8e,
	0x18, 0x94, 0xf2, 0x12, 0xae, 0xa0, 0x65, 0x19, 0x4e, 0x71, 0xd1, 0x0d, 0x00, 0xab, 0xd3, 0xf7,
	0x03, 0xec, 0x11, 0x42, 0x67, 0x9c, 0x30, 0xc7, 0x91, 0x8a, 0x8b, 0xf6, 0x60, 0x8e, 0x7a, 0x77,
	0x10, 0x78, 0x2e, 0x73, 0xb1, 0xfb, 0x84, 0x2e, 0x9e, 0x21, 0x7c, 0xc7, 0x81, 0xe7, 0x52, 0x37,
	0xdf, 0x81, 0x2b, 0x03, 0xa7, 0x13, 0x60, 0xcf, 0x33, 0x0d, 0xdf, 0x39, 0x09, 0x1e, 0x98, 0x1e,
	0x36, 0x88, 0xcd, 0xb6, 0xd3, 0x93, 0xbe, 0x46, 0x0c, 0xd0, 0x96, 0x43, 0x02, 0x9d, 0xe3, 0x8f,
	0x19, 0x9a, 0x58, 0x6b, 0xf7, 0x7c, 0xbb, 0x85, 0x8d, 0x81, 0xed, 0x4a, 0xde, 0x39, 0x6b, 0x19,
	0xf2, 0xd8, 0x76, 0xd1, 0x9b, 0xb0, 0xc4, 0xaa, 0xdb, 0x31, 0xd8, 0xdf, 0x7e, 0xaf, 0x87, 0x3b,
	0x64, 0x8f, 0xfe, 0x38, 0x17, 0xa2, 0xb5, 0xec, 0xd0, 0x3a, 0xa7, 0x54, 0x8a, 0x8b, 0x4e, 0x27,
	0x19, 0xe9, 0x0c, 0xb0, 0x67, 0xb7, 0xb0, 0x14, 0xd0, 0xca, 0x5b, 0xbf, 0xb0, 0xf2, 0x38, 0xbd,
	0x3a, 0xc0, 0x1e, 0xa1, 0x27, 0x11, 0x3b, 0xbf, 0x25, 0x95, 0x09, 0x43, 0x37, 0x61, 0xb6, 0xd9,
	0x76, 0x59, 0xea, 0x78, 0x86, 0xdd, 0x92, 0xfa, 0xe3, 0xf6, 0xe5, 0x9b, 0x6d, 0x97, 0x26, 0x8d,
	0xa7, 0xb4, 0xd0, 0xab, 0x20, 0x12, 0x72, 0x17, 0x63, 0xcf, 0x08, 0xfb, 0xce, 0x60, 0x9c, 0x63,
	0xae, 0xd9, 0x76, 0x6b, 0x18, 0x7b, 0x25, 0xde, 0x7d, 0xce, 0xe0, 0x52, 0x80, 0xbb, 0x6e, 0xc7,
	0x0c, 0xb0, 0xe1, 0x46, 0x71, 0x91, 0x1e, 0xd0, 0xf8, 0xdd, 0x79, 0x82, 0x7c, 0xab, 0x73, 0xee,
	0x61, 0x50, 0x59, 0xd2, 0xa1, 0xe0, 0x1c, 0x02, 0xad, 0x41, 0xde, 0xe9, 0x07, 0x51, 0x90, 0xde,
	0x1b, 0x37, 0x0e, 0x38, 0x96, 0x44, 0xe9, 0x2d, 0x98, 0x1d, 0xd8, 0xae, 0x31, 0xf0, 0x3c, 0xd7,
	0xe8, 0x3a, 0x2d, 0x2c, 0x3d, 0xa4, 0xae, 0x5d, 0x19, 0x33, 0xe9, 0xd8, 0x76, 0x8f, 0x3d, 0xcf,
	0xa5, 0x8e, 0xcc, 0x0f, 0xd8, 0xe2, 0xc8, 0x69, 0x61, 0xf4, 0x9b, 0x70, 0x65, 0x24, 0xca, 0x3d,
	0x1c, 0x3c, 0x70, 0xbc, 0x33, 0xd6, 0xd3, 0xdf, 0xa7, 0xb2, 0x9e, 0x3f, 0x27, 0xcb, 0x0b, 0xfa,
	0x66, 0xa7, 0xca, 0x28, 0xa9, 0xc8, 0xcb, 0xc3, 0x04, 0x88, 0x81, 0xd1, 0x6b, 0xb0, 0xc0, 0x93,
	0xad, 0x67, 0x76, 0x31, 0x2b, 0x52, 0xe9, 0xb7, 0xc7, 0xb7, 0x23, 0x32, 0x9a, 0x6a, 0x44, 0x82,
	0x76, 0x00, 0x85, 0x0e, 0x88, 0x31, 0xfe, 0xce, 0x38, 0xe3, 0x02, 0x27, 0x8a, 0x71, 0xae, 0x03,
	0x6a, 0x61, 0xdf, 0xf6, 0x70, 0xcb, 0x70, 0x1d, 0xa7, 0x63, 0x58, 0x4e, 0xbf, 0x17, 0x48, 0x5f,
	0x5f, 0x15, 0x6e, 0xa4, 0x35, 0x91, 0x63, 0x6a, 0x8e, 0xd3, 0x29, 0x13, 0x38, 0x7a, 0x00, 0x79,
	0x9e, 0xd5, 0x74, 0xbb, 0xbf, 0x4b, 0xb7, 0xfb, 0xc2, 0x78, 0x35, 0x8e, 0xe5, 0x36, 0xed, 0xbe,
	0x5b, 0xff, 0xf2, 0x03, 0x61, 0x55, 0x57, 0xea, 0xb2, 0x51, 0x57, 0x0d, 0xf6, 0xb7, 0x51, 0xad,
	0xca, 0x87, 0x86, 0x52, 0xd3, 0xe5, 0xb2, 0xa1, 0x6a, 0x86, 0xae, 0x1f, 0x12, 0x4b, 0xb3, 0x1f,
	0x09, 0xe9, 0x95, 0xe4, 0x94, 0x90, 0xd0, 0x20, 0x88, 0xd8, 0xd1, 0x1b, 0x00, 0xec, 0x24, 0x0a,
	0xcc, 0x00, 0x4b, 0x1f, 0x50, 0xbd, 0xd7, 0x2e, 0xac, 0x06, 0x42, 0xa4, 0xd1, 0xa3, 0x96, 0x3e,
	0xa2, 0x2f, 0x82, 0xe4, 0xb8, 0xd8, 0x33, 0x03, 0xbb, 0xd7, 0x36, 0xfc, 0x87, 0x7e, 0x80, 0xbb,
	0x51, 0xf9, 0x7f, 0x28, 0xd0, 0xfa, 0x5f, 0x8a, 0x08, 0x74, 0x8a, 0x0f, 0xcb, 0xff, 0x2d, 0xc8,
	0x75, 0x4d, 0x8f, 0x37, 0xf8, 0x6f, 0x08, 0x4f, 0xda, 0xe1, 0x09, 0x0f, 0x6d, 0x3d, 0xfb, 0x30,
	0x47, 0xf9, 0x87, 0x2d, 0xec, 0xa3, 0x27, 0x15, 0x32, 0x43, 0x18, 0xa3, 0x1e, 0xf6, 0x06, 0x5c,
	0xe2, 0xae, 0x6f, 0x61, 0xb3, 0x65, 0x90, 0x61, 0xcd, 0xe9, 0x07, 0xd2, 0xef, 0x11, 0xf3, 0x67,
	0x77, 0xf3, 0xc4, 0x75, 0x99, 0xb5, 0x94, 0xf4, 0x67, 0xff, 0x0d, 0xda, 0x02, 0x23, 0xac, 0x60,
	0xb3, 0x55, 0x67, 0x64, 0x68, 0x19, 0x32, 0x1e, 0x6e, 0x93, 0xfd, 0x7e, 0x93, 0xed, 0x97, 0x2f,
	0xd1, 0xeb, 0x90, 0xa6, 0x3b, 0x97, 0x7e, 0x5f, 0x78, 0xd2, 0x23, 0x88, 0xd2, 0xa3, 0x12, 0xcc,
	0x58, 0x98, 0x95, 0x00, 0x2d, 0xa3, 0x6f, 0xb1, 0x79, 0xa6, 0x30, 0x71, 0xc0, 0xc0, 0x24, 0x2c,
	0xa4, 0x7c, 0x34, 0xb0, 0xa2, 0xe7, 0x95, 0x0e, 0xa0, 0xf3, 0xa7, 0x0a, 0x12, 0x21, 0x79, 0x86,
	0x1f, 0x4a, 0xcc, 0x4c, 0xf2, 0x88, 0xbe, 0x0c, 0xe9, 0x81, 0xd9, 0xe9, 0xb3, 0xb1, 0x2c, 0xbf,
	0xbd, 0x36, 0x49, 0xc5, 0xe4, 0x51, 0x4c, 0x63, 0x8c, 0x77, 0x12, 0x3b, 0xc2, 0x8a, 0x0c, 0xcb,
	0x17, 0xf4, 0x94, 0x09, 0x2a, 0x17, 0xe3, 0x2a, 0x73, 0x31, 0x31, 0xf7, 0x52, 0x59, 0x2c, 0x9e,
	0xdc, 0x4b, 0x65, 0x4f, 0xc4, 0x76, 0xf1, 0xa7, 0x59, 0x98, 0x2b, 0x7b, 0xd8, 0x0c, 0x70, 0x34,
	0xe2, 0x7d, 0xf1, 0x29, 0x47, 0xbc, 0xd8, 0x58, 0x27, 0x8d, 0x8d, 0x75, 0xbf, 0xd4, 0x51, 0xee,
	0xd9, 0x31, 0xf6, 0x0b, 0x1d, 0x63, 0xcf, 0x4e, 0x96, 0x5f, 0xd3, 0xc9, 0x52, 0xf9, 0x45, 0x4f,
	0x96, 0x91, 0x63, 0x62, 0xe7, 0x31, 0x8d, 0xfe, 0x83, 0xc7, 0xf6, 0xf9, 0xcd, 0xc9, 0xed, 0xf5,
	0x1b, 0xb4, 0xbd, 0x3e, 0x55, 0x47, 0xfd, 0xec, 0x8d, 0xf1, 0xce, 0xc2, 0x3f, 0xbc, 0x35, 0xf6,
	0xea, 0x58, 0xfc, 0xd7, 0x2c, 0xcc, 0x6b, 0xd8, 0xed, 0x98, 0xd6, 0xb0, 0xd7, 0xfc, 0x4a, 0x1b,
	0xc6, 0x63, 0x67, 0xe6, 0xd4, 0xb3, 0x99, 0xf9, 0x59, 0xb3, 0x79, 0xd6, 0x6c, 0xfe, 0xd7, 0x9b,
	0xcd, 0x1d, 0xe5, 0x5c, 0xa7, 0xf8, 0xcf, 0xb7, 0x6e, 0xdf, 0x5a, 0xdf, 0xda, 0x7e, 0x7d, 0x7d,
	0x7b, 0xfd, 0xd5, 0xf5, 0xad, 0xed, 0xdb, 0xeb, 0x5b, 0x5b, 0x64, 0xfd, 0xca, 0xfa, 0xd6, 0xf6,
	0xd6, 0xfa, 0xd6, 0xd6, 0xeb, 0xeb, 0x5b, 0x5b, 0x3b, 0xeb, 0x5b, 0xdb, 0x04, 0x47, 0xe0, 0xdb,
	0xeb, 0x5b, 0xdb, 0xaf, 0xad, 0x6f, 0x6d, 0xdd, 0xe6, 0xb7, 0x56, 0xdf, 0xce, 0x43, 0x7e, 0x1f,
	0x07, 0x9f, 0xfb, 0x79, 0xe6, 0xb3, 0xb4, 0xa7, 0xff, 0x2b, 0x57, 0x52, 0xcf, 0xda, 0xe8, 0xb3,
	0x36, 0xfa, 0xac, 0x8d, 0x5e, 0xdc, 0x46, 0xdf, 0x1c, 0xb9, 0x14, 0xf8, 0x50, 0x78, 0xca, 0x5b,
	0x81, 0xcf, 0xfb, 0xc8, 0xf7, 0x6f, 0x49, 0x98, 0x3d, 0xc6, 0x1e, 0x31, 0xb6, 0xef, 0x53, 0x57,
	0xad, 0xc1, 0xc2, 0x80, 0x94, 0x4d, 0xcf, 0x0f, 0xcc, 0x9e, 0xc5, 0xa2, 0xcb, 0xdf, 0x5a, 0xe7,
	0x07, 0xd8, 0x53, 0x38, 0x9c, 0x04, 0x14, 0x1d, 0xc2, 0x8c, 0xed, 0xfa, 0xd8, 0xa2, 0xde, 0xe9,
	0x93, 0x16, 0x4c, 0xfa, 0xd1, 0xcb, 0x93, 0x4c, 0x52, 0x08, 0x5d, 0x99, 0x75, 0x20, 0xdb, 0xe9,
	0x31, 0x85, 0x5a, 0x9e, 0xb2, 0xb3, 0x05, 0x52, 0x20, 0x4f, 0x6f, 0x62, 0xb9, 0xb0, 0x24, 0x15,
	0x76, 0x63, 0x92, 0xb0, 0x92, 0x87, 0xfd, 0x73, 0xb2, 0x80, 0x30, 0x73, 0x51, 0x15, 0xc8, 0xdb,
	0xbd, 0xe0, 0x24, 0x14, 0x95, 0xa2, 0xa2, 0x5e, 0x98, 0x68, 0x57, 0x2f, 0xc0, 0xde, 0x09, 0x99,
	0x78, 0xb9, 0x14, 0xc2, 0xc7, 0xa5, 0xb4, 0x40, 0x62, 0x8d, 0xb6, 0x4f, 0x92, 0x95, 0xc7, 0x91,
	0x8b, 0x4c, 0x53, 0x91, 0x13, 0xaf, 0x09, 0x58, 0x0e, 0x9e, 0xb3, 0x6f, 0x69, 0x28, 0x8b, 0x51,
	0x70, 0x2d, 0xff, 0x1f, 0x50, 0xbc, 0x9f, 0x72, 0xf9, 0x99, 0xa7, 0x96, 0x2f, 0xfa, 0x51, 0xfe,
	0x33, 0xc8, 0xbd, 0x54, 0x76, 0x5a, 0xcc, 0xde, 0x4b, 0x65, 0xb3, 0x62, 0xae, 0xf8, 0x27, 0x02,
	0x5c, 0x3a, 0xc6, 0xde, 0x91, 0xe9, 0x07, 0x23, 0xe1, 0xbe, 0x02, 0x59, 0x12, 0xee, 0x58, 0x94,
	0xa7, 0x07, 0xd8, 0xa3, 0xd1, 0x5d, 0x06, 0xf2, 0x68, 0x34, 0x94, 0x0a, 0x3f, 0x5b, 0x33, 0x03,
	0xec, 0x35, 0x94, 0x0a, 0x3a, 0x82, 0xc5, 0xc0, 0x33, 0x7b, 0xbe, 0x4d, 0xb4, 0x1b, 0xd1, 0x4f,
	0x7a, 0xfc, 0x8c, 0x5d, 0xd9, 0x60, 0x3f, 0xfa, 0x6d, 0x84, 0x3f, 0xfa, 0x6d, 0xd4, 0x43, 0x0a,
	0xed, 0xd2, 0x90, 0x2f, 0x02, 0x16, 0xff, 0x4b, 0x80, 0xcb, 0x13, 0xd3, 0x03, 0x89, 0x90, 0xec,
	0x7b, 0x9d, 0xf0, 0xce, 0xa4, 0xef, 0x75, 0xd0, 0x2d, 0x48, 0xb3, 0x4a, 0x4c, 0x5c, 0x9c, 0xfd,
	0x4a, 0x4d, 0x67, 0x39, 0x85, 0x35, 0x46, 0x8c, 0xb6, 0x20, 0xe5, 0x39, 0x1d, 0x4c, 0x0d, 0xbc,
	0xa0, 0x7a, 0x29, 0x93, 0xe6, 0x74, 0xb0, 0x46, 0x49, 0xd1, 0x8b, 0x30, 0xeb, 0xe1, 0xae, 0x13,
	0x60, 0xde, 0xf1, 0xf9, 0x79, 0x3f, 0x0a, 0x24, 0xe3, 0x87, 0xed, 0x1f, 0x3a, 0x96, 0xd9, 0xa1,
	0xbf, 0x5b, 0x65, 0xb5, 0x70, 0x89, 0x56, 0x21, 0x4f, 0xfc, 0xe8, 0xb0, 0xd6, 0x27, 0x65, 0x28,
	0x77, 0x1c, 0x54, 0x7c, 0x17, 0x16, 0x27, 0xe5, 0xf1, 0x84, 0x4d, 0xbf, 0x3a, 0xba, 0xe9, 0x89,
	0xf6, 0x1f, 0xd7, 0xb5, 0x5a, 0x7c, 0xcf, 0xc5, 0xef, 0xa4, 0x60, 0x7e, 0x2c, 0xb9, 0xd1, 0x17,
	0x20, 0x61, 0xbb, 0x12, 0xbb, 0x84, 0xbb, 0x3a, 0x26, 0x45, 0x71, 0xf5, 0x7e, 0xb3, 0x87, 0x03,
	0xda, 0x3b, 0x13, 0xb6, 0x4b, 0xec, 0xe8, 0x9a, 0x16, 0x0f, 0x3d, 0x79, 0x44, 0x15, 0x98, 0x19,
	0x39, 0x7b, 0x92, 0x4f, 0x7a, 0xf6, 0xe4, 0x7b, 0xb1, 0x13, 0x07, 0x41, 0x8a, 0x66, 0x1b, 0x73,
	0x28, 0x7d, 0x46, 0x3b, 0x30, 0x6d, 0xf3, 0xc3, 0xf1, 0x31, 0xbf, 0xff, 0x71, 0xaf, 0xd3, 0xbe,
	0x96, 0xb1, 0xd9, 0xe1, 0x78, 0x1d, 0xf2, 0xad, 0x53, 0xcb, 0xe5, 0x3f, 0x36, 0x51, 0x3f, 0x67,
	0x35, 0x20, 0x20, 0x76, 0x4f, 0x87, 0x9e, 0x1f, 0x1a, 0x4d, 0xd5, 0x66, 0x59, 0x24, 0x38, 0x8c,
	0x26, 0xfa, 0x35, 0x80, 0x8e, 0xdd, 0x3b, 0xe3, 0x3d, 0x3e, 0x47, 0x45, 0xe4, 0x08, 0x84, 0xf5,
	0xf0, 0x5d, 0x98, 0x31, 0xad, 0xc0, 0x1e, 0x84, 0x87, 0x00, 0x3c, 0xc6, 0x42, 0x4a, 0xc7, 0xe2,
	0x90, 0x37, 0x87, 0x0b, 0x22, 0x83, 0xaa, 0xf8, 0x5a, 0xdf, 0xec, 0xd8, 0xc1, 0x43, 0x29, 0x7f,
	0xb1, 0x8c, 0x43, 0xbb, 0x77, 0xf6, 0x36, 0x23, 0xd3, 0xf2, 0x9d, 0xe1, 0x82, 0x8c, 0xc9, 0x54,
	0x06, 0xf5, 0xfd, 0xcc, 0xc5, 0x63, 0x32, 0x11, 0xc0, 0xc6, 0xe4, 0x0e, 0x7f, 0x62, 0x9d, 0xa0,
	0xf8, 0xcf, 0x09, 0x58, 0x9a, 0xdc, 0x3c, 0x26, 0x24, 0xdd, 0xed, 0xd1, 0xa4, 0xbb, 0x7e, 0x71,
	0x27, 0x1a, 0x29, 0xb5, 0xed, 0x91, 0x52, 0x2b, 0x5c, 0xcc, 0xf5, 0xd4, 0xb5, 0xf6, 0x06, 0xa4,
	0x71, 0xcf, 0x32, 0x5d, 0x9e, 0x21, 0x2f, 0x8d, 0x89, 0x66, 0x52, 0x65, 0x42, 0xe1, 0xf7, 0x3b,
	0x26, 0x6d, 0x31, 0xc4, 0x09, 0x8c, 0x29, 0x5e, 0xa9, 0x99, 0xc7, 0x56, 0xea, 0xf4, 0xb9, 0x4a,
	0x45, 0x05, 0xe0, 0xb3, 0x44, 0x75, 0x98, 0x40, 0x31, 0x48, 0xf1, 0x8f, 0x05, 0x58, 0x3a, 0x1e,
	0x1b, 0x46, 0xa3, 0x8a, 0x5b, 0x30, 0x07, 0xa6, 0xdd, 0x31, 0x9b, 0x9d, 0xe1, 0xab, 0x03, 0xf3,
	0xb2, 0x18, 0x21, 0xc2, 0x59, 0xa3, 0x0a, 0x62, 0x0b, 0xbb, 0x1d, 0xe7, 0x61, 0x17, 0xf7, 0x02,
	0x63, 0xe8, 0xfd, 0x0b, 0x8e, 0xae, 0x4a, 0x44, 0xcb, 0x22, 0x30, 0xdf, 0x1a, 0x05, 0x14, 0xff,
	0x48, 0x80, 0xcb, 0xea, 0xe8, 0x58, 0xf3, 0x79, 0x30, 0xeb, 0x53, 0x01, 0xe6, 0xc7, 0x88, 0x48,
	0x78, 0x46, 0xcd, 0x08, 0x97, 0xe8, 0x6d, 0x58, 0xea, 0x3a, 0x2d, 0xfb, 0xc4, 0xb6, 0xcc, 0xb1,
	0xe3, 0x26, 0xf1, 0x73, 0x8f, 0x9b, 0xcb, 0x71, 0xce, 0x08, 0x8c, 0x96, 0xc8, 0x8c, 0xe5, 0xf7,
	0x3b, 0x01, 0xcd, 0x52, 0x3a, 0x62, 0x91, 0x15, 0x31, 0xa2, 0x8b, 0x7d, 0xdf, 0x6c, 0x87, 0xcd,
	0x29, 0x5c, 0xa2, 0xb7, 0x20, 0xed, 0x9e, 0x9a, 0x7e, 0xd8, 0x9d, 0x26, 0x0e, 0x25, 0x61, 0xe4,
	0x1b, 0x6e, 0xdb, 0x33, 0x5b, 0xb8, 0x46, 0xe8, 0x35, 0xc6, 0x56, 0xfc, 0x47, 0x01, 0x66, 0x75,
	0xcb, 0xec, 0x90, 0x38, 0xb0, 0x08, 0xbc, 0x16, 0x4a, 0x64, 0x63, 0xdc, 0xea, 0x44, 0x89, 0x8c,
	0x23, 0x2e, 0x29, 0x6e, 0x63, 0x62, 0xd4, 0xc6, 0xdb, 0xb0, 0x4c, 0xe7, 0xe9, 0x9e, 0xd3, 0xc2,
	0x6c, 0xa8, 0x36, 0xac, 0xbe, 0xe7, 0xe1, 0x1e, 0xdb, 0x66, 0x5a, 0x5b, 0x24, 0x68, 0x92, 0xd4,
	0x74, 0xb2, 0x2e, 0x33, 0x1c, 0x7a, 0x15, 0x96, 0xc6, 0xd9, 0x02, 0xd3, 0x6b, 0xe3, 0x80, 0xfa,
	0x20, 0xad, 0x5d, 0x1a, 0xe1, 0xaa, 0x53, 0x54, 0xf1, 0x0e, 0x64, 0x09, 0x48, 0xe9, 0x9d, 0x38,
	0x68, 0x05, 0xb2, 0xa7, 0x8e, 0x1f, 0xc4, 0x26, 0x88, 0x68, 0x4d, 0x7a, 0x3d, 0xed, 0x06, 0x64,
	0x30, 0xcc, 0xb1, 0x6a, 0x2f, 0xfe, 0x20, 0x05, 0x19, 0xd5, 0xa7, 0xac, 0x2f, 0x41, 0xc2, 0xf1,
	0xf9, 0x79, 0xb4, 0x34, 0xc9, 0x03, 0xaa, 0xae, 0x25, 0x1c, 0x1f, 0xdd, 0x86, 0x69, 0xd7, 0x73,
	0x5a, 0x7d, 0x2b, 0xe0, 0x41, 0xbf, 0x3a, 0x89, 0xb8, 0xc6, 0x48, 0xb4, 0x90, 0x16, 0x6d, 0x42,
	0xba, 0xe9, 0x98, 0x5e, 0x8b, 0x0f, 0x26, 0x57, 0x26, 0x31, 0xed, 0x12, 0x02, 0x8d, 0xd1, 0x11,
	0x3d, 0xd6, 0xa9, 0xe9, 0xfb, 0x36, 0x6b, 0x41, 0x17, 0xe8, 0x29, 0x33, 0x12, 0x2d, 0xa4, 0x45,
	0xeb, 0x90, 0x6a, 0xda, 0x8e, 0x4f, 0x93, 0x23, 0xbf, 0x2d, 0x4d, 0x54, 0x63, 0x3b, 0xbe, 0x46,
	0xa9, 0xd0, 0xcb, 0x90, 0xb4, 0xdc, 0x3e, 0xed, 0x42, 0xf9, 0xed, 0xe5, 0x89, 0x0a, 0xdc, 0xbe,
	0x46, 0x68, 0xd0, 0x36, 0x64, 0xba, 0xb8, 0xeb, 0x78, 0x0f, 0x69, 0x57, 0xca, 0x9f, 0x7b, 0x65,
	0xa4, 0xd4, 0x47, 0x94, 0x42, 0xe3, 0x94, 0xe8, 0x4b, 0x30, 0xed, 0x07, 0x8e, 0x47, 0x12, 0x24,
	0x4b, 0x67, 0xc8, 0xe7, 0x27, 0xa6, 0x16, 0x23, 0xa9, 0xe0, 0x81, 0x6d, 0x61, 0x2d, 0xe4, 0x20,
	0xcc, 0xfc, 0x60, 0x94, 0x72, 0x17, 0x33, 0xf3, 0xa3, 0x3d, 0x64, 0xe6, 0x1c, 0xc4, 0xda, 0x33,
	0xec, 0xf5, 0x70, 0x87, 0x9e, 0x90, 0x17, 0x58, 0x7b, 0x40, 0x29, 0x34, 0x4e, 0x89, 0x36, 0x21,
	0xd9, 0xf7, 0x9b, 0x52, 0x9e, 0x2a, 0x9b, 0x38, 0xd8, 0x34, 0xf4, 0x5d, 0xae, 0x88, 0x50, 0x16,
	0xbf, 0x2d, 0x40, 0x42, 0xd5, 0xa3, 0x21, 0x42, 0x88, 0x0d, 0x11, 0x4b, 0x90, 0x19, 0xe0, 0x5e,
	0xcb, 0xf1, 0x86, 0xe3, 0x2a, 0x59, 0xc5, 0x7b, 0x4b, 0x72, 0xb4, 0xb7, 0x48, 0x30, 0xed, 0xe1,
	0x0e, 0x26, 0x65, 0xc8, 0x0b, 0x9e, 0x2f, 0x51, 0x11, 0x66, 0x4c, 0xcf, 0x3a, 0xb5, 0x03, 0x6c,
	0x05, 0x7d, 0x8f, 0xd5, 0x7d, 0x4e, 0x1b, 0x81, 0x15, 0x7f, 0x0b, 0x32, 0x6c, 0x37, 0x71, 0x39,
	0xc2, 0xa8, 0x9c, 0x98, 0xee, 0xc4, 0xa8, 0xee, 0x71, 0x0d, 0xc9, 0x09, 0x1a, 0xda, 0x30, 0xcd,
	0x93, 0xfa, 0x97, 0xb4, 0xe1, 0x25, 0xc8, 0xf8, 0xd8, 0xb3, 0xcd, 0x0e, 0xdf, 0x2f, 0x5f, 0x15,
	0x3f, 0x12, 0x20, 0x4d, 0x2b, 0xe1, 0x57, 0xab, 0x07, 0x5d, 0x85, 0x9c, 0xe9, 0xfb, 0x98, 0xb4,
	0x98, 0x36, 0xf7, 0x69, 0x96, 0x02, 0xea, 0x66, 0xbb, 0xf8, 0x4d, 0x01, 0xa6, 0x79, 0x6d, 0x11,
	0x33, 0xa2, 0xdb, 0xc0, 0x59, 0x8d, 0x3e, 0xff, 0xba, 0xcc, 0x38, 0x84, 0x14, 0xa9, 0xd6, 0x98,
	0x3a, 0xe1, 0x22, 0x75, 0x63, 0x21, 0x45, 0x90, 0x6a, 0x91, 0xc3, 0x91, 0x59, 0x41, 0x9f, 0x8b,
	0x7f, 0x2e, 0x40, 0xb2, 0xec, 0xf6, 0x2f, 0x94, 0xb6, 0x08, 0x69, 0x32, 0xf6, 0x76, 0xc2, 0x1f,
	0x81, 0xe9, 0x82, 0x40, 0x7d, 0x17, 0x63, 0xd6, 0xb9, 0x66, 0x35, 0xb6, 0x20, 0x50, 0xcb, 0xb4,
	0x4e, 0x59, 0xb2, 0xce, 0x6a, 0x6c, 0x41, 0xb4, 0x5a, 0x6e, 0x9f, 0x75, 0x9f, 0x59, 0x8d, 0x3e,
	0x53, 0x4a, 0xc7, 0xc3, 0x3e, 0xed, 0x32, 0x84, 0x92, 0x2c, 0x88, 0xe5, 0xc1, 0xa9, 0x87, 0xcd,
	0x96, 0x4f, 0xfb, 0xc9, 0xac, 0x16, 0x2e, 0x8b, 0x07, 0x90, 0x61, 0x6d, 0x64, 0xc4, 0xf1, 0x39,
	0xee, 0xf8, 0xc8, 0x9a, 0x44, 0xdc, 0x9a, 0x65, 0x98, 0xf6, 0xed, 0xf7, 0xb1, 0xd1, 0x6d, 0x72,
	0x2b, 0x33, 0x64, 0x79, 0xd4, 0x2c, 0xfe, 0x29, 0x39, 0xec, 0xe2, 0xfd, 0xe5, 0xa2, 0xa4, 0x6a,
	0x79, 0x36, 0x99, 0xd9, 0x79, 0x34, 0xd9, 0x2a, 0xe6, 0xa8, 0xe4, 0x64, 0x47, 0xa5, 0xe2, 0x8e,
	0x1a, 0x46, 0x38, 0x3d, 0x12, 0xe1, 0xd0, 0xb8, 0x76, 0x93, 0xbb, 0x80, 0x1a, 0xb7, 0xdf, 0x2c,
	0xfe, 0x45, 0x02, 0x66, 0x47, 0xfa, 0xd7, 0x53, 0x19, 0x77, 0x0d, 0xc0, 0x76, 0xa3, 0x5b, 0xc2,
	0x24, 0x3d, 0xd5, 0x72, 0xb6, 0x1b, 0x8e, 0xa8, 0xd7, 0x21, 0xdf, 0x35, 0xad, 0x08, 0xcf, 0x2c,
	0x85, 0xae, 0x69, 0x85, 0x04, 0x08, 0x52, 0xae, 0xe3, 0x05, 0xdc, 0x58, 0xfa, 0x3c, 0xf4, 0x6e,
	0x26, 0xee, 0xdd, 0xf1, 0x17, 0x86, 0xe9, 0xcf, 0xfa, 0xc2, 0x90, 0x7d, 0x9a, 0x17, 0x86, 0xe2,
	0x7f, 0xa4, 0x20, 0x17, 0x75, 0x5e, 0xf2, 0x76, 0xd0, 0xec, 0xfb, 0xbc, 0x18, 0xc9, 0xe3, 0xf8,
	0xbd, 0xfb, 0xec, 0xf0, 0xde, 0x3d, 0xdc, 0x22, 0xcb, 0x09, 0xb6, 0xc5, 0x55, 0xc8, 0xb7, 0xb0,
	0x6f, 0x79, 0x36, 0xfd, 0x96, 0x96, 0xbe, 0x61, 0xe5, 0xb4, 0x38, 0x88, 0x78, 0x8e, 0xc5, 0x99,
	0xbd, 0xa4, 0x01, 0xf3, 0x1c, 0x03, 0xd1, 0x19, 0xfc, 0x79, 0x98, 0xe1, 0xc7, 0x3a, 0xa3, 0xc8,
	0x33, 0x19, 0x1c, 0x46, 0x49, 0xae, 0x40, 0x96, 0x7e, 0x74, 0x48, 0xb2, 0x61, 0x8e, 0x55, 0xa6,
	0xad, 0x47, 0x05, 0x6f, 0xb7, 0x0c, 0x9e, 0x57, 0xf3, 0xac, 0xe0, 0xed, 0xd6, 0x31, 0xcb, 0x2c,
	0x12, 0xd4, 0x96, 0x11, 0x0e, 0x18, 0x22, 0xc5, 0xe6, 0xec, 0x56, 0xd8, 0x79, 0xff, 0x1f, 0xcc,
	0xd9, 0x46, 0xd7, 0xec, 0xf5, 0x4f, 0x4c, 0xda, 0x95, 0x3d, 0x69, 0x81, 0xbd, 0x9e, 0xd8, 0x47,
	0x31, 0xe0, 0x30, 0x8c, 0x88, 0xe5, 0x67, 0x54, 0x24, 0x4d, 0xab, 0x65, 0x90, 0x33, 0xee, 0x12,
	0xcb, 0xa4, 0xa6, 0xd5, 0x6a, 0xf8, 0x4d, 0xa2, 0x94, 0x20, 0x5a, 0xd4, 0xc1, 0xd2, 0x22, 0x53,
	0xda, 0xb4, 0x5a, 0xdc, 0xe3, 0x2f, 0xc2, 0x5c, 0x93, 0x23, 0x0d, 0xab, 0x63, 0xfa, 0xbe, 0x74,
	0x99, 0x9d, 0x0f, 0x4d, 0x46, 0x50, 0x26, 0x30, 0xf4, 0x05, 0x40, 0x11, 0x95, 0xdf, 0x6f, 0x72,
	0xca, 0x25, 0x76, 0x59, 0xc7, 0x29, 0xf5, 0x7e, 0x93, 0x11, 0xaf, 0xc1, 0x42, 0x44, 0x4c, 0x67,
	0x65, 0xcb, 0xe9, 0x48, 0xcb, 0x23, 0xb4, 0x35, 0x0e, 0x46, 0x2f, 0x13, 0xda, 0xae, 0xf9, 0x9e,
	0xe1, 0x9a, 0xd6, 0x19, 0x0e, 0x0c, 0x52, 0x3c, 0x92, 0x44, 0x23, 0x3a, 0xd7, 0x3c, 0x32, 0xdf,
	0xab, 0x51, 0xb0, 0x6e, 0xbf, 0x8f, 0xa9, 0x6b, 0x23, 0xe7, 0x5d, 0xe1, 0xae, 0xe5, 0xbe, 0xbb,
	0x97, 0xca, 0xa6, 0xc4, 0xf4, 0xbd, 0x54, 0x36, 0x2d, 0x66, 0xee, 0xa5, 0xb2, 0x19, 0x71, 0x3a,
	0x7e, 0x27, 0x75, 0x2f, 0x95, 0x9d, 0x11, 0x67, 0xef, 0xa5, 0xb2, 0xb3, 0xe2, 0x5c, 0xf1, 0x9f,
	0x04, 0x58, 0x09, 0x6f, 0x50, 0xfb, 0xfe, 0x11, 0x0e, 0x3c, 0xdb, 0xf2, 0xf7, 0x6c, 0xdc, 0x69,
	0x55, 0xcc, 0xc0, 0x44, 0x4a, 0xf8, 0xf5, 0x0c, 0x99, 0x13, 0x5e, 0x7f, 0xdc, 0xf5, 0xeb, 0x79,
	0xe6, 0x8d, 0x03, 0xfc, 0x90, 0x7d, 0xd7, 0x47, 0x3f, 0xbb, 0x79, 0x65, 0xf8, 0xd9, 0x4d, 0x72,
	0xc2, 0x94, 0xc2, 0xb8, 0x8f, 0x09, 0x05, 0xff, 0x24, 0x67, 0xe5, 0x35, 0xc8, 0x86, 0x22, 0x9e,
	0xe6, 0x33, 0x9e, 0xe2, 0x77, 0x05, 0xb8, 0x7c, 0xce, 0x2c, 0xba, 0x9d, 0x2f, 0x43, 0xfa, 0x84,
	0x98, 0xc7, 0xa7, 0xff, 0xb5, 0x27, 0xdf, 0x90, 0xc6, 0x18, 0xd1, 0x2e, 0x3d, 0x6b, 0x4c, 0xbe,
	0x89, 0x8d, 0xa7, 0xf3, 0x08, 0x3d, 0x9b, 0xcc, 0xb5, 0x37, 0x21, 0x1b, 0xfe, 0xa4, 0x86, 0xf2,
	0x30, 0xad, 0x54, 0x8f, 0x4b, 0x87, 0x4a, 0x45, 0x9c, 0x42, 0x0b, 0x30, 0xab, 0xc9, 0xfb, 0x8a,
	0x5a, 0x2d, 0x1d, 0x1a, 0x72, 0x65, 0x5f, 0x16, 0x05, 0x02, 0x2a, 0x37, 0xf4, 0xba, 0x7a, 0x24,
	0x6b, 0x0c, 0x94, 0x58, 0xdb, 0x83, 0x7c, 0xec, 0x8b, 0x6c, 0x34, 0x07, 0x50, 0x55, 0x0d, 0xbd,
	0xb1, 0x5b, 0x7f, 0xa7, 0x26, 0x33, 0x21, 0xc7, 0xb2, 0x6e, 0x28, 0xaa, 0xd1, 0xd0, 0x65, 0x43,
	0x23, 0x42, 0x16, 0x41, 0xe4, 0xa0, 0xb2, 0x6c, 0x28, 0x55, 0xe3, 0x60, 0x47, 0x17, 0x13, 0x6b,
	0xdf, 0x15, 0x00, 0x86, 0x37, 0xd6, 0xa8, 0x08, 0x85, 0xb2, 0xcc, 0x3e, 0xdf, 0x3b, 0x52, 0x2b,
	0x84, 0x6e, 0x5f, 0x93, 0x75, 0xdd, 0x90, 0xd9, 0x9f, 0xfd, 0xfb, 0xe2, 0x14, 0xba, 0x0a, 0xcb,
	0x13, 0x69, 0xf6, 0xef, 0x8b, 0x02, 0x5a, 0x81, 0xa5, 0x11, 0xe4, 0x90, 0x31, 0x81, 0x9e, 0x03,
	0x69, 0x04, 0x57, 0x29, 0x1b, 0xe5, 0x43, 0xb5, 0x51, 0x21, 0xd8, 0x24, 0xb1, 0x6f, 0x04, 0x5b,
	0xae, 0xc9, 0x62, 0x6a, 0x6d, 0x0b, 0x60, 0x78, 0xa5, 0x48, 0xb6, 0xd5, 0xa8, 0x1e, 0x54, 0xd5,
	0xfb, 0x55, 0x43, 0xaf, 0x97, 0xea, 0x64, 0xa7, 0x19, 0x48, 0x34, 0x6a, 0xa2, 0x80, 0xb2, 0x90,
	0xaa, 0xa8, 0xf7, 0xab, 0x62, 0x62, 0xed, 0x4b, 0x90, 0x8b, 0x2e, 0x14, 0x91, 0x08, 0x33, 0x21,
	0x87, 0xa6, 0x1e, 0x12, 0x86, 0x59, 0xc8, 0x29, 0x55, 0xa5, 0xae, 0x94, 0xea, 0xaa, 0x26, 0x0a,
	0x64, 0xa9, 0xc9, 0x7a, 0x4d, 0xad, 0x56, 0x64, 0x4d, 0x4c, 0xac, 0x7d, 0x05, 0xf2, 0xb1, 0x8b,
	0x15, 0x24, 0xc1, 0x62, 0xc8, 0xce, 0x3f, 0x67, 0x0c, 0xf5, 0xce, 0x42, 0x8e, 0x43, 0xa8, 0xfa,
	0x79, 0xc8, 0xf3, 0x25, 0xb3, 0x02, 0x5d, 0x82, 0xf9, 0x10, 0xa0, 0xe8, 0xa5, 0xdd, 0x43, 0xb9,
	0x22, 0x26, 0xd7, 0xde, 0x06, 0x18, 0x5e, 0xc0, 0xa0, 0x65, 0xb8, 0x34, 0x26, 0x9c, 0x9b, 0xb8,
	0x08, 0x62, 0xf8, 0xf1, 0x64, 0xcc, 0xd2, 0x21, 0x34, 0x6e, 0xf0, 0xbb, 0x90, 0x8b, 0xae, 0x1f,
	0x89, 0x13, 0x08, 0x87, 0x38, 0x85, 0x00, 0x32, 0xa5, 0x72, 0x5d, 0x39, 0x26, 0x91, 0x9f, 0x03,
	0x28, 0xab, 0xd5, 0xaa, 0x5c, 0xae, 0x2b, 0xd5, 0x7d, 0x31, 0x41, 0x4c, 0xe7, 0x6b, 0x62, 0x14,
	0x31, 0x5d, 0xd6, 0xeb, 0xa5, 0xdd, 0x43, 0x45, 0xbf, 0x2b, 0x57, 0xc4, 0x14, 0xe1, 0xad, 0xc8,
	0x87, 0x72, 0x5d, 0x16, 0xd3, 0x6b, 0x15, 0xc8, 0xc7, 0xee, 0xd5, 0x48, 0x00, 0xa8, 0x03, 0x0c,
	0x6e, 0xb8, 0x38, 0x45, 0x3c, 0xcc, 0x40, 0x91, 0xbe, 0x08, 0xb2, 0x5b, 0x2a, 0x1f, 0x34, 0x6a,
	0xcc, 0xab, 0xb1, 0x83, 0x92, 0xf8, 0xe6, 0xed, 0x46, 0xe9, 0x50, 0xa9, 0xbf, 0x33, 0x2a, 0x27,
	0x04, 0xee, 0xab, 0x6a, 0x85, 0xc9, 0x09, 0x21, 0x35, 0x55, 0xd5, 0xc4, 0x04, 0x71, 0x41, 0x08,
	0x89, 0x79, 0xf5, 0x5b, 0x02, 0x64, 0xc3, 0x63, 0x14, 0x5d, 0x86, 0x85, 0x43, 0xa5, 0x7a, 0x60,
	0x90, 0x42, 0x88, 0x49, 0x5f, 0x02, 0x34, 0x04, 0xcb, 0xf5, 0xbb, 0xb2, 0x56, 0x95, 0xeb, 0xa2,
	0x40, 0x92, 0x79, 0x08, 0xbf, 0xaf, 0xec, 0x29, 0xc6, 0xce, 0x2b, 0xdb, 0xc6, 0xd6, 0x56, 0xa9,
	0xcc, 0x12, 0x76, 0x22, 0x72, 0x77, 0xbf, 0x2a, 0x26, 0x89, 0x79, 0x43, 0xec, 0xad, 0x7d, 0x31,
	0xb5, 0xf6, 0x02, 0xe4, 0x63, 0xd7, 0xa4, 0xc4, 0x8f, 0xc4, 0x0f, 0x4a, 0x59, 0x9c, 0xa2, 0xe9,
	0x79, 0xb7, 0x5c, 0x13, 0x85, 0xb5, 0x0f, 0x40, 0xba, 0xe8, 0x67, 0x55, 0x74, 0x1d, 0xae, 0xd2,
	0x02, 0xd0, 0xd5, 0xbd, 0xfa, 0xfd, 0x92, 0x26, 0x1b, 0xea, 0xb1, 0xac, 0x69, 0x4a, 0x85, 0xd5,
	0x85, 0x38, 0x85, 0x56, 0xe1, 0xb9, 0x0b, 0x08, 0xaa, 0xf2, 0x7d, 0x99, 0x64, 0xc9, 0xc5, 0x14,
	0x7b, 0x87, 0xb2, 0x5c, 0x17, 0x13, 0xc4, 0x5d, 0x8b, 0x93, 0xee, 0x4b, 0x48, 0x58, 0x1a, 0xb5,
	0x7d, 0xad, 0x44, 0x6b, 0x3a, 0x6c, 0x47, 0x97, 0x61, 0x21, 0x04, 0xd6, 0x35, 0x65, 0x7f, 0x5f,
	0xd6, 0x64, 0x12, 0x1b, 0x92, 0xbb, 0x11, 0xad, 0x51, 0xd3, 0x54, 0x5a, 0xe7, 0x62, 0x22, 0x4e,
	0x5f, 0x56, 0x8f, 0x6a, 0x24, 0x8d, 0x48, 0x92, 0x21, 0x98, 0x0b, 0xc1, 0x7b, 0x25, 0x85, 0xc4,
	0x2d, 0xb5, 0xd6, 0x84, 0x99, 0xf8, 0x2d, 0x0b, 0xd1, 0xaf, 0x97, 0x4b, 0x87, 0x4a, 0x75, 0x3f,
	0xa6, 0x7f, 0x19, 0x2e, 0x0d, 0x81, 0x43, 0x45, 0x02, 0x91, 0x18, 0x22, 0xb8, 0xc4, 0x04, 0xcd,
	0x3c, 0x0e, 0xab, 0xa8, 0x55, 0x59, 0x4c, 0xae, 0x7d, 0x4f, 0x80, 0x5c, 0xf4, 0xe3, 0x20, 0x89,
	0x88, 0x5a, 0x3d, 0x54, 0xaa, 0x32, 0xcb, 0xb7, 0x9a, 0xa6, 0x1e, 0x2b, 0xba, 0xa2, 0x56, 0x49,
	0x5d, 0xd0, 0x56, 0xc0, 0x6c, 0x64, 0x65, 0x92, 0x87, 0x69, 0xbd, 0x5e, 0xaa, 0x56, 0x76, 0xdf,
	0x11, 0x93, 0x84, 0x33, 0xb4, 0x9b, 0x68, 0xd6, 0x64, 0xd2, 0xa3, 0xf5, 0xba, 0x56, 0xaa, 0x2b,
	0x6a, 0x55, 0x4c, 0x13, 0x69, 0xf7, 0x4b, 0x0a, 0x29, 0xb0, 0xaa, 0x5a, 0x91, 0x75, 0x31, 0x43,
	0x76, 0x53, 0x91, 0xcb, 0xea, 0xd1, 0x91, 0xa2, 0x87, 0x2a, 0xa6, 0x49, 0x46, 0x71, 0x32, 0x63,
	0x4f, 0xd5, 0x8c, 0x11, 0x21, 0xd9, 0xb5, 0xbf, 0x49, 0xc1, 0xd2, 0xe4, 0x83, 0x83, 0xf4, 0x55,
	0x1a, 0x56, 0x56, 0x64, 0xc6, 0xde, 0xa1, 0x7a, 0xdf, 0x28, 0xab, 0x8d, 0x2a, 0xa9, 0x75, 0x09,
	0x16, 0x29, 0x8e, 0x02, 0x75, 0xb9, 0xde, 0xa8, 0x19, 0x1a, 0x69, 0x52, 0x02, 0xc9, 0x7a, 0x8a,
	0x51, 0xaa, 0x46, 0xfd, 0xae, 0xa6, 0x36, 0xf6, 0xef, 0xd6, 0x1a, 0x75, 0x31, 0x41, 0x9d, 0x4a,
	0xe0, 0x6a, 0xa3, 0x1e, 0x47, 0x24, 0x87, 0xd9, 0xf3, 0x8e, 0x5e, 0x97, 0x8f, 0x42, 0x6d, 0x35,
	0xb5, 0xc2, 0x95, 0xa5, 0x50, 0x01, 0x56, 0x28, 0xc5, 0xf1, 0xc1, 0x8e, 0x7e, 0x1e, 0x9f, 0x46,
	0x57, 0xe0, 0x32, 0xc5, 0x6b, 0xe3, 0x5a, 0x33, 0xd1, 0x1e, 0xb4, 0x73, 0x8a, 0xa7, 0x49, 0x1d,
	0x32, 0xc5, 0xe7, 0xcd, 0xcd, 0x12, 0xaf, 0x0d, 0x91, 0x63, 0xac, 0xb9, 0x68, 0x33, 0x55, 0x76,
	0x6a, 0x34, 0x8c, 0x86, 0x5e, 0xda, 0x97, 0x45, 0x88, 0xf4, 0x51, 0xc4, 0x91, 0x7c, 0xa4, 0x6a,
	0xef, 0x70, 0x5c, 0x3e, 0xf2, 0x19, 0xc5, 0x55, 0x14, 0xfd, 0x80, 0x63, 0x66, 0xa2, 0x1a, 0xa4,
	0x98, 0xf3, 0xee, 0x9e, 0x45, 0xd7, 0xe0, 0xca, 0x90, 0x60, 0xdc, 0xe7, 0x73, 0xd1, 0x4e, 0xaa,
	0xec, 0x6c, 0x8c, 0xdb, 0x3a, 0x1f, 0xed, 0x84, 0x22, 0xc7, 0x76, 0x22, 0x46, 0xbe, 0x65, 0xac,
	0x7b, 0x63, 0xdc, 0x0b, 0xa3, 0xa6, 0x29, 0x7b, 0xe3, 0x02, 0xd0, 0xee, 0x1f, 0x08, 0x3f, 0xfc,
	0xa4, 0x30, 0xf5, 0xa3, 0x4f, 0x0a, 0x53, 0x9f, 0x7e, 0x52, 0x10, 0x7e, 0xf6, 0x49, 0x41, 0xf8,
	0xf0, 0x51, 0x41, 0xf8, 0xcb, 0x47, 0x05, 0xe1, 0xaf, 0x1e, 0x15, 0x84, 0x8f, 0x1f, 0x15, 0x84,
	0xbf, 0x7f, 0x54, 0x10, 0x7e, 0xf8, 0xa8, 0x20, 0xfc, 0xe8, 0x51, 0x41, 0xf8, 0xf1, 0xa3, 0x82,
	0xf0, 0xd3, 0x47, 0x85, 0xa9, 0x4f, 0x1f, 0x15, 0x84, 0xef, 0xfc, 0xa4, 0x30, 0xf5, 0xf1, 0x4f,
	0x0a, 0xc2, 0x6f, 0xdc, 0x6d, 0x3b, 0xee, 0x59, 0x7b, 0x23, 0xfc, 0xbe, 0x63, 0xa3, 0xef, 0x6f,
	0xd2, 0x87, 0x13, 0xc7, 0xeb, 0xde, 0x74, 0x3d, 0x67, 0x60, 0xb7, 0xb0, 0x77, 0x33, 0x44, 0x6f,
	0xba, 0xcd, 0xb6, 0xb3, 0x89, 0xdf, 0x0b, 0xc2, 0xff, 0x63, 0x1c, 0xfe, 0x3b, 0x63, 0x33, 0x43,
	0x07, 0xdd, 0x57, 0xff, 0x27, 0x00, 0x00, 0xff, 0xff, 0x12, 0xfe, 0x47, 0x8e, 0xeb, 0x38, 0x00,
	0x00,
}

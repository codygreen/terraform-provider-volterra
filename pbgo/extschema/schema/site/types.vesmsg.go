//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package site

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AresConnectionStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AresConnectionStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AresConnectionStatus) DeepCopy() *AresConnectionStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AresConnectionStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AresConnectionStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AresConnectionStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AresConnectionStatusValidator().Validate(ctx, m, opts...)
}

type ValidateAresConnectionStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAresConnectionStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AresConnectionStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AresConnectionStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAresConnectionStatusValidator = func() *ValidateAresConnectionStatus {
	v := &ValidateAresConnectionStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AresConnectionStatusValidator() db.Validator {
	return DefaultAresConnectionStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *Bios) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Bios) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Bios) DeepCopy() *Bios {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Bios{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Bios) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Bios) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BiosValidator().Validate(ctx, m, opts...)
}

type ValidateBios struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBios) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Bios)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Bios got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["date"]; exists {

		vOpts := append(opts, db.WithValidateField("date"))
		if err := fv(ctx, m.GetDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBiosValidator = func() *ValidateBios {
	v := &ValidateBios{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BiosValidator() db.Validator {
	return DefaultBiosValidator
}

// augmented methods on protoc/std generated struct

func (m *Board) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Board) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Board) DeepCopy() *Board {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Board{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Board) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Board) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BoardValidator().Validate(ctx, m, opts...)
}

type ValidateBoard struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBoard) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Board)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Board got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asset_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("asset_tag"))
		if err := fv(ctx, m.GetAssetTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBoardValidator = func() *ValidateBoard {
	v := &ValidateBoard{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BoardValidator() db.Validator {
	return DefaultBoardValidator
}

// augmented methods on protoc/std generated struct

func (m *Chassis) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Chassis) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Chassis) DeepCopy() *Chassis {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Chassis{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Chassis) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Chassis) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChassisValidator().Validate(ctx, m, opts...)
}

type ValidateChassis struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChassis) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Chassis)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Chassis got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asset_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("asset_tag"))
		if err := fv(ctx, m.GetAssetTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChassisValidator = func() *ValidateChassis {
	v := &ValidateChassis{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ChassisValidator() db.Validator {
	return DefaultChassisValidator
}

// augmented methods on protoc/std generated struct

func (m *Coordinates) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Coordinates) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Coordinates) DeepCopy() *Coordinates {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Coordinates{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Coordinates) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Coordinates) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CoordinatesValidator().Validate(ctx, m, opts...)
}

type ValidateCoordinates struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCoordinates) LatitudeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewFloatValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for latitude")
	}

	return validatorFn, nil
}

func (v *ValidateCoordinates) LongitudeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewFloatValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for longitude")
	}

	return validatorFn, nil
}

func (v *ValidateCoordinates) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Coordinates)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Coordinates got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["latitude"]; exists {

		vOpts := append(opts, db.WithValidateField("latitude"))
		if err := fv(ctx, m.GetLatitude(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["longitude"]; exists {

		vOpts := append(opts, db.WithValidateField("longitude"))
		if err := fv(ctx, m.GetLongitude(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCoordinatesValidator = func() *ValidateCoordinates {
	v := &ValidateCoordinates{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLatitude := v.LatitudeValidationRuleHandler
	rulesLatitude := map[string]string{
		"ves.io.schema.rules.float.gte": "-90.0",
		"ves.io.schema.rules.float.lte": "90.0",
	}
	vFn, err = vrhLatitude(rulesLatitude)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Coordinates.latitude: %s", err)
		panic(errMsg)
	}
	v.FldValidators["latitude"] = vFn

	vrhLongitude := v.LongitudeValidationRuleHandler
	rulesLongitude := map[string]string{
		"ves.io.schema.rules.float.gte": "-180.0",
		"ves.io.schema.rules.float.lte": "180.0",
	}
	vFn, err = vrhLongitude(rulesLongitude)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Coordinates.longitude: %s", err)
		panic(errMsg)
	}
	v.FldValidators["longitude"] = vFn

	return v
}()

func CoordinatesValidator() db.Validator {
	return DefaultCoordinatesValidator
}

// augmented methods on protoc/std generated struct

func (m *Cpu) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Cpu) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Cpu) DeepCopy() *Cpu {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Cpu{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Cpu) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Cpu) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CpuValidator().Validate(ctx, m, opts...)
}

type ValidateCpu struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCpu) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Cpu)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Cpu got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache"]; exists {

		vOpts := append(opts, db.WithValidateField("cache"))
		if err := fv(ctx, m.GetCache(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cores"]; exists {

		vOpts := append(opts, db.WithValidateField("cores"))
		if err := fv(ctx, m.GetCores(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cpus"]; exists {

		vOpts := append(opts, db.WithValidateField("cpus"))
		if err := fv(ctx, m.GetCpus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["model"]; exists {

		vOpts := append(opts, db.WithValidateField("model"))
		if err := fv(ctx, m.GetModel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["threads"]; exists {

		vOpts := append(opts, db.WithValidateField("threads"))
		if err := fv(ctx, m.GetThreads(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCpuValidator = func() *ValidateCpu {
	v := &ValidateCpu{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CpuValidator() db.Validator {
	return DefaultCpuValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) SiteTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteType)
		return int32(i)
	}
	// SiteType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ce_site_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_site_mode"))
		if err := fv(ctx, m.GetCeSiteMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteType := v.SiteTypeValidationRuleHandler
	rulesSiteType := map[string]string{
		"ves.io.schema.rules.enum.not_in": "0",
	}
	vFn, err = vrhSiteType(rulesSiteType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.site_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeploymentState) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeploymentState) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeploymentState) DeepCopy() *DeploymentState {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeploymentState{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeploymentState) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeploymentState) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeploymentStateValidator().Validate(ctx, m, opts...)
}

type ValidateDeploymentState struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeploymentState) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeploymentState)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeploymentState got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["modification_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("modification_timestamp"))
		if err := fv(ctx, m.GetModificationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phase"]; exists {

		vOpts := append(opts, db.WithValidateField("phase"))
		if err := fv(ctx, m.GetPhase(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeploymentStateValidator = func() *ValidateDeploymentState {
	v := &ValidateDeploymentState{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeploymentStateValidator() db.Validator {
	return DefaultDeploymentStateValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetConnectedReDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetConnectedReForConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *GetSpecType) GetConnectedReDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetConnectedRe() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.connected_re[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetConnectedReDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetConnectedReDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedRe() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetConnectedReForConfigDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetConnectedReForConfig() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.connected_re_for_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re_for_config",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetConnectedReForConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetConnectedReForConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedReForConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) SiteTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteType)
		return int32(i)
	}
	// SiteType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConnectedReValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConnectedReForConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re_for_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re_for_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re_for_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ce_site_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_site_mode"))
		if err := fv(ctx, m.GetCeSiteMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re"))
		if err := fv(ctx, m.GetConnectedRe(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re_for_config"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re_for_config"))
		if err := fv(ctx, m.GetConnectedReForConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_state"]; exists {

		vOpts := append(opts, db.WithValidateField("site_state"))
		if err := fv(ctx, m.GetSiteState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteType := v.SiteTypeValidationRuleHandler
	rulesSiteType := map[string]string{
		"ves.io.schema.rules.enum.not_in": "0",
	}
	vFn, err = vrhSiteType(rulesSiteType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.site_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhConnectedRe := v.ConnectedReValidationRuleHandler
	rulesConnectedRe := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedRe(rulesConnectedRe)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.connected_re: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re"] = vFn

	vrhConnectedReForConfig := v.ConnectedReForConfigValidationRuleHandler
	rulesConnectedReForConfig := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedReForConfig(rulesConnectedReForConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.connected_re_for_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re_for_config"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetConnectedReDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetConnectedReForConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *GlobalSpecType) GetConnectedReDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetConnectedRe() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.connected_re[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetConnectedReDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetConnectedReDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedRe() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetConnectedReForConfigDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetConnectedReForConfig() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.connected_re_for_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re_for_config",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetConnectedReForConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetConnectedReForConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedReForConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) SiteTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteType)
		return int32(i)
	}
	// SiteType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConnectedReValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConnectedReForConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re_for_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re_for_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re_for_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StaticRoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for static_routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) PublicIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for public_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ClusterIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ares_list"]; exists {

		vOpts := append(opts, db.WithValidateField("ares_list"))
		for idx, item := range m.GetAresList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ares_vtrp_list"]; exists {

		vOpts := append(opts, db.WithValidateField("ares_vtrp_list"))
		for idx, item := range m.GetAresVtrpList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ce_site_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_site_mode"))
		if err := fv(ctx, m.GetCeSiteMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cluster_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("cluster_ip"))
		if err := fv(ctx, m.GetClusterIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re"))
		if err := fv(ctx, m.GetConnectedRe(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re_for_config"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re_for_config"))
		if err := fv(ctx, m.GetConnectedReForConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["k8s_api_servers"]; exists {

		vOpts := append(opts, db.WithValidateField("k8s_api_servers"))
		for key, value := range m.GetK8SApiServers() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mars_list"]; exists {

		vOpts := append(opts, db.WithValidateField("mars_list"))
		for idx, item := range m.GetMarsList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mars_vtrp_list"]; exists {

		vOpts := append(opts, db.WithValidateField("mars_vtrp_list"))
		for idx, item := range m.GetMarsVtrpList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["opera"]; exists {

		vOpts := append(opts, db.WithValidateField("opera"))
		if err := fv(ctx, m.GetOpera(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("public_ip"))
		if err := fv(ctx, m.GetPublicIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rakar"]; exists {

		vOpts := append(opts, db.WithValidateField("rakar"))
		if err := fv(ctx, m.GetRakar(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_state"]; exists {

		vOpts := append(opts, db.WithValidateField("site_state"))
		if err := fv(ctx, m.GetSiteState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_subtype"]; exists {

		vOpts := append(opts, db.WithValidateField("site_subtype"))
		if err := fv(ctx, m.GetSiteSubtype(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_routes"]; exists {
		vOpts := append(opts, db.WithValidateField("static_routes"))
		if err := fv(ctx, m.GetStaticRoutes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["template_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("template_parameters"))
		for key, value := range m.GetTemplateParameters() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vega"]; exists {

		vOpts := append(opts, db.WithValidateField("vega"))
		if err := fv(ctx, m.GetVega(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteType := v.SiteTypeValidationRuleHandler
	rulesSiteType := map[string]string{
		"ves.io.schema.rules.enum.not_in": "0",
	}
	vFn, err = vrhSiteType(rulesSiteType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.site_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhConnectedRe := v.ConnectedReValidationRuleHandler
	rulesConnectedRe := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedRe(rulesConnectedRe)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.connected_re: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re"] = vFn

	vrhConnectedReForConfig := v.ConnectedReForConfigValidationRuleHandler
	rulesConnectedReForConfig := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedReForConfig(rulesConnectedReForConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.connected_re_for_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re_for_config"] = vFn

	vrhStaticRoutes := v.StaticRoutesValidationRuleHandler
	rulesStaticRoutes := map[string]string{
		"ves.io.schema.rules.message.required":                  "true",
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
	}
	vFn, err = vrhStaticRoutes(rulesStaticRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.static_routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_routes"] = vFn

	vrhPublicIp := v.PublicIpValidationRuleHandler
	rulesPublicIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhPublicIp(rulesPublicIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.public_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ip"] = vFn

	vrhClusterIp := v.ClusterIpValidationRuleHandler
	rulesClusterIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhClusterIp(rulesClusterIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.cluster_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_ip"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InterfaceStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InterfaceStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InterfaceStatus) DeepCopy() *InterfaceStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InterfaceStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InterfaceStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InterfaceStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InterfaceStatusValidator().Validate(ctx, m, opts...)
}

type ValidateInterfaceStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInterfaceStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InterfaceStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InterfaceStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["active_state"]; exists {

		vOpts := append(opts, db.WithValidateField("active_state"))
		if err := fv(ctx, m.GetActiveState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_server"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_server"))
		if err := fv(ctx, m.GetDhcpServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_mode"))
		if err := fv(ctx, m.GetIpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_quality"]; exists {

		vOpts := append(opts, db.WithValidateField("link_quality"))
		if err := fv(ctx, m.GetLinkQuality(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_state"]; exists {

		vOpts := append(opts, db.WithValidateField("link_state"))
		if err := fv(ctx, m.GetLinkState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_type"]; exists {

		vOpts := append(opts, db.WithValidateField("link_type"))
		if err := fv(ctx, m.GetLinkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mac"]; exists {

		vOpts := append(opts, db.WithValidateField("mac"))
		if err := fv(ctx, m.GetMac(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_name"]; exists {

		vOpts := append(opts, db.WithValidateField("network_name"))
		if err := fv(ctx, m.GetNetworkName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("network_type"))
		if err := fv(ctx, m.GetNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInterfaceStatusValidator = func() *ValidateInterfaceStatus {
	v := &ValidateInterfaceStatus{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["ip"] = ves_io_schema.IpSubnetTypeValidator().Validate

	return v
}()

func InterfaceStatusValidator() db.Validator {
	return DefaultInterfaceStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *IpsecConnectionStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IpsecConnectionStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IpsecConnectionStatus) DeepCopy() *IpsecConnectionStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IpsecConnectionStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IpsecConnectionStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IpsecConnectionStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IpsecConnectionStatusValidator().Validate(ctx, m, opts...)
}

type ValidateIpsecConnectionStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIpsecConnectionStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IpsecConnectionStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IpsecConnectionStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["isLocal"]; exists {

		vOpts := append(opts, db.WithValidateField("isLocal"))
		if err := fv(ctx, m.GetIsLocal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["remoteAddress"]; exists {

		vOpts := append(opts, db.WithValidateField("remoteAddress"))
		if err := fv(ctx, m.GetRemoteAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		if err := fv(ctx, m.GetRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["verNodeName"]; exists {

		vOpts := append(opts, db.WithValidateField("verNodeName"))
		if err := fv(ctx, m.GetVerNodeName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIpsecConnectionStatusValidator = func() *ValidateIpsecConnectionStatus {
	v := &ValidateIpsecConnectionStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func IpsecConnectionStatusValidator() db.Validator {
	return DefaultIpsecConnectionStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SApiServerParameters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SApiServerParameters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *K8SApiServerParameters) DeepCopy() *K8SApiServerParameters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SApiServerParameters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SApiServerParameters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SApiServerParameters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SApiServerParametersValidator().Validate(ctx, m, opts...)
}

type ValidateK8SApiServerParameters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SApiServerParameters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SApiServerParameters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SApiServerParameters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SApiServerParametersValidator = func() *ValidateK8SApiServerParameters {
	v := &ValidateK8SApiServerParameters{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func K8SApiServerParametersValidator() db.Validator {
	return DefaultK8SApiServerParametersValidator
}

// augmented methods on protoc/std generated struct

func (m *Kernel) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Kernel) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Kernel) DeepCopy() *Kernel {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Kernel{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Kernel) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Kernel) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return KernelValidator().Validate(ctx, m, opts...)
}

type ValidateKernel struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateKernel) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Kernel)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Kernel got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["architecture"]; exists {

		vOpts := append(opts, db.WithValidateField("architecture"))
		if err := fv(ctx, m.GetArchitecture(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["release"]; exists {

		vOpts := append(opts, db.WithValidateField("release"))
		if err := fv(ctx, m.GetRelease(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultKernelValidator = func() *ValidateKernel {
	v := &ValidateKernel{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func KernelValidator() db.Validator {
	return DefaultKernelValidator
}

// augmented methods on protoc/std generated struct

func (m *Memory) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Memory) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Memory) DeepCopy() *Memory {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Memory{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Memory) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Memory) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MemoryValidator().Validate(ctx, m, opts...)
}

type ValidateMemory struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMemory) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Memory)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Memory got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["size_mb"]; exists {

		vOpts := append(opts, db.WithValidateField("size_mb"))
		if err := fv(ctx, m.GetSizeMb(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMemoryValidator = func() *ValidateMemory {
	v := &ValidateMemory{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MemoryValidator() db.Validator {
	return DefaultMemoryValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkDevice) DeepCopy() *NetworkDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["driver"]; exists {

		vOpts := append(opts, db.WithValidateField("driver"))
		if err := fv(ctx, m.GetDriver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_address"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_address"))
		for idx, item := range m.GetIpAddress() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["link_quality"]; exists {

		vOpts := append(opts, db.WithValidateField("link_quality"))
		if err := fv(ctx, m.GetLinkQuality(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_type"]; exists {

		vOpts := append(opts, db.WithValidateField("link_type"))
		if err := fv(ctx, m.GetLinkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mac_address"]; exists {

		vOpts := append(opts, db.WithValidateField("mac_address"))
		if err := fv(ctx, m.GetMacAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkDeviceValidator = func() *ValidateNetworkDevice {
	v := &ValidateNetworkDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkDeviceValidator() db.Validator {
	return DefaultNetworkDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *NodeInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NodeInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NodeInfo) DeepCopy() *NodeInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NodeInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NodeInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NodeInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeInfoValidator().Validate(ctx, m, opts...)
}

type ValidateNodeInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNodeInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NodeInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NodeInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["hostname"]; exists {

		vOpts := append(opts, db.WithValidateField("hostname"))
		if err := fv(ctx, m.GetHostname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		for idx, item := range m.GetRole() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeInfoValidator = func() *ValidateNodeInfo {
	v := &ValidateNodeInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NodeInfoValidator() db.Validator {
	return DefaultNodeInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *OS) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OS) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OS) DeepCopy() *OS {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OS{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OS) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OS) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OSValidator().Validate(ctx, m, opts...)
}

type ValidateOS struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOS) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OS)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OS got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["architecture"]; exists {

		vOpts := append(opts, db.WithValidateField("architecture"))
		if err := fv(ctx, m.GetArchitecture(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["release"]; exists {

		vOpts := append(opts, db.WithValidateField("release"))
		if err := fv(ctx, m.GetRelease(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOSValidator = func() *ValidateOS {
	v := &ValidateOS{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OSValidator() db.Validator {
	return DefaultOSValidator
}

// augmented methods on protoc/std generated struct

func (m *OperatingSystemStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OperatingSystemStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OperatingSystemStatus) DeepCopy() *OperatingSystemStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OperatingSystemStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OperatingSystemStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OperatingSystemStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OperatingSystemStatusValidator().Validate(ctx, m, opts...)
}

type ValidateOperatingSystemStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOperatingSystemStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OperatingSystemStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OperatingSystemStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["available_version"]; exists {

		vOpts := append(opts, db.WithValidateField("available_version"))
		if err := fv(ctx, m.GetAvailableVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment_state"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment_state"))
		if err := fv(ctx, m.GetDeploymentState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOperatingSystemStatusValidator = func() *ValidateOperatingSystemStatus {
	v := &ValidateOperatingSystemStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OperatingSystemStatusValidator() db.Validator {
	return DefaultOperatingSystemStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *OsInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OsInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OsInfo) DeepCopy() *OsInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OsInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OsInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OsInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OsInfoValidator().Validate(ctx, m, opts...)
}

type ValidateOsInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOsInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OsInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OsInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bios"]; exists {

		vOpts := append(opts, db.WithValidateField("bios"))
		if err := fv(ctx, m.GetBios(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["board"]; exists {

		vOpts := append(opts, db.WithValidateField("board"))
		if err := fv(ctx, m.GetBoard(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["chassis"]; exists {

		vOpts := append(opts, db.WithValidateField("chassis"))
		if err := fv(ctx, m.GetChassis(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cpu"]; exists {

		vOpts := append(opts, db.WithValidateField("cpu"))
		if err := fv(ctx, m.GetCpu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["kernel"]; exists {

		vOpts := append(opts, db.WithValidateField("kernel"))
		if err := fv(ctx, m.GetKernel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["memory"]; exists {

		vOpts := append(opts, db.WithValidateField("memory"))
		if err := fv(ctx, m.GetMemory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		for idx, item := range m.GetNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["os"]; exists {

		vOpts := append(opts, db.WithValidateField("os"))
		if err := fv(ctx, m.GetOs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product"]; exists {

		vOpts := append(opts, db.WithValidateField("product"))
		if err := fv(ctx, m.GetProduct(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage"]; exists {

		vOpts := append(opts, db.WithValidateField("storage"))
		for idx, item := range m.GetStorage() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["usb"]; exists {

		vOpts := append(opts, db.WithValidateField("usb"))
		for idx, item := range m.GetUsb() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOsInfoValidator = func() *ValidateOsInfo {
	v := &ValidateOsInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OsInfoValidator() db.Validator {
	return DefaultOsInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *Product) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Product) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Product) DeepCopy() *Product {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Product{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Product) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Product) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProductValidator().Validate(ctx, m, opts...)
}

type ValidateProduct struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProduct) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Product)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Product got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProductValidator = func() *ValidateProduct {
	v := &ValidateProduct{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ProductValidator() db.Validator {
	return DefaultProductValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ScalingStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ScalingStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ScalingStatus) DeepCopy() *ScalingStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ScalingStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ScalingStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ScalingStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ScalingStatusValidator().Validate(ctx, m, opts...)
}

type ValidateScalingStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateScalingStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ScalingStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ScalingStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phase"]; exists {

		vOpts := append(opts, db.WithValidateField("phase"))
		if err := fv(ctx, m.GetPhase(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_node_count_current"]; exists {

		vOpts := append(opts, db.WithValidateField("pool_node_count_current"))
		if err := fv(ctx, m.GetPoolNodeCountCurrent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_node_count_target"]; exists {

		vOpts := append(opts, db.WithValidateField("pool_node_count_target"))
		if err := fv(ctx, m.GetPoolNodeCountTarget(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultScalingStatusValidator = func() *ValidateScalingStatus {
	v := &ValidateScalingStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ScalingStatusValidator() db.Validator {
	return DefaultScalingStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStatusMetricsData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStatusMetricsData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStatusMetricsData) DeepCopy() *SiteStatusMetricsData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStatusMetricsData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStatusMetricsData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStatusMetricsData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStatusMetricsDataValidator().Validate(ctx, m, opts...)
}

type ValidateSiteStatusMetricsData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStatusMetricsData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStatusMetricsData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStatusMetricsData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["field"]; exists {

		vOpts := append(opts, db.WithValidateField("field"))
		if err := fv(ctx, m.GetField(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStatusMetricsDataValidator = func() *ValidateSiteStatusMetricsData {
	v := &ValidateSiteStatusMetricsData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteStatusMetricsDataValidator() db.Validator {
	return DefaultSiteStatusMetricsDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStatusMetricsFieldData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStatusMetricsFieldData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStatusMetricsFieldData) DeepCopy() *SiteStatusMetricsFieldData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStatusMetricsFieldData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStatusMetricsFieldData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStatusMetricsFieldData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStatusMetricsFieldDataValidator().Validate(ctx, m, opts...)
}

type ValidateSiteStatusMetricsFieldData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStatusMetricsFieldData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStatusMetricsFieldData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStatusMetricsFieldData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		for key, value := range m.GetKey() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		for idx, item := range m.GetValue() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStatusMetricsFieldDataValidator = func() *ValidateSiteStatusMetricsFieldData {
	v := &ValidateSiteStatusMetricsFieldData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteStatusMetricsFieldDataValidator() db.Validator {
	return DefaultSiteStatusMetricsFieldDataValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageDevice) DeepCopy() *StorageDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["driver"]; exists {

		vOpts := append(opts, db.WithValidateField("driver"))
		if err := fv(ctx, m.GetDriver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["model"]; exists {

		vOpts := append(opts, db.WithValidateField("model"))
		if err := fv(ctx, m.GetModel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["size_gb"]; exists {

		vOpts := append(opts, db.WithValidateField("size_gb"))
		if err := fv(ctx, m.GetSizeGb(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDeviceValidator = func() *ValidateStorageDevice {
	v := &ValidateStorageDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StorageDeviceValidator() db.Validator {
	return DefaultStorageDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *TunnelConnectionStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TunnelConnectionStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TunnelConnectionStatus) DeepCopy() *TunnelConnectionStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TunnelConnectionStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TunnelConnectionStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TunnelConnectionStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TunnelConnectionStatusValidator().Validate(ctx, m, opts...)
}

type ValidateTunnelConnectionStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTunnelConnectionStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TunnelConnectionStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TunnelConnectionStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["encap"]; exists {

		vOpts := append(opts, db.WithValidateField("encap"))
		if err := fv(ctx, m.GetEncap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["isLocal"]; exists {

		vOpts := append(opts, db.WithValidateField("isLocal"))
		if err := fv(ctx, m.GetIsLocal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["remoteAddress"]; exists {

		vOpts := append(opts, db.WithValidateField("remoteAddress"))
		if err := fv(ctx, m.GetRemoteAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		if err := fv(ctx, m.GetRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnelName"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnelName"))
		if err := fv(ctx, m.GetTunnelName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["verNodeName"]; exists {

		vOpts := append(opts, db.WithValidateField("verNodeName"))
		if err := fv(ctx, m.GetVerNodeName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTunnelConnectionStatusValidator = func() *ValidateTunnelConnectionStatus {
	v := &ValidateTunnelConnectionStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TunnelConnectionStatusValidator() db.Validator {
	return DefaultTunnelConnectionStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *USBDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *USBDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *USBDevice) DeepCopy() *USBDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &USBDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *USBDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *USBDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return USBDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateUSBDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUSBDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*USBDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *USBDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_device_class"]; exists {

		vOpts := append(opts, db.WithValidateField("b_device_class"))
		if err := fv(ctx, m.GetBDeviceClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_device_protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("b_device_protocol"))
		if err := fv(ctx, m.GetBDeviceProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_device_sub_class"]; exists {

		vOpts := append(opts, db.WithValidateField("b_device_sub_class"))
		if err := fv(ctx, m.GetBDeviceSubClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_max_packet_size"]; exists {

		vOpts := append(opts, db.WithValidateField("b_max_packet_size"))
		if err := fv(ctx, m.GetBMaxPacketSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bcd_device"]; exists {

		vOpts := append(opts, db.WithValidateField("bcd_device"))
		if err := fv(ctx, m.GetBcdDevice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bcd_usb"]; exists {

		vOpts := append(opts, db.WithValidateField("bcd_usb"))
		if err := fv(ctx, m.GetBcdUsb(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bus"]; exists {

		vOpts := append(opts, db.WithValidateField("bus"))
		if err := fv(ctx, m.GetBus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["i_manufacturer"]; exists {

		vOpts := append(opts, db.WithValidateField("i_manufacturer"))
		if err := fv(ctx, m.GetIManufacturer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["i_product"]; exists {

		vOpts := append(opts, db.WithValidateField("i_product"))
		if err := fv(ctx, m.GetIProduct(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["i_serial"]; exists {

		vOpts := append(opts, db.WithValidateField("i_serial"))
		if err := fv(ctx, m.GetISerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id_product"]; exists {

		vOpts := append(opts, db.WithValidateField("id_product"))
		if err := fv(ctx, m.GetIdProduct(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id_vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("id_vendor"))
		if err := fv(ctx, m.GetIdVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product_name"]; exists {

		vOpts := append(opts, db.WithValidateField("product_name"))
		if err := fv(ctx, m.GetProductName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor_name"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor_name"))
		if err := fv(ctx, m.GetVendorName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUSBDeviceValidator = func() *ValidateUSBDevice {
	v := &ValidateUSBDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func USBDeviceValidator() db.Validator {
	return DefaultUSBDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *VerMasterStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerMasterStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerMasterStatusType) DeepCopy() *VerMasterStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerMasterStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerMasterStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerMasterStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerMasterStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerMasterStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerMasterStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerMasterStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerMasterStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["transition_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("transition_timestamp"))
		if err := fv(ctx, m.GetTransitionTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ver_UID"]; exists {

		vOpts := append(opts, db.WithValidateField("ver_UID"))
		if err := fv(ctx, m.GetVer_UID(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ver_name"]; exists {

		vOpts := append(opts, db.WithValidateField("ver_name"))
		if err := fv(ctx, m.GetVerName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerMasterStatusTypeValidator = func() *ValidateVerMasterStatusType {
	v := &ValidateVerMasterStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VerMasterStatusTypeValidator() db.Validator {
	return DefaultVerMasterStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerStatusType) DeepCopy() *VerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ares_status"]; exists {

		vOpts := append(opts, db.WithValidateField("ares_status"))
		for idx, item := range m.GetAresStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["configured_tunnel_status"]; exists {

		vOpts := append(opts, db.WithValidateField("configured_tunnel_status"))
		for idx, item := range m.GetConfiguredTunnelStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["intf_status"]; exists {

		vOpts := append(opts, db.WithValidateField("intf_status"))
		for idx, item := range m.GetIntfStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ipsec_status"]; exists {

		vOpts := append(opts, db.WithValidateField("ipsec_status"))
		for idx, item := range m.GetIpsecStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_tunnel_status"]; exists {

		vOpts := append(opts, db.WithValidateField("site_tunnel_status"))
		for idx, item := range m.GetSiteTunnelStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ver_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("ver_instance_name"))
		if err := fv(ctx, m.GetVerInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerStatusTypeValidator = func() *ValidateVerStatusType {
	v := &ValidateVerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["intf_status"] = InterfaceStatusValidator().Validate

	return v
}()

func VerStatusTypeValidator() db.Validator {
	return DefaultVerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VolterraSoftwareStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolterraSoftwareStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolterraSoftwareStatus) DeepCopy() *VolterraSoftwareStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolterraSoftwareStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolterraSoftwareStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolterraSoftwareStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolterraSoftwareStatusValidator().Validate(ctx, m, opts...)
}

type ValidateVolterraSoftwareStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolterraSoftwareStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolterraSoftwareStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolterraSoftwareStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["available_version"]; exists {

		vOpts := append(opts, db.WithValidateField("available_version"))
		if err := fv(ctx, m.GetAvailableVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment_state"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment_state"))
		if err := fv(ctx, m.GetDeploymentState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolterraSoftwareStatusValidator = func() *ValidateVolterraSoftwareStatus {
	v := &ValidateVolterraSoftwareStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VolterraSoftwareStatusValidator() db.Validator {
	return DefaultVolterraSoftwareStatusValidator
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.BgpPeerAddress = f.GetBgpPeerAddress()
	m.BgpRouterId = f.GetBgpRouterId()
	m.CeSiteMode = f.GetCeSiteMode()
	m.Coordinates = f.GetCoordinates()
	m.DesiredPoolCount = f.GetDesiredPoolCount()
	m.InsideNameserver = f.GetInsideNameserver()
	m.InsideVip = f.GetInsideVip()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideNameserver = f.GetOutsideNameserver()
	m.OutsideVip = f.GetOutsideVip()
	m.Region = f.GetRegion()
	m.SiteToSiteNetworkType = f.GetSiteToSiteNetworkType()
	m.SiteToSiteTunnelIp = f.GetSiteToSiteTunnelIp()
	m.SiteType = f.GetSiteType()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.VipVrrpMode = f.GetVipVrrpMode()
	m.VolterraSoftwareOveride = f.GetVolterraSoftwareOveride()
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Address = m1.Address
	f.BgpPeerAddress = m1.BgpPeerAddress
	f.BgpRouterId = m1.BgpRouterId
	f.CeSiteMode = m1.CeSiteMode
	f.Coordinates = m1.Coordinates
	f.DesiredPoolCount = m1.DesiredPoolCount
	f.InsideNameserver = m1.InsideNameserver
	f.InsideVip = m1.InsideVip
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideNameserver = m1.OutsideNameserver
	f.OutsideVip = m1.OutsideVip
	f.Region = m1.Region
	f.SiteToSiteNetworkType = m1.SiteToSiteNetworkType
	f.SiteToSiteTunnelIp = m1.SiteToSiteTunnelIp
	f.SiteType = m1.SiteType
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.VipVrrpMode = m1.VipVrrpMode
	f.VolterraSoftwareOveride = m1.VolterraSoftwareOveride
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.BgpPeerAddress = f.GetBgpPeerAddress()
	m.BgpRouterId = f.GetBgpRouterId()
	m.CeSiteMode = f.GetCeSiteMode()
	m.ConnectedRe = f.GetConnectedRe()
	m.ConnectedReForConfig = f.GetConnectedReForConfig()
	m.Coordinates = f.GetCoordinates()
	m.DesiredPoolCount = f.GetDesiredPoolCount()
	m.InsideNameserver = f.GetInsideNameserver()
	m.InsideVip = f.GetInsideVip()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideNameserver = f.GetOutsideNameserver()
	m.OutsideVip = f.GetOutsideVip()
	m.Region = f.GetRegion()
	m.SiteState = f.GetSiteState()
	m.SiteToSiteNetworkType = f.GetSiteToSiteNetworkType()
	m.SiteToSiteTunnelIp = f.GetSiteToSiteTunnelIp()
	m.SiteType = f.GetSiteType()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.VipVrrpMode = f.GetVipVrrpMode()
	m.VolterraSoftwareOveride = f.GetVolterraSoftwareOveride()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Address = m1.Address
	f.BgpPeerAddress = m1.BgpPeerAddress
	f.BgpRouterId = m1.BgpRouterId
	f.CeSiteMode = m1.CeSiteMode
	f.ConnectedRe = m1.ConnectedRe
	f.ConnectedReForConfig = m1.ConnectedReForConfig
	f.Coordinates = m1.Coordinates
	f.DesiredPoolCount = m1.DesiredPoolCount
	f.InsideNameserver = m1.InsideNameserver
	f.InsideVip = m1.InsideVip
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideNameserver = m1.OutsideNameserver
	f.OutsideVip = m1.OutsideVip
	f.Region = m1.Region
	f.SiteState = m1.SiteState
	f.SiteToSiteNetworkType = m1.SiteToSiteNetworkType
	f.SiteToSiteTunnelIp = m1.SiteToSiteTunnelIp
	f.SiteType = m1.SiteType
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.VipVrrpMode = m1.VipVrrpMode
	f.VolterraSoftwareOveride = m1.VolterraSoftwareOveride
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.BgpPeerAddress = f.GetBgpPeerAddress()
	m.BgpRouterId = f.GetBgpRouterId()
	m.Coordinates = f.GetCoordinates()
	m.DesiredPoolCount = f.GetDesiredPoolCount()
	m.InsideNameserver = f.GetInsideNameserver()
	m.InsideVip = f.GetInsideVip()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideNameserver = f.GetOutsideNameserver()
	m.OutsideVip = f.GetOutsideVip()
	m.Region = f.GetRegion()
	m.SiteToSiteNetworkType = f.GetSiteToSiteNetworkType()
	m.SiteToSiteTunnelIp = f.GetSiteToSiteTunnelIp()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.VipVrrpMode = f.GetVipVrrpMode()
	m.VolterraSoftwareOveride = f.GetVolterraSoftwareOveride()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Address = m1.Address
	f.BgpPeerAddress = m1.BgpPeerAddress
	f.BgpRouterId = m1.BgpRouterId
	f.Coordinates = m1.Coordinates
	f.DesiredPoolCount = m1.DesiredPoolCount
	f.InsideNameserver = m1.InsideNameserver
	f.InsideVip = m1.InsideVip
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideNameserver = m1.OutsideNameserver
	f.OutsideVip = m1.OutsideVip
	f.Region = m1.Region
	f.SiteToSiteNetworkType = m1.SiteToSiteNetworkType
	f.SiteToSiteTunnelIp = m1.SiteToSiteTunnelIp
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.VipVrrpMode = m1.VipVrrpMode
	f.VolterraSoftwareOveride = m1.VolterraSoftwareOveride
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/bgp/types.proto

package bgp

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	google_protobuf1 "github.com/gogo/protobuf/types"

	ves_io_schema3 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// BGP Router ID
//
// x-displayName: "BGP Router ID"
// Dictates how BGP router id is derived
type BgpRouterIdType int32

const (
	// x-displayName: "From Interface"
	// Use IP address of interface on which BGP is configured as BGP router ID
	BGP_ROUTER_ID_FROM_INTERFACE BgpRouterIdType = 0
	// x-displayName: "From IP Address"
	// Use BGP Router ID from BGP Parameters as BGP router ID
	BGP_ROUTER_ID_FROM_IP_ADDRESS BgpRouterIdType = 1
	// x-displayName: "From Site"
	// Use BGP Router ID from corresponding site object as BGP router ID
	BGP_ROUTER_ID_FROM_SITE_OBJECT BgpRouterIdType = 2
	// x-displayName: "From Site Template"
	// Use BGP Router ID Key from corresponding site's Site Template Parameters as BGP router ID.
	// This is not currently supported.
	BGP_ROUTER_ID_FROM_SITE_TEMPLATE_PARAMETERS BgpRouterIdType = 3
)

var BgpRouterIdType_name = map[int32]string{
	0: "BGP_ROUTER_ID_FROM_INTERFACE",
	1: "BGP_ROUTER_ID_FROM_IP_ADDRESS",
	2: "BGP_ROUTER_ID_FROM_SITE_OBJECT",
	3: "BGP_ROUTER_ID_FROM_SITE_TEMPLATE_PARAMETERS",
}
var BgpRouterIdType_value = map[string]int32{
	"BGP_ROUTER_ID_FROM_INTERFACE":                0,
	"BGP_ROUTER_ID_FROM_IP_ADDRESS":               1,
	"BGP_ROUTER_ID_FROM_SITE_OBJECT":              2,
	"BGP_ROUTER_ID_FROM_SITE_TEMPLATE_PARAMETERS": 3,
}

func (BgpRouterIdType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// BGP Peer Address
//
// x-displayName: "BGP Peer Address"
// Dictates how BGP peer address is derived
type BgpPeerAddressType int32

const (
	// x-displayName: "From Default GW"
	// Use default gateway IP address of interface on which the BGP is configured as BGP peer address
	BGP_PEER_ADDRESS_FROM_DEFAULT_GW BgpPeerAddressType = 0
	// x-displayName: "From IP Address"
	// Use BGP Peer Address from BGP Peer as BGP peer address
	BGP_PEER_ADDRESS_FROM_IP_ADDRESS BgpPeerAddressType = 1
	// x-displayName: "From Site"
	// Use BGP Peer Address from corresponding site object as BGP peer address
	BGP_PEER_ADDRESS_FROM_SITE_OBJECT BgpPeerAddressType = 2
	// x-displayName: "From Site Template"
	// Use BGP Peer Key from corresponding site's Site Template Parameters as BGP peer address.
	// This is not currently supported.
	BGP_PEER_ADDRESS_FROM_SITE_TEMPLATE_PARAMETERS BgpPeerAddressType = 3
	// x-displayName: "Offset from beginning of Subnet"
	// Derive BGP Peer Address from subnet of interface on which the BGP is configured. If the interface
	// has Address Allocator configured, the offset is used to derive BGP Peer Address from the subnet
	// assigned by the address allocator for the interface. When Address Allocator is not configured, the
	// subnet of the interface is used to derive BGP Peer Address.
	//
	// Nth address in the subnet, N being the Peer Subnet Offset of the BGP Peer, is used as peer address.
	// For example, if the subnet is 1.2.3.0/24, Peer Subnet Offset is set to 5 and Peer Address Type
	// is set to "Offset from beginning of Subnet", peer address of 1.2.3.5 is used.
	BGP_PEER_ADDRESS_OFFSET_FROM_SUBNET_BEGIN BgpPeerAddressType = 4
	// x-displayName: "Offset from end of Subnet"
	// Derive BGP Peer Address from subnet of interface on which the BGP is configured. If the interface
	// has Address Allocator configured, the offset is used to derive BGP Peer Address from the subnet
	// assigned by the address allocator for the interface. When Address Allocator is not configured, the
	// subnet of the interface is used to derive BGP Peer Address.
	//
	// Nth last address in the subnet, N being the Peer Subnet Offset of the BGP Peer, is used as peer address.
	// For example, if the subnet is 1.2.3.0/24, Peer Subnet Offset is set to 5 and Peer Address Type
	// is set to "Offset from end of Subnet", peer address of 1.2.3.250 is used.
	BGP_PEER_ADDRESS_OFFSET_FROM_SUBNET_END BgpPeerAddressType = 5
)

var BgpPeerAddressType_name = map[int32]string{
	0: "BGP_PEER_ADDRESS_FROM_DEFAULT_GW",
	1: "BGP_PEER_ADDRESS_FROM_IP_ADDRESS",
	2: "BGP_PEER_ADDRESS_FROM_SITE_OBJECT",
	3: "BGP_PEER_ADDRESS_FROM_SITE_TEMPLATE_PARAMETERS",
	4: "BGP_PEER_ADDRESS_OFFSET_FROM_SUBNET_BEGIN",
	5: "BGP_PEER_ADDRESS_OFFSET_FROM_SUBNET_END",
}
var BgpPeerAddressType_value = map[string]int32{
	"BGP_PEER_ADDRESS_FROM_DEFAULT_GW":               0,
	"BGP_PEER_ADDRESS_FROM_IP_ADDRESS":               1,
	"BGP_PEER_ADDRESS_FROM_SITE_OBJECT":              2,
	"BGP_PEER_ADDRESS_FROM_SITE_TEMPLATE_PARAMETERS": 3,
	"BGP_PEER_ADDRESS_OFFSET_FROM_SUBNET_BEGIN":      4,
	"BGP_PEER_ADDRESS_OFFSET_FROM_SUBNET_END":        5,
}

func (BgpPeerAddressType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// BGP Peer States
//
// x-displayName: "BGP Peer States"
// Indicates the state of BGP Peering session
type BgpPeerUpDownType int32

const (
	// x-displayName: "Down"
	// Peering session is Down (not in Established state)
	BGP_PEER_DOWN BgpPeerUpDownType = 0
	// x-displayName: "Up"
	// Peering session is Up (in Established state)
	BGP_PEER_UP BgpPeerUpDownType = 1
)

var BgpPeerUpDownType_name = map[int32]string{
	0: "BGP_PEER_DOWN",
	1: "BGP_PEER_UP",
}
var BgpPeerUpDownType_value = map[string]int32{
	"BGP_PEER_DOWN": 0,
	"BGP_PEER_UP":   1,
}

func (BgpPeerUpDownType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// BGP Parameters
//
// x-displayName: "BGP Parameters"
// BGP parameters for the local site
type BgpParameters struct {
	// ASN
	//
	// x-displayName: "ASN"
	// x-example: 64512
	// x-required
	// Autonomous System Number for current site
	Asn uint32 `protobuf:"varint,1,opt,name=asn,proto3" json:"asn,omitempty"`
	// Router ID Type
	//
	// x-displayName: "Router ID Type"
	// x-required
	// Decides how BGP router id is derived
	BgpRouterIdType BgpRouterIdType `protobuf:"varint,2,opt,name=bgp_router_id_type,json=bgpRouterIdType,proto3,enum=ves.io.schema.bgp.BgpRouterIdType" json:"bgp_router_id_type,omitempty"`
	// Router ID
	//
	// x-displayName: "Router ID"
	// If Router ID Type is set to "From IP Address", this is used as Router ID. Else, this is ignored.
	BgpRouterId *ves_io_schema3.IpAddressType `protobuf:"bytes,3,opt,name=bgp_router_id,json=bgpRouterId" json:"bgp_router_id,omitempty"`
	// Router ID Key
	//
	// x-displayName: "Router ID Key"
	// If Router ID Type is set to "From Site Template", this is used to lookup BGP router ID
	// from site template parameters map in site object. Else, this is ignored.
	BgpRouterIdKey string `protobuf:"bytes,4,opt,name=bgp_router_id_key,json=bgpRouterIdKey,proto3" json:"bgp_router_id_key,omitempty"`
}

func (m *BgpParameters) Reset()                    { *m = BgpParameters{} }
func (*BgpParameters) ProtoMessage()               {}
func (*BgpParameters) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *BgpParameters) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

func (m *BgpParameters) GetBgpRouterIdType() BgpRouterIdType {
	if m != nil {
		return m.BgpRouterIdType
	}
	return BGP_ROUTER_ID_FROM_INTERFACE
}

func (m *BgpParameters) GetBgpRouterId() *ves_io_schema3.IpAddressType {
	if m != nil {
		return m.BgpRouterId
	}
	return nil
}

func (m *BgpParameters) GetBgpRouterIdKey() string {
	if m != nil {
		return m.BgpRouterIdKey
	}
	return ""
}

// BGP Peer
//
// x-displayName: "BGP Peer"
// BGP Neighbor parameters
type BgpPeer struct {
	// ASN
	//
	// x-displayName: "ASN"
	// x-example: 64512
	// x-required
	// Autonomous System Number for BGP peer
	Asn uint32 `protobuf:"varint,1,opt,name=asn,proto3" json:"asn,omitempty"`
	// Peer Address Type
	//
	// x-displayName: "Peer Address Type"
	// x-required
	// Decides how bgp peer address is derived for this peer
	BgpPeerAddressType BgpPeerAddressType `protobuf:"varint,2,opt,name=bgp_peer_address_type,json=bgpPeerAddressType,proto3,enum=ves.io.schema.bgp.BgpPeerAddressType" json:"bgp_peer_address_type,omitempty"`
	// Peer Address
	//
	// x-displayName: "Peer Address"
	// If Peer Address Type is set to "From IP Address", this is used as Peer Address. Else, this is ignored.
	BgpPeerAddress *ves_io_schema3.IpAddressType `protobuf:"bytes,3,opt,name=bgp_peer_address,json=bgpPeerAddress" json:"bgp_peer_address,omitempty"`
	// Peer Address Key
	//
	// x-displayName: "Peer Address Key"
	// If Peer Address Type is set to "From Site Template", this is used to lookup BGP peer address
	// from site template parameters map in site object. Else, this is ignored.
	BgpPeerAddressKey string `protobuf:"bytes,4,opt,name=bgp_peer_address_key,json=bgpPeerAddressKey,proto3" json:"bgp_peer_address_key,omitempty"`
	// Peer Port
	//
	// x-displayName: "Peer Port"
	// x-example: 179
	// Peer's port number, defaults to port 179 when not set
	Port uint32 `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	// Peer Subnet Offset
	//
	// x-displayName: "Peer Subnet Offset"
	// x-example: 1
	// This is used to derive BGP Peer Address from subnet of the interface on which BGP is configured. If
	// the interface has Address Allocator configured, BGP Peer Address is derived from the subnet assigned
	// by the address allocator for the interface. When Address Allocator is not configured, the subnet of
	// the interface is used to derive BGP Peer Address.
	//
	// If Peer Address Type is set to "Offset from beginning of Subnet", this offset value is added to the subnet
	// and used as the peer address. For example, if the subnet is 1.2.3.0/24 and offset is set to 5 with
	// Peer Address Type set to "Offset from beginning of Subnet", peer address of 1.2.3.5 is used.
	//
	// If Peer Address Type is set to "Offset from end of Subnet", this offset value is subtracted from the
	// end of subnet and used as the peer address. For example, if the subnet is 1.2.3.0/24 and offset is
	// set to 5 with Peer Address Type set to "Offset from end of Subnet", peer address of 1.2.3.250 is used.
	BgpPeerSubnetOffset uint32 `protobuf:"varint,6,opt,name=bgp_peer_subnet_offset,json=bgpPeerSubnetOffset,proto3" json:"bgp_peer_subnet_offset,omitempty"`
}

func (m *BgpPeer) Reset()                    { *m = BgpPeer{} }
func (*BgpPeer) ProtoMessage()               {}
func (*BgpPeer) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *BgpPeer) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

func (m *BgpPeer) GetBgpPeerAddressType() BgpPeerAddressType {
	if m != nil {
		return m.BgpPeerAddressType
	}
	return BGP_PEER_ADDRESS_FROM_DEFAULT_GW
}

func (m *BgpPeer) GetBgpPeerAddress() *ves_io_schema3.IpAddressType {
	if m != nil {
		return m.BgpPeerAddress
	}
	return nil
}

func (m *BgpPeer) GetBgpPeerAddressKey() string {
	if m != nil {
		return m.BgpPeerAddressKey
	}
	return ""
}

func (m *BgpPeer) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *BgpPeer) GetBgpPeerSubnetOffset() uint32 {
	if m != nil {
		return m.BgpPeerSubnetOffset
	}
	return 0
}

// Global Specification
//
// x-displayName: "Global Specification"
// BGP specification to peer with external BGP servers
type GlobalSpecType struct {
	// Where
	//
	// x-displayName: "Where"
	// x-required
	// Set of sites in which this configuration is valid and must be present
	Where *ves_io_schema4.SiteVirtualSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	// BGP Parameters
	//
	// x-displayName: "Parameters"
	// x-required
	// BGP parameters for local site
	BgpParameters *BgpParameters `protobuf:"bytes,2,opt,name=bgp_parameters,json=bgpParameters" json:"bgp_parameters,omitempty"`
	// BGP Peers
	//
	// x-displayName: "Peers"
	// x-required
	// BGP parameters for peer
	BgpPeers []*BgpPeer `protobuf:"bytes,3,rep,name=bgp_peers,json=bgpPeers" json:"bgp_peers,omitempty"`
	// Interfaces
	//
	// x-displayName: "Interfaces"
	// x-required
	// List of interfaces to which the BGP configuration is applied
	NetworkInterface []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=network_interface,json=networkInterface" json:"network_interface,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *GlobalSpecType) GetWhere() *ves_io_schema4.SiteVirtualSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GlobalSpecType) GetBgpParameters() *BgpParameters {
	if m != nil {
		return m.BgpParameters
	}
	return nil
}

func (m *GlobalSpecType) GetBgpPeers() []*BgpPeer {
	if m != nil {
		return m.BgpPeers
	}
	return nil
}

func (m *GlobalSpecType) GetNetworkInterface() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkInterface
	}
	return nil
}

// Create bgp
//
// x-displayName: "Specification"
// BGP object is the configuration for peering with external BGP servers.
// It is created by users in system namespace.
type CreateSpecType struct {
	Where            *ves_io_schema4.SiteVirtualSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	BgpParameters    *BgpParameters                             `protobuf:"bytes,2,opt,name=bgp_parameters,json=bgpParameters" json:"bgp_parameters,omitempty"`
	BgpPeers         []*BgpPeer                                 `protobuf:"bytes,3,rep,name=bgp_peers,json=bgpPeers" json:"bgp_peers,omitempty"`
	NetworkInterface []*ves_io_schema4.ObjectRefType            `protobuf:"bytes,4,rep,name=network_interface,json=networkInterface" json:"network_interface,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *CreateSpecType) GetWhere() *ves_io_schema4.SiteVirtualSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *CreateSpecType) GetBgpParameters() *BgpParameters {
	if m != nil {
		return m.BgpParameters
	}
	return nil
}

func (m *CreateSpecType) GetBgpPeers() []*BgpPeer {
	if m != nil {
		return m.BgpPeers
	}
	return nil
}

func (m *CreateSpecType) GetNetworkInterface() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkInterface
	}
	return nil
}

// Replace bgp
//
// x-displayName: "Specification"
// BGP object is the configuration for peering with external BGP servers.
// Replace bgp will replace the contents of given BGP object.
type ReplaceSpecType struct {
	Where            *ves_io_schema4.SiteVirtualSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	BgpParameters    *BgpParameters                             `protobuf:"bytes,2,opt,name=bgp_parameters,json=bgpParameters" json:"bgp_parameters,omitempty"`
	BgpPeers         []*BgpPeer                                 `protobuf:"bytes,3,rep,name=bgp_peers,json=bgpPeers" json:"bgp_peers,omitempty"`
	NetworkInterface []*ves_io_schema4.ObjectRefType            `protobuf:"bytes,4,rep,name=network_interface,json=networkInterface" json:"network_interface,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *ReplaceSpecType) GetWhere() *ves_io_schema4.SiteVirtualSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *ReplaceSpecType) GetBgpParameters() *BgpParameters {
	if m != nil {
		return m.BgpParameters
	}
	return nil
}

func (m *ReplaceSpecType) GetBgpPeers() []*BgpPeer {
	if m != nil {
		return m.BgpPeers
	}
	return nil
}

func (m *ReplaceSpecType) GetNetworkInterface() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkInterface
	}
	return nil
}

// Get bgp
//
// x-displayName: "Specification"
// BGP object is the configuration for peering with external BGP servers.
// Get bgp reads from system namespace.
type GetSpecType struct {
	Where            *ves_io_schema4.SiteVirtualSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	BgpParameters    *BgpParameters                             `protobuf:"bytes,2,opt,name=bgp_parameters,json=bgpParameters" json:"bgp_parameters,omitempty"`
	BgpPeers         []*BgpPeer                                 `protobuf:"bytes,3,rep,name=bgp_peers,json=bgpPeers" json:"bgp_peers,omitempty"`
	NetworkInterface []*ves_io_schema4.ObjectRefType            `protobuf:"bytes,4,rep,name=network_interface,json=networkInterface" json:"network_interface,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *GetSpecType) GetWhere() *ves_io_schema4.SiteVirtualSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GetSpecType) GetBgpParameters() *BgpParameters {
	if m != nil {
		return m.BgpParameters
	}
	return nil
}

func (m *GetSpecType) GetBgpPeers() []*BgpPeer {
	if m != nil {
		return m.BgpPeers
	}
	return nil
}

func (m *GetSpecType) GetNetworkInterface() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkInterface
	}
	return nil
}

// BGP Peer Status
//
// x-displayName: "BGP Peer Status"
// Most recently observed status of the BGP Peering session
type BgpPeerStatusType struct {
	// Peer Address
	//
	// x-displayName: "Peer Address"
	// Address of the Peer
	PeerAddress *ves_io_schema3.IpAddressType `protobuf:"bytes,3,opt,name=peer_address,json=peerAddress" json:"peer_address,omitempty"`
	// Peer Port
	//
	// x-displayName: "Peer Port"
	// Port used by the Peer
	PeerPort uint32 `protobuf:"varint,4,opt,name=peer_port,json=peerPort,proto3" json:"peer_port,omitempty"`
	// State
	//
	// x-displayName: "State"
	// Current state of the BGP Peering session
	UpDown BgpPeerUpDownType `protobuf:"varint,1,opt,name=up_down,json=upDown,proto3,enum=ves.io.schema.bgp.BgpPeerUpDownType" json:"up_down,omitempty"`
	// Peer Router ID
	//
	// x-displayName: "Peer Router ID"
	// Router ID of the peer
	PeerRouterId string `protobuf:"bytes,5,opt,name=peer_router_id,json=peerRouterId,proto3" json:"peer_router_id,omitempty"`
	// Peer ASN
	//
	// x-displayName: "Peer ASN"
	// Autonomous System Number (ASN) of the Peer
	PeerAsn uint32 `protobuf:"varint,6,opt,name=peer_asn,json=peerAsn,proto3" json:"peer_asn,omitempty"`
	// State Change Timestamp
	//
	// x-displayName: "State Change Timestamp"
	// Timestamp at which last state change to Established state or to not Established state happened
	UpDownTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,7,opt,name=up_down_timestamp,json=upDownTimestamp" json:"up_down_timestamp,omitempty"`
	// Connection Flap Count
	//
	// x-displayName: "BGP Connection Flap Count"
	// Number of times the connection moved from Established state to a non Established state
	ConnectionFlapCount uint32 `protobuf:"varint,8,opt,name=connection_flap_count,json=connectionFlapCount,proto3" json:"connection_flap_count,omitempty"`
	// Advertised Prefix Count
	//
	// x-displayName: "Advertised Prefix Count"
	// Number of prefixes advertised to the peer
	AdvertisedPrefixCount uint32 `protobuf:"varint,9,opt,name=advertised_prefix_count,json=advertisedPrefixCount,proto3" json:"advertised_prefix_count,omitempty"`
	// Received Prefix Count
	//
	// x-displayName: "Received Prefix Count"
	// Number of prefixes received from the peer
	ReceivedPrefixCount uint32 `protobuf:"varint,10,opt,name=received_prefix_count,json=receivedPrefixCount,proto3" json:"received_prefix_count,omitempty"`
	// Interface Name
	//
	// x-displayName: "Interface Name"
	// Name of the interface through which peering is being done
	InterfaceName string `protobuf:"bytes,11,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	// Local Address
	//
	// x-displayName: "Local Address"
	// Local address used by the VER to connect to the peer
	LocalAddress string `protobuf:"bytes,12,opt,name=local_address,json=localAddress,proto3" json:"local_address,omitempty"`
}

func (m *BgpPeerStatusType) Reset()                    { *m = BgpPeerStatusType{} }
func (*BgpPeerStatusType) ProtoMessage()               {}
func (*BgpPeerStatusType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *BgpPeerStatusType) GetPeerAddress() *ves_io_schema3.IpAddressType {
	if m != nil {
		return m.PeerAddress
	}
	return nil
}

func (m *BgpPeerStatusType) GetPeerPort() uint32 {
	if m != nil {
		return m.PeerPort
	}
	return 0
}

func (m *BgpPeerStatusType) GetUpDown() BgpPeerUpDownType {
	if m != nil {
		return m.UpDown
	}
	return BGP_PEER_DOWN
}

func (m *BgpPeerStatusType) GetPeerRouterId() string {
	if m != nil {
		return m.PeerRouterId
	}
	return ""
}

func (m *BgpPeerStatusType) GetPeerAsn() uint32 {
	if m != nil {
		return m.PeerAsn
	}
	return 0
}

func (m *BgpPeerStatusType) GetUpDownTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.UpDownTimestamp
	}
	return nil
}

func (m *BgpPeerStatusType) GetConnectionFlapCount() uint32 {
	if m != nil {
		return m.ConnectionFlapCount
	}
	return 0
}

func (m *BgpPeerStatusType) GetAdvertisedPrefixCount() uint32 {
	if m != nil {
		return m.AdvertisedPrefixCount
	}
	return 0
}

func (m *BgpPeerStatusType) GetReceivedPrefixCount() uint32 {
	if m != nil {
		return m.ReceivedPrefixCount
	}
	return 0
}

func (m *BgpPeerStatusType) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *BgpPeerStatusType) GetLocalAddress() string {
	if m != nil {
		return m.LocalAddress
	}
	return ""
}

// BGP Status
//
// x-displayName: "BGP Status"
// Status of all BGP peering sessions
type BgpStatusType struct {
	// Local Router ID
	//
	// x-displayName: "Local Router ID"
	// Router ID of the VER
	LocalRouterId string `protobuf:"bytes,1,opt,name=local_router_id,json=localRouterId,proto3" json:"local_router_id,omitempty"`
	// Local ASN
	//
	// x-displayName: "Local ASN"
	// Autonomous System Number (ASN) of the VER
	LocalAsn uint32 `protobuf:"varint,2,opt,name=local_asn,json=localAsn,proto3" json:"local_asn,omitempty"`
	// BGP Peer Status
	//
	// x-displayName: "BGP Peer Status"
	// Status of the BGP Peer
	PeerStatusList []*BgpPeerStatusType `protobuf:"bytes,3,rep,name=peer_status_list,json=peerStatusList" json:"peer_status_list,omitempty"`
}

func (m *BgpStatusType) Reset()                    { *m = BgpStatusType{} }
func (*BgpStatusType) ProtoMessage()               {}
func (*BgpStatusType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *BgpStatusType) GetLocalRouterId() string {
	if m != nil {
		return m.LocalRouterId
	}
	return ""
}

func (m *BgpStatusType) GetLocalAsn() uint32 {
	if m != nil {
		return m.LocalAsn
	}
	return 0
}

func (m *BgpStatusType) GetPeerStatusList() []*BgpPeerStatusType {
	if m != nil {
		return m.PeerStatusList
	}
	return nil
}

func init() {
	proto.RegisterType((*BgpParameters)(nil), "ves.io.schema.bgp.BgpParameters")
	golang_proto.RegisterType((*BgpParameters)(nil), "ves.io.schema.bgp.BgpParameters")
	proto.RegisterType((*BgpPeer)(nil), "ves.io.schema.bgp.BgpPeer")
	golang_proto.RegisterType((*BgpPeer)(nil), "ves.io.schema.bgp.BgpPeer")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.bgp.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.bgp.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.bgp.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.bgp.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.bgp.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.bgp.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.bgp.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.bgp.GetSpecType")
	proto.RegisterType((*BgpPeerStatusType)(nil), "ves.io.schema.bgp.BgpPeerStatusType")
	golang_proto.RegisterType((*BgpPeerStatusType)(nil), "ves.io.schema.bgp.BgpPeerStatusType")
	proto.RegisterType((*BgpStatusType)(nil), "ves.io.schema.bgp.BgpStatusType")
	golang_proto.RegisterType((*BgpStatusType)(nil), "ves.io.schema.bgp.BgpStatusType")
	proto.RegisterEnum("ves.io.schema.bgp.BgpRouterIdType", BgpRouterIdType_name, BgpRouterIdType_value)
	golang_proto.RegisterEnum("ves.io.schema.bgp.BgpRouterIdType", BgpRouterIdType_name, BgpRouterIdType_value)
	proto.RegisterEnum("ves.io.schema.bgp.BgpPeerAddressType", BgpPeerAddressType_name, BgpPeerAddressType_value)
	golang_proto.RegisterEnum("ves.io.schema.bgp.BgpPeerAddressType", BgpPeerAddressType_name, BgpPeerAddressType_value)
	proto.RegisterEnum("ves.io.schema.bgp.BgpPeerUpDownType", BgpPeerUpDownType_name, BgpPeerUpDownType_value)
	golang_proto.RegisterEnum("ves.io.schema.bgp.BgpPeerUpDownType", BgpPeerUpDownType_name, BgpPeerUpDownType_value)
}
func (x BgpRouterIdType) String() string {
	s, ok := BgpRouterIdType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BgpPeerAddressType) String() string {
	s, ok := BgpPeerAddressType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BgpPeerUpDownType) String() string {
	s, ok := BgpPeerUpDownType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *BgpParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BgpParameters)
	if !ok {
		that2, ok := that.(BgpParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Asn != that1.Asn {
		return false
	}
	if this.BgpRouterIdType != that1.BgpRouterIdType {
		return false
	}
	if !this.BgpRouterId.Equal(that1.BgpRouterId) {
		return false
	}
	if this.BgpRouterIdKey != that1.BgpRouterIdKey {
		return false
	}
	return true
}
func (this *BgpPeer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BgpPeer)
	if !ok {
		that2, ok := that.(BgpPeer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Asn != that1.Asn {
		return false
	}
	if this.BgpPeerAddressType != that1.BgpPeerAddressType {
		return false
	}
	if !this.BgpPeerAddress.Equal(that1.BgpPeerAddress) {
		return false
	}
	if this.BgpPeerAddressKey != that1.BgpPeerAddressKey {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.BgpPeerSubnetOffset != that1.BgpPeerSubnetOffset {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if !this.BgpParameters.Equal(that1.BgpParameters) {
		return false
	}
	if len(this.BgpPeers) != len(that1.BgpPeers) {
		return false
	}
	for i := range this.BgpPeers {
		if !this.BgpPeers[i].Equal(that1.BgpPeers[i]) {
			return false
		}
	}
	if len(this.NetworkInterface) != len(that1.NetworkInterface) {
		return false
	}
	for i := range this.NetworkInterface {
		if !this.NetworkInterface[i].Equal(that1.NetworkInterface[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if !this.BgpParameters.Equal(that1.BgpParameters) {
		return false
	}
	if len(this.BgpPeers) != len(that1.BgpPeers) {
		return false
	}
	for i := range this.BgpPeers {
		if !this.BgpPeers[i].Equal(that1.BgpPeers[i]) {
			return false
		}
	}
	if len(this.NetworkInterface) != len(that1.NetworkInterface) {
		return false
	}
	for i := range this.NetworkInterface {
		if !this.NetworkInterface[i].Equal(that1.NetworkInterface[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if !this.BgpParameters.Equal(that1.BgpParameters) {
		return false
	}
	if len(this.BgpPeers) != len(that1.BgpPeers) {
		return false
	}
	for i := range this.BgpPeers {
		if !this.BgpPeers[i].Equal(that1.BgpPeers[i]) {
			return false
		}
	}
	if len(this.NetworkInterface) != len(that1.NetworkInterface) {
		return false
	}
	for i := range this.NetworkInterface {
		if !this.NetworkInterface[i].Equal(that1.NetworkInterface[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if !this.BgpParameters.Equal(that1.BgpParameters) {
		return false
	}
	if len(this.BgpPeers) != len(that1.BgpPeers) {
		return false
	}
	for i := range this.BgpPeers {
		if !this.BgpPeers[i].Equal(that1.BgpPeers[i]) {
			return false
		}
	}
	if len(this.NetworkInterface) != len(that1.NetworkInterface) {
		return false
	}
	for i := range this.NetworkInterface {
		if !this.NetworkInterface[i].Equal(that1.NetworkInterface[i]) {
			return false
		}
	}
	return true
}
func (this *BgpPeerStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BgpPeerStatusType)
	if !ok {
		that2, ok := that.(BgpPeerStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PeerAddress.Equal(that1.PeerAddress) {
		return false
	}
	if this.PeerPort != that1.PeerPort {
		return false
	}
	if this.UpDown != that1.UpDown {
		return false
	}
	if this.PeerRouterId != that1.PeerRouterId {
		return false
	}
	if this.PeerAsn != that1.PeerAsn {
		return false
	}
	if !this.UpDownTimestamp.Equal(that1.UpDownTimestamp) {
		return false
	}
	if this.ConnectionFlapCount != that1.ConnectionFlapCount {
		return false
	}
	if this.AdvertisedPrefixCount != that1.AdvertisedPrefixCount {
		return false
	}
	if this.ReceivedPrefixCount != that1.ReceivedPrefixCount {
		return false
	}
	if this.InterfaceName != that1.InterfaceName {
		return false
	}
	if this.LocalAddress != that1.LocalAddress {
		return false
	}
	return true
}
func (this *BgpStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BgpStatusType)
	if !ok {
		that2, ok := that.(BgpStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LocalRouterId != that1.LocalRouterId {
		return false
	}
	if this.LocalAsn != that1.LocalAsn {
		return false
	}
	if len(this.PeerStatusList) != len(that1.PeerStatusList) {
		return false
	}
	for i := range this.PeerStatusList {
		if !this.PeerStatusList[i].Equal(that1.PeerStatusList[i]) {
			return false
		}
	}
	return true
}
func (this *BgpParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&bgp.BgpParameters{")
	s = append(s, "Asn: "+fmt.Sprintf("%#v", this.Asn)+",\n")
	s = append(s, "BgpRouterIdType: "+fmt.Sprintf("%#v", this.BgpRouterIdType)+",\n")
	if this.BgpRouterId != nil {
		s = append(s, "BgpRouterId: "+fmt.Sprintf("%#v", this.BgpRouterId)+",\n")
	}
	s = append(s, "BgpRouterIdKey: "+fmt.Sprintf("%#v", this.BgpRouterIdKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BgpPeer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&bgp.BgpPeer{")
	s = append(s, "Asn: "+fmt.Sprintf("%#v", this.Asn)+",\n")
	s = append(s, "BgpPeerAddressType: "+fmt.Sprintf("%#v", this.BgpPeerAddressType)+",\n")
	if this.BgpPeerAddress != nil {
		s = append(s, "BgpPeerAddress: "+fmt.Sprintf("%#v", this.BgpPeerAddress)+",\n")
	}
	s = append(s, "BgpPeerAddressKey: "+fmt.Sprintf("%#v", this.BgpPeerAddressKey)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "BgpPeerSubnetOffset: "+fmt.Sprintf("%#v", this.BgpPeerSubnetOffset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&bgp.GlobalSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.BgpParameters != nil {
		s = append(s, "BgpParameters: "+fmt.Sprintf("%#v", this.BgpParameters)+",\n")
	}
	if this.BgpPeers != nil {
		s = append(s, "BgpPeers: "+fmt.Sprintf("%#v", this.BgpPeers)+",\n")
	}
	if this.NetworkInterface != nil {
		s = append(s, "NetworkInterface: "+fmt.Sprintf("%#v", this.NetworkInterface)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&bgp.CreateSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.BgpParameters != nil {
		s = append(s, "BgpParameters: "+fmt.Sprintf("%#v", this.BgpParameters)+",\n")
	}
	if this.BgpPeers != nil {
		s = append(s, "BgpPeers: "+fmt.Sprintf("%#v", this.BgpPeers)+",\n")
	}
	if this.NetworkInterface != nil {
		s = append(s, "NetworkInterface: "+fmt.Sprintf("%#v", this.NetworkInterface)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&bgp.ReplaceSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.BgpParameters != nil {
		s = append(s, "BgpParameters: "+fmt.Sprintf("%#v", this.BgpParameters)+",\n")
	}
	if this.BgpPeers != nil {
		s = append(s, "BgpPeers: "+fmt.Sprintf("%#v", this.BgpPeers)+",\n")
	}
	if this.NetworkInterface != nil {
		s = append(s, "NetworkInterface: "+fmt.Sprintf("%#v", this.NetworkInterface)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&bgp.GetSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.BgpParameters != nil {
		s = append(s, "BgpParameters: "+fmt.Sprintf("%#v", this.BgpParameters)+",\n")
	}
	if this.BgpPeers != nil {
		s = append(s, "BgpPeers: "+fmt.Sprintf("%#v", this.BgpPeers)+",\n")
	}
	if this.NetworkInterface != nil {
		s = append(s, "NetworkInterface: "+fmt.Sprintf("%#v", this.NetworkInterface)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BgpPeerStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&bgp.BgpPeerStatusType{")
	if this.PeerAddress != nil {
		s = append(s, "PeerAddress: "+fmt.Sprintf("%#v", this.PeerAddress)+",\n")
	}
	s = append(s, "PeerPort: "+fmt.Sprintf("%#v", this.PeerPort)+",\n")
	s = append(s, "UpDown: "+fmt.Sprintf("%#v", this.UpDown)+",\n")
	s = append(s, "PeerRouterId: "+fmt.Sprintf("%#v", this.PeerRouterId)+",\n")
	s = append(s, "PeerAsn: "+fmt.Sprintf("%#v", this.PeerAsn)+",\n")
	if this.UpDownTimestamp != nil {
		s = append(s, "UpDownTimestamp: "+fmt.Sprintf("%#v", this.UpDownTimestamp)+",\n")
	}
	s = append(s, "ConnectionFlapCount: "+fmt.Sprintf("%#v", this.ConnectionFlapCount)+",\n")
	s = append(s, "AdvertisedPrefixCount: "+fmt.Sprintf("%#v", this.AdvertisedPrefixCount)+",\n")
	s = append(s, "ReceivedPrefixCount: "+fmt.Sprintf("%#v", this.ReceivedPrefixCount)+",\n")
	s = append(s, "InterfaceName: "+fmt.Sprintf("%#v", this.InterfaceName)+",\n")
	s = append(s, "LocalAddress: "+fmt.Sprintf("%#v", this.LocalAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BgpStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&bgp.BgpStatusType{")
	s = append(s, "LocalRouterId: "+fmt.Sprintf("%#v", this.LocalRouterId)+",\n")
	s = append(s, "LocalAsn: "+fmt.Sprintf("%#v", this.LocalAsn)+",\n")
	if this.PeerStatusList != nil {
		s = append(s, "PeerStatusList: "+fmt.Sprintf("%#v", this.PeerStatusList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *BgpParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BgpParameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Asn != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Asn))
	}
	if m.BgpRouterIdType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpRouterIdType))
	}
	if m.BgpRouterId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpRouterId.Size()))
		n1, err := m.BgpRouterId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.BgpRouterIdKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpRouterIdKey)))
		i += copy(dAtA[i:], m.BgpRouterIdKey)
	}
	return i, nil
}

func (m *BgpPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BgpPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Asn != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Asn))
	}
	if m.BgpPeerAddressType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpPeerAddressType))
	}
	if m.BgpPeerAddress != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpPeerAddress.Size()))
		n2, err := m.BgpPeerAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.BgpPeerAddressKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpPeerAddressKey)))
		i += copy(dAtA[i:], m.BgpPeerAddressKey)
	}
	if m.Port != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
	}
	if m.BgpPeerSubnetOffset != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpPeerSubnetOffset))
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n3, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.BgpParameters != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpParameters.Size()))
		n4, err := m.BgpParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.BgpPeers) > 0 {
		for _, msg := range m.BgpPeers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkInterface) > 0 {
		for _, msg := range m.NetworkInterface {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n5, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.BgpParameters != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpParameters.Size()))
		n6, err := m.BgpParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.BgpPeers) > 0 {
		for _, msg := range m.BgpPeers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkInterface) > 0 {
		for _, msg := range m.NetworkInterface {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n7, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.BgpParameters != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpParameters.Size()))
		n8, err := m.BgpParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.BgpPeers) > 0 {
		for _, msg := range m.BgpPeers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkInterface) > 0 {
		for _, msg := range m.NetworkInterface {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n9, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.BgpParameters != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpParameters.Size()))
		n10, err := m.BgpParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.BgpPeers) > 0 {
		for _, msg := range m.BgpPeers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkInterface) > 0 {
		for _, msg := range m.NetworkInterface {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BgpPeerStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BgpPeerStatusType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpDown != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UpDown))
	}
	if m.PeerAddress != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PeerAddress.Size()))
		n11, err := m.PeerAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.PeerPort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PeerPort))
	}
	if len(m.PeerRouterId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PeerRouterId)))
		i += copy(dAtA[i:], m.PeerRouterId)
	}
	if m.PeerAsn != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PeerAsn))
	}
	if m.UpDownTimestamp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UpDownTimestamp.Size()))
		n12, err := m.UpDownTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.ConnectionFlapCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionFlapCount))
	}
	if m.AdvertisedPrefixCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AdvertisedPrefixCount))
	}
	if m.ReceivedPrefixCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ReceivedPrefixCount))
	}
	if len(m.InterfaceName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InterfaceName)))
		i += copy(dAtA[i:], m.InterfaceName)
	}
	if len(m.LocalAddress) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LocalAddress)))
		i += copy(dAtA[i:], m.LocalAddress)
	}
	return i, nil
}

func (m *BgpStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BgpStatusType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LocalRouterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LocalRouterId)))
		i += copy(dAtA[i:], m.LocalRouterId)
	}
	if m.LocalAsn != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LocalAsn))
	}
	if len(m.PeerStatusList) > 0 {
		for _, msg := range m.PeerStatusList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedBgpParameters(r randyTypes, easy bool) *BgpParameters {
	this := &BgpParameters{}
	this.Asn = uint32(r.Uint32())
	this.BgpRouterIdType = BgpRouterIdType([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(10) != 0 {
		this.BgpRouterId = ves_io_schema3.NewPopulatedIpAddressType(r, easy)
	}
	this.BgpRouterIdKey = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBgpPeer(r randyTypes, easy bool) *BgpPeer {
	this := &BgpPeer{}
	this.Asn = uint32(r.Uint32())
	this.BgpPeerAddressType = BgpPeerAddressType([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	if r.Intn(10) != 0 {
		this.BgpPeerAddress = ves_io_schema3.NewPopulatedIpAddressType(r, easy)
	}
	this.BgpPeerAddressKey = string(randStringTypes(r))
	this.Port = uint32(r.Uint32())
	this.BgpPeerSubnetOffset = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	if r.Intn(10) != 0 {
		this.Where = ves_io_schema4.NewPopulatedSiteVirtualSiteRefSelector(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BgpParameters = NewPopulatedBgpParameters(r, easy)
	}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.BgpPeers = make([]*BgpPeer, v1)
		for i := 0; i < v1; i++ {
			this.BgpPeers[i] = NewPopulatedBgpPeer(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.NetworkInterface = make([]*ves_io_schema4.ObjectRefType, v2)
		for i := 0; i < v2; i++ {
			this.NetworkInterface[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	if r.Intn(10) != 0 {
		this.Where = ves_io_schema4.NewPopulatedSiteVirtualSiteRefSelector(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BgpParameters = NewPopulatedBgpParameters(r, easy)
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.BgpPeers = make([]*BgpPeer, v3)
		for i := 0; i < v3; i++ {
			this.BgpPeers[i] = NewPopulatedBgpPeer(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.NetworkInterface = make([]*ves_io_schema4.ObjectRefType, v4)
		for i := 0; i < v4; i++ {
			this.NetworkInterface[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	if r.Intn(10) != 0 {
		this.Where = ves_io_schema4.NewPopulatedSiteVirtualSiteRefSelector(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BgpParameters = NewPopulatedBgpParameters(r, easy)
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.BgpPeers = make([]*BgpPeer, v5)
		for i := 0; i < v5; i++ {
			this.BgpPeers[i] = NewPopulatedBgpPeer(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.NetworkInterface = make([]*ves_io_schema4.ObjectRefType, v6)
		for i := 0; i < v6; i++ {
			this.NetworkInterface[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	if r.Intn(10) != 0 {
		this.Where = ves_io_schema4.NewPopulatedSiteVirtualSiteRefSelector(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BgpParameters = NewPopulatedBgpParameters(r, easy)
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.BgpPeers = make([]*BgpPeer, v7)
		for i := 0; i < v7; i++ {
			this.BgpPeers[i] = NewPopulatedBgpPeer(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.NetworkInterface = make([]*ves_io_schema4.ObjectRefType, v8)
		for i := 0; i < v8; i++ {
			this.NetworkInterface[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBgpPeerStatusType(r randyTypes, easy bool) *BgpPeerStatusType {
	this := &BgpPeerStatusType{}
	this.UpDown = BgpPeerUpDownType([]int32{0, 1}[r.Intn(2)])
	if r.Intn(10) != 0 {
		this.PeerAddress = ves_io_schema3.NewPopulatedIpAddressType(r, easy)
	}
	this.PeerPort = uint32(r.Uint32())
	this.PeerRouterId = string(randStringTypes(r))
	this.PeerAsn = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.UpDownTimestamp = google_protobuf1.NewPopulatedTimestamp(r, easy)
	}
	this.ConnectionFlapCount = uint32(r.Uint32())
	this.AdvertisedPrefixCount = uint32(r.Uint32())
	this.ReceivedPrefixCount = uint32(r.Uint32())
	this.InterfaceName = string(randStringTypes(r))
	this.LocalAddress = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBgpStatusType(r randyTypes, easy bool) *BgpStatusType {
	this := &BgpStatusType{}
	this.LocalRouterId = string(randStringTypes(r))
	this.LocalAsn = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.PeerStatusList = make([]*BgpPeerStatusType, v9)
		for i := 0; i < v9; i++ {
			this.PeerStatusList[i] = NewPopulatedBgpPeerStatusType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v10 := r.Intn(100)
	tmps := make([]rune, v10)
	for i := 0; i < v10; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v11 := r.Int63()
		if r.Intn(2) == 0 {
			v11 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v11))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *BgpParameters) Size() (n int) {
	var l int
	_ = l
	if m.Asn != 0 {
		n += 1 + sovTypes(uint64(m.Asn))
	}
	if m.BgpRouterIdType != 0 {
		n += 1 + sovTypes(uint64(m.BgpRouterIdType))
	}
	if m.BgpRouterId != nil {
		l = m.BgpRouterId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpRouterIdKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BgpPeer) Size() (n int) {
	var l int
	_ = l
	if m.Asn != 0 {
		n += 1 + sovTypes(uint64(m.Asn))
	}
	if m.BgpPeerAddressType != 0 {
		n += 1 + sovTypes(uint64(m.BgpPeerAddressType))
	}
	if m.BgpPeerAddress != nil {
		l = m.BgpPeerAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpPeerAddressKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.BgpPeerSubnetOffset != 0 {
		n += 1 + sovTypes(uint64(m.BgpPeerSubnetOffset))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BgpParameters != nil {
		l = m.BgpParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.BgpPeers) > 0 {
		for _, e := range m.BgpPeers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkInterface) > 0 {
		for _, e := range m.NetworkInterface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BgpParameters != nil {
		l = m.BgpParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.BgpPeers) > 0 {
		for _, e := range m.BgpPeers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkInterface) > 0 {
		for _, e := range m.NetworkInterface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BgpParameters != nil {
		l = m.BgpParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.BgpPeers) > 0 {
		for _, e := range m.BgpPeers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkInterface) > 0 {
		for _, e := range m.NetworkInterface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BgpParameters != nil {
		l = m.BgpParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.BgpPeers) > 0 {
		for _, e := range m.BgpPeers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkInterface) > 0 {
		for _, e := range m.NetworkInterface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *BgpPeerStatusType) Size() (n int) {
	var l int
	_ = l
	if m.UpDown != 0 {
		n += 1 + sovTypes(uint64(m.UpDown))
	}
	if m.PeerAddress != nil {
		l = m.PeerAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PeerPort != 0 {
		n += 1 + sovTypes(uint64(m.PeerPort))
	}
	l = len(m.PeerRouterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PeerAsn != 0 {
		n += 1 + sovTypes(uint64(m.PeerAsn))
	}
	if m.UpDownTimestamp != nil {
		l = m.UpDownTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ConnectionFlapCount != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionFlapCount))
	}
	if m.AdvertisedPrefixCount != 0 {
		n += 1 + sovTypes(uint64(m.AdvertisedPrefixCount))
	}
	if m.ReceivedPrefixCount != 0 {
		n += 1 + sovTypes(uint64(m.ReceivedPrefixCount))
	}
	l = len(m.InterfaceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LocalAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BgpStatusType) Size() (n int) {
	var l int
	_ = l
	l = len(m.LocalRouterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalAsn != 0 {
		n += 1 + sovTypes(uint64(m.LocalAsn))
	}
	if len(m.PeerStatusList) > 0 {
		for _, e := range m.PeerStatusList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BgpParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BgpParameters{`,
		`Asn:` + fmt.Sprintf("%v", this.Asn) + `,`,
		`BgpRouterIdType:` + fmt.Sprintf("%v", this.BgpRouterIdType) + `,`,
		`BgpRouterId:` + strings.Replace(fmt.Sprintf("%v", this.BgpRouterId), "IpAddressType", "ves_io_schema3.IpAddressType", 1) + `,`,
		`BgpRouterIdKey:` + fmt.Sprintf("%v", this.BgpRouterIdKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BgpPeer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BgpPeer{`,
		`Asn:` + fmt.Sprintf("%v", this.Asn) + `,`,
		`BgpPeerAddressType:` + fmt.Sprintf("%v", this.BgpPeerAddressType) + `,`,
		`BgpPeerAddress:` + strings.Replace(fmt.Sprintf("%v", this.BgpPeerAddress), "IpAddressType", "ves_io_schema3.IpAddressType", 1) + `,`,
		`BgpPeerAddressKey:` + fmt.Sprintf("%v", this.BgpPeerAddressKey) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`BgpPeerSubnetOffset:` + fmt.Sprintf("%v", this.BgpPeerSubnetOffset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "SiteVirtualSiteRefSelector", "ves_io_schema4.SiteVirtualSiteRefSelector", 1) + `,`,
		`BgpParameters:` + strings.Replace(fmt.Sprintf("%v", this.BgpParameters), "BgpParameters", "BgpParameters", 1) + `,`,
		`BgpPeers:` + strings.Replace(fmt.Sprintf("%v", this.BgpPeers), "BgpPeer", "BgpPeer", 1) + `,`,
		`NetworkInterface:` + strings.Replace(fmt.Sprintf("%v", this.NetworkInterface), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "SiteVirtualSiteRefSelector", "ves_io_schema4.SiteVirtualSiteRefSelector", 1) + `,`,
		`BgpParameters:` + strings.Replace(fmt.Sprintf("%v", this.BgpParameters), "BgpParameters", "BgpParameters", 1) + `,`,
		`BgpPeers:` + strings.Replace(fmt.Sprintf("%v", this.BgpPeers), "BgpPeer", "BgpPeer", 1) + `,`,
		`NetworkInterface:` + strings.Replace(fmt.Sprintf("%v", this.NetworkInterface), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "SiteVirtualSiteRefSelector", "ves_io_schema4.SiteVirtualSiteRefSelector", 1) + `,`,
		`BgpParameters:` + strings.Replace(fmt.Sprintf("%v", this.BgpParameters), "BgpParameters", "BgpParameters", 1) + `,`,
		`BgpPeers:` + strings.Replace(fmt.Sprintf("%v", this.BgpPeers), "BgpPeer", "BgpPeer", 1) + `,`,
		`NetworkInterface:` + strings.Replace(fmt.Sprintf("%v", this.NetworkInterface), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "SiteVirtualSiteRefSelector", "ves_io_schema4.SiteVirtualSiteRefSelector", 1) + `,`,
		`BgpParameters:` + strings.Replace(fmt.Sprintf("%v", this.BgpParameters), "BgpParameters", "BgpParameters", 1) + `,`,
		`BgpPeers:` + strings.Replace(fmt.Sprintf("%v", this.BgpPeers), "BgpPeer", "BgpPeer", 1) + `,`,
		`NetworkInterface:` + strings.Replace(fmt.Sprintf("%v", this.NetworkInterface), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BgpPeerStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BgpPeerStatusType{`,
		`UpDown:` + fmt.Sprintf("%v", this.UpDown) + `,`,
		`PeerAddress:` + strings.Replace(fmt.Sprintf("%v", this.PeerAddress), "IpAddressType", "ves_io_schema3.IpAddressType", 1) + `,`,
		`PeerPort:` + fmt.Sprintf("%v", this.PeerPort) + `,`,
		`PeerRouterId:` + fmt.Sprintf("%v", this.PeerRouterId) + `,`,
		`PeerAsn:` + fmt.Sprintf("%v", this.PeerAsn) + `,`,
		`UpDownTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.UpDownTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`ConnectionFlapCount:` + fmt.Sprintf("%v", this.ConnectionFlapCount) + `,`,
		`AdvertisedPrefixCount:` + fmt.Sprintf("%v", this.AdvertisedPrefixCount) + `,`,
		`ReceivedPrefixCount:` + fmt.Sprintf("%v", this.ReceivedPrefixCount) + `,`,
		`InterfaceName:` + fmt.Sprintf("%v", this.InterfaceName) + `,`,
		`LocalAddress:` + fmt.Sprintf("%v", this.LocalAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BgpStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BgpStatusType{`,
		`LocalRouterId:` + fmt.Sprintf("%v", this.LocalRouterId) + `,`,
		`LocalAsn:` + fmt.Sprintf("%v", this.LocalAsn) + `,`,
		`PeerStatusList:` + strings.Replace(fmt.Sprintf("%v", this.PeerStatusList), "BgpPeerStatusType", "BgpPeerStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BgpParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BgpParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BgpParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterIdType", wireType)
			}
			m.BgpRouterIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BgpRouterIdType |= (BgpRouterIdType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpRouterId == nil {
				m.BgpRouterId = &ves_io_schema3.IpAddressType{}
			}
			if err := m.BgpRouterId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterIdKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpRouterIdKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BgpPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BgpPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BgpPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddressType", wireType)
			}
			m.BgpPeerAddressType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BgpPeerAddressType |= (BgpPeerAddressType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpPeerAddress == nil {
				m.BgpPeerAddress = &ves_io_schema3.IpAddressType{}
			}
			if err := m.BgpPeerAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddressKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerAddressKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerSubnetOffset", wireType)
			}
			m.BgpPeerSubnetOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BgpPeerSubnetOffset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.SiteVirtualSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpParameters == nil {
				m.BgpParameters = &BgpParameters{}
			}
			if err := m.BgpParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeers = append(m.BgpPeers, &BgpPeer{})
			if err := m.BgpPeers[len(m.BgpPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkInterface = append(m.NetworkInterface, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkInterface[len(m.NetworkInterface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.SiteVirtualSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpParameters == nil {
				m.BgpParameters = &BgpParameters{}
			}
			if err := m.BgpParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeers = append(m.BgpPeers, &BgpPeer{})
			if err := m.BgpPeers[len(m.BgpPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkInterface = append(m.NetworkInterface, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkInterface[len(m.NetworkInterface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.SiteVirtualSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpParameters == nil {
				m.BgpParameters = &BgpParameters{}
			}
			if err := m.BgpParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeers = append(m.BgpPeers, &BgpPeer{})
			if err := m.BgpPeers[len(m.BgpPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkInterface = append(m.NetworkInterface, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkInterface[len(m.NetworkInterface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.SiteVirtualSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpParameters == nil {
				m.BgpParameters = &BgpParameters{}
			}
			if err := m.BgpParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeers = append(m.BgpPeers, &BgpPeer{})
			if err := m.BgpPeers[len(m.BgpPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkInterface = append(m.NetworkInterface, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkInterface[len(m.NetworkInterface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BgpPeerStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BgpPeerStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BgpPeerStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpDown", wireType)
			}
			m.UpDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpDown |= (BgpPeerUpDownType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddress == nil {
				m.PeerAddress = &ves_io_schema3.IpAddressType{}
			}
			if err := m.PeerAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerPort", wireType)
			}
			m.PeerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAsn", wireType)
			}
			m.PeerAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerAsn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpDownTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpDownTimestamp == nil {
				m.UpDownTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.UpDownTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionFlapCount", wireType)
			}
			m.ConnectionFlapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionFlapCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisedPrefixCount", wireType)
			}
			m.AdvertisedPrefixCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvertisedPrefixCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedPrefixCount", wireType)
			}
			m.ReceivedPrefixCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivedPrefixCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BgpStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BgpStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BgpStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAsn", wireType)
			}
			m.LocalAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAsn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerStatusList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerStatusList = append(m.PeerStatusList, &BgpPeerStatusType{})
			if err := m.PeerStatusList[len(m.PeerStatusList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/bgp/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/bgp/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 1383 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x3d, 0x8c, 0x1a, 0x47,
	0x14, 0x66, 0x80, 0xbb, 0xe3, 0x06, 0xc3, 0xc1, 0xd8, 0x17, 0x63, 0xce, 0x5e, 0x63, 0x62, 0xc7,
	0xf8, 0xcc, 0x81, 0x8c, 0xff, 0x22, 0x2b, 0x39, 0x1b, 0x8e, 0x05, 0x11, 0xdb, 0x80, 0x06, 0x2e,
	0x96, 0x52, 0x64, 0xb5, 0xc0, 0xb0, 0xde, 0x18, 0x76, 0x57, 0xbb, 0x03, 0xe7, 0x2b, 0x22, 0xa5,
	0x4d, 0x17, 0x25, 0x45, 0xaa, 0x74, 0x89, 0x14, 0xa5, 0x4b, 0x17, 0xe5, 0x9a, 0x53, 0xaa, 0x28,
	0x45, 0xe4, 0xa4, 0x72, 0x99, 0xc3, 0x8d, 0xd3, 0x59, 0x57, 0x59, 0x69, 0x1c, 0xed, 0xec, 0xb2,
	0xfc, 0xdc, 0x4f, 0x9c, 0xc8, 0x55, 0xe4, 0x6e, 0x76, 0xde, 0xf7, 0xbe, 0x79, 0xf3, 0xbd, 0x99,
	0x79, 0x6f, 0xe1, 0xa9, 0x3e, 0x31, 0x52, 0xb2, 0x9a, 0x36, 0x9a, 0xf7, 0x49, 0x57, 0x4c, 0x37,
	0x24, 0x2d, 0x4d, 0x37, 0x35, 0x62, 0xa4, 0x34, 0x5d, 0xa5, 0x2a, 0x0a, 0x5b, 0xe6, 0x94, 0x65,
	0x4e, 0x35, 0x24, 0x2d, 0xba, 0x22, 0xc9, 0xf4, 0x7e, 0xaf, 0x91, 0x6a, 0xaa, 0xdd, 0xb4, 0xa4,
	0x4a, 0x6a, 0x9a, 0x21, 0x1b, 0xbd, 0x36, 0xfb, 0x62, 0x1f, 0x6c, 0x64, 0x31, 0x44, 0x4f, 0x4b,
	0xaa, 0x2a, 0x75, 0xc8, 0x08, 0x45, 0xe5, 0x2e, 0x31, 0xa8, 0xd8, 0xd5, 0x6c, 0xc0, 0xf1, 0xc9,
	0x08, 0x14, 0x42, 0x6d, 0xc3, 0xd2, 0xa4, 0x41, 0xd5, 0xa8, 0xac, 0x2a, 0x76, 0x60, 0xd1, 0xa9,
	0xb8, 0xb5, 0x3e, 0x15, 0xc6, 0xe2, 0x8e, 0x9e, 0x98, 0x34, 0x8f, 0x9b, 0x4e, 0x4e, 0x9a, 0xfa,
	0x62, 0x47, 0x6e, 0x89, 0x94, 0xd8, 0xd6, 0xd8, 0x94, 0x55, 0x26, 0x1b, 0xc2, 0xc4, 0xca, 0xf1,
	0x2f, 0xdc, 0x30, 0x90, 0x93, 0xb4, 0xaa, 0xa8, 0x8b, 0x5d, 0x42, 0x89, 0x6e, 0xa0, 0xd3, 0xd0,
	0x23, 0x1a, 0x4a, 0x04, 0xc4, 0x40, 0x22, 0x90, 0x0b, 0x3c, 0xdf, 0x02, 0xae, 0x1f, 0xff, 0xdc,
	0xf6, 0x78, 0x97, 0xdd, 0x09, 0x80, 0x4d, 0x0b, 0x5a, 0x87, 0xa8, 0x21, 0x69, 0x82, 0xae, 0xf6,
	0x28, 0xd1, 0x05, 0xb9, 0xc5, 0x42, 0x8d, 0xb8, 0x63, 0x20, 0x11, 0xcc, 0xc4, 0x53, 0x7b, 0x24,
	0x4e, 0xe5, 0x24, 0x0d, 0x33, 0x6c, 0xa9, 0x55, 0xdf, 0xd4, 0x48, 0xce, 0x6b, 0x72, 0xe2, 0x85,
	0xc6, 0xe4, 0x34, 0xba, 0x05, 0x03, 0x13, 0xb4, 0x11, 0x4f, 0x0c, 0x24, 0xfc, 0x99, 0x93, 0x53,
	0x8c, 0x25, 0x2d, 0xdb, 0x6a, 0xe9, 0xc4, 0x30, 0x4c, 0x27, 0xec, 0x1f, 0x63, 0x41, 0xef, 0xc0,
	0xf0, 0x64, 0x60, 0x0f, 0xc8, 0x66, 0xc4, 0x1b, 0x03, 0x89, 0xf9, 0x5c, 0xf8, 0xe9, 0x16, 0x00,
	0xce, 0x5e, 0x74, 0x77, 0xe4, 0x16, 0x0e, 0x8e, 0xb9, 0xde, 0x26, 0x9b, 0x37, 0xe0, 0xee, 0xea,
	0xdc, 0xa5, 0x64, 0x26, 0x79, 0x39, 0x79, 0x25, 0xfe, 0xa5, 0x07, 0xce, 0x99, 0xaa, 0x10, 0xa2,
	0xff, 0xb3, 0x1e, 0x1f, 0xc2, 0x45, 0x73, 0x59, 0x8d, 0x10, 0x5d, 0x10, 0xad, 0xd8, 0xc6, 0x25,
	0x39, 0xb7, 0xbf, 0x24, 0x26, 0xf7, 0xd8, 0x4e, 0x6c, 0x55, 0x4c, 0x65, 0xa7, 0x2c, 0xa8, 0x00,
	0x43, 0xd3, 0xfc, 0x2f, 0xa5, 0x4d, 0x70, 0x92, 0x0b, 0xe5, 0xe0, 0xb1, 0x3d, 0x71, 0x1e, 0xaa,
	0x50, 0x78, 0x92, 0xe0, 0x36, 0xd9, 0x44, 0xe7, 0xa1, 0x57, 0x53, 0x75, 0x1a, 0x99, 0x61, 0x6a,
	0x1c, 0xdd, 0x1e, 0xf3, 0x99, 0x5d, 0xf6, 0x46, 0x5e, 0xbc, 0xf0, 0x60, 0x06, 0x40, 0x05, 0xf8,
	0x86, 0xb3, 0x98, 0xd1, 0x6b, 0x28, 0x84, 0x0a, 0x6a, 0xbb, 0x6d, 0x10, 0x1a, 0x99, 0x65, 0xae,
	0xe1, 0x71, 0x57, 0xef, 0xb2, 0x3b, 0x12, 0xc3, 0x47, 0xed, 0xe5, 0x6a, 0x0c, 0x5e, 0x61, 0xe8,
	0x1b, 0xc1, 0xdd, 0x55, 0xbf, 0x95, 0x95, 0xab, 0xc9, 0x6b, 0xc9, 0x2b, 0xf1, 0xbf, 0xdc, 0x30,
	0x58, 0xec, 0xa8, 0x0d, 0xb1, 0x53, 0xd3, 0x48, 0x93, 0xe9, 0x73, 0x13, 0xce, 0x6c, 0xdc, 0x27,
	0x3a, 0x61, 0x29, 0xf2, 0x67, 0x2e, 0x4c, 0x89, 0x52, 0x93, 0x29, 0x79, 0x5f, 0xd6, 0x69, 0x4f,
	0xec, 0x98, 0x43, 0x4c, 0xda, 0x35, 0xd2, 0x21, 0x4d, 0xaa, 0xea, 0xd8, 0xf2, 0x43, 0x45, 0x18,
	0x64, 0xb1, 0x3a, 0x77, 0x80, 0x65, 0xce, 0x9f, 0x89, 0x1d, 0x90, 0x39, 0x07, 0x87, 0xcd, 0x13,
	0x3b, 0x76, 0x75, 0xae, 0xc3, 0xf9, 0xe1, 0xa6, 0xcd, 0x14, 0x79, 0x12, 0xfe, 0x4c, 0xf4, 0xe0,
	0xec, 0x63, 0x9f, 0xbd, 0x61, 0x03, 0x6d, 0xc0, 0xb0, 0x42, 0xe8, 0x86, 0xaa, 0x3f, 0x10, 0x64,
	0x85, 0x12, 0xbd, 0x2d, 0x36, 0x49, 0xc4, 0xcb, 0x08, 0xa6, 0x73, 0x5c, 0x69, 0x7c, 0x44, 0x9a,
	0x14, 0x93, 0x36, 0x3b, 0x35, 0xc9, 0xef, 0x3e, 0xde, 0xeb, 0xf9, 0x68, 0x0b, 0x00, 0x53, 0xd6,
	0x99, 0xcf, 0x81, 0x3b, 0xe4, 0x1b, 0x8e, 0x7c, 0x00, 0x87, 0x6c, 0x68, 0x69, 0x88, 0xbc, 0x91,
	0xfc, 0x69, 0x0b, 0x24, 0x60, 0x14, 0x86, 0x73, 0xc5, 0x6a, 0xac, 0xa9, 0x2a, 0x6d, 0x59, 0xea,
	0xe9, 0xa2, 0xf9, 0x40, 0xa0, 0x19, 0x76, 0x15, 0x20, 0x84, 0x33, 0xf7, 0x98, 0x4a, 0xe0, 0x52,
	0xfc, 0x37, 0x37, 0x0c, 0xae, 0xe9, 0x44, 0xa4, 0xe4, 0xff, 0x24, 0xbe, 0xf0, 0x5f, 0xc5, 0x3f,
	0xb6, 0x9f, 0xf8, 0xfb, 0x88, 0xbc, 0xf4, 0xcb, 0xea, 0xd4, 0x99, 0xdd, 0x5d, 0x9d, 0x33, 0xd5,
	0xbd, 0x94, 0xbc, 0x12, 0xff, 0xdd, 0x0d, 0x17, 0x30, 0xd1, 0x3a, 0x62, 0xf3, 0xb5, 0xa8, 0xaf,
	0x4c, 0xd4, 0x5f, 0xdd, 0xd0, 0x5f, 0x24, 0xf4, 0xb5, 0xa0, 0xaf, 0x4a, 0xd0, 0x6f, 0xbc, 0x30,
	0x6c, 0xc7, 0x54, 0xa3, 0x22, 0xed, 0x59, 0x95, 0xe9, 0x5d, 0x38, 0xd7, 0xd3, 0x84, 0x96, 0xba,
	0x61, 0x95, 0xc7, 0x60, 0xe6, 0xec, 0xc1, 0x5b, 0x59, 0xd7, 0xf2, 0xea, 0x86, 0xc2, 0x0a, 0xd3,
	0x6c, 0x8f, 0x8d, 0xd1, 0x4d, 0x78, 0xe4, 0x5f, 0x17, 0x35, 0xbf, 0x36, 0x56, 0xd1, 0x96, 0xe0,
	0x3c, 0x23, 0x60, 0x25, 0xc9, 0x2c, 0x63, 0x01, 0xec, 0x33, 0x27, 0xaa, 0x66, 0x05, 0x3a, 0x0b,
	0x83, 0xcc, 0x38, 0x6a, 0x28, 0xcc, 0xa2, 0x35, 0x8f, 0xd9, 0x9a, 0x4e, 0xcf, 0x70, 0x02, 0xfa,
	0xac, 0x18, 0x0c, 0xc5, 0xaa, 0x4c, 0x78, 0x8e, 0xad, 0x60, 0x28, 0xa8, 0x00, 0xc3, 0xf6, 0xee,
	0x04, 0xa7, 0xcb, 0x8b, 0xcc, 0xb1, 0x18, 0xa3, 0x29, 0xab, 0x0f, 0x4c, 0x0d, 0xfb, 0xc0, 0x54,
	0x7d, 0x88, 0xc0, 0x0b, 0xd6, 0xee, 0x9c, 0x09, 0x94, 0x81, 0x8b, 0x4d, 0x55, 0x51, 0x48, 0xd3,
	0x7c, 0x56, 0x85, 0x76, 0x47, 0xd4, 0x84, 0xa6, 0xda, 0x53, 0x68, 0xc4, 0xc7, 0xd6, 0x3b, 0x3a,
	0x32, 0x16, 0x3a, 0xa2, 0xb6, 0x66, 0x9a, 0xd0, 0x35, 0x78, 0x5c, 0x6c, 0xf5, 0x89, 0x4e, 0x65,
	0x83, 0xb4, 0x04, 0x4d, 0x27, 0x6d, 0xf9, 0xa1, 0xed, 0x35, 0xcf, 0xbc, 0x16, 0x47, 0xe6, 0x2a,
	0xb3, 0x5a, 0x7e, 0x19, 0xb8, 0xa8, 0x93, 0x26, 0x91, 0xfb, 0xd3, 0x5e, 0xd0, 0x5a, 0x6b, 0x68,
	0x1c, 0xf7, 0x39, 0x07, 0x83, 0xce, 0xb9, 0x10, 0x14, 0xb1, 0x4b, 0x22, 0x7e, 0x26, 0x54, 0xc0,
	0x99, 0x2d, 0x8b, 0x5d, 0x82, 0xde, 0x84, 0x81, 0x8e, 0xda, 0x14, 0x3b, 0x4e, 0xba, 0x8e, 0x58,
	0x72, 0xb2, 0x49, 0x3b, 0x23, 0xf1, 0xaf, 0x01, 0x6b, 0x27, 0xc7, 0xce, 0xc8, 0x5b, 0x70, 0xc1,
	0x72, 0x1b, 0xe5, 0x01, 0x58, 0xf4, 0x6c, 0xda, 0x49, 0xc4, 0x12, 0x9c, 0xb7, 0xe9, 0x0d, 0x85,
	0x5d, 0xae, 0x00, 0xf6, 0x59, 0xd4, 0x86, 0x82, 0xca, 0x30, 0x64, 0x75, 0x12, 0x8c, 0x57, 0xe8,
	0xc8, 0x06, 0xb5, 0x2f, 0xcf, 0x21, 0x27, 0x6e, 0x14, 0x04, 0x66, 0x27, 0xc1, 0xfa, 0xbe, 0x23,
	0x1b, 0x74, 0xf9, 0x7b, 0x00, 0x17, 0xa6, 0xda, 0x52, 0x14, 0x83, 0x27, 0x73, 0xc5, 0xaa, 0x80,
	0x2b, 0xeb, 0x75, 0x1e, 0x0b, 0xa5, 0xbc, 0x50, 0xc0, 0x95, 0xbb, 0x42, 0xa9, 0x5c, 0xe7, 0x71,
	0x21, 0xbb, 0xc6, 0x87, 0x5c, 0xe8, 0x0c, 0x3c, 0xb5, 0x1f, 0xa2, 0x2a, 0x64, 0xf3, 0x79, 0xcc,
	0xd7, 0x6a, 0x21, 0x80, 0xe2, 0x90, 0xdb, 0x07, 0x52, 0x2b, 0xd5, 0x79, 0xa1, 0x92, 0x7b, 0x8f,
	0x5f, 0xab, 0x87, 0xdc, 0xe8, 0x2a, 0xbc, 0x78, 0x10, 0xa6, 0xce, 0xdf, 0xad, 0xde, 0xc9, 0xd6,
	0x79, 0xa1, 0x9a, 0xc5, 0xd9, 0xbb, 0x7c, 0x9d, 0xc7, 0xb5, 0x90, 0x27, 0xea, 0x35, 0x7b, 0xa5,
	0xe5, 0xaf, 0xdc, 0x10, 0xed, 0xed, 0x1b, 0xd1, 0x59, 0x18, 0x33, 0xd9, 0xaa, 0x3c, 0x8f, 0x87,
	0x71, 0x58, 0x84, 0x79, 0xbe, 0x90, 0x5d, 0xbf, 0x53, 0x17, 0x8a, 0xf7, 0x42, 0xae, 0x83, 0x51,
	0x13, 0xd1, 0x9f, 0x83, 0x67, 0xf6, 0x47, 0x4d, 0x6e, 0xe0, 0x6d, 0x98, 0x3a, 0x04, 0x76, 0xc8,
	0x1e, 0xd0, 0x0a, 0xbc, 0xb0, 0xc7, 0xb3, 0x52, 0x28, 0xd4, 0xf8, 0xba, 0x4d, 0xb0, 0x9e, 0x2b,
	0xf3, 0x75, 0x21, 0xc7, 0x17, 0x4b, 0xe5, 0x90, 0x17, 0x5d, 0x84, 0xe7, 0x5f, 0x06, 0xce, 0x97,
	0xf3, 0xa1, 0x99, 0xe5, 0xeb, 0xce, 0x0b, 0x35, 0x7a, 0x6a, 0x50, 0x18, 0x06, 0x1c, 0x86, 0x7c,
	0xe5, 0x5e, 0x39, 0xe4, 0x42, 0x0b, 0xd0, 0xef, 0x4c, 0xad, 0x57, 0x43, 0x20, 0xf7, 0x29, 0x78,
	0xb4, 0xc3, 0xb9, 0x1e, 0xef, 0x70, 0xae, 0x67, 0x3b, 0x1c, 0x78, 0xbe, 0xc3, 0x81, 0x4f, 0x06,
	0x1c, 0xf8, 0x76, 0xc0, 0x81, 0x1f, 0x06, 0x1c, 0xd8, 0x1e, 0x70, 0xe0, 0xe7, 0x01, 0x07, 0x1e,
	0x0d, 0x38, 0xf0, 0x78, 0xc0, 0x81, 0x3f, 0x06, 0x1c, 0x78, 0x3a, 0xe0, 0x5c, 0xcf, 0x06, 0x1c,
	0xf8, 0xec, 0x09, 0xe7, 0xda, 0x7e, 0xc2, 0x81, 0x0f, 0x8a, 0x92, 0xaa, 0x3d, 0x90, 0x52, 0x7d,
	0xb5, 0x43, 0x89, 0xae, 0x8b, 0xa9, 0x9e, 0x91, 0x66, 0x83, 0xb6, 0xaa, 0x77, 0x57, 0x34, 0x5d,
	0xed, 0xcb, 0x2d, 0xa2, 0xaf, 0x0c, 0xcd, 0x69, 0xad, 0x21, 0xa9, 0x69, 0xf2, 0x90, 0xda, 0xbf,
	0x65, 0xa3, 0xbf, 0xd5, 0xc6, 0x2c, 0x7b, 0x50, 0x2e, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xd1,
	0x5d, 0x61, 0xcb, 0xc9, 0x0e, 0x00, 0x00,
}

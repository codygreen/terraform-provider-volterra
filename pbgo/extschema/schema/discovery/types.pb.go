// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/discovery/types.proto

package discovery

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// REST scheme
//
// x-displayName: "Scheme"
// Scheme to use when doing REST API to discovery server
type SchemeType int32

const (
	// x-displayName: "HTTP"
	// http:// Scheme
	HTTP SchemeType = 0
	// x-displayName: "HTTPS"
	// https:// Scheme
	HTTPS SchemeType = 1
)

var SchemeType_name = map[int32]string{
	0: "HTTP",
	1: "HTTPS",
}
var SchemeType_value = map[string]int32{
	"HTTP":  0,
	"HTTPS": 1,
}

func (SchemeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// VirtualIPDiscoveryType
//
// x-displayName: "Virtual IP Discovery"
// How is the Virtual IP discovery done
// Two modes are possible
//   DNS_DELEGATION: Program DNS delegation for a sub-domain in external K8s cluster
//   PUBLISH_SERVICE: Create/Register a service in external K8s/consul cluster
type VirtualIPDiscoveryType int32

const (
	// x-displayName: "DNS Delegation"
	// DNS sub domain is delegated to volterra site.
	DNS_DELEGATION VirtualIPDiscoveryType = 0
	// x-displayName: "Publish"
	// Name to VIP mapping is published in external discovery service
	PUBLISH_SERVICE VirtualIPDiscoveryType = 1
)

var VirtualIPDiscoveryType_name = map[int32]string{
	0: "DNS_DELEGATION",
	1: "PUBLISH_SERVICE",
}
var VirtualIPDiscoveryType_value = map[string]int32{
	"DNS_DELEGATION":  0,
	"PUBLISH_SERVICE": 1,
}

func (VirtualIPDiscoveryType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// K8SDNSMode
//
// x-displayName: "DNS Mode"
// Two modes are possible
type K8SDNSMode int32

const (
	// x-displayName: "Core DNS"
	// CoreDNS: Whether external K8s cluster is running core-dns
	CORE_DNS K8SDNSMode = 0
	// x-displayName: "K8s DNS"
	// KubeDNS: External K8s cluster is running kube-dns
	KUBE_DNS K8SDNSMode = 1
)

var K8SDNSMode_name = map[int32]string{
	0: "CORE_DNS",
	1: "KUBE_DNS",
}
var K8SDNSMode_value = map[string]int32{
	"CORE_DNS": 0,
	"KUBE_DNS": 1,
}

func (K8SDNSMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// VER status for Discovery
//
// x-displayName: "VER Status"
// This VER status is per site on which discovery is happening and it lists all services that site has discovered.
type VerStatusType struct {
	// Connection status
	//
	// x-displayName: "Connection Status"
	// Indicates connection status to external discovery service
	Connected bool `protobuf:"varint,1,opt,name=connected,proto3" json:"connected,omitempty"`
	// Origin site
	//
	// x-displayName: "Site"
	// Name of the site that reported this status
	Site string `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`
	// Type of discovery
	//
	// x-displayName: "External Discovery"
	// Service discovery type. Possible values are K8S and Consul
	Type ves_io_schema4.DiscoveryType `protobuf:"varint,3,opt,name=type,proto3,enum=ves.io.schema.DiscoveryType" json:"type,omitempty"`
	// Discovered Services
	//
	// x-displayName: "Discovered Services"
	// List of discovered services
	Services []*DiscoveredServiceType `protobuf:"bytes,4,rep,name=services" json:"services,omitempty"`
}

func (m *VerStatusType) Reset()                    { *m = VerStatusType{} }
func (*VerStatusType) ProtoMessage()               {}
func (*VerStatusType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *VerStatusType) GetConnected() bool {
	if m != nil {
		return m.Connected
	}
	return false
}

func (m *VerStatusType) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *VerStatusType) GetType() ves_io_schema4.DiscoveryType {
	if m != nil {
		return m.Type
	}
	return ves_io_schema4.INVALID_DISCOVERY
}

func (m *VerStatusType) GetServices() []*DiscoveredServiceType {
	if m != nil {
		return m.Services
	}
	return nil
}

// Pod info
//
// x-displayName: "POD"
// Information about POD providing the service
type PodInfoType struct {
	// POD name
	//
	// x-example: "mypod-nk8wr"
	// x-displayName: "Name"
	// Name of the Pod
	PodName string `protobuf:"bytes,1,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	// IP Address
	//
	// x-displayName: "IP"
	// x-example: "192.1.2.3"
	// IP Address of the POD
	Ip string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *PodInfoType) Reset()                    { *m = PodInfoType{} }
func (*PodInfoType) ProtoMessage()               {}
func (*PodInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *PodInfoType) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

func (m *PodInfoType) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

// Discovered Service
//
// x-displayName: "Service"
// Details of each Discovered Service
type DiscoveredServiceType struct {
	// Service name
	//
	// x-displayName: "Service"
	// x-example: "myservice"
	// Name of the discovered service
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "mynamespace"
	// Namespace of the discovered service
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Service Type
	//
	// x-displayName: "Type"
	// x-example: "NodePort"
	// Type of discovered service. Examples include "ClusterIP", "NodePort" etc
	ServiceType string `protobuf:"bytes,3,opt,name=service_type,json=serviceType,proto3" json:"service_type,omitempty"`
	// Service IP
	//
	// x-displayName: "IP"
	// x-example: "192.1.2.3"
	// IP Address of the service
	ClusterIp string `protobuf:"bytes,4,opt,name=cluster_ip,json=clusterIp,proto3" json:"cluster_ip,omitempty"`
	// Service labels
	//
	// x-displayName: "Labels"
	// Key value pairs defined as labels for the service
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// POD list
	//
	// x-displayName: "PODs"
	// List of pod-name to IP address mappings for the service
	Pods []*PodInfoType `protobuf:"bytes,6,rep,name=pods" json:"pods,omitempty"`
	// Port mapping
	//
	// x-displayName: "Port Mapping"
	// port number to target port mapping for ClusterIP service
	// port number to node-port mapping for NodePort service
	PortMap map[uint32]uint32 `protobuf:"bytes,7,rep,name=port_map,json=portMap" json:"port_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *DiscoveredServiceType) Reset()                    { *m = DiscoveredServiceType{} }
func (*DiscoveredServiceType) ProtoMessage()               {}
func (*DiscoveredServiceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *DiscoveredServiceType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *DiscoveredServiceType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DiscoveredServiceType) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

func (m *DiscoveredServiceType) GetClusterIp() string {
	if m != nil {
		return m.ClusterIp
	}
	return ""
}

func (m *DiscoveredServiceType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *DiscoveredServiceType) GetPods() []*PodInfoType {
	if m != nil {
		return m.Pods
	}
	return nil
}

func (m *DiscoveredServiceType) GetPortMap() map[uint32]uint32 {
	if m != nil {
		return m.PortMap
	}
	return nil
}

// TLS config
//
// x-displayName: "Client TLS Config"
// TLS config for client of discovery service
type TLSClientConfigType struct {
	// Server Name
	//
	// x-displayName: "SNI name"
	// x-example: "k8s.acme.com"
	// ServerName is passed to the server for SNI and is used in the client to check server
	// ceritificates against. If ServerName is empty, the hostname used to contact the
	// server is used
	ServerName string `protobuf:"bytes,1,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// Client credentials
	//
	// x-displayName: "Client Credentials"
	// Volterra Secret. URL to fetch the client certificate file
	CertificateUrl *ves_io_schema4.SecretType `protobuf:"bytes,2,opt,name=certificate_url,json=certificateUrl" json:"certificate_url,omitempty"`
	// The TLS certificate URL.
	//
	// x-displayName: "Client Certificate"
	// Client  certificate is PEM-encoded certificate or certificate-chain.
	Certificate string `protobuf:"bytes,5,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// Private Key
	//
	// x-displayName: "Client Private Key"
	// Client private key file containing data in PEM format including the PEM headers.
	// The data in this key file has to match accompanying certificate.
	// The data may be optionally secured using BlindFold.
	KeyUrl *ves_io_schema4.SecretType `protobuf:"bytes,3,opt,name=key_url,json=keyUrl" json:"key_url,omitempty"`
	// Server CA certificates
	//
	// x-displayName: "Server CA Certificates"
	// Volterra Secret. URL to fetch the server CA certificate file
	CaCertificateUrl *ves_io_schema4.SecretType `protobuf:"bytes,4,opt,name=ca_certificate_url,json=caCertificateUrl" json:"ca_certificate_url,omitempty"`
	// Server CA certificates
	//
	// x-displayName: "Server CA Certificates"
	// The URL or value for trusted Server CA certificate or certificate chain
	// Certificates in PEM format including the PEM headers.
	TrustedCaUrl string `protobuf:"bytes,6,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"`
}

func (m *TLSClientConfigType) Reset()                    { *m = TLSClientConfigType{} }
func (*TLSClientConfigType) ProtoMessage()               {}
func (*TLSClientConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *TLSClientConfigType) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *TLSClientConfigType) GetCertificateUrl() *ves_io_schema4.SecretType {
	if m != nil {
		return m.CertificateUrl
	}
	return nil
}

func (m *TLSClientConfigType) GetCertificate() string {
	if m != nil {
		return m.Certificate
	}
	return ""
}

func (m *TLSClientConfigType) GetKeyUrl() *ves_io_schema4.SecretType {
	if m != nil {
		return m.KeyUrl
	}
	return nil
}

func (m *TLSClientConfigType) GetCaCertificateUrl() *ves_io_schema4.SecretType {
	if m != nil {
		return m.CaCertificateUrl
	}
	return nil
}

func (m *TLSClientConfigType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

// REST API config
//
// x-displayName: "REST API Config"
// Configuration details to access discovery service rest API.
type RestConfigType struct {
	// Discovery Service API server
	//
	// x-displayName: "API Server and Port"
	// x-required
	// x-example: "api.acme.com:4430"
	// API server must be a fully qualified domain string and port specified as host:port pair
	ApiServer string `protobuf:"bytes,1,opt,name=api_server,json=apiServer,proto3" json:"api_server,omitempty"`
	// TLS parameters
	//
	// x-displayName: "TLS Parameters"
	// TLS settings to enable transport layer security
	TlsInfo *TLSClientConfigType `protobuf:"bytes,2,opt,name=tls_info,json=tlsInfo" json:"tls_info,omitempty"`
}

func (m *RestConfigType) Reset()                    { *m = RestConfigType{} }
func (*RestConfigType) ProtoMessage()               {}
func (*RestConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *RestConfigType) GetApiServer() string {
	if m != nil {
		return m.ApiServer
	}
	return ""
}

func (m *RestConfigType) GetTlsInfo() *TLSClientConfigType {
	if m != nil {
		return m.TlsInfo
	}
	return nil
}

// K8S access info
//
// x-displayName: "K8s API Server"
// K8S API server access
type K8SAccessInfo struct {
	// Oneof for K8s config
	//
	// x-displayName: "Select Kubernetes Credentials"
	// x-required
	// Kubernetes credentials can be kubeconfig or TLS param
	//
	// Types that are valid to be assigned to ConfigType:
	//	*K8SAccessInfo_KubeconfigUrl
	//	*K8SAccessInfo_ConnectionInfo
	//	*K8SAccessInfo_InCluster
	ConfigType isK8SAccessInfo_ConfigType `protobuf_oneof:"config_type"`
	// Kubernetes Network reachability
	//
	// x-displayName: "Kubernetes POD network reachability"
	// x-required
	// Specify which IP addresses to discover from Kubernetes services based
	// on reachability of Kubernetes POD
	//
	// Types that are valid to be assigned to K8SPodNetworkChoice:
	//	*K8SAccessInfo_Isolated
	//	*K8SAccessInfo_Reachable
	K8SPodNetworkChoice isK8SAccessInfo_K8SPodNetworkChoice `protobuf_oneof:"k8s_pod_network_choice"`
}

func (m *K8SAccessInfo) Reset()                    { *m = K8SAccessInfo{} }
func (*K8SAccessInfo) ProtoMessage()               {}
func (*K8SAccessInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

type isK8SAccessInfo_ConfigType interface {
	isK8SAccessInfo_ConfigType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isK8SAccessInfo_K8SPodNetworkChoice interface {
	isK8SAccessInfo_K8SPodNetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type K8SAccessInfo_KubeconfigUrl struct {
	KubeconfigUrl *ves_io_schema4.SecretType `protobuf:"bytes,1,opt,name=kubeconfig_url,json=kubeconfigUrl,oneof"`
}
type K8SAccessInfo_ConnectionInfo struct {
	ConnectionInfo *RestConfigType `protobuf:"bytes,2,opt,name=connection_info,json=connectionInfo,oneof"`
}
type K8SAccessInfo_InCluster struct {
	InCluster bool `protobuf:"varint,3,opt,name=in_cluster,json=inCluster,proto3,oneof"`
}
type K8SAccessInfo_Isolated struct {
	Isolated *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=isolated,oneof"`
}
type K8SAccessInfo_Reachable struct {
	Reachable *ves_io_schema4.Empty `protobuf:"bytes,5,opt,name=reachable,oneof"`
}

func (*K8SAccessInfo_KubeconfigUrl) isK8SAccessInfo_ConfigType()      {}
func (*K8SAccessInfo_ConnectionInfo) isK8SAccessInfo_ConfigType()     {}
func (*K8SAccessInfo_InCluster) isK8SAccessInfo_ConfigType()          {}
func (*K8SAccessInfo_Isolated) isK8SAccessInfo_K8SPodNetworkChoice()  {}
func (*K8SAccessInfo_Reachable) isK8SAccessInfo_K8SPodNetworkChoice() {}

func (m *K8SAccessInfo) GetConfigType() isK8SAccessInfo_ConfigType {
	if m != nil {
		return m.ConfigType
	}
	return nil
}
func (m *K8SAccessInfo) GetK8SPodNetworkChoice() isK8SAccessInfo_K8SPodNetworkChoice {
	if m != nil {
		return m.K8SPodNetworkChoice
	}
	return nil
}

func (m *K8SAccessInfo) GetKubeconfigUrl() *ves_io_schema4.SecretType {
	if x, ok := m.GetConfigType().(*K8SAccessInfo_KubeconfigUrl); ok {
		return x.KubeconfigUrl
	}
	return nil
}

func (m *K8SAccessInfo) GetConnectionInfo() *RestConfigType {
	if x, ok := m.GetConfigType().(*K8SAccessInfo_ConnectionInfo); ok {
		return x.ConnectionInfo
	}
	return nil
}

func (m *K8SAccessInfo) GetInCluster() bool {
	if x, ok := m.GetConfigType().(*K8SAccessInfo_InCluster); ok {
		return x.InCluster
	}
	return false
}

func (m *K8SAccessInfo) GetIsolated() *ves_io_schema4.Empty {
	if x, ok := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Isolated); ok {
		return x.Isolated
	}
	return nil
}

func (m *K8SAccessInfo) GetReachable() *ves_io_schema4.Empty {
	if x, ok := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Reachable); ok {
		return x.Reachable
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*K8SAccessInfo) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _K8SAccessInfo_OneofMarshaler, _K8SAccessInfo_OneofUnmarshaler, _K8SAccessInfo_OneofSizer, []interface{}{
		(*K8SAccessInfo_KubeconfigUrl)(nil),
		(*K8SAccessInfo_ConnectionInfo)(nil),
		(*K8SAccessInfo_InCluster)(nil),
		(*K8SAccessInfo_Isolated)(nil),
		(*K8SAccessInfo_Reachable)(nil),
	}
}

func _K8SAccessInfo_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*K8SAccessInfo)
	// config_type
	switch x := m.ConfigType.(type) {
	case *K8SAccessInfo_KubeconfigUrl:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KubeconfigUrl); err != nil {
			return err
		}
	case *K8SAccessInfo_ConnectionInfo:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConnectionInfo); err != nil {
			return err
		}
	case *K8SAccessInfo_InCluster:
		t := uint64(0)
		if x.InCluster {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("K8SAccessInfo.ConfigType has unexpected type %T", x)
	}
	// k8s_pod_network_choice
	switch x := m.K8SPodNetworkChoice.(type) {
	case *K8SAccessInfo_Isolated:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Isolated); err != nil {
			return err
		}
	case *K8SAccessInfo_Reachable:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Reachable); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("K8SAccessInfo.K8SPodNetworkChoice has unexpected type %T", x)
	}
	return nil
}

func _K8SAccessInfo_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*K8SAccessInfo)
	switch tag {
	case 1: // config_type.kubeconfig_url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.SecretType)
		err := b.DecodeMessage(msg)
		m.ConfigType = &K8SAccessInfo_KubeconfigUrl{msg}
		return true, err
	case 2: // config_type.connection_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestConfigType)
		err := b.DecodeMessage(msg)
		m.ConfigType = &K8SAccessInfo_ConnectionInfo{msg}
		return true, err
	case 3: // config_type.in_cluster
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConfigType = &K8SAccessInfo_InCluster{x != 0}
		return true, err
	case 4: // k8s_pod_network_choice.isolated
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.K8SPodNetworkChoice = &K8SAccessInfo_Isolated{msg}
		return true, err
	case 5: // k8s_pod_network_choice.reachable
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.K8SPodNetworkChoice = &K8SAccessInfo_Reachable{msg}
		return true, err
	default:
		return false, nil
	}
}

func _K8SAccessInfo_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*K8SAccessInfo)
	// config_type
	switch x := m.ConfigType.(type) {
	case *K8SAccessInfo_KubeconfigUrl:
		s := proto.Size(x.KubeconfigUrl)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *K8SAccessInfo_ConnectionInfo:
		s := proto.Size(x.ConnectionInfo)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *K8SAccessInfo_InCluster:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// k8s_pod_network_choice
	switch x := m.K8SPodNetworkChoice.(type) {
	case *K8SAccessInfo_Isolated:
		s := proto.Size(x.Isolated)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *K8SAccessInfo_Reachable:
		s := proto.Size(x.Reachable)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Hashicorp Consul Credentials
//
// x-displayName: "Hashicorp Consul Credentials"
// Authentication parameters to access Hashicorp Consul.
type ConsulHttpBasicAuthInfoType struct {
	// username
	//
	// x-displayName: "User Name"
	// x-example: "Joe"
	// username in consul
	UserName string `protobuf:"bytes,1,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	// password
	//
	// x-displayName: "Password"
	// Volterra Secret. URL for password, needs to be fetched from this path
	PasswdUrl *ves_io_schema4.SecretType `protobuf:"bytes,2,opt,name=passwd_url,json=passwdUrl" json:"passwd_url,omitempty"`
}

func (m *ConsulHttpBasicAuthInfoType) Reset()      { *m = ConsulHttpBasicAuthInfoType{} }
func (*ConsulHttpBasicAuthInfoType) ProtoMessage() {}
func (*ConsulHttpBasicAuthInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{6}
}

func (m *ConsulHttpBasicAuthInfoType) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ConsulHttpBasicAuthInfoType) GetPasswdUrl() *ves_io_schema4.SecretType {
	if m != nil {
		return m.PasswdUrl
	}
	return nil
}

// ConsulAccessInfo
//
// x-displayName: "Hashicorp Consul Parameters"
// Hashicorp Consul API server information
type ConsulAccessInfo struct {
	// Connection Parameters
	//
	// x-displayName: "Connection Parameters"
	// Configuration details to access Hashicorp Consul API service using REST.
	ConnectionInfo *RestConfigType `protobuf:"bytes,1,opt,name=connection_info,json=connectionInfo" json:"connection_info,omitempty"`
	// Scheme
	//
	// x-displayName: "Scheme"
	// scheme
	Scheme SchemeType `protobuf:"varint,2,opt,name=scheme,proto3,enum=ves.io.schema.discovery.SchemeType" json:"scheme,omitempty"`
	// Http authentication parameters
	//
	// x-displayName: "HTTP Authentication Parameters"
	// Username and password used for HTTP/HTTPS access
	HttpBasicAuthInfo *ConsulHttpBasicAuthInfoType `protobuf:"bytes,3,opt,name=http_basic_auth_info,json=httpBasicAuthInfo" json:"http_basic_auth_info,omitempty"`
}

func (m *ConsulAccessInfo) Reset()                    { *m = ConsulAccessInfo{} }
func (*ConsulAccessInfo) ProtoMessage()               {}
func (*ConsulAccessInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *ConsulAccessInfo) GetConnectionInfo() *RestConfigType {
	if m != nil {
		return m.ConnectionInfo
	}
	return nil
}

func (m *ConsulAccessInfo) GetScheme() SchemeType {
	if m != nil {
		return m.Scheme
	}
	return HTTP
}

func (m *ConsulAccessInfo) GetHttpBasicAuthInfo() *ConsulHttpBasicAuthInfoType {
	if m != nil {
		return m.HttpBasicAuthInfo
	}
	return nil
}

// VIP Discovery Info Type
//
// x-displayName: "VIP Publish Configuration"
// K8S Configuration to publish VIPs
type VipDiscoveryInfoType struct {
	// enable/disable publish VIP
	//
	// x-displayName: "VIP Publish Enable"
	// Are we publishing Virtual Host domains to Virtual IP mapping to external cluster
	PublishVirtualIp bool `protobuf:"varint,1,opt,name=publish_virtual_ip,json=publishVirtualIp,proto3" json:"publish_virtual_ip,omitempty"`
	// VIP publish method
	//
	// x-displayName: "VIP Publish Method"
	// How is Virtual IP discovery performed
	// Two modes are possible
	//   DNS_DELEGATION: Program DNS delegation for a sub-domain in external cluster
	//   PUBLISH_SERVICE: Create/Register a service in external K8s/consul cluster
	Type VirtualIPDiscoveryType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.discovery.VirtualIPDiscoveryType" json:"type,omitempty"`
	// DNS delegation sub-domain
	//
	// x-displayName: "Subdomain"
	// Subdomain for which DNS delegation is done
	// Volterra Edge Router will only respond for DNS queries on this sub-domain
	// While programming the DNS DELEGATE on external cluster, VER will take ownership of this
	// sub-domain
	Subdomain string `protobuf:"bytes,3,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	// DNS mode
	//
	// x-displayName: "DNS Mode"
	// When virtual IP is published with DNS delegation, this field indicates whether
	// external K8s is running core DNS or kube DNS
	DnsMode K8SDNSMode `protobuf:"varint,4,opt,name=dns_mode,json=dnsMode,proto3,enum=ves.io.schema.discovery.K8SDNSMode" json:"dns_mode,omitempty"`
	// default namespace
	//
	// x-displayName: "Default Namespace"
	// When virtual IP is published with "PUBLISH_SERVICE" mode, this field indicates the namespace
	// where the service/endpoints needs to be created if the domain name doesn't specify it
	// explicitly. K8S administrator of the external K8s should ensure this namespace is created
	Namespace string `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *VipDiscoveryInfoType) Reset()                    { *m = VipDiscoveryInfoType{} }
func (*VipDiscoveryInfoType) ProtoMessage()               {}
func (*VipDiscoveryInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *VipDiscoveryInfoType) GetPublishVirtualIp() bool {
	if m != nil {
		return m.PublishVirtualIp
	}
	return false
}

func (m *VipDiscoveryInfoType) GetType() VirtualIPDiscoveryType {
	if m != nil {
		return m.Type
	}
	return DNS_DELEGATION
}

func (m *VipDiscoveryInfoType) GetSubdomain() string {
	if m != nil {
		return m.Subdomain
	}
	return ""
}

func (m *VipDiscoveryInfoType) GetDnsMode() K8SDNSMode {
	if m != nil {
		return m.DnsMode
	}
	return CORE_DNS
}

func (m *VipDiscoveryInfoType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type K8SPublishType struct {
	// namespace
	//
	// x-displayName: "Default Namespace"
	// x-required
	// The namespace where the service/endpoints need to be created if it's not included in the domain.
	// The external K8S administrator needs to ensure that the namespace exists.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *K8SPublishType) Reset()                    { *m = K8SPublishType{} }
func (*K8SPublishType) ProtoMessage()               {}
func (*K8SPublishType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *K8SPublishType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type K8SDelegationType struct {
	// subdomain
	//
	// x-displayName: "Subdomain"
	// x-required
	// The DNS subdomain for which Volterra will respond to DNS queries.
	Subdomain string `protobuf:"bytes,1,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	// DNS mode
	//
	// x-displayName: "DNS Mode"
	// x-required
	// Indicates whether external K8S is running core DNS or kube DNS
	DnsMode K8SDNSMode `protobuf:"varint,2,opt,name=dns_mode,json=dnsMode,proto3,enum=ves.io.schema.discovery.K8SDNSMode" json:"dns_mode,omitempty"`
}

func (m *K8SDelegationType) Reset()                    { *m = K8SDelegationType{} }
func (*K8SDelegationType) ProtoMessage()               {}
func (*K8SDelegationType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *K8SDelegationType) GetSubdomain() string {
	if m != nil {
		return m.Subdomain
	}
	return ""
}

func (m *K8SDelegationType) GetDnsMode() K8SDNSMode {
	if m != nil {
		return m.DnsMode
	}
	return CORE_DNS
}

// K8S VIP Discovery Info Type
//
// x-displayName: "VIP Publish Configurations
// K8S Configuration to publish VIPs
type K8SVipDiscoveryInfoType struct {
	// publish choice
	//
	// x-displayName: "Select VIP Publishing or DNS Delegation"
	// x-required
	// Select VIP Publishing or DNS Delegation
	//
	// Types that are valid to be assigned to PublishChoice:
	//	*K8SVipDiscoveryInfoType_Disable
	//	*K8SVipDiscoveryInfoType_Publish
	//	*K8SVipDiscoveryInfoType_PublishFqdns
	//	*K8SVipDiscoveryInfoType_DnsDelegation
	PublishChoice isK8SVipDiscoveryInfoType_PublishChoice `protobuf_oneof:"publish_choice"`
}

func (m *K8SVipDiscoveryInfoType) Reset()                    { *m = K8SVipDiscoveryInfoType{} }
func (*K8SVipDiscoveryInfoType) ProtoMessage()               {}
func (*K8SVipDiscoveryInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

type isK8SVipDiscoveryInfoType_PublishChoice interface {
	isK8SVipDiscoveryInfoType_PublishChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type K8SVipDiscoveryInfoType_Disable struct {
	Disable *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=disable,oneof"`
}
type K8SVipDiscoveryInfoType_Publish struct {
	Publish *K8SPublishType `protobuf:"bytes,3,opt,name=publish,oneof"`
}
type K8SVipDiscoveryInfoType_PublishFqdns struct {
	PublishFqdns *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=publish_fqdns,json=publishFqdns,oneof"`
}
type K8SVipDiscoveryInfoType_DnsDelegation struct {
	DnsDelegation *K8SDelegationType `protobuf:"bytes,5,opt,name=dns_delegation,json=dnsDelegation,oneof"`
}

func (*K8SVipDiscoveryInfoType_Disable) isK8SVipDiscoveryInfoType_PublishChoice()       {}
func (*K8SVipDiscoveryInfoType_Publish) isK8SVipDiscoveryInfoType_PublishChoice()       {}
func (*K8SVipDiscoveryInfoType_PublishFqdns) isK8SVipDiscoveryInfoType_PublishChoice()  {}
func (*K8SVipDiscoveryInfoType_DnsDelegation) isK8SVipDiscoveryInfoType_PublishChoice() {}

func (m *K8SVipDiscoveryInfoType) GetPublishChoice() isK8SVipDiscoveryInfoType_PublishChoice {
	if m != nil {
		return m.PublishChoice
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetDisable() *ves_io_schema4.Empty {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Disable); ok {
		return x.Disable
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetPublish() *K8SPublishType {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Publish); ok {
		return x.Publish
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetPublishFqdns() *ves_io_schema4.Empty {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_PublishFqdns); ok {
		return x.PublishFqdns
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetDnsDelegation() *K8SDelegationType {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_DnsDelegation); ok {
		return x.DnsDelegation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*K8SVipDiscoveryInfoType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _K8SVipDiscoveryInfoType_OneofMarshaler, _K8SVipDiscoveryInfoType_OneofUnmarshaler, _K8SVipDiscoveryInfoType_OneofSizer, []interface{}{
		(*K8SVipDiscoveryInfoType_Disable)(nil),
		(*K8SVipDiscoveryInfoType_Publish)(nil),
		(*K8SVipDiscoveryInfoType_PublishFqdns)(nil),
		(*K8SVipDiscoveryInfoType_DnsDelegation)(nil),
	}
}

func _K8SVipDiscoveryInfoType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*K8SVipDiscoveryInfoType)
	// publish_choice
	switch x := m.PublishChoice.(type) {
	case *K8SVipDiscoveryInfoType_Disable:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Disable); err != nil {
			return err
		}
	case *K8SVipDiscoveryInfoType_Publish:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Publish); err != nil {
			return err
		}
	case *K8SVipDiscoveryInfoType_PublishFqdns:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PublishFqdns); err != nil {
			return err
		}
	case *K8SVipDiscoveryInfoType_DnsDelegation:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsDelegation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("K8SVipDiscoveryInfoType.PublishChoice has unexpected type %T", x)
	}
	return nil
}

func _K8SVipDiscoveryInfoType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*K8SVipDiscoveryInfoType)
	switch tag {
	case 2: // publish_choice.disable
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PublishChoice = &K8SVipDiscoveryInfoType_Disable{msg}
		return true, err
	case 3: // publish_choice.publish
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(K8SPublishType)
		err := b.DecodeMessage(msg)
		m.PublishChoice = &K8SVipDiscoveryInfoType_Publish{msg}
		return true, err
	case 4: // publish_choice.publish_fqdns
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PublishChoice = &K8SVipDiscoveryInfoType_PublishFqdns{msg}
		return true, err
	case 5: // publish_choice.dns_delegation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(K8SDelegationType)
		err := b.DecodeMessage(msg)
		m.PublishChoice = &K8SVipDiscoveryInfoType_DnsDelegation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _K8SVipDiscoveryInfoType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*K8SVipDiscoveryInfoType)
	// publish_choice
	switch x := m.PublishChoice.(type) {
	case *K8SVipDiscoveryInfoType_Disable:
		s := proto.Size(x.Disable)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *K8SVipDiscoveryInfoType_Publish:
		s := proto.Size(x.Publish)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *K8SVipDiscoveryInfoType_PublishFqdns:
		s := proto.Size(x.PublishFqdns)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *K8SVipDiscoveryInfoType_DnsDelegation:
		s := proto.Size(x.DnsDelegation)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Consul VIP Discovery Info Type
//
// x-displayName: "VIP Publish Configuration"
// Consul Configuration to publish VIPs
type ConsulVipDiscoveryInfoType struct {
	// publish choice
	//
	// x-displayName: "Enable/Disable VIP Publishing"
	// x-required
	// Enable or disable VIP Publishing.
	//
	// Types that are valid to be assigned to PublishChoice:
	//	*ConsulVipDiscoveryInfoType_Disable
	//	*ConsulVipDiscoveryInfoType_Publish
	PublishChoice isConsulVipDiscoveryInfoType_PublishChoice `protobuf_oneof:"publish_choice"`
}

func (m *ConsulVipDiscoveryInfoType) Reset()      { *m = ConsulVipDiscoveryInfoType{} }
func (*ConsulVipDiscoveryInfoType) ProtoMessage() {}
func (*ConsulVipDiscoveryInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{12}
}

type isConsulVipDiscoveryInfoType_PublishChoice interface {
	isConsulVipDiscoveryInfoType_PublishChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConsulVipDiscoveryInfoType_Disable struct {
	Disable *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=disable,oneof"`
}
type ConsulVipDiscoveryInfoType_Publish struct {
	Publish *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=publish,oneof"`
}

func (*ConsulVipDiscoveryInfoType_Disable) isConsulVipDiscoveryInfoType_PublishChoice() {}
func (*ConsulVipDiscoveryInfoType_Publish) isConsulVipDiscoveryInfoType_PublishChoice() {}

func (m *ConsulVipDiscoveryInfoType) GetPublishChoice() isConsulVipDiscoveryInfoType_PublishChoice {
	if m != nil {
		return m.PublishChoice
	}
	return nil
}

func (m *ConsulVipDiscoveryInfoType) GetDisable() *ves_io_schema4.Empty {
	if x, ok := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Disable); ok {
		return x.Disable
	}
	return nil
}

func (m *ConsulVipDiscoveryInfoType) GetPublish() *ves_io_schema4.Empty {
	if x, ok := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Publish); ok {
		return x.Publish
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ConsulVipDiscoveryInfoType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ConsulVipDiscoveryInfoType_OneofMarshaler, _ConsulVipDiscoveryInfoType_OneofUnmarshaler, _ConsulVipDiscoveryInfoType_OneofSizer, []interface{}{
		(*ConsulVipDiscoveryInfoType_Disable)(nil),
		(*ConsulVipDiscoveryInfoType_Publish)(nil),
	}
}

func _ConsulVipDiscoveryInfoType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ConsulVipDiscoveryInfoType)
	// publish_choice
	switch x := m.PublishChoice.(type) {
	case *ConsulVipDiscoveryInfoType_Disable:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Disable); err != nil {
			return err
		}
	case *ConsulVipDiscoveryInfoType_Publish:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Publish); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ConsulVipDiscoveryInfoType.PublishChoice has unexpected type %T", x)
	}
	return nil
}

func _ConsulVipDiscoveryInfoType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ConsulVipDiscoveryInfoType)
	switch tag {
	case 2: // publish_choice.disable
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PublishChoice = &ConsulVipDiscoveryInfoType_Disable{msg}
		return true, err
	case 3: // publish_choice.publish
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PublishChoice = &ConsulVipDiscoveryInfoType_Publish{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ConsulVipDiscoveryInfoType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ConsulVipDiscoveryInfoType)
	// publish_choice
	switch x := m.PublishChoice.(type) {
	case *ConsulVipDiscoveryInfoType_Disable:
		s := proto.Size(x.Disable)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConsulVipDiscoveryInfoType_Publish:
		s := proto.Size(x.Publish)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// K8s discovery type
//
// x-displayName: "K8S Discovery Configuration"
// Discovery configuration for K8s.
type K8SDiscoveryType struct {
	// Kubernetes Credentials
	//
	// x-displayName: "Access Credentials"
	// x-required
	// Credentials can be kubeconfig file or mutual TLS using PKI certificates
	AccessInfo *K8SAccessInfo `protobuf:"bytes,1,opt,name=access_info,json=accessInfo" json:"access_info,omitempty"`
	// publish info
	//
	// x-displayName: "VIP Publishing Configuration"
	// x-required
	// Configuration to publish VIPs
	PublishInfo *K8SVipDiscoveryInfoType `protobuf:"bytes,2,opt,name=publish_info,json=publishInfo" json:"publish_info,omitempty"`
}

func (m *K8SDiscoveryType) Reset()                    { *m = K8SDiscoveryType{} }
func (*K8SDiscoveryType) ProtoMessage()               {}
func (*K8SDiscoveryType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *K8SDiscoveryType) GetAccessInfo() *K8SAccessInfo {
	if m != nil {
		return m.AccessInfo
	}
	return nil
}

func (m *K8SDiscoveryType) GetPublishInfo() *K8SVipDiscoveryInfoType {
	if m != nil {
		return m.PublishInfo
	}
	return nil
}

// consul discovery type
//
// x-displayName: "Consul Discovery Configuration"
// Discovery configuration for Hashicorp Consul
type ConsulDiscoveryType struct {
	// Hashicorp Consul Credentials
	//
	// x-displayName: "Access Credentials"
	// x-required
	// Credentials to access Hashicorp Consul service discovery
	AccessInfo *ConsulAccessInfo `protobuf:"bytes,1,opt,name=access_info,json=accessInfo" json:"access_info,omitempty"`
	// publish info
	//
	// x-displayName: "VIP Publishing Configuration"
	// x-required
	// Configuration to publish VIPs
	PublishInfo *ConsulVipDiscoveryInfoType `protobuf:"bytes,2,opt,name=publish_info,json=publishInfo" json:"publish_info,omitempty"`
}

func (m *ConsulDiscoveryType) Reset()                    { *m = ConsulDiscoveryType{} }
func (*ConsulDiscoveryType) ProtoMessage()               {}
func (*ConsulDiscoveryType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *ConsulDiscoveryType) GetAccessInfo() *ConsulAccessInfo {
	if m != nil {
		return m.AccessInfo
	}
	return nil
}

func (m *ConsulDiscoveryType) GetPublishInfo() *ConsulVipDiscoveryInfoType {
	if m != nil {
		return m.PublishInfo
	}
	return nil
}

// Specification for discovery
//
// x-displayName: "Specification"
// Desired state of discovery
type GlobalSpecType struct {
	// Where
	//
	// x-displayName: "Select Site, Virtual Site or Network"
	// x-required
	// All the sites where this discovery config is valid.
	Where *ves_io_schema4.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	// discovery choice
	//
	// x-displayName: "Select Discovery Method"
	// x-required
	// Select discovery method as K8S or Hashicorp Consul
	//
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*GlobalSpecType_DiscoveryK8S
	//	*GlobalSpecType_DiscoveryConsul
	DiscoveryChoice isGlobalSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
	// Discovery type
	//
	// x-displayName: "Type of Discovery"
	// x-required
	// Type of discovery K8s or consul
	Type ves_io_schema4.DiscoveryType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.DiscoveryType" json:"type,omitempty"`
	// VIP publish
	//
	// x-displayName: "VIP Publishing configuration"
	// Configuration to publish VIP(s) in to a discovery service.
	PublishVip *VipDiscoveryInfoType `protobuf:"bytes,3,opt,name=publish_vip,json=publishVip" json:"publish_vip,omitempty"`
	// Access Info
	//
	// x-displayName: "Select How Endpoints are Discovered"
	// Endpoints can be discovered from Kubernetes service configuration or Consul
	//
	// Types that are valid to be assigned to AccessInfo:
	//	*GlobalSpecType_K8S
	//	*GlobalSpecType_Consul
	AccessInfo isGlobalSpecType_AccessInfo `protobuf_oneof:"access_info"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

type isGlobalSpecType_DiscoveryChoice interface {
	isGlobalSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_AccessInfo interface {
	isGlobalSpecType_AccessInfo()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,oneof"`
}
type GlobalSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,oneof"`
}
type GlobalSpecType_K8S struct {
	K8S *K8SAccessInfo `protobuf:"bytes,4,opt,name=k8s,oneof"`
}
type GlobalSpecType_Consul struct {
	Consul *ConsulAccessInfo `protobuf:"bytes,5,opt,name=consul,oneof"`
}

func (*GlobalSpecType_DiscoveryK8S) isGlobalSpecType_DiscoveryChoice()    {}
func (*GlobalSpecType_DiscoveryConsul) isGlobalSpecType_DiscoveryChoice() {}
func (*GlobalSpecType_K8S) isGlobalSpecType_AccessInfo()                  {}
func (*GlobalSpecType_Consul) isGlobalSpecType_AccessInfo()               {}

func (m *GlobalSpecType) GetDiscoveryChoice() isGlobalSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}
func (m *GlobalSpecType) GetAccessInfo() isGlobalSpecType_AccessInfo {
	if m != nil {
		return m.AccessInfo
	}
	return nil
}

func (m *GlobalSpecType) GetWhere() *ves_io_schema4.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GlobalSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *GlobalSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

func (m *GlobalSpecType) GetType() ves_io_schema4.DiscoveryType {
	if m != nil {
		return m.Type
	}
	return ves_io_schema4.INVALID_DISCOVERY
}

func (m *GlobalSpecType) GetPublishVip() *VipDiscoveryInfoType {
	if m != nil {
		return m.PublishVip
	}
	return nil
}

func (m *GlobalSpecType) GetK8S() *K8SAccessInfo {
	if x, ok := m.GetAccessInfo().(*GlobalSpecType_K8S); ok {
		return x.K8S
	}
	return nil
}

func (m *GlobalSpecType) GetConsul() *ConsulAccessInfo {
	if x, ok := m.GetAccessInfo().(*GlobalSpecType_Consul); ok {
		return x.Consul
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_DiscoveryK8S)(nil),
		(*GlobalSpecType_DiscoveryConsul)(nil),
		(*GlobalSpecType_K8S)(nil),
		(*GlobalSpecType_Consul)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// discovery_choice
	switch x := m.DiscoveryChoice.(type) {
	case *GlobalSpecType_DiscoveryK8S:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiscoveryK8S); err != nil {
			return err
		}
	case *GlobalSpecType_DiscoveryConsul:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiscoveryConsul); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.DiscoveryChoice has unexpected type %T", x)
	}
	// access_info
	switch x := m.AccessInfo.(type) {
	case *GlobalSpecType_K8S:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.K8S); err != nil {
			return err
		}
	case *GlobalSpecType_Consul:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Consul); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.AccessInfo has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 8: // discovery_choice.discovery_k8s
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(K8SDiscoveryType)
		err := b.DecodeMessage(msg)
		m.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{msg}
		return true, err
	case 9: // discovery_choice.discovery_consul
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConsulDiscoveryType)
		err := b.DecodeMessage(msg)
		m.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{msg}
		return true, err
	case 4: // access_info.k8s
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(K8SAccessInfo)
		err := b.DecodeMessage(msg)
		m.AccessInfo = &GlobalSpecType_K8S{msg}
		return true, err
	case 5: // access_info.consul
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConsulAccessInfo)
		err := b.DecodeMessage(msg)
		m.AccessInfo = &GlobalSpecType_Consul{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// discovery_choice
	switch x := m.DiscoveryChoice.(type) {
	case *GlobalSpecType_DiscoveryK8S:
		s := proto.Size(x.DiscoveryK8S)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_DiscoveryConsul:
		s := proto.Size(x.DiscoveryConsul)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// access_info
	switch x := m.AccessInfo.(type) {
	case *GlobalSpecType_K8S:
		s := proto.Size(x.K8S)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_Consul:
		s := proto.Size(x.Consul)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create discovery
//
// x-displayName: "Create Discovery"
// API to create discovery object for a site or virtual site in system namespace
type CreateSpecType struct {
	Where *ves_io_schema4.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*CreateSpecType_DiscoveryK8S
	//	*CreateSpecType_DiscoveryConsul
	DiscoveryChoice isCreateSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

type isCreateSpecType_DiscoveryChoice interface {
	isCreateSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,oneof"`
}
type CreateSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,oneof"`
}

func (*CreateSpecType_DiscoveryK8S) isCreateSpecType_DiscoveryChoice()    {}
func (*CreateSpecType_DiscoveryConsul) isCreateSpecType_DiscoveryChoice() {}

func (m *CreateSpecType) GetDiscoveryChoice() isCreateSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}

func (m *CreateSpecType) GetWhere() *ves_io_schema4.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *CreateSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *CreateSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_DiscoveryK8S)(nil),
		(*CreateSpecType_DiscoveryConsul)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// discovery_choice
	switch x := m.DiscoveryChoice.(type) {
	case *CreateSpecType_DiscoveryK8S:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiscoveryK8S); err != nil {
			return err
		}
	case *CreateSpecType_DiscoveryConsul:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiscoveryConsul); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.DiscoveryChoice has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 8: // discovery_choice.discovery_k8s
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(K8SDiscoveryType)
		err := b.DecodeMessage(msg)
		m.DiscoveryChoice = &CreateSpecType_DiscoveryK8S{msg}
		return true, err
	case 9: // discovery_choice.discovery_consul
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConsulDiscoveryType)
		err := b.DecodeMessage(msg)
		m.DiscoveryChoice = &CreateSpecType_DiscoveryConsul{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// discovery_choice
	switch x := m.DiscoveryChoice.(type) {
	case *CreateSpecType_DiscoveryK8S:
		s := proto.Size(x.DiscoveryK8S)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DiscoveryConsul:
		s := proto.Size(x.DiscoveryConsul)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace discovery
//
// x-displayName: "Replace Discovery"
// API to replace discovery object for a site or virtual site in system namespace
type ReplaceSpecType struct {
	Where *ves_io_schema4.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*ReplaceSpecType_DiscoveryK8S
	//	*ReplaceSpecType_DiscoveryConsul
	DiscoveryChoice isReplaceSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

type isReplaceSpecType_DiscoveryChoice interface {
	isReplaceSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,oneof"`
}
type ReplaceSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,oneof"`
}

func (*ReplaceSpecType_DiscoveryK8S) isReplaceSpecType_DiscoveryChoice()    {}
func (*ReplaceSpecType_DiscoveryConsul) isReplaceSpecType_DiscoveryChoice() {}

func (m *ReplaceSpecType) GetDiscoveryChoice() isReplaceSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetWhere() *ves_io_schema4.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *ReplaceSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *ReplaceSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_DiscoveryK8S)(nil),
		(*ReplaceSpecType_DiscoveryConsul)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// discovery_choice
	switch x := m.DiscoveryChoice.(type) {
	case *ReplaceSpecType_DiscoveryK8S:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiscoveryK8S); err != nil {
			return err
		}
	case *ReplaceSpecType_DiscoveryConsul:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiscoveryConsul); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.DiscoveryChoice has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 8: // discovery_choice.discovery_k8s
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(K8SDiscoveryType)
		err := b.DecodeMessage(msg)
		m.DiscoveryChoice = &ReplaceSpecType_DiscoveryK8S{msg}
		return true, err
	case 9: // discovery_choice.discovery_consul
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConsulDiscoveryType)
		err := b.DecodeMessage(msg)
		m.DiscoveryChoice = &ReplaceSpecType_DiscoveryConsul{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// discovery_choice
	switch x := m.DiscoveryChoice.(type) {
	case *ReplaceSpecType_DiscoveryK8S:
		s := proto.Size(x.DiscoveryK8S)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DiscoveryConsul:
		s := proto.Size(x.DiscoveryConsul)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get discovery
//
// x-displayName: "Get Discovery"
// API to Get discovery object for a site or virtual site in system namespace
type GetSpecType struct {
	Where      *ves_io_schema4.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	Type       ves_io_schema4.DiscoveryType           `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.DiscoveryType" json:"type,omitempty"`
	PublishVip *VipDiscoveryInfoType                  `protobuf:"bytes,3,opt,name=publish_vip,json=publishVip" json:"publish_vip,omitempty"`
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*GetSpecType_DiscoveryK8S
	//	*GetSpecType_DiscoveryConsul
	DiscoveryChoice isGetSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

type isGetSpecType_DiscoveryChoice interface {
	isGetSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,oneof"`
}
type GetSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,oneof"`
}

func (*GetSpecType_DiscoveryK8S) isGetSpecType_DiscoveryChoice()    {}
func (*GetSpecType_DiscoveryConsul) isGetSpecType_DiscoveryChoice() {}

func (m *GetSpecType) GetDiscoveryChoice() isGetSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}

func (m *GetSpecType) GetWhere() *ves_io_schema4.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GetSpecType) GetType() ves_io_schema4.DiscoveryType {
	if m != nil {
		return m.Type
	}
	return ves_io_schema4.INVALID_DISCOVERY
}

func (m *GetSpecType) GetPublishVip() *VipDiscoveryInfoType {
	if m != nil {
		return m.PublishVip
	}
	return nil
}

func (m *GetSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *GetSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_DiscoveryK8S)(nil),
		(*GetSpecType_DiscoveryConsul)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// discovery_choice
	switch x := m.DiscoveryChoice.(type) {
	case *GetSpecType_DiscoveryK8S:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiscoveryK8S); err != nil {
			return err
		}
	case *GetSpecType_DiscoveryConsul:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiscoveryConsul); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.DiscoveryChoice has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 8: // discovery_choice.discovery_k8s
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(K8SDiscoveryType)
		err := b.DecodeMessage(msg)
		m.DiscoveryChoice = &GetSpecType_DiscoveryK8S{msg}
		return true, err
	case 9: // discovery_choice.discovery_consul
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConsulDiscoveryType)
		err := b.DecodeMessage(msg)
		m.DiscoveryChoice = &GetSpecType_DiscoveryConsul{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// discovery_choice
	switch x := m.DiscoveryChoice.(type) {
	case *GetSpecType_DiscoveryK8S:
		s := proto.Size(x.DiscoveryK8S)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DiscoveryConsul:
		s := proto.Size(x.DiscoveryConsul)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.discovery.VerStatusType")
	golang_proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.discovery.VerStatusType")
	proto.RegisterType((*PodInfoType)(nil), "ves.io.schema.discovery.PodInfoType")
	golang_proto.RegisterType((*PodInfoType)(nil), "ves.io.schema.discovery.PodInfoType")
	proto.RegisterType((*DiscoveredServiceType)(nil), "ves.io.schema.discovery.DiscoveredServiceType")
	golang_proto.RegisterType((*DiscoveredServiceType)(nil), "ves.io.schema.discovery.DiscoveredServiceType")
	proto.RegisterType((*TLSClientConfigType)(nil), "ves.io.schema.discovery.TLSClientConfigType")
	golang_proto.RegisterType((*TLSClientConfigType)(nil), "ves.io.schema.discovery.TLSClientConfigType")
	proto.RegisterType((*RestConfigType)(nil), "ves.io.schema.discovery.RestConfigType")
	golang_proto.RegisterType((*RestConfigType)(nil), "ves.io.schema.discovery.RestConfigType")
	proto.RegisterType((*K8SAccessInfo)(nil), "ves.io.schema.discovery.K8SAccessInfo")
	golang_proto.RegisterType((*K8SAccessInfo)(nil), "ves.io.schema.discovery.K8SAccessInfo")
	proto.RegisterType((*ConsulHttpBasicAuthInfoType)(nil), "ves.io.schema.discovery.ConsulHttpBasicAuthInfoType")
	golang_proto.RegisterType((*ConsulHttpBasicAuthInfoType)(nil), "ves.io.schema.discovery.ConsulHttpBasicAuthInfoType")
	proto.RegisterType((*ConsulAccessInfo)(nil), "ves.io.schema.discovery.ConsulAccessInfo")
	golang_proto.RegisterType((*ConsulAccessInfo)(nil), "ves.io.schema.discovery.ConsulAccessInfo")
	proto.RegisterType((*VipDiscoveryInfoType)(nil), "ves.io.schema.discovery.VipDiscoveryInfoType")
	golang_proto.RegisterType((*VipDiscoveryInfoType)(nil), "ves.io.schema.discovery.VipDiscoveryInfoType")
	proto.RegisterType((*K8SPublishType)(nil), "ves.io.schema.discovery.K8SPublishType")
	golang_proto.RegisterType((*K8SPublishType)(nil), "ves.io.schema.discovery.K8SPublishType")
	proto.RegisterType((*K8SDelegationType)(nil), "ves.io.schema.discovery.K8SDelegationType")
	golang_proto.RegisterType((*K8SDelegationType)(nil), "ves.io.schema.discovery.K8SDelegationType")
	proto.RegisterType((*K8SVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.K8SVipDiscoveryInfoType")
	golang_proto.RegisterType((*K8SVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.K8SVipDiscoveryInfoType")
	proto.RegisterType((*ConsulVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.ConsulVipDiscoveryInfoType")
	golang_proto.RegisterType((*ConsulVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.ConsulVipDiscoveryInfoType")
	proto.RegisterType((*K8SDiscoveryType)(nil), "ves.io.schema.discovery.K8SDiscoveryType")
	golang_proto.RegisterType((*K8SDiscoveryType)(nil), "ves.io.schema.discovery.K8SDiscoveryType")
	proto.RegisterType((*ConsulDiscoveryType)(nil), "ves.io.schema.discovery.ConsulDiscoveryType")
	golang_proto.RegisterType((*ConsulDiscoveryType)(nil), "ves.io.schema.discovery.ConsulDiscoveryType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.discovery.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.discovery.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.discovery.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.discovery.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.discovery.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.discovery.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.discovery.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.discovery.GetSpecType")
	proto.RegisterEnum("ves.io.schema.discovery.SchemeType", SchemeType_name, SchemeType_value)
	golang_proto.RegisterEnum("ves.io.schema.discovery.SchemeType", SchemeType_name, SchemeType_value)
	proto.RegisterEnum("ves.io.schema.discovery.VirtualIPDiscoveryType", VirtualIPDiscoveryType_name, VirtualIPDiscoveryType_value)
	golang_proto.RegisterEnum("ves.io.schema.discovery.VirtualIPDiscoveryType", VirtualIPDiscoveryType_name, VirtualIPDiscoveryType_value)
	proto.RegisterEnum("ves.io.schema.discovery.K8SDNSMode", K8SDNSMode_name, K8SDNSMode_value)
	golang_proto.RegisterEnum("ves.io.schema.discovery.K8SDNSMode", K8SDNSMode_name, K8SDNSMode_value)
}
func (x SchemeType) String() string {
	s, ok := SchemeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VirtualIPDiscoveryType) String() string {
	s, ok := VirtualIPDiscoveryType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x K8SDNSMode) String() string {
	s, ok := K8SDNSMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *VerStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerStatusType)
	if !ok {
		that2, ok := that.(VerStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Connected != that1.Connected {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Services) != len(that1.Services) {
		return false
	}
	for i := range this.Services {
		if !this.Services[i].Equal(that1.Services[i]) {
			return false
		}
	}
	return true
}
func (this *PodInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodInfoType)
	if !ok {
		that2, ok := that.(PodInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodName != that1.PodName {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *DiscoveredServiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredServiceType)
	if !ok {
		that2, ok := that.(DiscoveredServiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ServiceType != that1.ServiceType {
		return false
	}
	if this.ClusterIp != that1.ClusterIp {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Pods) != len(that1.Pods) {
		return false
	}
	for i := range this.Pods {
		if !this.Pods[i].Equal(that1.Pods[i]) {
			return false
		}
	}
	if len(this.PortMap) != len(that1.PortMap) {
		return false
	}
	for i := range this.PortMap {
		if this.PortMap[i] != that1.PortMap[i] {
			return false
		}
	}
	return true
}
func (this *TLSClientConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TLSClientConfigType)
	if !ok {
		that2, ok := that.(TLSClientConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	if !this.CertificateUrl.Equal(that1.CertificateUrl) {
		return false
	}
	if this.Certificate != that1.Certificate {
		return false
	}
	if !this.KeyUrl.Equal(that1.KeyUrl) {
		return false
	}
	if !this.CaCertificateUrl.Equal(that1.CaCertificateUrl) {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *RestConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestConfigType)
	if !ok {
		that2, ok := that.(RestConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiServer != that1.ApiServer {
		return false
	}
	if !this.TlsInfo.Equal(that1.TlsInfo) {
		return false
	}
	return true
}
func (this *K8SAccessInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo)
	if !ok {
		that2, ok := that.(K8SAccessInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigType == nil {
		if this.ConfigType != nil {
			return false
		}
	} else if this.ConfigType == nil {
		return false
	} else if !this.ConfigType.Equal(that1.ConfigType) {
		return false
	}
	if that1.K8SPodNetworkChoice == nil {
		if this.K8SPodNetworkChoice != nil {
			return false
		}
	} else if this.K8SPodNetworkChoice == nil {
		return false
	} else if !this.K8SPodNetworkChoice.Equal(that1.K8SPodNetworkChoice) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_KubeconfigUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_KubeconfigUrl)
	if !ok {
		that2, ok := that.(K8SAccessInfo_KubeconfigUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.KubeconfigUrl.Equal(that1.KubeconfigUrl) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_ConnectionInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_ConnectionInfo)
	if !ok {
		that2, ok := that.(K8SAccessInfo_ConnectionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectionInfo.Equal(that1.ConnectionInfo) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_InCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_InCluster)
	if !ok {
		that2, ok := that.(K8SAccessInfo_InCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InCluster != that1.InCluster {
		return false
	}
	return true
}
func (this *K8SAccessInfo_Isolated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_Isolated)
	if !ok {
		that2, ok := that.(K8SAccessInfo_Isolated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Isolated.Equal(that1.Isolated) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_Reachable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_Reachable)
	if !ok {
		that2, ok := that.(K8SAccessInfo_Reachable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Reachable.Equal(that1.Reachable) {
		return false
	}
	return true
}
func (this *ConsulHttpBasicAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulHttpBasicAuthInfoType)
	if !ok {
		that2, ok := that.(ConsulHttpBasicAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if !this.PasswdUrl.Equal(that1.PasswdUrl) {
		return false
	}
	return true
}
func (this *ConsulAccessInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulAccessInfo)
	if !ok {
		that2, ok := that.(ConsulAccessInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectionInfo.Equal(that1.ConnectionInfo) {
		return false
	}
	if this.Scheme != that1.Scheme {
		return false
	}
	if !this.HttpBasicAuthInfo.Equal(that1.HttpBasicAuthInfo) {
		return false
	}
	return true
}
func (this *VipDiscoveryInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VipDiscoveryInfoType)
	if !ok {
		that2, ok := that.(VipDiscoveryInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PublishVirtualIp != that1.PublishVirtualIp {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Subdomain != that1.Subdomain {
		return false
	}
	if this.DnsMode != that1.DnsMode {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *K8SPublishType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SPublishType)
	if !ok {
		that2, ok := that.(K8SPublishType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *K8SDelegationType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SDelegationType)
	if !ok {
		that2, ok := that.(K8SDelegationType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Subdomain != that1.Subdomain {
		return false
	}
	if this.DnsMode != that1.DnsMode {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PublishChoice == nil {
		if this.PublishChoice != nil {
			return false
		}
	} else if this.PublishChoice == nil {
		return false
	} else if !this.PublishChoice.Equal(that1.PublishChoice) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_Disable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_Disable)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_Disable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disable.Equal(that1.Disable) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_Publish) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_Publish)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_Publish)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Publish.Equal(that1.Publish) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_PublishFqdns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_PublishFqdns)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_PublishFqdns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PublishFqdns.Equal(that1.PublishFqdns) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_DnsDelegation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_DnsDelegation)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_DnsDelegation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsDelegation.Equal(that1.DnsDelegation) {
		return false
	}
	return true
}
func (this *ConsulVipDiscoveryInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulVipDiscoveryInfoType)
	if !ok {
		that2, ok := that.(ConsulVipDiscoveryInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PublishChoice == nil {
		if this.PublishChoice != nil {
			return false
		}
	} else if this.PublishChoice == nil {
		return false
	} else if !this.PublishChoice.Equal(that1.PublishChoice) {
		return false
	}
	return true
}
func (this *ConsulVipDiscoveryInfoType_Disable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulVipDiscoveryInfoType_Disable)
	if !ok {
		that2, ok := that.(ConsulVipDiscoveryInfoType_Disable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disable.Equal(that1.Disable) {
		return false
	}
	return true
}
func (this *ConsulVipDiscoveryInfoType_Publish) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulVipDiscoveryInfoType_Publish)
	if !ok {
		that2, ok := that.(ConsulVipDiscoveryInfoType_Publish)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Publish.Equal(that1.Publish) {
		return false
	}
	return true
}
func (this *K8SDiscoveryType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SDiscoveryType)
	if !ok {
		that2, ok := that.(K8SDiscoveryType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessInfo.Equal(that1.AccessInfo) {
		return false
	}
	if !this.PublishInfo.Equal(that1.PublishInfo) {
		return false
	}
	return true
}
func (this *ConsulDiscoveryType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulDiscoveryType)
	if !ok {
		that2, ok := that.(ConsulDiscoveryType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessInfo.Equal(that1.AccessInfo) {
		return false
	}
	if !this.PublishInfo.Equal(that1.PublishInfo) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.PublishVip.Equal(that1.PublishVip) {
		return false
	}
	if that1.AccessInfo == nil {
		if this.AccessInfo != nil {
			return false
		}
	} else if this.AccessInfo == nil {
		return false
	} else if !this.AccessInfo.Equal(that1.AccessInfo) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(GlobalSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(GlobalSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *GlobalSpecType_K8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_K8S)
	if !ok {
		that2, ok := that.(GlobalSpecType_K8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.K8S.Equal(that1.K8S) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Consul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Consul)
	if !ok {
		that2, ok := that.(GlobalSpecType_Consul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Consul.Equal(that1.Consul) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(CreateSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *CreateSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(CreateSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.PublishVip.Equal(that1.PublishVip) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(GetSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *GetSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(GetSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *VerStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&discovery.VerStatusType{")
	s = append(s, "Connected: "+fmt.Sprintf("%#v", this.Connected)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Services != nil {
		s = append(s, "Services: "+fmt.Sprintf("%#v", this.Services)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.PodInfoType{")
	s = append(s, "PodName: "+fmt.Sprintf("%#v", this.PodName)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoveredServiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&discovery.DiscoveredServiceType{")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ServiceType: "+fmt.Sprintf("%#v", this.ServiceType)+",\n")
	s = append(s, "ClusterIp: "+fmt.Sprintf("%#v", this.ClusterIp)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.Pods != nil {
		s = append(s, "Pods: "+fmt.Sprintf("%#v", this.Pods)+",\n")
	}
	keysForPortMap := make([]uint32, 0, len(this.PortMap))
	for k, _ := range this.PortMap {
		keysForPortMap = append(keysForPortMap, k)
	}
	sortkeys.Uint32s(keysForPortMap)
	mapStringForPortMap := "map[uint32]uint32{"
	for _, k := range keysForPortMap {
		mapStringForPortMap += fmt.Sprintf("%#v: %#v,", k, this.PortMap[k])
	}
	mapStringForPortMap += "}"
	if this.PortMap != nil {
		s = append(s, "PortMap: "+mapStringForPortMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSClientConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&discovery.TLSClientConfigType{")
	s = append(s, "ServerName: "+fmt.Sprintf("%#v", this.ServerName)+",\n")
	if this.CertificateUrl != nil {
		s = append(s, "CertificateUrl: "+fmt.Sprintf("%#v", this.CertificateUrl)+",\n")
	}
	s = append(s, "Certificate: "+fmt.Sprintf("%#v", this.Certificate)+",\n")
	if this.KeyUrl != nil {
		s = append(s, "KeyUrl: "+fmt.Sprintf("%#v", this.KeyUrl)+",\n")
	}
	if this.CaCertificateUrl != nil {
		s = append(s, "CaCertificateUrl: "+fmt.Sprintf("%#v", this.CaCertificateUrl)+",\n")
	}
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RestConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.RestConfigType{")
	s = append(s, "ApiServer: "+fmt.Sprintf("%#v", this.ApiServer)+",\n")
	if this.TlsInfo != nil {
		s = append(s, "TlsInfo: "+fmt.Sprintf("%#v", this.TlsInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SAccessInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.K8SAccessInfo{")
	if this.ConfigType != nil {
		s = append(s, "ConfigType: "+fmt.Sprintf("%#v", this.ConfigType)+",\n")
	}
	if this.K8SPodNetworkChoice != nil {
		s = append(s, "K8SPodNetworkChoice: "+fmt.Sprintf("%#v", this.K8SPodNetworkChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SAccessInfo_KubeconfigUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_KubeconfigUrl{` +
		`KubeconfigUrl:` + fmt.Sprintf("%#v", this.KubeconfigUrl) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_ConnectionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_ConnectionInfo{` +
		`ConnectionInfo:` + fmt.Sprintf("%#v", this.ConnectionInfo) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_InCluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_InCluster{` +
		`InCluster:` + fmt.Sprintf("%#v", this.InCluster) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_Isolated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_Isolated{` +
		`Isolated:` + fmt.Sprintf("%#v", this.Isolated) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_Reachable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_Reachable{` +
		`Reachable:` + fmt.Sprintf("%#v", this.Reachable) + `}`}, ", ")
	return s
}
func (this *ConsulHttpBasicAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.ConsulHttpBasicAuthInfoType{")
	s = append(s, "UserName: "+fmt.Sprintf("%#v", this.UserName)+",\n")
	if this.PasswdUrl != nil {
		s = append(s, "PasswdUrl: "+fmt.Sprintf("%#v", this.PasswdUrl)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulAccessInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&discovery.ConsulAccessInfo{")
	if this.ConnectionInfo != nil {
		s = append(s, "ConnectionInfo: "+fmt.Sprintf("%#v", this.ConnectionInfo)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.HttpBasicAuthInfo != nil {
		s = append(s, "HttpBasicAuthInfo: "+fmt.Sprintf("%#v", this.HttpBasicAuthInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VipDiscoveryInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.VipDiscoveryInfoType{")
	s = append(s, "PublishVirtualIp: "+fmt.Sprintf("%#v", this.PublishVirtualIp)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Subdomain: "+fmt.Sprintf("%#v", this.Subdomain)+",\n")
	s = append(s, "DnsMode: "+fmt.Sprintf("%#v", this.DnsMode)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SPublishType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&discovery.K8SPublishType{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SDelegationType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.K8SDelegationType{")
	s = append(s, "Subdomain: "+fmt.Sprintf("%#v", this.Subdomain)+",\n")
	s = append(s, "DnsMode: "+fmt.Sprintf("%#v", this.DnsMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SVipDiscoveryInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&discovery.K8SVipDiscoveryInfoType{")
	if this.PublishChoice != nil {
		s = append(s, "PublishChoice: "+fmt.Sprintf("%#v", this.PublishChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SVipDiscoveryInfoType_Disable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_Disable{` +
		`Disable:` + fmt.Sprintf("%#v", this.Disable) + `}`}, ", ")
	return s
}
func (this *K8SVipDiscoveryInfoType_Publish) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_Publish{` +
		`Publish:` + fmt.Sprintf("%#v", this.Publish) + `}`}, ", ")
	return s
}
func (this *K8SVipDiscoveryInfoType_PublishFqdns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_PublishFqdns{` +
		`PublishFqdns:` + fmt.Sprintf("%#v", this.PublishFqdns) + `}`}, ", ")
	return s
}
func (this *K8SVipDiscoveryInfoType_DnsDelegation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_DnsDelegation{` +
		`DnsDelegation:` + fmt.Sprintf("%#v", this.DnsDelegation) + `}`}, ", ")
	return s
}
func (this *ConsulVipDiscoveryInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.ConsulVipDiscoveryInfoType{")
	if this.PublishChoice != nil {
		s = append(s, "PublishChoice: "+fmt.Sprintf("%#v", this.PublishChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulVipDiscoveryInfoType_Disable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ConsulVipDiscoveryInfoType_Disable{` +
		`Disable:` + fmt.Sprintf("%#v", this.Disable) + `}`}, ", ")
	return s
}
func (this *ConsulVipDiscoveryInfoType_Publish) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ConsulVipDiscoveryInfoType_Publish{` +
		`Publish:` + fmt.Sprintf("%#v", this.Publish) + `}`}, ", ")
	return s
}
func (this *K8SDiscoveryType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.K8SDiscoveryType{")
	if this.AccessInfo != nil {
		s = append(s, "AccessInfo: "+fmt.Sprintf("%#v", this.AccessInfo)+",\n")
	}
	if this.PublishInfo != nil {
		s = append(s, "PublishInfo: "+fmt.Sprintf("%#v", this.PublishInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulDiscoveryType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.ConsulDiscoveryType{")
	if this.AccessInfo != nil {
		s = append(s, "AccessInfo: "+fmt.Sprintf("%#v", this.AccessInfo)+",\n")
	}
	if this.PublishInfo != nil {
		s = append(s, "PublishInfo: "+fmt.Sprintf("%#v", this.PublishInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&discovery.GlobalSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.PublishVip != nil {
		s = append(s, "PublishVip: "+fmt.Sprintf("%#v", this.PublishVip)+",\n")
	}
	if this.AccessInfo != nil {
		s = append(s, "AccessInfo: "+fmt.Sprintf("%#v", this.AccessInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_K8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_K8S{` +
		`K8S:` + fmt.Sprintf("%#v", this.K8S) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Consul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_Consul{` +
		`Consul:` + fmt.Sprintf("%#v", this.Consul) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&discovery.CreateSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&discovery.ReplaceSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.GetSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.PublishVip != nil {
		s = append(s, "PublishVip: "+fmt.Sprintf("%#v", this.PublishVip)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *VerStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerStatusType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Connected {
		dAtA[i] = 0x8
		i++
		if m.Connected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Site) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i += copy(dAtA[i:], m.Site)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PodInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PodName)))
		i += copy(dAtA[i:], m.PodName)
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	return i, nil
}

func (m *DiscoveredServiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveredServiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.ServiceType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceType)))
		i += copy(dAtA[i:], m.ServiceType)
	}
	if len(m.ClusterIp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterIp)))
		i += copy(dAtA[i:], m.ClusterIp)
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x2a
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Pods) > 0 {
		for _, msg := range m.Pods {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PortMap) > 0 {
		keysForPortMap := make([]uint32, 0, len(m.PortMap))
		for k, _ := range m.PortMap {
			keysForPortMap = append(keysForPortMap, uint32(k))
		}
		sortkeys.Uint32s(keysForPortMap)
		for _, k := range keysForPortMap {
			dAtA[i] = 0x3a
			i++
			v := m.PortMap[uint32(k)]
			mapSize := 1 + sovTypes(uint64(k)) + 1 + sovTypes(uint64(v))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTypes(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *TLSClientConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSClientConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if m.CertificateUrl != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CertificateUrl.Size()))
		n1, err := m.CertificateUrl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.KeyUrl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.KeyUrl.Size()))
		n2, err := m.KeyUrl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CaCertificateUrl != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CaCertificateUrl.Size()))
		n3, err := m.CaCertificateUrl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Certificate) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Certificate)))
		i += copy(dAtA[i:], m.Certificate)
	}
	if len(m.TrustedCaUrl) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i += copy(dAtA[i:], m.TrustedCaUrl)
	}
	return i, nil
}

func (m *RestConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiServer) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiServer)))
		i += copy(dAtA[i:], m.ApiServer)
	}
	if m.TlsInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsInfo.Size()))
		n4, err := m.TlsInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *K8SAccessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SAccessInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigType != nil {
		nn5, err := m.ConfigType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.K8SPodNetworkChoice != nil {
		nn6, err := m.K8SPodNetworkChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	return i, nil
}

func (m *K8SAccessInfo_KubeconfigUrl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.KubeconfigUrl != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.KubeconfigUrl.Size()))
		n7, err := m.KubeconfigUrl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *K8SAccessInfo_ConnectionInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ConnectionInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionInfo.Size()))
		n8, err := m.ConnectionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *K8SAccessInfo_InCluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	if m.InCluster {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *K8SAccessInfo_Isolated) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Isolated != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Isolated.Size()))
		n9, err := m.Isolated.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *K8SAccessInfo_Reachable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Reachable != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Reachable.Size()))
		n10, err := m.Reachable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *ConsulHttpBasicAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulHttpBasicAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.PasswdUrl != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PasswdUrl.Size()))
		n11, err := m.PasswdUrl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *ConsulAccessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulAccessInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConnectionInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionInfo.Size()))
		n12, err := m.ConnectionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Scheme != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Scheme))
	}
	if m.HttpBasicAuthInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpBasicAuthInfo.Size()))
		n13, err := m.HttpBasicAuthInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *VipDiscoveryInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipDiscoveryInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublishVirtualIp {
		dAtA[i] = 0x8
		i++
		if m.PublishVirtualIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if len(m.Subdomain) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subdomain)))
		i += copy(dAtA[i:], m.Subdomain)
	}
	if m.DnsMode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsMode))
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	return i, nil
}

func (m *K8SPublishType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SPublishType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	return i, nil
}

func (m *K8SDelegationType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SDelegationType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subdomain) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subdomain)))
		i += copy(dAtA[i:], m.Subdomain)
	}
	if m.DnsMode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsMode))
	}
	return i, nil
}

func (m *K8SVipDiscoveryInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SVipDiscoveryInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublishChoice != nil {
		nn14, err := m.PublishChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	return i, nil
}

func (m *K8SVipDiscoveryInfoType_Disable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Disable != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Disable.Size()))
		n15, err := m.Disable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *K8SVipDiscoveryInfoType_Publish) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Publish != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Publish.Size()))
		n16, err := m.Publish.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *K8SVipDiscoveryInfoType_PublishFqdns) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PublishFqdns != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PublishFqdns.Size()))
		n17, err := m.PublishFqdns.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *K8SVipDiscoveryInfoType_DnsDelegation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DnsDelegation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsDelegation.Size()))
		n18, err := m.DnsDelegation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *ConsulVipDiscoveryInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulVipDiscoveryInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublishChoice != nil {
		nn19, err := m.PublishChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn19
	}
	return i, nil
}

func (m *ConsulVipDiscoveryInfoType_Disable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Disable != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Disable.Size()))
		n20, err := m.Disable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *ConsulVipDiscoveryInfoType_Publish) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Publish != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Publish.Size()))
		n21, err := m.Publish.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *K8SDiscoveryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SDiscoveryType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccessInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AccessInfo.Size()))
		n22, err := m.AccessInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.PublishInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PublishInfo.Size()))
		n23, err := m.PublishInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *ConsulDiscoveryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulDiscoveryType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccessInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AccessInfo.Size()))
		n24, err := m.AccessInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.PublishInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PublishInfo.Size()))
		n25, err := m.PublishInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n26, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.PublishVip != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PublishVip.Size()))
		n27, err := m.PublishVip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.AccessInfo != nil {
		nn28, err := m.AccessInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn28
	}
	if m.DiscoveryChoice != nil {
		nn29, err := m.DiscoveryChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn29
	}
	return i, nil
}

func (m *GlobalSpecType_K8S) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.K8S != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.K8S.Size()))
		n30, err := m.K8S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *GlobalSpecType_Consul) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Consul != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Consul.Size()))
		n31, err := m.Consul.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *GlobalSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DiscoveryK8S != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryK8S.Size()))
		n32, err := m.DiscoveryK8S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *GlobalSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DiscoveryConsul != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryConsul.Size()))
		n33, err := m.DiscoveryConsul.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n34, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.DiscoveryChoice != nil {
		nn35, err := m.DiscoveryChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn35
	}
	return i, nil
}

func (m *CreateSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DiscoveryK8S != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryK8S.Size()))
		n36, err := m.DiscoveryK8S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *CreateSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DiscoveryConsul != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryConsul.Size()))
		n37, err := m.DiscoveryConsul.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n38, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.DiscoveryChoice != nil {
		nn39, err := m.DiscoveryChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn39
	}
	return i, nil
}

func (m *ReplaceSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DiscoveryK8S != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryK8S.Size()))
		n40, err := m.DiscoveryK8S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *ReplaceSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DiscoveryConsul != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryConsul.Size()))
		n41, err := m.DiscoveryConsul.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n42, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.PublishVip != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PublishVip.Size()))
		n43, err := m.PublishVip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.DiscoveryChoice != nil {
		nn44, err := m.DiscoveryChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn44
	}
	return i, nil
}

func (m *GetSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DiscoveryK8S != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryK8S.Size()))
		n45, err := m.DiscoveryK8S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *GetSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DiscoveryConsul != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryConsul.Size()))
		n46, err := m.DiscoveryConsul.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *VerStatusType) Size() (n int) {
	var l int
	_ = l
	if m.Connected {
		n += 2
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PodInfoType) Size() (n int) {
	var l int
	_ = l
	l = len(m.PodName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DiscoveredServiceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Pods) > 0 {
		for _, e := range m.Pods {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.PortMap) > 0 {
		for k, v := range m.PortMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + sovTypes(uint64(v))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TLSClientConfigType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CertificateUrl != nil {
		l = m.CertificateUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.KeyUrl != nil {
		l = m.KeyUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CaCertificateUrl != nil {
		l = m.CaCertificateUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RestConfigType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ApiServer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TlsInfo != nil {
		l = m.TlsInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SAccessInfo) Size() (n int) {
	var l int
	_ = l
	if m.ConfigType != nil {
		n += m.ConfigType.Size()
	}
	if m.K8SPodNetworkChoice != nil {
		n += m.K8SPodNetworkChoice.Size()
	}
	return n
}

func (m *K8SAccessInfo_KubeconfigUrl) Size() (n int) {
	var l int
	_ = l
	if m.KubeconfigUrl != nil {
		l = m.KubeconfigUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SAccessInfo_ConnectionInfo) Size() (n int) {
	var l int
	_ = l
	if m.ConnectionInfo != nil {
		l = m.ConnectionInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SAccessInfo_InCluster) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *K8SAccessInfo_Isolated) Size() (n int) {
	var l int
	_ = l
	if m.Isolated != nil {
		l = m.Isolated.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SAccessInfo_Reachable) Size() (n int) {
	var l int
	_ = l
	if m.Reachable != nil {
		l = m.Reachable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulHttpBasicAuthInfoType) Size() (n int) {
	var l int
	_ = l
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PasswdUrl != nil {
		l = m.PasswdUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConsulAccessInfo) Size() (n int) {
	var l int
	_ = l
	if m.ConnectionInfo != nil {
		l = m.ConnectionInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Scheme != 0 {
		n += 1 + sovTypes(uint64(m.Scheme))
	}
	if m.HttpBasicAuthInfo != nil {
		l = m.HttpBasicAuthInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VipDiscoveryInfoType) Size() (n int) {
	var l int
	_ = l
	if m.PublishVirtualIp {
		n += 2
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Subdomain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DnsMode != 0 {
		n += 1 + sovTypes(uint64(m.DnsMode))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SPublishType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SDelegationType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Subdomain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DnsMode != 0 {
		n += 1 + sovTypes(uint64(m.DnsMode))
	}
	return n
}

func (m *K8SVipDiscoveryInfoType) Size() (n int) {
	var l int
	_ = l
	if m.PublishChoice != nil {
		n += m.PublishChoice.Size()
	}
	return n
}

func (m *K8SVipDiscoveryInfoType_Disable) Size() (n int) {
	var l int
	_ = l
	if m.Disable != nil {
		l = m.Disable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SVipDiscoveryInfoType_Publish) Size() (n int) {
	var l int
	_ = l
	if m.Publish != nil {
		l = m.Publish.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SVipDiscoveryInfoType_PublishFqdns) Size() (n int) {
	var l int
	_ = l
	if m.PublishFqdns != nil {
		l = m.PublishFqdns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SVipDiscoveryInfoType_DnsDelegation) Size() (n int) {
	var l int
	_ = l
	if m.DnsDelegation != nil {
		l = m.DnsDelegation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulVipDiscoveryInfoType) Size() (n int) {
	var l int
	_ = l
	if m.PublishChoice != nil {
		n += m.PublishChoice.Size()
	}
	return n
}

func (m *ConsulVipDiscoveryInfoType_Disable) Size() (n int) {
	var l int
	_ = l
	if m.Disable != nil {
		l = m.Disable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulVipDiscoveryInfoType_Publish) Size() (n int) {
	var l int
	_ = l
	if m.Publish != nil {
		l = m.Publish.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SDiscoveryType) Size() (n int) {
	var l int
	_ = l
	if m.AccessInfo != nil {
		l = m.AccessInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PublishInfo != nil {
		l = m.PublishInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConsulDiscoveryType) Size() (n int) {
	var l int
	_ = l
	if m.AccessInfo != nil {
		l = m.AccessInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PublishInfo != nil {
		l = m.PublishInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.PublishVip != nil {
		l = m.PublishVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AccessInfo != nil {
		n += m.AccessInfo.Size()
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	return n
}

func (m *GlobalSpecType_K8S) Size() (n int) {
	var l int
	_ = l
	if m.K8S != nil {
		l = m.K8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Consul) Size() (n int) {
	var l int
	_ = l
	if m.Consul != nil {
		l = m.Consul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DiscoveryK8S) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DiscoveryConsul) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	return n
}

func (m *CreateSpecType_DiscoveryK8S) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DiscoveryConsul) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_DiscoveryK8S) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DiscoveryConsul) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.PublishVip != nil {
		l = m.PublishVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	return n
}

func (m *GetSpecType_DiscoveryK8S) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DiscoveryConsul) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *VerStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VerStatusType{`,
		`Connected:` + fmt.Sprintf("%v", this.Connected) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Services:` + strings.Replace(fmt.Sprintf("%v", this.Services), "DiscoveredServiceType", "DiscoveredServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodInfoType{`,
		`PodName:` + fmt.Sprintf("%v", this.PodName) + `,`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredServiceType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForPortMap := make([]uint32, 0, len(this.PortMap))
	for k, _ := range this.PortMap {
		keysForPortMap = append(keysForPortMap, k)
	}
	sortkeys.Uint32s(keysForPortMap)
	mapStringForPortMap := "map[uint32]uint32{"
	for _, k := range keysForPortMap {
		mapStringForPortMap += fmt.Sprintf("%v: %v,", k, this.PortMap[k])
	}
	mapStringForPortMap += "}"
	s := strings.Join([]string{`&DiscoveredServiceType{`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ServiceType:` + fmt.Sprintf("%v", this.ServiceType) + `,`,
		`ClusterIp:` + fmt.Sprintf("%v", this.ClusterIp) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Pods:` + strings.Replace(fmt.Sprintf("%v", this.Pods), "PodInfoType", "PodInfoType", 1) + `,`,
		`PortMap:` + mapStringForPortMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *TLSClientConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TLSClientConfigType{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`CertificateUrl:` + strings.Replace(fmt.Sprintf("%v", this.CertificateUrl), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`KeyUrl:` + strings.Replace(fmt.Sprintf("%v", this.KeyUrl), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`CaCertificateUrl:` + strings.Replace(fmt.Sprintf("%v", this.CaCertificateUrl), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`Certificate:` + fmt.Sprintf("%v", this.Certificate) + `,`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestConfigType{`,
		`ApiServer:` + fmt.Sprintf("%v", this.ApiServer) + `,`,
		`TlsInfo:` + strings.Replace(fmt.Sprintf("%v", this.TlsInfo), "TLSClientConfigType", "TLSClientConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo{`,
		`ConfigType:` + fmt.Sprintf("%v", this.ConfigType) + `,`,
		`K8SPodNetworkChoice:` + fmt.Sprintf("%v", this.K8SPodNetworkChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_KubeconfigUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_KubeconfigUrl{`,
		`KubeconfigUrl:` + strings.Replace(fmt.Sprintf("%v", this.KubeconfigUrl), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_ConnectionInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_ConnectionInfo{`,
		`ConnectionInfo:` + strings.Replace(fmt.Sprintf("%v", this.ConnectionInfo), "RestConfigType", "RestConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_InCluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_InCluster{`,
		`InCluster:` + fmt.Sprintf("%v", this.InCluster) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_Isolated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_Isolated{`,
		`Isolated:` + strings.Replace(fmt.Sprintf("%v", this.Isolated), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_Reachable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_Reachable{`,
		`Reachable:` + strings.Replace(fmt.Sprintf("%v", this.Reachable), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulHttpBasicAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulHttpBasicAuthInfoType{`,
		`UserName:` + fmt.Sprintf("%v", this.UserName) + `,`,
		`PasswdUrl:` + strings.Replace(fmt.Sprintf("%v", this.PasswdUrl), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulAccessInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulAccessInfo{`,
		`ConnectionInfo:` + strings.Replace(fmt.Sprintf("%v", this.ConnectionInfo), "RestConfigType", "RestConfigType", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`HttpBasicAuthInfo:` + strings.Replace(fmt.Sprintf("%v", this.HttpBasicAuthInfo), "ConsulHttpBasicAuthInfoType", "ConsulHttpBasicAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VipDiscoveryInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VipDiscoveryInfoType{`,
		`PublishVirtualIp:` + fmt.Sprintf("%v", this.PublishVirtualIp) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Subdomain:` + fmt.Sprintf("%v", this.Subdomain) + `,`,
		`DnsMode:` + fmt.Sprintf("%v", this.DnsMode) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SPublishType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SPublishType{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SDelegationType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SDelegationType{`,
		`Subdomain:` + fmt.Sprintf("%v", this.Subdomain) + `,`,
		`DnsMode:` + fmt.Sprintf("%v", this.DnsMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType{`,
		`PublishChoice:` + fmt.Sprintf("%v", this.PublishChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_Disable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_Disable{`,
		`Disable:` + strings.Replace(fmt.Sprintf("%v", this.Disable), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_Publish) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_Publish{`,
		`Publish:` + strings.Replace(fmt.Sprintf("%v", this.Publish), "K8SPublishType", "K8SPublishType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_PublishFqdns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_PublishFqdns{`,
		`PublishFqdns:` + strings.Replace(fmt.Sprintf("%v", this.PublishFqdns), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_DnsDelegation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_DnsDelegation{`,
		`DnsDelegation:` + strings.Replace(fmt.Sprintf("%v", this.DnsDelegation), "K8SDelegationType", "K8SDelegationType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulVipDiscoveryInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulVipDiscoveryInfoType{`,
		`PublishChoice:` + fmt.Sprintf("%v", this.PublishChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulVipDiscoveryInfoType_Disable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulVipDiscoveryInfoType_Disable{`,
		`Disable:` + strings.Replace(fmt.Sprintf("%v", this.Disable), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulVipDiscoveryInfoType_Publish) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulVipDiscoveryInfoType_Publish{`,
		`Publish:` + strings.Replace(fmt.Sprintf("%v", this.Publish), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SDiscoveryType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SDiscoveryType{`,
		`AccessInfo:` + strings.Replace(fmt.Sprintf("%v", this.AccessInfo), "K8SAccessInfo", "K8SAccessInfo", 1) + `,`,
		`PublishInfo:` + strings.Replace(fmt.Sprintf("%v", this.PublishInfo), "K8SVipDiscoveryInfoType", "K8SVipDiscoveryInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulDiscoveryType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulDiscoveryType{`,
		`AccessInfo:` + strings.Replace(fmt.Sprintf("%v", this.AccessInfo), "ConsulAccessInfo", "ConsulAccessInfo", 1) + `,`,
		`PublishInfo:` + strings.Replace(fmt.Sprintf("%v", this.PublishInfo), "ConsulVipDiscoveryInfoType", "ConsulVipDiscoveryInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "ves_io_schema4.NetworkSiteRefSelector", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`PublishVip:` + strings.Replace(fmt.Sprintf("%v", this.PublishVip), "VipDiscoveryInfoType", "VipDiscoveryInfoType", 1) + `,`,
		`AccessInfo:` + fmt.Sprintf("%v", this.AccessInfo) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_K8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_K8S{`,
		`K8S:` + strings.Replace(fmt.Sprintf("%v", this.K8S), "K8SAccessInfo", "K8SAccessInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Consul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Consul{`,
		`Consul:` + strings.Replace(fmt.Sprintf("%v", this.Consul), "ConsulAccessInfo", "ConsulAccessInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "ves_io_schema4.NetworkSiteRefSelector", 1) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "ves_io_schema4.NetworkSiteRefSelector", 1) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "ves_io_schema4.NetworkSiteRefSelector", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`PublishVip:` + strings.Replace(fmt.Sprintf("%v", this.PublishVip), "VipDiscoveryInfoType", "VipDiscoveryInfoType", 1) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *VerStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Connected = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ves_io_schema4.DiscoveryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &DiscoveredServiceType{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveredServiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveredServiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveredServiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pods = append(m.Pods, &PodInfoType{})
			if err := m.Pods[len(m.Pods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMap == nil {
				m.PortMap = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PortMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSClientConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSClientConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSClientConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertificateUrl == nil {
				m.CertificateUrl = &ves_io_schema4.SecretType{}
			}
			if err := m.CertificateUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyUrl == nil {
				m.KeyUrl = &ves_io_schema4.SecretType{}
			}
			if err := m.KeyUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificateUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaCertificateUrl == nil {
				m.CaCertificateUrl = &ves_io_schema4.SecretType{}
			}
			if err := m.CaCertificateUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsInfo == nil {
				m.TlsInfo = &TLSClientConfigType{}
			}
			if err := m.TlsInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SAccessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SAccessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SAccessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeconfigUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigType = &K8SAccessInfo_KubeconfigUrl{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigType = &K8SAccessInfo_ConnectionInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ConfigType = &K8SAccessInfo_InCluster{b}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.K8SPodNetworkChoice = &K8SAccessInfo_Isolated{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reachable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.K8SPodNetworkChoice = &K8SAccessInfo_Reachable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulHttpBasicAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulHttpBasicAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulHttpBasicAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswdUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PasswdUrl == nil {
				m.PasswdUrl = &ves_io_schema4.SecretType{}
			}
			if err := m.PasswdUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulAccessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulAccessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulAccessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectionInfo == nil {
				m.ConnectionInfo = &RestConfigType{}
			}
			if err := m.ConnectionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			m.Scheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scheme |= (SchemeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpBasicAuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpBasicAuthInfo == nil {
				m.HttpBasicAuthInfo = &ConsulHttpBasicAuthInfoType{}
			}
			if err := m.HttpBasicAuthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipDiscoveryInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipDiscoveryInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipDiscoveryInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVirtualIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishVirtualIp = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (VirtualIPDiscoveryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subdomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsMode", wireType)
			}
			m.DnsMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsMode |= (K8SDNSMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SPublishType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SPublishType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SPublishType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SDelegationType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SDelegationType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SDelegationType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subdomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsMode", wireType)
			}
			m.DnsMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsMode |= (K8SDNSMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SVipDiscoveryInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SVipDiscoveryInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SVipDiscoveryInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_Disable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SPublishType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_Publish{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishFqdns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_PublishFqdns{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsDelegation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDelegationType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_DnsDelegation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulVipDiscoveryInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulVipDiscoveryInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulVipDiscoveryInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &ConsulVipDiscoveryInfoType_Disable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &ConsulVipDiscoveryInfoType_Publish{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SDiscoveryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SDiscoveryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SDiscoveryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessInfo == nil {
				m.AccessInfo = &K8SAccessInfo{}
			}
			if err := m.AccessInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishInfo == nil {
				m.PublishInfo = &K8SVipDiscoveryInfoType{}
			}
			if err := m.PublishInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulDiscoveryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulDiscoveryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulDiscoveryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessInfo == nil {
				m.AccessInfo = &ConsulAccessInfo{}
			}
			if err := m.AccessInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishInfo == nil {
				m.PublishInfo = &ConsulVipDiscoveryInfoType{}
			}
			if err := m.PublishInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ves_io_schema4.DiscoveryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishVip == nil {
				m.PublishVip = &VipDiscoveryInfoType{}
			}
			if err := m.PublishVip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SAccessInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AccessInfo = &GlobalSpecType_K8S{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulAccessInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AccessInfo = &GlobalSpecType_Consul{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &CreateSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &CreateSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &ReplaceSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &ReplaceSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ves_io_schema4.DiscoveryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishVip == nil {
				m.PublishVip = &VipDiscoveryInfoType{}
			}
			if err := m.PublishVip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GetSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GetSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/discovery/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/discovery/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 2230 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0xe6, 0xf0, 0x9f, 0x8f, 0x12, 0x45, 0x8f, 0x95, 0x98, 0x51, 0x0c, 0x96, 0xa6, 0xe3, 0x5a,
	0x51, 0x28, 0xea, 0xc7, 0x8e, 0x4b, 0xcb, 0xad, 0x11, 0x93, 0x92, 0x2d, 0x59, 0x96, 0xcc, 0xee,
	0xca, 0x32, 0xda, 0x0b, 0xb1, 0xdc, 0x1d, 0x91, 0x0b, 0x2d, 0x77, 0xb7, 0xbb, 0x4b, 0x39, 0x3a,
	0x14, 0x30, 0xda, 0x43, 0x51, 0x9d, 0x02, 0xf4, 0x50, 0xc0, 0xc7, 0x5e, 0xda, 0xa2, 0xb7, 0x1e,
	0xd2, 0xa2, 0xd4, 0xc1, 0x30, 0x50, 0x20, 0xe8, 0xa5, 0xea, 0xcd, 0x47, 0x9b, 0xb9, 0xa4, 0x39,
	0x19, 0x39, 0x19, 0xed, 0x21, 0xc5, 0xcc, 0x2e, 0x97, 0x4b, 0x8a, 0xd4, 0x4f, 0x63, 0xf4, 0xd2,
	0xdc, 0x76, 0x77, 0xde, 0xcf, 0x37, 0xdf, 0x7b, 0xf3, 0xcd, 0x93, 0x08, 0x17, 0x77, 0x88, 0x99,
	0x97, 0xb5, 0x19, 0x53, 0xac, 0x93, 0x86, 0x30, 0x23, 0xc9, 0xa6, 0xa8, 0xed, 0x10, 0x63, 0x77,
	0xc6, 0xda, 0xd5, 0x89, 0x99, 0xd7, 0x0d, 0xcd, 0xd2, 0xf0, 0x39, 0xdb, 0x28, 0x6f, 0x1b, 0xe5,
	0x5d, 0xa3, 0x89, 0xe9, 0x9a, 0x6c, 0xd5, 0x9b, 0xd5, 0xbc, 0xa8, 0x35, 0x66, 0x6a, 0x5a, 0x4d,
	0x9b, 0x61, 0xf6, 0xd5, 0xe6, 0x16, 0x7b, 0x63, 0x2f, 0xec, 0xc9, 0x8e, 0x33, 0xf1, 0x6e, 0x6f,
	0x32, 0x4d, 0xb7, 0x64, 0x4d, 0x75, 0x92, 0x4c, 0xbc, 0xd3, 0xbb, 0xe8, 0xc9, 0x3f, 0x71, 0xbe,
	0x77, 0x69, 0x47, 0x50, 0x64, 0x49, 0xb0, 0x88, 0xb3, 0x9a, 0xe9, 0x5b, 0x95, 0xc9, 0xa3, 0x4a,
	0x4f, 0xe8, 0xec, 0x3f, 0x10, 0x8c, 0x6e, 0x12, 0x83, 0xb7, 0x04, 0xab, 0x69, 0x6e, 0xec, 0xea,
	0x04, 0x67, 0x21, 0x26, 0x6a, 0xaa, 0x4a, 0x44, 0x8b, 0x48, 0x29, 0x94, 0x41, 0x93, 0xd1, 0x62,
	0xf0, 0x75, 0x0b, 0xf9, 0xb8, 0xee, 0x67, 0x9c, 0x82, 0xa0, 0x29, 0x5b, 0x24, 0xe5, 0xcf, 0xa0,
	0xc9, 0x98, 0xb3, 0xcc, 0xbe, 0xe0, 0x59, 0x08, 0x52, 0x78, 0xa9, 0x40, 0x06, 0x4d, 0x26, 0xe6,
	0xcf, 0xe7, 0x7b, 0xe9, 0x59, 0xec, 0xd0, 0x43, 0x33, 0x71, 0xcc, 0x12, 0x97, 0x21, 0x6a, 0x12,
	0x63, 0x47, 0x16, 0x89, 0x99, 0x0a, 0x66, 0x02, 0x93, 0xf1, 0xf9, 0x7c, 0x7e, 0x08, 0xa9, 0xae,
	0x3f, 0x91, 0x78, 0xdb, 0x85, 0xc6, 0x29, 0x06, 0x0f, 0x5a, 0x08, 0x71, 0x6e, 0x94, 0xec, 0x22,
	0xc4, 0xcb, 0x9a, 0xb4, 0xa2, 0x6e, 0x69, 0x6c, 0x43, 0xdf, 0x81, 0xa8, 0xae, 0x49, 0x15, 0x55,
	0x68, 0x10, 0xb6, 0x9f, 0x0e, 0xe0, 0x88, 0xae, 0x49, 0xeb, 0x42, 0x83, 0xe0, 0x71, 0xf0, 0xcb,
	0x7a, 0xcf, 0x5e, 0xfc, 0xb2, 0x9e, 0xdd, 0x8b, 0xc0, 0x5b, 0x03, 0xf3, 0xe1, 0x59, 0x18, 0x71,
	0x72, 0x79, 0x83, 0x8e, 0x52, 0xcf, 0xbf, 0xfc, 0xf3, 0x69, 0x20, 0x68, 0xf8, 0x53, 0x1f, 0x71,
	0x71, 0xc7, 0x84, 0x65, 0xf8, 0x00, 0x62, 0xd4, 0xd2, 0xd4, 0x05, 0xb1, 0x43, 0x5a, 0x9f, 0x79,
	0x77, 0xdd, 0x1b, 0xde, 0xa5, 0x72, 0x68, 0x78, 0x06, 0x28, 0x07, 0x20, 0x2a, 0x4d, 0xd3, 0x22,
	0x46, 0x45, 0xd6, 0x53, 0xc1, 0x43, 0xf6, 0x3a, 0xe2, 0x62, 0x8e, 0xc1, 0x8a, 0x8e, 0x3f, 0x86,
	0xb0, 0x22, 0x54, 0x89, 0x62, 0xa6, 0x42, 0x8c, 0xee, 0x85, 0xd3, 0xd1, 0x9d, 0xbf, 0xc7, 0x9c,
	0x97, 0x54, 0xcb, 0xd8, 0x2d, 0xbe, 0x47, 0x33, 0x84, 0x9e, 0x20, 0x7f, 0x32, 0x49, 0x9f, 0xe0,
	0x09, 0x8a, 0x4c, 0x85, 0x8c, 0xc0, 0x01, 0x42, 0xed, 0x17, 0x7f, 0x0d, 0x84, 0xf7, 0xf6, 0x91,
	0x3f, 0xea, 0xe3, 0x9c, 0x7c, 0xf8, 0x26, 0x04, 0x75, 0x4d, 0x32, 0x53, 0x61, 0x96, 0xf7, 0xbd,
	0xa1, 0x79, 0x3d, 0xd5, 0x2b, 0x06, 0x9f, 0xd2, 0xe2, 0x32, 0x3f, 0xfc, 0x38, 0x40, 0x4b, 0x69,
	0x58, 0x95, 0x86, 0xa0, 0xa7, 0x22, 0x2c, 0xc8, 0x8d, 0x53, 0x82, 0x2f, 0x6b, 0x86, 0xb5, 0x26,
	0xe8, 0x36, 0xfa, 0xdf, 0xfa, 0x69, 0x70, 0x0a, 0x7c, 0xf4, 0x09, 0x82, 0x6c, 0x74, 0x2a, 0x9c,
	0xfa, 0xfa, 0xeb, 0xc0, 0xa4, 0xfb, 0x65, 0xca, 0xfd, 0x42, 0x77, 0x33, 0xb3, 0xb7, 0x8f, 0x3e,
	0xc0, 0xef, 0x7f, 0xd9, 0x42, 0x97, 0x56, 0x54, 0x51, 0x6b, 0xc8, 0x6a, 0x2d, 0x43, 0xd1, 0x64,
	0xd4, 0x66, 0xa3, 0x4a, 0x8c, 0x8c, 0x55, 0x17, 0xac, 0x8c, 0x4a, 0x88, 0x64, 0x66, 0x0c, 0xd2,
	0x10, 0x74, 0xea, 0x93, 0xde, 0xdb, 0x47, 0x13, 0x38, 0xd5, 0x6e, 0xa1, 0x71, 0xd7, 0x87, 0x42,
	0xc8, 0xac, 0x33, 0x1f, 0x6a, 0x02, 0x7b, 0xfb, 0x28, 0x8c, 0x83, 0x9f, 0xb5, 0x90, 0xaf, 0xcb,
	0x19, 0x4b, 0xf8, 0x70, 0x6f, 0x1f, 0xf1, 0x13, 0x3f, 0xfc, 0xb2, 0x85, 0xd6, 0xee, 0x37, 0xad,
	0x9a, 0x36, 0x30, 0xe1, 0x23, 0x59, 0x51, 0x32, 0x35, 0x2d, 0x63, 0x69, 0x99, 0x4e, 0x89, 0xcb,
	0x99, 0xce, 0x51, 0xc8, 0x68, 0x46, 0x46, 0xd5, 0x24, 0x32, 0xcd, 0xdc, 0x3a, 0x5f, 0x5d, 0x60,
	0x13, 0x0c, 0x98, 0x1b, 0x7b, 0x10, 0xb0, 0x09, 0x06, 0x8c, 0x9e, 0x15, 0xc6, 0xdb, 0xc4, 0x75,
	0x88, 0x7b, 0xea, 0x8f, 0x93, 0x10, 0xd8, 0x26, 0xbb, 0xf6, 0x09, 0xe0, 0xe8, 0x23, 0x1e, 0x87,
	0xd0, 0x8e, 0xa0, 0x34, 0x9d, 0x36, 0xe7, 0xec, 0x97, 0x05, 0x7f, 0x01, 0x4d, 0x2c, 0xc0, 0x88,
	0x97, 0x7d, 0xaf, 0xef, 0xe8, 0x00, 0xdf, 0x51, 0x8f, 0x6f, 0xf6, 0x75, 0x00, 0xce, 0x6e, 0xdc,
	0xe3, 0x4b, 0x8a, 0x4c, 0x54, 0xab, 0xa4, 0xa9, 0x5b, 0x72, 0x8d, 0x75, 0x7e, 0x01, 0xd8, 0x41,
	0x20, 0x86, 0xf7, 0x24, 0x9e, 0xeb, 0xb4, 0x7e, 0xc8, 0x08, 0xa4, 0x1e, 0xfb, 0x9d, 0x43, 0x50,
	0x47, 0x1c, 0xd8, 0xb6, 0xec, 0x48, 0xae, 0xc1, 0x98, 0x48, 0x0c, 0x4b, 0xde, 0x92, 0x45, 0xc1,
	0x22, 0x95, 0xa6, 0xa1, 0xb0, 0xac, 0xf1, 0xf9, 0x77, 0xfa, 0x3a, 0x8a, 0x27, 0xa2, 0x41, 0x2c,
	0xd6, 0x8b, 0xb1, 0xe7, 0x3f, 0x45, 0x5f, 0xb4, 0x10, 0x4a, 0x21, 0x2e, 0xe1, 0x71, 0x7e, 0x60,
	0x28, 0xb8, 0x00, 0x91, 0x6d, 0xb2, 0xcb, 0xc2, 0x04, 0x8e, 0x0b, 0x63, 0xeb, 0x55, 0x78, 0x9b,
	0xec, 0x52, 0x4f, 0x0e, 0xb0, 0x28, 0x54, 0xfa, 0xb1, 0x04, 0x4f, 0x81, 0x25, 0x29, 0x0a, 0xa5,
	0x5e, 0x34, 0x4b, 0x10, 0xf7, 0x04, 0x4c, 0x85, 0x18, 0x2d, 0x17, 0x5f, 0xb7, 0x50, 0xf0, 0x37,
	0xfb, 0x28, 0x5c, 0x15, 0x4c, 0x72, 0xed, 0x2a, 0xa5, 0x25, 0x6c, 0x04, 0x27, 0x1f, 0x3f, 0x8e,
	0x3a, 0x5c, 0x7d, 0x82, 0x10, 0xe7, 0xf5, 0xc3, 0x2b, 0x90, 0xb0, 0x0c, 0xda, 0x53, 0x52, 0x45,
	0x14, 0x18, 0xac, 0xf0, 0xc9, 0x23, 0x8d, 0x38, 0xae, 0x25, 0xe1, 0x81, 0xa1, 0x2c, 0x14, 0x9e,
	0xb5, 0xd0, 0x55, 0x48, 0xc1, 0x19, 0x9e, 0x95, 0x20, 0x53, 0x16, 0x0c, 0xa1, 0x41, 0x2c, 0x62,
	0x98, 0x38, 0x30, 0x97, 0xbb, 0x46, 0x57, 0xec, 0xe2, 0xf6, 0xac, 0x7c, 0x98, 0xbb, 0x92, 0xfd,
	0x35, 0x82, 0x04, 0x47, 0x4c, 0x6f, 0xd5, 0xaf, 0x01, 0x08, 0xba, 0x5c, 0xb1, 0xab, 0xd9, 0x5f,
	0x74, 0xaa, 0x8f, 0xb7, 0x1d, 0x1c, 0x2f, 0x10, 0xe2, 0x62, 0x82, 0x2e, 0xdb, 0x49, 0xf1, 0x1a,
	0x44, 0x2d, 0xc5, 0xac, 0xc8, 0xea, 0x96, 0xe6, 0x14, 0x3b, 0x37, 0x54, 0x3e, 0x06, 0x74, 0x9b,
	0x53, 0xb8, 0x88, 0xa5, 0x98, 0x54, 0x9e, 0xb2, 0x7f, 0x0c, 0xc0, 0xe8, 0x6a, 0x81, 0xbf, 0x25,
	0x8a, 0xc4, 0x64, 0x5f, 0xf0, 0x32, 0x24, 0xb6, 0x9b, 0x55, 0x22, 0x32, 0x17, 0x46, 0x18, 0x3a,
	0x51, 0x33, 0x2c, 0xfb, 0xb8, 0xd1, 0xae, 0xa3, 0xdd, 0x15, 0x63, 0xce, 0x75, 0x2b, 0x6b, 0xaa,
	0x17, 0xf1, 0xe5, 0xa1, 0x88, 0x7b, 0x49, 0x5a, 0xf6, 0x71, 0x89, 0x6e, 0x04, 0x86, 0x6e, 0x12,
	0x40, 0x56, 0x2b, 0x8e, 0x4a, 0xb0, 0x36, 0x8d, 0x16, 0x23, 0x4e, 0x1b, 0x2d, 0xfb, 0xb8, 0x98,
	0xac, 0x96, 0xec, 0x35, 0x5c, 0x80, 0xa8, 0x6c, 0x6a, 0x8a, 0x40, 0x47, 0x00, 0xbb, 0x13, 0xc7,
	0xfb, 0xd2, 0x2e, 0x35, 0x74, 0x6b, 0xd7, 0x16, 0xe7, 0x65, 0xc4, 0xb9, 0xd6, 0x78, 0x01, 0x62,
	0x06, 0x11, 0xc4, 0xba, 0x50, 0x55, 0xec, 0xbe, 0x3b, 0xce, 0xb5, 0x6b, 0xbe, 0x10, 0xfd, 0xea,
	0x66, 0x68, 0x6e, 0x36, 0x37, 0x37, 0x57, 0x4c, 0x43, 0xdc, 0xe1, 0x90, 0x8d, 0x08, 0x63, 0xd4,
	0xf6, 0xa0, 0x85, 0xa0, 0xdd, 0x42, 0x81, 0xb9, 0xdc, 0x7c, 0x71, 0x1a, 0xde, 0xde, 0x2e, 0x98,
	0x15, 0x76, 0xad, 0x13, 0xeb, 0x91, 0x66, 0x6c, 0x57, 0xc4, 0xba, 0x26, 0x8b, 0x04, 0x9f, 0x7d,
	0xda, 0x42, 0x54, 0xb2, 0xa8, 0x79, 0x9c, 0x9a, 0x5f, 0xcd, 0x7d, 0x78, 0x37, 0x18, 0x85, 0x64,
	0xfc, 0x6e, 0x30, 0x1a, 0x4f, 0x8e, 0x64, 0x7f, 0x89, 0xe0, 0xdd, 0x92, 0xa6, 0x9a, 0x4d, 0x65,
	0xd9, 0xb2, 0xf4, 0xa2, 0x60, 0xca, 0xe2, 0xad, 0xa6, 0x55, 0x77, 0xa7, 0x85, 0x29, 0x88, 0x35,
	0xcd, 0x5e, 0x3d, 0xe9, 0xbb, 0x7a, 0xa3, 0x74, 0x9d, 0x69, 0xc8, 0x4d, 0x00, 0x5d, 0x30, 0xcd,
	0x47, 0xd2, 0xc9, 0xe4, 0xc3, 0x6e, 0x9f, 0x98, 0xed, 0xf2, 0xc0, 0x50, 0xb2, 0xbf, 0xf2, 0x43,
	0xd2, 0xc6, 0xe2, 0xe9, 0xa1, 0xf2, 0xe1, 0xca, 0xa3, 0x53, 0x55, 0xfe, 0x50, 0xdd, 0x6f, 0x43,
	0x98, 0xb9, 0xd8, 0xba, 0x9a, 0x98, 0xbf, 0x38, 0x34, 0x10, 0xcf, 0xcc, 0xfa, 0xf5, 0xc5, 0xf1,
	0xc6, 0x04, 0xc6, 0xeb, 0x96, 0xa5, 0x57, 0xaa, 0x94, 0xb4, 0x8a, 0xd0, 0xb4, 0xea, 0x36, 0x3c,
	0x5b, 0xf0, 0xae, 0x0e, 0x8d, 0x7a, 0x04, 0xdd, 0xdc, 0x99, 0x7a, 0xff, 0xe7, 0xec, 0xa7, 0x7e,
	0x18, 0xdf, 0x94, 0x75, 0x77, 0x56, 0x74, 0x4b, 0x33, 0x0f, 0x58, 0x6f, 0x56, 0x15, 0xd9, 0xac,
	0x57, 0x76, 0x64, 0xc3, 0x6a, 0x0a, 0x0a, 0x1d, 0x77, 0xbc, 0x23, 0x6a, 0xd2, 0x59, 0xdf, 0xb4,
	0x97, 0x57, 0x74, 0xbc, 0xe2, 0xcc, 0xa3, 0xf6, 0xce, 0x67, 0x86, 0x62, 0xec, 0x78, 0x94, 0x7b,
	0x46, 0xd4, 0xce, 0x68, 0x6b, 0xd9, 0x53, 0x56, 0xcc, 0x6c, 0x56, 0x25, 0xad, 0x21, 0xc8, 0xaa,
	0x33, 0x94, 0x25, 0x7a, 0x6f, 0x1a, 0xae, 0x6b, 0x80, 0x17, 0x21, 0x2a, 0xa9, 0x66, 0xa5, 0xa1,
	0x49, 0x84, 0x1d, 0xa1, 0xa3, 0x68, 0x5f, 0x2d, 0xf0, 0x8b, 0xeb, 0xfc, 0x9a, 0x26, 0x75, 0x12,
	0x46, 0x24, 0xd5, 0xa4, 0xaf, 0xbd, 0x83, 0x63, 0xe8, 0xe8, 0xc1, 0x31, 0xfb, 0x03, 0x48, 0xac,
	0x16, 0xf8, 0xb2, 0x4d, 0x01, 0x63, 0xac, 0xc7, 0x1d, 0x1d, 0xe3, 0xfe, 0x0b, 0x04, 0x67, 0x28,
	0x12, 0xa2, 0x90, 0x9a, 0x40, 0x9b, 0x67, 0xe3, 0xd0, 0xae, 0xd1, 0x69, 0x76, 0xed, 0xff, 0x6f,
	0x77, 0x9d, 0xfd, 0xbb, 0x1f, 0xce, 0xad, 0x16, 0xf8, 0x81, 0x4d, 0x30, 0x0b, 0x11, 0x49, 0x36,
	0x99, 0xbc, 0xf8, 0x87, 0xcb, 0xcb, 0x32, 0x8d, 0x66, 0x9b, 0xe1, 0x12, 0x44, 0x9c, 0xb6, 0x70,
	0x3a, 0xf5, 0xf2, 0x51, 0x90, 0x3c, 0xf4, 0xd1, 0x20, 0x8e, 0x27, 0xbe, 0x01, 0xa3, 0x9d, 0xde,
	0xdb, 0xfa, 0x89, 0xa4, 0x9a, 0x47, 0xc9, 0xe2, 0xb2, 0x8f, 0x1b, 0x71, 0x8c, 0x6f, 0x53, 0x5b,
	0xcc, 0x43, 0x82, 0xb2, 0x22, 0xb9, 0xcc, 0x3a, 0xca, 0x38, 0x75, 0x24, 0x37, 0x3d, 0x75, 0xa0,
	0x37, 0x84, 0xa4, 0x9a, 0xdd, 0x8f, 0xc5, 0x4b, 0x90, 0xe8, 0x20, 0xf2, 0x68, 0x9f, 0x9f, 0x6a,
	0x4c, 0xbb, 0x85, 0x22, 0xf3, 0xb9, 0x2b, 0x39, 0x5b, 0xfb, 0x50, 0xd2, 0x9f, 0xfd, 0x3d, 0x82,
	0x09, 0xfb, 0x18, 0xbe, 0x21, 0x52, 0x67, 0xfb, 0x49, 0x1d, 0xea, 0xe1, 0x98, 0x15, 0x2f, 0x1c,
	0xc2, 0x3b, 0xe6, 0xc1, 0x1b, 0x98, 0xcf, 0x5d, 0x71, 0xb0, 0x7e, 0x85, 0x20, 0x49, 0xf7, 0xef,
	0x3d, 0x88, 0xf8, 0x0e, 0xc4, 0x05, 0xa6, 0x91, 0x5e, 0x45, 0xfc, 0xee, 0x51, 0xfc, 0x75, 0x25,
	0x95, 0x03, 0xa1, 0x2b, 0xaf, 0x3c, 0x74, 0x6a, 0xe3, 0xbd, 0x55, 0x67, 0x8f, 0x8a, 0x34, 0x88,
	0x32, 0x2e, 0xee, 0x44, 0xa1, 0x1f, 0x16, 0x3e, 0x7a, 0xd6, 0x42, 0xdf, 0x87, 0x73, 0x80, 0xed,
	0xa4, 0x99, 0x92, 0x41, 0x24, 0xa2, 0x5a, 0xb2, 0xa0, 0x98, 0x18, 0xcd, 0xc1, 0x05, 0x38, 0xbf,
	0xb9, 0x52, 0xce, 0x38, 0xad, 0x45, 0x47, 0x6d, 0x5b, 0xad, 0x9b, 0x06, 0x2b, 0x25, 0x46, 0xf3,
	0xd9, 0x7f, 0x23, 0x38, 0x6b, 0x17, 0xa8, 0x77, 0xdf, 0x77, 0x07, 0xed, 0xfb, 0xfd, 0x63, 0xa4,
	0x76, 0xc8, 0xd6, 0x37, 0x07, 0x6e, 0xfd, 0xca, 0x31, 0xc1, 0xfe, 0x17, 0xbb, 0xff, 0x43, 0x08,
	0x12, 0x77, 0x14, 0xad, 0x2a, 0x28, 0xbc, 0x4e, 0x44, 0xb6, 0xf1, 0x1b, 0x10, 0x7a, 0x54, 0x27,
	0x06, 0x71, 0xb6, 0x7c, 0xa9, 0x0f, 0xe5, 0xba, 0x7d, 0xed, 0xf3, 0xb2, 0x45, 0x38, 0xb2, 0xc5,
	0x13, 0x85, 0x88, 0x96, 0x66, 0x70, 0xb6, 0x0f, 0xbe, 0xde, 0xa3, 0xfa, 0x47, 0xfe, 0x17, 0xc2,
	0x9d, 0x80, 0x1c, 0x95, 0x7f, 0x08, 0xf1, 0xee, 0x25, 0xa3, 0x3b, 0xcd, 0x3d, 0x7d, 0xc4, 0xbd,
	0x71, 0x98, 0x9d, 0x6e, 0x48, 0x70, 0xef, 0x23, 0x1d, 0x97, 0x20, 0xb0, 0x5d, 0xe8, 0xe8, 0xc6,
	0x09, 0x3b, 0xb7, 0x3b, 0x9e, 0x21, 0x8e, 0x7a, 0xe3, 0x7b, 0x10, 0x16, 0x59, 0x55, 0x1c, 0x05,
	0x39, 0x79, 0x27, 0x78, 0x43, 0x39, 0x31, 0xf0, 0x26, 0x8c, 0xba, 0x0e, 0x15, 0x0a, 0x2e, 0x7a,
	0x4c, 0xd0, 0xfe, 0x63, 0xe9, 0x4e, 0xaf, 0x23, 0xae, 0xcd, 0x6a, 0xc1, 0xc4, 0x15, 0x48, 0x76,
	0xe3, 0x3a, 0x78, 0x63, 0xc7, 0xcc, 0xdb, 0x03, 0x9a, 0xdf, 0x8d, 0x3e, 0xe6, 0x9a, 0xd9, 0x56,
	0x0b, 0x97, 0x9f, 0xb5, 0xd0, 0x45, 0x00, 0x08, 0x3d, 0x64, 0xe5, 0x46, 0x73, 0xf0, 0x16, 0x24,
	0x5d, 0xdf, 0xcc, 0x1a, 0xb1, 0xea, 0x9a, 0x84, 0xd1, 0xf7, 0x8a, 0x17, 0x7b, 0x90, 0x74, 0x65,
	0x27, 0x7a, 0xd0, 0x42, 0x11, 0x2a, 0x3b, 0x85, 0xdc, 0xf5, 0x62, 0xb6, 0xe7, 0x8c, 0xd9, 0x23,
	0xe4, 0x41, 0x0b, 0x85, 0x9d, 0xf1, 0xf1, 0x55, 0x0b, 0xa1, 0xbb, 0xc1, 0x68, 0x24, 0x19, 0xbd,
	0x1b, 0x8c, 0x86, 0x93, 0x91, 0xec, 0x9f, 0xfc, 0x90, 0x28, 0x19, 0x44, 0xb0, 0xc8, 0x9b, 0xe9,
	0xd6, 0xf2, 0x37, 0x2d, 0xc3, 0xa1, 0x02, 0xfc, 0xe8, 0xcd, 0x14, 0x60, 0x10, 0xf5, 0x67, 0xfe,
	0x76, 0xb3, 0xef, 0xa8, 0x16, 0x27, 0x07, 0x90, 0x3c, 0xfe, 0xb3, 0x7f, 0xa1, 0x43, 0x5f, 0xb3,
	0x7f, 0xf6, 0xc3, 0x18, 0x47, 0x74, 0x45, 0x10, 0xbf, 0xa5, 0xee, 0x94, 0xd4, 0x7d, 0x1a, 0x80,
	0xf8, 0x1d, 0x62, 0xbd, 0x19, 0xda, 0x66, 0x4f, 0xae, 0x8f, 0x8e, 0x2c, 0xae, 0x7f, 0x73, 0x59,
	0xec, 0x51, 0xc3, 0xff, 0x9b, 0xc2, 0x4d, 0x5d, 0x00, 0xe8, 0xfe, 0x59, 0x85, 0xa3, 0x10, 0x5c,
	0xde, 0xd8, 0x28, 0x27, 0x7d, 0x38, 0x06, 0x21, 0xfa, 0xc4, 0x27, 0xd1, 0xd4, 0x2d, 0x78, 0x7b,
	0xf0, 0xdf, 0x1f, 0x18, 0x43, 0x62, 0x71, 0x9d, 0xaf, 0x2c, 0x2e, 0xdd, 0x5b, 0xba, 0x73, 0x6b,
	0x63, 0xe5, 0xfe, 0x7a, 0xd2, 0x87, 0xcf, 0xc2, 0x58, 0xf9, 0x41, 0xf1, 0xde, 0x0a, 0xbf, 0x5c,
	0xe1, 0x97, 0xb8, 0xcd, 0x95, 0xd2, 0x52, 0x12, 0x4d, 0x4d, 0x02, 0x74, 0xe7, 0x69, 0x3c, 0x02,
	0xd1, 0xd2, 0x7d, 0x6e, 0xa9, 0xb2, 0xb8, 0xce, 0x27, 0x7d, 0xf4, 0x6d, 0xf5, 0x41, 0xd1, 0x7e,
	0x43, 0xc5, 0x9f, 0xa3, 0x83, 0x97, 0x69, 0xdf, 0xf3, 0x97, 0x69, 0xdf, 0xab, 0x97, 0x69, 0xf4,
	0xb8, 0x9d, 0x46, 0xbf, 0x6b, 0xa7, 0xd1, 0x67, 0xed, 0x34, 0x3a, 0x68, 0xa7, 0xd1, 0xf3, 0x76,
	0x1a, 0xbd, 0x68, 0xa7, 0xd1, 0x17, 0xed, 0xb4, 0xef, 0x55, 0x3b, 0x8d, 0x3e, 0xf9, 0x3c, 0xed,
	0x7b, 0xfa, 0x79, 0x1a, 0xfd, 0x78, 0xad, 0xa6, 0xe9, 0xdb, 0xb5, 0xfc, 0x8e, 0xa6, 0x58, 0xc4,
	0x30, 0x84, 0x7c, 0xd3, 0x9c, 0x61, 0x0f, 0x5b, 0x9a, 0xd1, 0x98, 0xd6, 0x0d, 0x6d, 0x47, 0x96,
	0x88, 0x31, 0xdd, 0x59, 0x9e, 0xd1, 0xab, 0x35, 0x6d, 0x86, 0x7c, 0x6c, 0x39, 0xbf, 0x3c, 0xf4,
	0xff, 0x86, 0x52, 0x0d, 0xb3, 0x9f, 0x1f, 0xae, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0x1f, 0xa2,
	0x69, 0x81, 0x65, 0x19, 0x00, 0x00,
}

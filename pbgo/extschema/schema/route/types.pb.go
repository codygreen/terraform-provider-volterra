// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/route/types.proto

package route

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	strings "strings"

	reflect "reflect"

	sortkeys "github.com/gogo/protobuf/sortkeys"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// RouteDestination
//
// x-displayName: "Destination"
// Each destination is a reference to cluster, it priority, weight and subset criteria.
type RouteDestination struct {
	// cluster
	//
	// x-displayName: "Cluster"
	// x-required
	// Indicates the upstream cluster to which the request should be sent. If the cluster
	// does not exist ServiceUnavailable response will be sent
	Cluster []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1,rep,name=cluster" json:"cluster,omitempty"`
	// weight
	//
	// x-displayName: "Weight"
	// x-example: 10
	// When requests have to distributed among multiple upstream clusters,
	// multiple destinations are configured, each having its own cluster and weight.
	// Traffic is distributed among clusters based on the weight configured.
	//
	// Example:
	//    destinations:
	//    - cluster:
	//      - kind: ves.io.vega.cfg.adc.cluster.Object
	//        uid: cluster-1
	//     weight: 20
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-2
	//     weight: 30
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-3
	//     weight: 10
	//
	// This indicates that out of every 60 requests, 10 goes to cluster-3, 30 to
	// cluster-2 and 20 to cluster-1
	//
	// When single destination is configured, weight is ignored. All the requests are
	// sent to the cluster specified in the destination
	Weight uint32 `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	// endpoint_subsets
	//
	// x-displayName: "Endpoint Subsets"
	// Upstream cluster may be configured to divide its endpoints into subsets based on metadata
	// attached to the endpoints. Routes may then specify the metadata that a endpoint must match in
	// order to be selected by the load balancer
	//
	// Labels field of endpoint object's metadata is used for subset matching.
	// For endpoints which are discovered in K8S or Consul cluster, the label of the service is merged with
	// endpoint's labels. In case of Consul, the label is derived from the "Tag" field.
	// For labels that are common between configured endpoint and discovered service, labels from discovered service
	// takes precedence.
	//
	// List of key-value pairs that will be used as matching metadata. Only those endpoints of
	// upstream cluster which match this metadata will be selected for load balancing
	EndpointSubsets map[string]string `protobuf:"bytes,4,rep,name=endpoint_subsets,json=endpointSubsets" json:"endpoint_subsets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RouteDestination) Reset()                    { *m = RouteDestination{} }
func (*RouteDestination) ProtoMessage()               {}
func (*RouteDestination) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *RouteDestination) GetCluster() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *RouteDestination) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *RouteDestination) GetEndpointSubsets() map[string]string {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

// MirrorPolicyType
//
// x-displayName: "Mirror Policy"
// MirrorPolicy is used for shadowing traffic from one cluster to another. The approach used
// is "fire and forget", meaning it will not wait for the shadow cluster to
// respond before returning the response from the primary cluster. All normal statistics are
// collected for the shadow cluster making this feature useful for testing and troubleshooting.
type MirrorPolicyType struct {
	// cluster
	//
	// x-displayName: "Mirror Destination Cluster"
	// x-required
	// Specifies the cluster to which the requests will be mirrored. The cluster object
	// referred here must be present.
	Cluster []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1,rep,name=cluster" json:"cluster,omitempty"`
	// percent
	//
	// x-displayName: "Mirror Percentage"
	// Percentage of requests to be mirrored
	Percent *ves_io_schema4.FractionalPercent `protobuf:"bytes,2,opt,name=percent" json:"percent,omitempty"`
}

func (m *MirrorPolicyType) Reset()                    { *m = MirrorPolicyType{} }
func (*MirrorPolicyType) ProtoMessage()               {}
func (*MirrorPolicyType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *MirrorPolicyType) GetCluster() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *MirrorPolicyType) GetPercent() *ves_io_schema4.FractionalPercent {
	if m != nil {
		return m.Percent
	}
	return nil
}

// SpdyConfigType
// Configuration to allow UPGRADE of connection to SPDY and any additional tuning
//
// x-displayName: "SPDY Configuration"
// Request headers of such upgrade looks like below
//   'connection', 'Upgrade'
//   'upgrade', 'SPDY/3.1'
//
// With configuration to allow SPDY upgrade, ADC will produce following response
//   'HTTP/1.1 101 Switching Protocols
//   'Upgrade': 'SPDY/3.1'
//   'Connection': 'Upgrade'
type SpdyConfigType struct {
	// use_spdy
	//
	// x-displayName: "Use SPDY"
	// x-example: true
	// Specifies that the HTTP client connection to this route is allowed to upgrade to
	// a SPDY connection
	UseSpdy bool `protobuf:"varint,1,opt,name=use_spdy,json=useSpdy,proto3" json:"use_spdy,omitempty"`
}

func (m *SpdyConfigType) Reset()                    { *m = SpdyConfigType{} }
func (*SpdyConfigType) ProtoMessage()               {}
func (*SpdyConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *SpdyConfigType) GetUseSpdy() bool {
	if m != nil {
		return m.UseSpdy
	}
	return false
}

// WebsocketConfigType
//
// x-displayName: "Websocket Configuration"
// Configuration to allow Websocket
//
// Request headers of such upgrade looks like below
//   'connection', 'Upgrade'
//   'upgrade', 'websocket'
//
// With configuration to allow websocket upgrade, ADC will produce following response
//   'HTTP/1.1 101 Switching Protocols
//   'Upgrade': 'websocket'
//   'Connection': 'Upgrade'
type WebsocketConfigType struct {
	// use_websocket
	//
	// x-displayName: "Use Websocket"
	// x-example: true
	// Specifies that the HTTP client connection to this route is allowed to upgrade to
	// a WebSocket connection
	UseWebsocket bool `protobuf:"varint,1,opt,name=use_websocket,json=useWebsocket,proto3" json:"use_websocket,omitempty"`
	// idle_timeout
	//
	// x-displayName: "Idle Timeout"
	// x-example: 2000
	// Idle Timeout for Websocket in milli seconds. After timeout, connection will be closed
	IdleTimeout uint32 `protobuf:"varint,2,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	// max_connect_attempts
	//
	// x-displayName: "Maximum Connection Attempts"
	// x-example: 5
	// The maximum number of unsuccessful connection attempts that will be made before
	// giving up. Default is 1
	MaxConnectAttempts uint32 `protobuf:"varint,3,opt,name=max_connect_attempts,json=maxConnectAttempts,proto3" json:"max_connect_attempts,omitempty"`
}

func (m *WebsocketConfigType) Reset()                    { *m = WebsocketConfigType{} }
func (*WebsocketConfigType) ProtoMessage()               {}
func (*WebsocketConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *WebsocketConfigType) GetUseWebsocket() bool {
	if m != nil {
		return m.UseWebsocket
	}
	return false
}

func (m *WebsocketConfigType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *WebsocketConfigType) GetMaxConnectAttempts() uint32 {
	if m != nil {
		return m.MaxConnectAttempts
	}
	return 0
}

// Cookie for hashing
//
// x-displayName: "Hashing using Cookie"
// Two types of cookie affinity:
//
// 1. Passive. Takes a cookie that's present in the cookies header and
//    hashes on its value.
//
// 2. Generated. Generates and sets a cookie with an expiration (TTL)
//    on the first request from the client in its response to the client,
//    based on the endpoint the request gets sent to. The client then
//    presents this on the next and all subsequent requests. The hash of
//    this is sufficient to ensure these requests get sent to the same
//    endpoint. The cookie is generated by hashing the source and
//    destination ports and addresses so that multiple independent HTTP2
//    streams on the same connection will independently receive the same
//    cookie, even if they arrive simultaneously.
type CookieForHashing struct {
	// name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "userid"
	// The name of the cookie that will be used to obtain the hash key. If the
	// cookie is not present and TTL below is not set, no hash will be
	// produced
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ttl
	//
	// x-displayName: "TTL"
	// x-example: 5000
	// If specified, a cookie with the TTL will be generated if the cookie is
	// not present. If the TTL is present and zero, the generated cookie will
	// be a session cookie. TTL value is in milliseconds
	Ttl uint32 `protobuf:"varint,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// path
	//
	// x-displayName: "Path"
	// x-example: "/Users/userid/browser/cookies"
	// The name of the path for the cookie. If no path is specified here, no path
	// will be set for the cookie
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *CookieForHashing) Reset()                    { *m = CookieForHashing{} }
func (*CookieForHashing) ProtoMessage()               {}
func (*CookieForHashing) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *CookieForHashing) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CookieForHashing) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *CookieForHashing) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// HashPolicyType
//
// x-displayName: "Hash Policy"
// HashPolicyType specifies the field of the incoming request that will be used for
// generating hash key. When multiple hash policies are configured, this can also specify
// if the current hash policy is terminal policy or not.
type HashPolicyType struct {
	// PolicySpecifier
	//
	// x-displayName: "Hash Policy Specifier"
	// x-required
	// Specifies whether hashing is done on incoming request header, cookie or source IP
	//
	// Types that are valid to be assigned to PolicySpecifier:
	//	*HashPolicyType_HeaderName
	//	*HashPolicyType_Cookie
	//	*HashPolicyType_SourceIp
	PolicySpecifier isHashPolicyType_PolicySpecifier `protobuf_oneof:"policy_specifier"`
	// terminal
	//
	// x-displayName: "Terminal"
	// x-example: true
	// Specify if its a terminal policy
	Terminal bool `protobuf:"varint,4,opt,name=terminal,proto3" json:"terminal,omitempty"`
}

func (m *HashPolicyType) Reset()                    { *m = HashPolicyType{} }
func (*HashPolicyType) ProtoMessage()               {}
func (*HashPolicyType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

type isHashPolicyType_PolicySpecifier interface {
	isHashPolicyType_PolicySpecifier()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HashPolicyType_HeaderName struct {
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3,oneof"`
}
type HashPolicyType_Cookie struct {
	Cookie *CookieForHashing `protobuf:"bytes,2,opt,name=cookie,oneof"`
}
type HashPolicyType_SourceIp struct {
	SourceIp bool `protobuf:"varint,3,opt,name=source_ip,json=sourceIp,proto3,oneof"`
}

func (*HashPolicyType_HeaderName) isHashPolicyType_PolicySpecifier() {}
func (*HashPolicyType_Cookie) isHashPolicyType_PolicySpecifier()     {}
func (*HashPolicyType_SourceIp) isHashPolicyType_PolicySpecifier()   {}

func (m *HashPolicyType) GetPolicySpecifier() isHashPolicyType_PolicySpecifier {
	if m != nil {
		return m.PolicySpecifier
	}
	return nil
}

func (m *HashPolicyType) GetHeaderName() string {
	if x, ok := m.GetPolicySpecifier().(*HashPolicyType_HeaderName); ok {
		return x.HeaderName
	}
	return ""
}

func (m *HashPolicyType) GetCookie() *CookieForHashing {
	if x, ok := m.GetPolicySpecifier().(*HashPolicyType_Cookie); ok {
		return x.Cookie
	}
	return nil
}

func (m *HashPolicyType) GetSourceIp() bool {
	if x, ok := m.GetPolicySpecifier().(*HashPolicyType_SourceIp); ok {
		return x.SourceIp
	}
	return false
}

func (m *HashPolicyType) GetTerminal() bool {
	if m != nil {
		return m.Terminal
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HashPolicyType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HashPolicyType_OneofMarshaler, _HashPolicyType_OneofUnmarshaler, _HashPolicyType_OneofSizer, []interface{}{
		(*HashPolicyType_HeaderName)(nil),
		(*HashPolicyType_Cookie)(nil),
		(*HashPolicyType_SourceIp)(nil),
	}
}

func _HashPolicyType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HashPolicyType)
	// policy_specifier
	switch x := m.PolicySpecifier.(type) {
	case *HashPolicyType_HeaderName:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.HeaderName)
	case *HashPolicyType_Cookie:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cookie); err != nil {
			return err
		}
	case *HashPolicyType_SourceIp:
		t := uint64(0)
		if x.SourceIp {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("HashPolicyType.PolicySpecifier has unexpected type %T", x)
	}
	return nil
}

func _HashPolicyType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HashPolicyType)
	switch tag {
	case 1: // policy_specifier.header_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PolicySpecifier = &HashPolicyType_HeaderName{x}
		return true, err
	case 2: // policy_specifier.cookie
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CookieForHashing)
		err := b.DecodeMessage(msg)
		m.PolicySpecifier = &HashPolicyType_Cookie{msg}
		return true, err
	case 3: // policy_specifier.source_ip
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PolicySpecifier = &HashPolicyType_SourceIp{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _HashPolicyType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HashPolicyType)
	// policy_specifier
	switch x := m.PolicySpecifier.(type) {
	case *HashPolicyType_HeaderName:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.HeaderName)))
		n += len(x.HeaderName)
	case *HashPolicyType_Cookie:
		s := proto.Size(x.Cookie)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HashPolicyType_SourceIp:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RouteDestinationList
//
// x-displayName: "Destination List"
// List of destination to choose if the route is match.
type RouteDestinationList struct {
	// destinations
	//
	// x-displayName: "Destination Origin pools (clusters)"
	// x-required
	// When requests have to distributed among multiple upstream clusters,
	// multiple destinations are configured, each having its own cluster and weight.
	// Traffic is distributed among clusters based on the weight configured.
	//
	// Example:
	//    destinations:
	//    - cluster:
	//      - kind: ves.io.vega.cfg.adc.cluster.Object
	//        uid: cluster-1
	//     weight: 20
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-2
	//     weight: 30
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-3
	//     weight: 50
	//
	// This indicates that out of every 100 requests, 50 goes to cluster-3, 30 to
	// cluster-2 and 20 to cluster-1
	//
	// When single destination is configured, weight is ignored. All the requests are
	// sent to the cluster specified in the destination
	Destinations []*RouteDestination `protobuf:"bytes,1,rep,name=destinations" json:"destinations,omitempty"`
	// prefix_rewrite
	//
	// x-displayName: "Prefix Rewrite"
	// x-example: "/"
	// prefix_rewrite indicates that during forwarding, the matched prefix (or path) should be swapped
	// with its value. When using regex path matching, the entire path (not including
	// the query string) will be swapped with this value. This option allows application
	// URLs to be rooted at a different path from those exposed at the reverse proxy layer.
	//
	// Example :
	//   gcSpec:
	//     routes:
	//     - match:
	//       - headers: []
	//         path:
	//           prefix : /register/
	//         query_params: []
	//       - headers: []
	//          path:
	//           prefix: /register
	//         query_params: []
	//       routeDestination:
	//         prefixRewrite: "/"
	//         destinations:
	//         - cluster:
	//           - kind: cluster.Object
	//             uid: cluster-1
	//
	// Having above entries in the config, requests to /register will be stripped to /,
	// while requests to /register/public will be stripped to /public
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3" json:"prefix_rewrite,omitempty"`
	// HostRewriteParams
	//
	// x-displayName: "Host Rewrite"
	// x-required
	// Specifies how the host header can be modified during forwarding
	//
	// Types that are valid to be assigned to HostRewriteParams:
	//	*RouteDestinationList_HostRewrite
	//	*RouteDestinationList_AutoHostRewrite
	HostRewriteParams isRouteDestinationList_HostRewriteParams `protobuf_oneof:"HostRewriteParams"`
	// timeout
	//
	// x-displayName: "Timeout"
	// x-example: 2000
	// Specifies the timeout for the route in milliseconds.
	// This timeout includes all retries.
	// For server side streaming, configure this field with higher value or leave it un-configured
	// for infinite timeout
	Timeout uint32 `protobuf:"varint,8,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// retry_policy
	//
	// x-displayName: "Retry Policy"
	// Indicates that the route has a retry policy.
	RetryPolicy *ves_io_schema4.RetryPolicyType `protobuf:"bytes,9,opt,name=retry_policy,json=retryPolicy" json:"retry_policy,omitempty"`
	// endpoint_subsets
	//
	// x-displayName: "Endpoint Subsets"
	// Upstream cluster may be configured to divide its endpoints into subsets based on metadata
	// attached to the endpoints. Routes may then specify the metadata that a endpoint must match in
	// order to be selected by the load balancer
	//
	// Labels field of endpoint object's metadata is used for subset matching.
	// For endpoint's which are discovered in K8S or Consul cluster, the label of the service is merged with
	// endpoint's labels. In case of Consul, the label is derived from the "Tag" field.
	// For labels that are common between configured endpoint and discovered service, labels from discovered service
	// takes precedence.
	//
	// List of key-value pairs that will be used as matching metadata. Only those endpoints of
	// upstream cluster which match this metadata will be selected for load balancing
	EndpointSubsets map[string]string `protobuf:"bytes,10,rep,name=endpoint_subsets,json=endpointSubsets" json:"endpoint_subsets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// mirror_policy
	//
	// x-displayName: "Mirror Policy"
	// MirrorPolicy is used for shadowing traffic from one cluster to another. The current
	// implementation is "fire and forget," meaning it will not wait for the shadow cluster to
	// respond before returning the response from the primary cluster. All normal statistics are
	// collected for the shadow cluster making this feature useful for testing.
	//
	// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
	// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
	MirrorPolicy *MirrorPolicyType `protobuf:"bytes,11,opt,name=mirror_policy,json=mirrorPolicy" json:"mirror_policy,omitempty"`
	// web_socket_config
	//
	// x-displayName: "Websocket Configuration"
	// Websocket configuration for each route
	WebSocketConfig *WebsocketConfigType `protobuf:"bytes,13,opt,name=web_socket_config,json=webSocketConfig" json:"web_socket_config,omitempty"`
	// buffer_policy
	//
	// x-displayName: "Buffer Policy"
	// Buffering configuration for requests
	// Some upstream applications are not capable of handling streamed data. This config
	// enables buffering the entire request before sending to upstream application. We can
	// specify the maximum buffer size and buffer interval with this config.
	// Route level buffer configuration overrides any configuration at VirtualHost level.
	BufferPolicy *ves_io_schema4.BufferConfigType `protobuf:"bytes,14,opt,name=buffer_policy,json=bufferPolicy" json:"buffer_policy,omitempty"`
	// cors_policy
	//
	// x-displayName: "CORS Policy"
	// Cross-Origin Resource Sharing requests configuration
	//
	// CORS is a mechanism that uses additional HTTP headers to tell a browser to let
	// a web application running at one origin (domain) have permission to access selected
	// resources from a server at a different origin
	CorsPolicy *ves_io_schema4.CorsPolicy `protobuf:"bytes,15,opt,name=cors_policy,json=corsPolicy" json:"cors_policy,omitempty"`
	// hash_policy
	//
	// x-displayName: "Hash Policy"
	// Specifies a list of hash policies to use for ring hash load balancing. Each
	// hash policy is evaluated individually and the combined result is used to
	// route the request
	HashPolicy []*HashPolicyType `protobuf:"bytes,16,rep,name=hash_policy,json=hashPolicy" json:"hash_policy,omitempty"`
	// priority
	//
	// x-displayName: "Priority"
	// Priority routing for each route. Different connection pools are used based on the priority of the route.
	// Also, circuit-breaker configuration at destination cluster is chosen based on the route priority.
	Priority ves_io_schema4.RoutingPriority `protobuf:"varint,18,opt,name=priority,proto3,enum=ves.io.schema.RoutingPriority" json:"priority,omitempty"`
	// spdy_config
	//
	// x-displayName: "SPDY Configuration"
	// SPDY configuration for each route
	SpdyConfig *SpdyConfigType `protobuf:"bytes,19,opt,name=spdy_config,json=spdyConfig" json:"spdy_config,omitempty"`
}

func (m *RouteDestinationList) Reset()                    { *m = RouteDestinationList{} }
func (*RouteDestinationList) ProtoMessage()               {}
func (*RouteDestinationList) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

type isRouteDestinationList_HostRewriteParams interface {
	isRouteDestinationList_HostRewriteParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteDestinationList_HostRewrite struct {
	HostRewrite string `protobuf:"bytes,6,opt,name=host_rewrite,json=hostRewrite,proto3,oneof"`
}
type RouteDestinationList_AutoHostRewrite struct {
	AutoHostRewrite bool `protobuf:"varint,7,opt,name=auto_host_rewrite,json=autoHostRewrite,proto3,oneof"`
}

func (*RouteDestinationList_HostRewrite) isRouteDestinationList_HostRewriteParams()     {}
func (*RouteDestinationList_AutoHostRewrite) isRouteDestinationList_HostRewriteParams() {}

func (m *RouteDestinationList) GetHostRewriteParams() isRouteDestinationList_HostRewriteParams {
	if m != nil {
		return m.HostRewriteParams
	}
	return nil
}

func (m *RouteDestinationList) GetDestinations() []*RouteDestination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

func (m *RouteDestinationList) GetPrefixRewrite() string {
	if m != nil {
		return m.PrefixRewrite
	}
	return ""
}

func (m *RouteDestinationList) GetHostRewrite() string {
	if x, ok := m.GetHostRewriteParams().(*RouteDestinationList_HostRewrite); ok {
		return x.HostRewrite
	}
	return ""
}

func (m *RouteDestinationList) GetAutoHostRewrite() bool {
	if x, ok := m.GetHostRewriteParams().(*RouteDestinationList_AutoHostRewrite); ok {
		return x.AutoHostRewrite
	}
	return false
}

func (m *RouteDestinationList) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RouteDestinationList) GetRetryPolicy() *ves_io_schema4.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetEndpointSubsets() map[string]string {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

func (m *RouteDestinationList) GetMirrorPolicy() *MirrorPolicyType {
	if m != nil {
		return m.MirrorPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetWebSocketConfig() *WebsocketConfigType {
	if m != nil {
		return m.WebSocketConfig
	}
	return nil
}

func (m *RouteDestinationList) GetBufferPolicy() *ves_io_schema4.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetCorsPolicy() *ves_io_schema4.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetHashPolicy() []*HashPolicyType {
	if m != nil {
		return m.HashPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetPriority() ves_io_schema4.RoutingPriority {
	if m != nil {
		return m.Priority
	}
	return ves_io_schema4.DEFAULT
}

func (m *RouteDestinationList) GetSpdyConfig() *SpdyConfigType {
	if m != nil {
		return m.SpdyConfig
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteDestinationList) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteDestinationList_OneofMarshaler, _RouteDestinationList_OneofUnmarshaler, _RouteDestinationList_OneofSizer, []interface{}{
		(*RouteDestinationList_HostRewrite)(nil),
		(*RouteDestinationList_AutoHostRewrite)(nil),
	}
}

func _RouteDestinationList_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteDestinationList)
	// HostRewriteParams
	switch x := m.HostRewriteParams.(type) {
	case *RouteDestinationList_HostRewrite:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.HostRewrite)
	case *RouteDestinationList_AutoHostRewrite:
		t := uint64(0)
		if x.AutoHostRewrite {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("RouteDestinationList.HostRewriteParams has unexpected type %T", x)
	}
	return nil
}

func _RouteDestinationList_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteDestinationList)
	switch tag {
	case 6: // HostRewriteParams.host_rewrite
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HostRewriteParams = &RouteDestinationList_HostRewrite{x}
		return true, err
	case 7: // HostRewriteParams.auto_host_rewrite
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.HostRewriteParams = &RouteDestinationList_AutoHostRewrite{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _RouteDestinationList_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteDestinationList)
	// HostRewriteParams
	switch x := m.HostRewriteParams.(type) {
	case *RouteDestinationList_HostRewrite:
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.HostRewrite)))
		n += len(x.HostRewrite)
	case *RouteDestinationList_AutoHostRewrite:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RouteQueryParams
//
// x-displayName: "Query Parameters"
// Query params keys to strip while manipulating the HTTP request
type RouteQueryParams struct {
	// query_params
	//
	// x-displayName: "Query Parameters"
	// x-example: "userid"
	// Query params keys to strip while manipulating the HTTP request
	QueryParams []string `protobuf:"bytes,1,rep,name=query_params,json=queryParams" json:"query_params,omitempty"`
}

func (m *RouteQueryParams) Reset()                    { *m = RouteQueryParams{} }
func (*RouteQueryParams) ProtoMessage()               {}
func (*RouteQueryParams) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *RouteQueryParams) GetQueryParams() []string {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

// RouteRedirect
//
// x-displayName: "Redirect"
// route redirect parameters when match action is redirect.
type RouteRedirect struct {
	// host_redirect
	//
	// x-displayName: "Host"
	// x-example: "one.ves.io"
	// swap host part of incoming URL in redirect URL
	HostRedirect string `protobuf:"bytes,1,opt,name=host_redirect,json=hostRedirect,proto3" json:"host_redirect,omitempty"`
	// path_redirect
	//
	// x-displayName: "Path"
	// x-example: "/api/register"
	// swap path part of incoming URL in redirect URL
	PathRedirect string `protobuf:"bytes,2,opt,name=path_redirect,json=pathRedirect,proto3" json:"path_redirect,omitempty"`
	// proto_redirect
	//
	// x-displayName: "Protocol"
	// x-example: "https"
	// swap proto part of incoming URL in redirect URL
	ProtoRedirect string `protobuf:"bytes,3,opt,name=proto_redirect,json=protoRedirect,proto3" json:"proto_redirect,omitempty"`
	// QueryParams
	//
	// x-displayName: "Query Parameters"
	// handling of incoming query parameters in redirect request.
	//
	// Types that are valid to be assigned to QueryParams:
	//	*RouteRedirect_StripQueryParams
	//	*RouteRedirect_AllParams
	//	*RouteRedirect_RetainAllParams
	//	*RouteRedirect_RemoveAllParams
	QueryParams isRouteRedirect_QueryParams `protobuf_oneof:"QueryParams"`
	// response_code
	//
	// x-displayName: "Response Code"
	// x-example: 303
	// The HTTP status code to use in the redirect response. The default response
	// code is MOVED_PERMANENTLY (301).
	ResponseCode uint32 `protobuf:"varint,6,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
}

func (m *RouteRedirect) Reset()                    { *m = RouteRedirect{} }
func (*RouteRedirect) ProtoMessage()               {}
func (*RouteRedirect) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

type isRouteRedirect_QueryParams interface {
	isRouteRedirect_QueryParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteRedirect_StripQueryParams struct {
	StripQueryParams *RouteQueryParams `protobuf:"bytes,4,opt,name=strip_query_params,json=stripQueryParams,oneof"`
}
type RouteRedirect_AllParams struct {
	AllParams bool `protobuf:"varint,5,opt,name=all_params,json=allParams,proto3,oneof"`
}
type RouteRedirect_RetainAllParams struct {
	RetainAllParams *ves_io_schema4.Empty `protobuf:"bytes,8,opt,name=retain_all_params,json=retainAllParams,oneof"`
}
type RouteRedirect_RemoveAllParams struct {
	RemoveAllParams *ves_io_schema4.Empty `protobuf:"bytes,9,opt,name=remove_all_params,json=removeAllParams,oneof"`
}

func (*RouteRedirect_StripQueryParams) isRouteRedirect_QueryParams() {}
func (*RouteRedirect_AllParams) isRouteRedirect_QueryParams()        {}
func (*RouteRedirect_RetainAllParams) isRouteRedirect_QueryParams()  {}
func (*RouteRedirect_RemoveAllParams) isRouteRedirect_QueryParams()  {}

func (m *RouteRedirect) GetQueryParams() isRouteRedirect_QueryParams {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *RouteRedirect) GetHostRedirect() string {
	if m != nil {
		return m.HostRedirect
	}
	return ""
}

func (m *RouteRedirect) GetPathRedirect() string {
	if m != nil {
		return m.PathRedirect
	}
	return ""
}

func (m *RouteRedirect) GetProtoRedirect() string {
	if m != nil {
		return m.ProtoRedirect
	}
	return ""
}

func (m *RouteRedirect) GetStripQueryParams() *RouteQueryParams {
	if x, ok := m.GetQueryParams().(*RouteRedirect_StripQueryParams); ok {
		return x.StripQueryParams
	}
	return nil
}

func (m *RouteRedirect) GetAllParams() bool {
	if x, ok := m.GetQueryParams().(*RouteRedirect_AllParams); ok {
		return x.AllParams
	}
	return false
}

func (m *RouteRedirect) GetRetainAllParams() *ves_io_schema4.Empty {
	if x, ok := m.GetQueryParams().(*RouteRedirect_RetainAllParams); ok {
		return x.RetainAllParams
	}
	return nil
}

func (m *RouteRedirect) GetRemoveAllParams() *ves_io_schema4.Empty {
	if x, ok := m.GetQueryParams().(*RouteRedirect_RemoveAllParams); ok {
		return x.RemoveAllParams
	}
	return nil
}

func (m *RouteRedirect) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteRedirect) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteRedirect_OneofMarshaler, _RouteRedirect_OneofUnmarshaler, _RouteRedirect_OneofSizer, []interface{}{
		(*RouteRedirect_StripQueryParams)(nil),
		(*RouteRedirect_AllParams)(nil),
		(*RouteRedirect_RetainAllParams)(nil),
		(*RouteRedirect_RemoveAllParams)(nil),
	}
}

func _RouteRedirect_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteRedirect)
	// QueryParams
	switch x := m.QueryParams.(type) {
	case *RouteRedirect_StripQueryParams:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StripQueryParams); err != nil {
			return err
		}
	case *RouteRedirect_AllParams:
		t := uint64(0)
		if x.AllParams {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *RouteRedirect_RetainAllParams:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RetainAllParams); err != nil {
			return err
		}
	case *RouteRedirect_RemoveAllParams:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RemoveAllParams); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RouteRedirect.QueryParams has unexpected type %T", x)
	}
	return nil
}

func _RouteRedirect_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteRedirect)
	switch tag {
	case 4: // QueryParams.strip_query_params
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteQueryParams)
		err := b.DecodeMessage(msg)
		m.QueryParams = &RouteRedirect_StripQueryParams{msg}
		return true, err
	case 5: // QueryParams.all_params
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryParams = &RouteRedirect_AllParams{x != 0}
		return true, err
	case 8: // QueryParams.retain_all_params
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.QueryParams = &RouteRedirect_RetainAllParams{msg}
		return true, err
	case 9: // QueryParams.remove_all_params
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.QueryParams = &RouteRedirect_RemoveAllParams{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RouteRedirect_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteRedirect)
	// QueryParams
	switch x := m.QueryParams.(type) {
	case *RouteRedirect_StripQueryParams:
		s := proto.Size(x.StripQueryParams)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RouteRedirect_AllParams:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *RouteRedirect_RetainAllParams:
		s := proto.Size(x.RetainAllParams)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RouteRedirect_RemoveAllParams:
		s := proto.Size(x.RemoveAllParams)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RouteDirectResponse
//
// x-displayName: "Direct Response"
// Send this direct response in case of route match action is direct response
type RouteDirectResponse struct {
	// response_code
	//
	// x-displayName: "Response Code"
	// x-example: 200
	// response code to send
	ResponseCode uint32 `protobuf:"varint,1,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	// response_body
	//
	// x-displayName: "Response Body"
	// x-example: "OK"
	// response body to send
	ResponseBody string `protobuf:"bytes,2,opt,name=response_body,json=responseBody,proto3" json:"response_body,omitempty"`
}

func (m *RouteDirectResponse) Reset()                    { *m = RouteDirectResponse{} }
func (*RouteDirectResponse) ProtoMessage()               {}
func (*RouteDirectResponse) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *RouteDirectResponse) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *RouteDirectResponse) GetResponseBody() string {
	if m != nil {
		return m.ResponseBody
	}
	return ""
}

// ServicePolicyInfo
//
// x-displayName: "Disable Service Policy"
// ServicePolicy configuration details at route level
type ServicePolicyInfo struct {
	// disable
	//
	// x-displayName: "Disable"
	// x-example: true
	// disable service policy at route level, if it is configured at virtual-host level
	Disable bool `protobuf:"varint,1,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ServicePolicyInfo) Reset()                    { *m = ServicePolicyInfo{} }
func (*ServicePolicyInfo) ProtoMessage()               {}
func (*ServicePolicyInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *ServicePolicyInfo) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// RouteType
//
// x-displayName: "Route"
// Each RouteType is a rule which has match condition and action. When the condition is
// matched for incoming request, the specified action is taken.
type RouteType struct {
	// match
	//
	// x-displayName: "Match"
	// route match condition
	Match []*ves_io_schema4.RouteMatch `protobuf:"bytes,1,rep,name=match" json:"match,omitempty"`
	// RouteAction
	//
	// x-displayName: "Action"
	// x-required
	// one of action to take when match is successful
	//
	// Types that are valid to be assigned to RouteAction:
	//	*RouteType_RouteDestination
	//	*RouteType_RouteRedirect
	//	*RouteType_RouteDirectResponse
	RouteAction isRouteType_RouteAction `protobuf_oneof:"RouteAction"`
	// disable_custom_script
	//
	// x-displayName: "Disable Custom Script"
	// x-example: true
	// disable execution of Javascript at route level, if it is configured at virtual-host level
	DisableCustomScript bool `protobuf:"varint,5,opt,name=disable_custom_script,json=disableCustomScript,proto3" json:"disable_custom_script,omitempty"`
	// service_policy
	//
	// x-displayName: "Service Policy"
	// service policy configuration at route level which overrides configuration at virtual-host level
	ServicePolicy *ServicePolicyInfo `protobuf:"bytes,12,opt,name=service_policy,json=servicePolicy" json:"service_policy,omitempty"`
	// Headers to add in request
	//
	// x-displayName: "Request Headers to Add"
	// Headers are key-value pairs to be added to HTTP requests being sent towards upstream.
	// Headers specified at this level are applied before headers from the
	// enclosing VirtualHost object level
	RequestHeadersToAdd []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=request_headers_to_add,json=requestHeadersToAdd" json:"request_headers_to_add,omitempty"`
	// Headers to add in response
	//
	// x-displayName: "Response Headers to Add"
	// Headers are key-value pairs to be added to HTTP response being sent towards downstream.
	// Headers specified at this level are applied before headers from the
	// enclosing VirtualHost object level
	ResponseHeadersToAdd []*ves_io_schema4.HeaderManipulationOptionType `protobuf:"bytes,8,rep,name=response_headers_to_add,json=responseHeadersToAdd" json:"response_headers_to_add,omitempty"`
	// Header to be removed from request
	//
	// x-displayName: "Request Headers to Remove"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP request being sent towards upstream.
	RequestHeadersToRemove []string `protobuf:"bytes,9,rep,name=request_headers_to_remove,json=requestHeadersToRemove" json:"request_headers_to_remove,omitempty"`
	// Header to be removed from response
	//
	// x-displayName: "Response Headers to Remove"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP response being sent towards downstream.
	ResponseHeadersToRemove []string `protobuf:"bytes,10,rep,name=response_headers_to_remove,json=responseHeadersToRemove" json:"response_headers_to_remove,omitempty"`
	// Enable the WAF (Web Application Firewall) functionality for Route
	//
	// x-displayName: "WAF"
	// WAF can be used to analyze inbound and outbound http/https traffic.
	// WAF can be configured either in BLOCKing Mode or ALERTing Mode.
	// In BLOCKing mode if WAF detects suspicious inbound/outbound traffic it blocks the request or response.
	// In ALERTing mode if suspicious traffic is detected, WAF generates ALERTs with details on the
	// suspicious traffic (instead of blocking traffic).
	//
	// waf_type can be either WAF or WAFRules.
	// WAF Object allows to
	//     Configure mode of the WAF (BLOCK/ALERT)
	//     Configure language used by the application which is being protected by the WAF
	//     Disable different high level security tags if required (e.g. SQLI_DETECTION, XSS_DETECTION etc)
	// WAFRules allows to
	//     Configure mode of the WAF (BLOCK/ALERT)
	//     Enable/Disable individual WAF security rules
	//
	// waf_type specified at route level overrides waf configuration at VirtualHost level
	WafType *ves_io_schema4.WafType `protobuf:"bytes,11,opt,name=waf_type,json=wafType" json:"waf_type,omitempty"`
	// disable_location_add
	//
	// x-displayName: "Disable Location Addition"
	// x-example: true
	// disables append of x-volterra-location = <re-site-name> at route level, if it is configured at
	// virtual-host level. This configuration is ignored on CE sites.
	DisableLocationAdd bool `protobuf:"varint,13,opt,name=disable_location_add,json=disableLocationAdd,proto3" json:"disable_location_add,omitempty"`
}

func (m *RouteType) Reset()                    { *m = RouteType{} }
func (*RouteType) ProtoMessage()               {}
func (*RouteType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

type isRouteType_RouteAction interface {
	isRouteType_RouteAction()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteType_RouteDestination struct {
	RouteDestination *RouteDestinationList `protobuf:"bytes,2,opt,name=route_destination,json=routeDestination,oneof"`
}
type RouteType_RouteRedirect struct {
	RouteRedirect *RouteRedirect `protobuf:"bytes,3,opt,name=route_redirect,json=routeRedirect,oneof"`
}
type RouteType_RouteDirectResponse struct {
	RouteDirectResponse *RouteDirectResponse `protobuf:"bytes,4,opt,name=route_direct_response,json=routeDirectResponse,oneof"`
}

func (*RouteType_RouteDestination) isRouteType_RouteAction()    {}
func (*RouteType_RouteRedirect) isRouteType_RouteAction()       {}
func (*RouteType_RouteDirectResponse) isRouteType_RouteAction() {}

func (m *RouteType) GetRouteAction() isRouteType_RouteAction {
	if m != nil {
		return m.RouteAction
	}
	return nil
}

func (m *RouteType) GetMatch() []*ves_io_schema4.RouteMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *RouteType) GetRouteDestination() *RouteDestinationList {
	if x, ok := m.GetRouteAction().(*RouteType_RouteDestination); ok {
		return x.RouteDestination
	}
	return nil
}

func (m *RouteType) GetRouteRedirect() *RouteRedirect {
	if x, ok := m.GetRouteAction().(*RouteType_RouteRedirect); ok {
		return x.RouteRedirect
	}
	return nil
}

func (m *RouteType) GetRouteDirectResponse() *RouteDirectResponse {
	if x, ok := m.GetRouteAction().(*RouteType_RouteDirectResponse); ok {
		return x.RouteDirectResponse
	}
	return nil
}

func (m *RouteType) GetDisableCustomScript() bool {
	if m != nil {
		return m.DisableCustomScript
	}
	return false
}

func (m *RouteType) GetServicePolicy() *ServicePolicyInfo {
	if m != nil {
		return m.ServicePolicy
	}
	return nil
}

func (m *RouteType) GetRequestHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *RouteType) GetResponseHeadersToAdd() []*ves_io_schema4.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *RouteType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *RouteType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *RouteType) GetWafType() *ves_io_schema4.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *RouteType) GetDisableLocationAdd() bool {
	if m != nil {
		return m.DisableLocationAdd
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteType_OneofMarshaler, _RouteType_OneofUnmarshaler, _RouteType_OneofSizer, []interface{}{
		(*RouteType_RouteDestination)(nil),
		(*RouteType_RouteRedirect)(nil),
		(*RouteType_RouteDirectResponse)(nil),
	}
}

func _RouteType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteType)
	// RouteAction
	switch x := m.RouteAction.(type) {
	case *RouteType_RouteDestination:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteDestination); err != nil {
			return err
		}
	case *RouteType_RouteRedirect:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteRedirect); err != nil {
			return err
		}
	case *RouteType_RouteDirectResponse:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteDirectResponse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RouteType.RouteAction has unexpected type %T", x)
	}
	return nil
}

func _RouteType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteType)
	switch tag {
	case 2: // RouteAction.route_destination
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteDestinationList)
		err := b.DecodeMessage(msg)
		m.RouteAction = &RouteType_RouteDestination{msg}
		return true, err
	case 3: // RouteAction.route_redirect
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteRedirect)
		err := b.DecodeMessage(msg)
		m.RouteAction = &RouteType_RouteRedirect{msg}
		return true, err
	case 4: // RouteAction.route_direct_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteDirectResponse)
		err := b.DecodeMessage(msg)
		m.RouteAction = &RouteType_RouteDirectResponse{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RouteType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteType)
	// RouteAction
	switch x := m.RouteAction.(type) {
	case *RouteType_RouteDestination:
		s := proto.Size(x.RouteDestination)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RouteType_RouteRedirect:
		s := proto.Size(x.RouteRedirect)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RouteType_RouteDirectResponse:
		s := proto.Size(x.RouteDirectResponse)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Route object configuration
type GlobalSpecType struct {
	// routes
	//
	// x-displayName: "Routes"
	// x-required
	// List of routes to match for incoming request
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes" json:"routes,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

func (m *GlobalSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// CreateSpecType
//
// x-displayName: "Create Route"
// Create route object in a given namespace. Route object is list of route rules.
// Each rule has match condition to match incoming requests and actions to take on matching requests.
// Virtual host object has reference to route object
type CreateSpecType struct {
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes" json:"routes,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *CreateSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// ReplaceSpecType
//
// x-displayName: "Replace Route"
// Replace route object in a given namespace. Route object is list of route rules.
// Each rule has match condition to match incoming requests and actions to take on matching requests.
// Virtual host object has reference to route object
type ReplaceSpecType struct {
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes" json:"routes,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *ReplaceSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// GetSpecType
//
// x-displayName: "Get Route"
// Get route object in a given namespace. Route object is list of route rules.
// Each rule has match condition to match incoming requests and actions to take on matching requests.
// Virtual host object has reference to route object
type GetSpecType struct {
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes" json:"routes,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *GetSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func init() {
	proto.RegisterType((*RouteDestination)(nil), "ves.io.schema.route.RouteDestination")
	golang_proto.RegisterType((*RouteDestination)(nil), "ves.io.schema.route.RouteDestination")
	proto.RegisterType((*MirrorPolicyType)(nil), "ves.io.schema.route.MirrorPolicyType")
	golang_proto.RegisterType((*MirrorPolicyType)(nil), "ves.io.schema.route.MirrorPolicyType")
	proto.RegisterType((*SpdyConfigType)(nil), "ves.io.schema.route.SpdyConfigType")
	golang_proto.RegisterType((*SpdyConfigType)(nil), "ves.io.schema.route.SpdyConfigType")
	proto.RegisterType((*WebsocketConfigType)(nil), "ves.io.schema.route.WebsocketConfigType")
	golang_proto.RegisterType((*WebsocketConfigType)(nil), "ves.io.schema.route.WebsocketConfigType")
	proto.RegisterType((*CookieForHashing)(nil), "ves.io.schema.route.CookieForHashing")
	golang_proto.RegisterType((*CookieForHashing)(nil), "ves.io.schema.route.CookieForHashing")
	proto.RegisterType((*HashPolicyType)(nil), "ves.io.schema.route.HashPolicyType")
	golang_proto.RegisterType((*HashPolicyType)(nil), "ves.io.schema.route.HashPolicyType")
	proto.RegisterType((*RouteDestinationList)(nil), "ves.io.schema.route.RouteDestinationList")
	golang_proto.RegisterType((*RouteDestinationList)(nil), "ves.io.schema.route.RouteDestinationList")
	proto.RegisterType((*RouteQueryParams)(nil), "ves.io.schema.route.RouteQueryParams")
	golang_proto.RegisterType((*RouteQueryParams)(nil), "ves.io.schema.route.RouteQueryParams")
	proto.RegisterType((*RouteRedirect)(nil), "ves.io.schema.route.RouteRedirect")
	golang_proto.RegisterType((*RouteRedirect)(nil), "ves.io.schema.route.RouteRedirect")
	proto.RegisterType((*RouteDirectResponse)(nil), "ves.io.schema.route.RouteDirectResponse")
	golang_proto.RegisterType((*RouteDirectResponse)(nil), "ves.io.schema.route.RouteDirectResponse")
	proto.RegisterType((*ServicePolicyInfo)(nil), "ves.io.schema.route.ServicePolicyInfo")
	golang_proto.RegisterType((*ServicePolicyInfo)(nil), "ves.io.schema.route.ServicePolicyInfo")
	proto.RegisterType((*RouteType)(nil), "ves.io.schema.route.RouteType")
	golang_proto.RegisterType((*RouteType)(nil), "ves.io.schema.route.RouteType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.route.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.route.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.route.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.route.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.route.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.route.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.route.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.route.GetSpecType")
}
func (this *RouteDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestination)
	if !ok {
		that2, ok := that.(RouteDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Cluster) != len(that1.Cluster) {
		return false
	}
	for i := range this.Cluster {
		if !this.Cluster[i].Equal(that1.Cluster[i]) {
			return false
		}
	}
	if this.Weight != that1.Weight {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if this.EndpointSubsets[i] != that1.EndpointSubsets[i] {
			return false
		}
	}
	return true
}
func (this *MirrorPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MirrorPolicyType)
	if !ok {
		that2, ok := that.(MirrorPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Cluster) != len(that1.Cluster) {
		return false
	}
	for i := range this.Cluster {
		if !this.Cluster[i].Equal(that1.Cluster[i]) {
			return false
		}
	}
	if !this.Percent.Equal(that1.Percent) {
		return false
	}
	return true
}
func (this *SpdyConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpdyConfigType)
	if !ok {
		that2, ok := that.(SpdyConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UseSpdy != that1.UseSpdy {
		return false
	}
	return true
}
func (this *WebsocketConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebsocketConfigType)
	if !ok {
		that2, ok := that.(WebsocketConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UseWebsocket != that1.UseWebsocket {
		return false
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if this.MaxConnectAttempts != that1.MaxConnectAttempts {
		return false
	}
	return true
}
func (this *CookieForHashing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing)
	if !ok {
		that2, ok := that.(CookieForHashing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *HashPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType)
	if !ok {
		that2, ok := that.(HashPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PolicySpecifier == nil {
		if this.PolicySpecifier != nil {
			return false
		}
	} else if this.PolicySpecifier == nil {
		return false
	} else if !this.PolicySpecifier.Equal(that1.PolicySpecifier) {
		return false
	}
	if this.Terminal != that1.Terminal {
		return false
	}
	return true
}
func (this *HashPolicyType_HeaderName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType_HeaderName)
	if !ok {
		that2, ok := that.(HashPolicyType_HeaderName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HeaderName != that1.HeaderName {
		return false
	}
	return true
}
func (this *HashPolicyType_Cookie) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType_Cookie)
	if !ok {
		that2, ok := that.(HashPolicyType_Cookie)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cookie.Equal(that1.Cookie) {
		return false
	}
	return true
}
func (this *HashPolicyType_SourceIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType_SourceIp)
	if !ok {
		that2, ok := that.(HashPolicyType_SourceIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SourceIp != that1.SourceIp {
		return false
	}
	return true
}
func (this *RouteDestinationList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList)
	if !ok {
		that2, ok := that.(RouteDestinationList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Destinations) != len(that1.Destinations) {
		return false
	}
	for i := range this.Destinations {
		if !this.Destinations[i].Equal(that1.Destinations[i]) {
			return false
		}
	}
	if this.PrefixRewrite != that1.PrefixRewrite {
		return false
	}
	if that1.HostRewriteParams == nil {
		if this.HostRewriteParams != nil {
			return false
		}
	} else if this.HostRewriteParams == nil {
		return false
	} else if !this.HostRewriteParams.Equal(that1.HostRewriteParams) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if this.EndpointSubsets[i] != that1.EndpointSubsets[i] {
			return false
		}
	}
	if !this.MirrorPolicy.Equal(that1.MirrorPolicy) {
		return false
	}
	if !this.WebSocketConfig.Equal(that1.WebSocketConfig) {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if len(this.HashPolicy) != len(that1.HashPolicy) {
		return false
	}
	for i := range this.HashPolicy {
		if !this.HashPolicy[i].Equal(that1.HashPolicy[i]) {
			return false
		}
	}
	if this.Priority != that1.Priority {
		return false
	}
	if !this.SpdyConfig.Equal(that1.SpdyConfig) {
		return false
	}
	return true
}
func (this *RouteDestinationList_HostRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_HostRewrite)
	if !ok {
		that2, ok := that.(RouteDestinationList_HostRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostRewrite != that1.HostRewrite {
		return false
	}
	return true
}
func (this *RouteDestinationList_AutoHostRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_AutoHostRewrite)
	if !ok {
		that2, ok := that.(RouteDestinationList_AutoHostRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AutoHostRewrite != that1.AutoHostRewrite {
		return false
	}
	return true
}
func (this *RouteQueryParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteQueryParams)
	if !ok {
		that2, ok := that.(RouteQueryParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if this.QueryParams[i] != that1.QueryParams[i] {
			return false
		}
	}
	return true
}
func (this *RouteRedirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect)
	if !ok {
		that2, ok := that.(RouteRedirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostRedirect != that1.HostRedirect {
		return false
	}
	if this.PathRedirect != that1.PathRedirect {
		return false
	}
	if this.ProtoRedirect != that1.ProtoRedirect {
		return false
	}
	if that1.QueryParams == nil {
		if this.QueryParams != nil {
			return false
		}
	} else if this.QueryParams == nil {
		return false
	} else if !this.QueryParams.Equal(that1.QueryParams) {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	return true
}
func (this *RouteRedirect_StripQueryParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_StripQueryParams)
	if !ok {
		that2, ok := that.(RouteRedirect_StripQueryParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StripQueryParams.Equal(that1.StripQueryParams) {
		return false
	}
	return true
}
func (this *RouteRedirect_AllParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_AllParams)
	if !ok {
		that2, ok := that.(RouteRedirect_AllParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AllParams != that1.AllParams {
		return false
	}
	return true
}
func (this *RouteRedirect_RetainAllParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_RetainAllParams)
	if !ok {
		that2, ok := that.(RouteRedirect_RetainAllParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RetainAllParams.Equal(that1.RetainAllParams) {
		return false
	}
	return true
}
func (this *RouteRedirect_RemoveAllParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_RemoveAllParams)
	if !ok {
		that2, ok := that.(RouteRedirect_RemoveAllParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RemoveAllParams.Equal(that1.RemoveAllParams) {
		return false
	}
	return true
}
func (this *RouteDirectResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDirectResponse)
	if !ok {
		that2, ok := that.(RouteDirectResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	if this.ResponseBody != that1.ResponseBody {
		return false
	}
	return true
}
func (this *ServicePolicyInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicePolicyInfo)
	if !ok {
		that2, ok := that.(ServicePolicyInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *RouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType)
	if !ok {
		that2, ok := that.(RouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Match) != len(that1.Match) {
		return false
	}
	for i := range this.Match {
		if !this.Match[i].Equal(that1.Match[i]) {
			return false
		}
	}
	if that1.RouteAction == nil {
		if this.RouteAction != nil {
			return false
		}
	} else if this.RouteAction == nil {
		return false
	} else if !this.RouteAction.Equal(that1.RouteAction) {
		return false
	}
	if this.DisableCustomScript != that1.DisableCustomScript {
		return false
	}
	if !this.ServicePolicy.Equal(that1.ServicePolicy) {
		return false
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if this.DisableLocationAdd != that1.DisableLocationAdd {
		return false
	}
	return true
}
func (this *RouteType_RouteDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_RouteDestination)
	if !ok {
		that2, ok := that.(RouteType_RouteDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteDestination.Equal(that1.RouteDestination) {
		return false
	}
	return true
}
func (this *RouteType_RouteRedirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_RouteRedirect)
	if !ok {
		that2, ok := that.(RouteType_RouteRedirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteRedirect.Equal(that1.RouteRedirect) {
		return false
	}
	return true
}
func (this *RouteType_RouteDirectResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_RouteDirectResponse)
	if !ok {
		that2, ok := that.(RouteType_RouteDirectResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteDirectResponse.Equal(that1.RouteDirectResponse) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *RouteDestination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&route.RouteDestination{")
	if this.Cluster != nil {
		s = append(s, "Cluster: "+fmt.Sprintf("%#v", this.Cluster)+",\n")
	}
	s = append(s, "Weight: "+fmt.Sprintf("%#v", this.Weight)+",\n")
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%#v: %#v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+mapStringForEndpointSubsets+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MirrorPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.MirrorPolicyType{")
	if this.Cluster != nil {
		s = append(s, "Cluster: "+fmt.Sprintf("%#v", this.Cluster)+",\n")
	}
	if this.Percent != nil {
		s = append(s, "Percent: "+fmt.Sprintf("%#v", this.Percent)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpdyConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.SpdyConfigType{")
	s = append(s, "UseSpdy: "+fmt.Sprintf("%#v", this.UseSpdy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WebsocketConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&route.WebsocketConfigType{")
	s = append(s, "UseWebsocket: "+fmt.Sprintf("%#v", this.UseWebsocket)+",\n")
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	s = append(s, "MaxConnectAttempts: "+fmt.Sprintf("%#v", this.MaxConnectAttempts)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieForHashing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&route.CookieForHashing{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Ttl: "+fmt.Sprintf("%#v", this.Ttl)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HashPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&route.HashPolicyType{")
	if this.PolicySpecifier != nil {
		s = append(s, "PolicySpecifier: "+fmt.Sprintf("%#v", this.PolicySpecifier)+",\n")
	}
	s = append(s, "Terminal: "+fmt.Sprintf("%#v", this.Terminal)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HashPolicyType_HeaderName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.HashPolicyType_HeaderName{` +
		`HeaderName:` + fmt.Sprintf("%#v", this.HeaderName) + `}`}, ", ")
	return s
}
func (this *HashPolicyType_Cookie) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.HashPolicyType_Cookie{` +
		`Cookie:` + fmt.Sprintf("%#v", this.Cookie) + `}`}, ", ")
	return s
}
func (this *HashPolicyType_SourceIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.HashPolicyType_SourceIp{` +
		`SourceIp:` + fmt.Sprintf("%#v", this.SourceIp) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&route.RouteDestinationList{")
	if this.Destinations != nil {
		s = append(s, "Destinations: "+fmt.Sprintf("%#v", this.Destinations)+",\n")
	}
	s = append(s, "PrefixRewrite: "+fmt.Sprintf("%#v", this.PrefixRewrite)+",\n")
	if this.HostRewriteParams != nil {
		s = append(s, "HostRewriteParams: "+fmt.Sprintf("%#v", this.HostRewriteParams)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%#v: %#v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+mapStringForEndpointSubsets+",\n")
	}
	if this.MirrorPolicy != nil {
		s = append(s, "MirrorPolicy: "+fmt.Sprintf("%#v", this.MirrorPolicy)+",\n")
	}
	if this.WebSocketConfig != nil {
		s = append(s, "WebSocketConfig: "+fmt.Sprintf("%#v", this.WebSocketConfig)+",\n")
	}
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	if this.HashPolicy != nil {
		s = append(s, "HashPolicy: "+fmt.Sprintf("%#v", this.HashPolicy)+",\n")
	}
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.SpdyConfig != nil {
		s = append(s, "SpdyConfig: "+fmt.Sprintf("%#v", this.SpdyConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteDestinationList_HostRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_HostRewrite{` +
		`HostRewrite:` + fmt.Sprintf("%#v", this.HostRewrite) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList_AutoHostRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_AutoHostRewrite{` +
		`AutoHostRewrite:` + fmt.Sprintf("%#v", this.AutoHostRewrite) + `}`}, ", ")
	return s
}
func (this *RouteQueryParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.RouteQueryParams{")
	s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteRedirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&route.RouteRedirect{")
	s = append(s, "HostRedirect: "+fmt.Sprintf("%#v", this.HostRedirect)+",\n")
	s = append(s, "PathRedirect: "+fmt.Sprintf("%#v", this.PathRedirect)+",\n")
	s = append(s, "ProtoRedirect: "+fmt.Sprintf("%#v", this.ProtoRedirect)+",\n")
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteRedirect_StripQueryParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_StripQueryParams{` +
		`StripQueryParams:` + fmt.Sprintf("%#v", this.StripQueryParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_AllParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_AllParams{` +
		`AllParams:` + fmt.Sprintf("%#v", this.AllParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_RetainAllParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_RetainAllParams{` +
		`RetainAllParams:` + fmt.Sprintf("%#v", this.RetainAllParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_RemoveAllParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_RemoveAllParams{` +
		`RemoveAllParams:` + fmt.Sprintf("%#v", this.RemoveAllParams) + `}`}, ", ")
	return s
}
func (this *RouteDirectResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.RouteDirectResponse{")
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "ResponseBody: "+fmt.Sprintf("%#v", this.ResponseBody)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServicePolicyInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.ServicePolicyInfo{")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&route.RouteType{")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	if this.RouteAction != nil {
		s = append(s, "RouteAction: "+fmt.Sprintf("%#v", this.RouteAction)+",\n")
	}
	s = append(s, "DisableCustomScript: "+fmt.Sprintf("%#v", this.DisableCustomScript)+",\n")
	if this.ServicePolicy != nil {
		s = append(s, "ServicePolicy: "+fmt.Sprintf("%#v", this.ServicePolicy)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	s = append(s, "DisableLocationAdd: "+fmt.Sprintf("%#v", this.DisableLocationAdd)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteType_RouteDestination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_RouteDestination{` +
		`RouteDestination:` + fmt.Sprintf("%#v", this.RouteDestination) + `}`}, ", ")
	return s
}
func (this *RouteType_RouteRedirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_RouteRedirect{` +
		`RouteRedirect:` + fmt.Sprintf("%#v", this.RouteRedirect) + `}`}, ", ")
	return s
}
func (this *RouteType_RouteDirectResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_RouteDirectResponse{` +
		`RouteDirectResponse:` + fmt.Sprintf("%#v", this.RouteDirectResponse) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.GlobalSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.CreateSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.ReplaceSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.GetSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *RouteDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDestination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		for _, msg := range m.Cluster {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Weight != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Weight))
	}
	if len(m.EndpointSubsets) > 0 {
		keysForEndpointSubsets := make([]string, 0, len(m.EndpointSubsets))
		for k, _ := range m.EndpointSubsets {
			keysForEndpointSubsets = append(keysForEndpointSubsets, string(k))
		}
		sortkeys.Strings(keysForEndpointSubsets)
		for _, k := range keysForEndpointSubsets {
			dAtA[i] = 0x22
			i++
			v := m.EndpointSubsets[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *MirrorPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		for _, msg := range m.Cluster {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Percent != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Percent.Size()))
		n1, err := m.Percent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *SpdyConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpdyConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseSpdy {
		dAtA[i] = 0x8
		i++
		if m.UseSpdy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *WebsocketConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebsocketConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseWebsocket {
		dAtA[i] = 0x8
		i++
		if m.UseWebsocket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
	}
	if m.MaxConnectAttempts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxConnectAttempts))
	}
	return i, nil
}

func (m *CookieForHashing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieForHashing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	return i, nil
}

func (m *HashPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashPolicyType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicySpecifier != nil {
		nn2, err := m.PolicySpecifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	if m.Terminal {
		dAtA[i] = 0x20
		i++
		if m.Terminal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HashPolicyType_HeaderName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderName)))
	i += copy(dAtA[i:], m.HeaderName)
	return i, nil
}
func (m *HashPolicyType_Cookie) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Cookie != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Cookie.Size()))
		n3, err := m.Cookie.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *HashPolicyType_SourceIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	if m.SourceIp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *RouteDestinationList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDestinationList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destinations) > 0 {
		for _, msg := range m.Destinations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PrefixRewrite) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrefixRewrite)))
		i += copy(dAtA[i:], m.PrefixRewrite)
	}
	if m.HostRewriteParams != nil {
		nn4, err := m.HostRewriteParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Timeout))
	}
	if m.RetryPolicy != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RetryPolicy.Size()))
		n5, err := m.RetryPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.EndpointSubsets) > 0 {
		keysForEndpointSubsets := make([]string, 0, len(m.EndpointSubsets))
		for k, _ := range m.EndpointSubsets {
			keysForEndpointSubsets = append(keysForEndpointSubsets, string(k))
		}
		sortkeys.Strings(keysForEndpointSubsets)
		for _, k := range keysForEndpointSubsets {
			dAtA[i] = 0x52
			i++
			v := m.EndpointSubsets[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.MirrorPolicy != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MirrorPolicy.Size()))
		n6, err := m.MirrorPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.WebSocketConfig != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WebSocketConfig.Size()))
		n7, err := m.WebSocketConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.BufferPolicy != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BufferPolicy.Size()))
		n8, err := m.BufferPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.CorsPolicy != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CorsPolicy.Size()))
		n9, err := m.CorsPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.HashPolicy) > 0 {
		for _, msg := range m.HashPolicy {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Priority != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
	}
	if m.SpdyConfig != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SpdyConfig.Size()))
		n10, err := m.SpdyConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *RouteDestinationList_HostRewrite) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x32
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.HostRewrite)))
	i += copy(dAtA[i:], m.HostRewrite)
	return i, nil
}
func (m *RouteDestinationList_AutoHostRewrite) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x38
	i++
	if m.AutoHostRewrite {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *RouteQueryParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteQueryParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for _, s := range m.QueryParams {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *RouteRedirect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteRedirect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostRedirect) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostRedirect)))
		i += copy(dAtA[i:], m.HostRedirect)
	}
	if len(m.PathRedirect) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PathRedirect)))
		i += copy(dAtA[i:], m.PathRedirect)
	}
	if len(m.ProtoRedirect) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProtoRedirect)))
		i += copy(dAtA[i:], m.ProtoRedirect)
	}
	if m.QueryParams != nil {
		nn11, err := m.QueryParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	if m.ResponseCode != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ResponseCode))
	}
	return i, nil
}

func (m *RouteRedirect_StripQueryParams) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StripQueryParams != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StripQueryParams.Size()))
		n12, err := m.StripQueryParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *RouteRedirect_AllParams) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x28
	i++
	if m.AllParams {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *RouteRedirect_RetainAllParams) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RetainAllParams != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RetainAllParams.Size()))
		n13, err := m.RetainAllParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *RouteRedirect_RemoveAllParams) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RemoveAllParams != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RemoveAllParams.Size()))
		n14, err := m.RemoveAllParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *RouteDirectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDirectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ResponseCode))
	}
	if len(m.ResponseBody) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseBody)))
		i += copy(dAtA[i:], m.ResponseBody)
	}
	return i, nil
}

func (m *ServicePolicyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServicePolicyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Disable {
		dAtA[i] = 0x8
		i++
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, msg := range m.Match {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RouteAction != nil {
		nn15, err := m.RouteAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	if m.DisableCustomScript {
		dAtA[i] = 0x28
		i++
		if m.DisableCustomScript {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, msg := range m.RequestHeadersToAdd {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, msg := range m.ResponseHeadersToAdd {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.WafType != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafType.Size()))
		n16, err := m.WafType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.ServicePolicy != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServicePolicy.Size()))
		n17, err := m.ServicePolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.DisableLocationAdd {
		dAtA[i] = 0x68
		i++
		if m.DisableLocationAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RouteType_RouteDestination) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RouteDestination != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RouteDestination.Size()))
		n18, err := m.RouteDestination.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *RouteType_RouteRedirect) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RouteRedirect != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RouteRedirect.Size()))
		n19, err := m.RouteRedirect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *RouteType_RouteDirectResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RouteDirectResponse != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RouteDirectResponse.Size()))
		n20, err := m.RouteDirectResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedRouteDestination(r randyTypes, easy bool) *RouteDestination {
	this := &RouteDestination{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Cluster = make([]*ves_io_schema4.ObjectRefType, v1)
		for i := 0; i < v1; i++ {
			this.Cluster[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	this.Weight = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v2 := r.Intn(10)
		this.EndpointSubsets = make(map[string]string)
		for i := 0; i < v2; i++ {
			this.EndpointSubsets[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMirrorPolicyType(r randyTypes, easy bool) *MirrorPolicyType {
	this := &MirrorPolicyType{}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Cluster = make([]*ves_io_schema4.ObjectRefType, v3)
		for i := 0; i < v3; i++ {
			this.Cluster[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Percent = ves_io_schema4.NewPopulatedFractionalPercent(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSpdyConfigType(r randyTypes, easy bool) *SpdyConfigType {
	this := &SpdyConfigType{}
	this.UseSpdy = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWebsocketConfigType(r randyTypes, easy bool) *WebsocketConfigType {
	this := &WebsocketConfigType{}
	this.UseWebsocket = bool(bool(r.Intn(2) == 0))
	this.IdleTimeout = uint32(r.Uint32())
	this.MaxConnectAttempts = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCookieForHashing(r randyTypes, easy bool) *CookieForHashing {
	this := &CookieForHashing{}
	this.Name = string(randStringTypes(r))
	this.Ttl = uint32(r.Uint32())
	this.Path = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHashPolicyType(r randyTypes, easy bool) *HashPolicyType {
	this := &HashPolicyType{}
	oneofNumber_PolicySpecifier := []int32{1, 2, 3}[r.Intn(3)]
	switch oneofNumber_PolicySpecifier {
	case 1:
		this.PolicySpecifier = NewPopulatedHashPolicyType_HeaderName(r, easy)
	case 2:
		this.PolicySpecifier = NewPopulatedHashPolicyType_Cookie(r, easy)
	case 3:
		this.PolicySpecifier = NewPopulatedHashPolicyType_SourceIp(r, easy)
	}
	this.Terminal = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHashPolicyType_HeaderName(r randyTypes, easy bool) *HashPolicyType_HeaderName {
	this := &HashPolicyType_HeaderName{}
	this.HeaderName = string(randStringTypes(r))
	return this
}
func NewPopulatedHashPolicyType_Cookie(r randyTypes, easy bool) *HashPolicyType_Cookie {
	this := &HashPolicyType_Cookie{}
	this.Cookie = NewPopulatedCookieForHashing(r, easy)
	return this
}
func NewPopulatedHashPolicyType_SourceIp(r randyTypes, easy bool) *HashPolicyType_SourceIp {
	this := &HashPolicyType_SourceIp{}
	this.SourceIp = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedRouteDestinationList(r randyTypes, easy bool) *RouteDestinationList {
	this := &RouteDestinationList{}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.Destinations = make([]*RouteDestination, v4)
		for i := 0; i < v4; i++ {
			this.Destinations[i] = NewPopulatedRouteDestination(r, easy)
		}
	}
	this.PrefixRewrite = string(randStringTypes(r))
	oneofNumber_HostRewriteParams := []int32{6, 7}[r.Intn(2)]
	switch oneofNumber_HostRewriteParams {
	case 6:
		this.HostRewriteParams = NewPopulatedRouteDestinationList_HostRewrite(r, easy)
	case 7:
		this.HostRewriteParams = NewPopulatedRouteDestinationList_AutoHostRewrite(r, easy)
	}
	this.Timeout = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.RetryPolicy = ves_io_schema4.NewPopulatedRetryPolicyType(r, easy)
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.EndpointSubsets = make(map[string]string)
		for i := 0; i < v5; i++ {
			this.EndpointSubsets[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		this.MirrorPolicy = NewPopulatedMirrorPolicyType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.WebSocketConfig = NewPopulatedWebsocketConfigType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BufferPolicy = ves_io_schema4.NewPopulatedBufferConfigType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CorsPolicy = ves_io_schema4.NewPopulatedCorsPolicy(r, easy)
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.HashPolicy = make([]*HashPolicyType, v6)
		for i := 0; i < v6; i++ {
			this.HashPolicy[i] = NewPopulatedHashPolicyType(r, easy)
		}
	}
	this.Priority = ves_io_schema4.RoutingPriority([]int32{0, 1}[r.Intn(2)])
	if r.Intn(10) != 0 {
		this.SpdyConfig = NewPopulatedSpdyConfigType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRouteDestinationList_HostRewrite(r randyTypes, easy bool) *RouteDestinationList_HostRewrite {
	this := &RouteDestinationList_HostRewrite{}
	this.HostRewrite = string(randStringTypes(r))
	return this
}
func NewPopulatedRouteDestinationList_AutoHostRewrite(r randyTypes, easy bool) *RouteDestinationList_AutoHostRewrite {
	this := &RouteDestinationList_AutoHostRewrite{}
	this.AutoHostRewrite = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedRouteQueryParams(r randyTypes, easy bool) *RouteQueryParams {
	this := &RouteQueryParams{}
	v7 := r.Intn(10)
	this.QueryParams = make([]string, v7)
	for i := 0; i < v7; i++ {
		this.QueryParams[i] = string(randStringTypes(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRouteRedirect(r randyTypes, easy bool) *RouteRedirect {
	this := &RouteRedirect{}
	this.HostRedirect = string(randStringTypes(r))
	this.PathRedirect = string(randStringTypes(r))
	this.ProtoRedirect = string(randStringTypes(r))
	oneofNumber_QueryParams := []int32{4, 5, 8, 9}[r.Intn(4)]
	switch oneofNumber_QueryParams {
	case 4:
		this.QueryParams = NewPopulatedRouteRedirect_StripQueryParams(r, easy)
	case 5:
		this.QueryParams = NewPopulatedRouteRedirect_AllParams(r, easy)
	case 8:
		this.QueryParams = NewPopulatedRouteRedirect_RetainAllParams(r, easy)
	case 9:
		this.QueryParams = NewPopulatedRouteRedirect_RemoveAllParams(r, easy)
	}
	this.ResponseCode = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRouteRedirect_StripQueryParams(r randyTypes, easy bool) *RouteRedirect_StripQueryParams {
	this := &RouteRedirect_StripQueryParams{}
	this.StripQueryParams = NewPopulatedRouteQueryParams(r, easy)
	return this
}
func NewPopulatedRouteRedirect_AllParams(r randyTypes, easy bool) *RouteRedirect_AllParams {
	this := &RouteRedirect_AllParams{}
	this.AllParams = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedRouteRedirect_RetainAllParams(r randyTypes, easy bool) *RouteRedirect_RetainAllParams {
	this := &RouteRedirect_RetainAllParams{}
	this.RetainAllParams = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedRouteRedirect_RemoveAllParams(r randyTypes, easy bool) *RouteRedirect_RemoveAllParams {
	this := &RouteRedirect_RemoveAllParams{}
	this.RemoveAllParams = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedRouteDirectResponse(r randyTypes, easy bool) *RouteDirectResponse {
	this := &RouteDirectResponse{}
	this.ResponseCode = uint32(r.Uint32())
	this.ResponseBody = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedServicePolicyInfo(r randyTypes, easy bool) *ServicePolicyInfo {
	this := &ServicePolicyInfo{}
	this.Disable = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRouteType(r randyTypes, easy bool) *RouteType {
	this := &RouteType{}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.Match = make([]*ves_io_schema4.RouteMatch, v8)
		for i := 0; i < v8; i++ {
			this.Match[i] = ves_io_schema4.NewPopulatedRouteMatch(r, easy)
		}
	}
	oneofNumber_RouteAction := []int32{2, 3, 4}[r.Intn(3)]
	switch oneofNumber_RouteAction {
	case 2:
		this.RouteAction = NewPopulatedRouteType_RouteDestination(r, easy)
	case 3:
		this.RouteAction = NewPopulatedRouteType_RouteRedirect(r, easy)
	case 4:
		this.RouteAction = NewPopulatedRouteType_RouteDirectResponse(r, easy)
	}
	this.DisableCustomScript = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.RequestHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v9)
		for i := 0; i < v9; i++ {
			this.RequestHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.ResponseHeadersToAdd = make([]*ves_io_schema4.HeaderManipulationOptionType, v10)
		for i := 0; i < v10; i++ {
			this.ResponseHeadersToAdd[i] = ves_io_schema4.NewPopulatedHeaderManipulationOptionType(r, easy)
		}
	}
	v11 := r.Intn(10)
	this.RequestHeadersToRemove = make([]string, v11)
	for i := 0; i < v11; i++ {
		this.RequestHeadersToRemove[i] = string(randStringTypes(r))
	}
	v12 := r.Intn(10)
	this.ResponseHeadersToRemove = make([]string, v12)
	for i := 0; i < v12; i++ {
		this.ResponseHeadersToRemove[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.WafType = ves_io_schema4.NewPopulatedWafType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ServicePolicy = NewPopulatedServicePolicyInfo(r, easy)
	}
	this.DisableLocationAdd = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRouteType_RouteDestination(r randyTypes, easy bool) *RouteType_RouteDestination {
	this := &RouteType_RouteDestination{}
	this.RouteDestination = NewPopulatedRouteDestinationList(r, easy)
	return this
}
func NewPopulatedRouteType_RouteRedirect(r randyTypes, easy bool) *RouteType_RouteRedirect {
	this := &RouteType_RouteRedirect{}
	this.RouteRedirect = NewPopulatedRouteRedirect(r, easy)
	return this
}
func NewPopulatedRouteType_RouteDirectResponse(r randyTypes, easy bool) *RouteType_RouteDirectResponse {
	this := &RouteType_RouteDirectResponse{}
	this.RouteDirectResponse = NewPopulatedRouteDirectResponse(r, easy)
	return this
}
func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.Routes = make([]*RouteType, v13)
		for i := 0; i < v13; i++ {
			this.Routes[i] = NewPopulatedRouteType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	if r.Intn(10) != 0 {
		v14 := r.Intn(5)
		this.Routes = make([]*RouteType, v14)
		for i := 0; i < v14; i++ {
			this.Routes[i] = NewPopulatedRouteType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	if r.Intn(10) != 0 {
		v15 := r.Intn(5)
		this.Routes = make([]*RouteType, v15)
		for i := 0; i < v15; i++ {
			this.Routes[i] = NewPopulatedRouteType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.Routes = make([]*RouteType, v16)
		for i := 0; i < v16; i++ {
			this.Routes[i] = NewPopulatedRouteType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v17 := r.Intn(100)
	tmps := make([]rune, v17)
	for i := 0; i < v17; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v18 := r.Int63()
		if r.Intn(2) == 0 {
			v18 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v18))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *RouteDestination) Size() (n int) {
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		for _, e := range m.Cluster {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Weight != 0 {
		n += 1 + sovTypes(uint64(m.Weight))
	}
	if len(m.EndpointSubsets) > 0 {
		for k, v := range m.EndpointSubsets {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MirrorPolicyType) Size() (n int) {
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		for _, e := range m.Cluster {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Percent != nil {
		l = m.Percent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SpdyConfigType) Size() (n int) {
	var l int
	_ = l
	if m.UseSpdy {
		n += 2
	}
	return n
}

func (m *WebsocketConfigType) Size() (n int) {
	var l int
	_ = l
	if m.UseWebsocket {
		n += 2
	}
	if m.IdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.MaxConnectAttempts != 0 {
		n += 1 + sovTypes(uint64(m.MaxConnectAttempts))
	}
	return n
}

func (m *CookieForHashing) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovTypes(uint64(m.Ttl))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *HashPolicyType) Size() (n int) {
	var l int
	_ = l
	if m.PolicySpecifier != nil {
		n += m.PolicySpecifier.Size()
	}
	if m.Terminal {
		n += 2
	}
	return n
}

func (m *HashPolicyType_HeaderName) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeaderName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HashPolicyType_Cookie) Size() (n int) {
	var l int
	_ = l
	if m.Cookie != nil {
		l = m.Cookie.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HashPolicyType_SourceIp) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteDestinationList) Size() (n int) {
	var l int
	_ = l
	if len(m.Destinations) > 0 {
		for _, e := range m.Destinations {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PrefixRewrite)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HostRewriteParams != nil {
		n += m.HostRewriteParams.Size()
	}
	if m.Timeout != 0 {
		n += 1 + sovTypes(uint64(m.Timeout))
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EndpointSubsets) > 0 {
		for k, v := range m.EndpointSubsets {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MirrorPolicy != nil {
		l = m.MirrorPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WebSocketConfig != nil {
		l = m.WebSocketConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.HashPolicy) > 0 {
		for _, e := range m.HashPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Priority != 0 {
		n += 2 + sovTypes(uint64(m.Priority))
	}
	if m.SpdyConfig != nil {
		l = m.SpdyConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RouteDestinationList_HostRewrite) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostRewrite)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteDestinationList_AutoHostRewrite) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteQueryParams) Size() (n int) {
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for _, s := range m.QueryParams {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *RouteRedirect) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostRedirect)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PathRedirect)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProtoRedirect)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.QueryParams != nil {
		n += m.QueryParams.Size()
	}
	if m.ResponseCode != 0 {
		n += 1 + sovTypes(uint64(m.ResponseCode))
	}
	return n
}

func (m *RouteRedirect_StripQueryParams) Size() (n int) {
	var l int
	_ = l
	if m.StripQueryParams != nil {
		l = m.StripQueryParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteRedirect_AllParams) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteRedirect_RetainAllParams) Size() (n int) {
	var l int
	_ = l
	if m.RetainAllParams != nil {
		l = m.RetainAllParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteRedirect_RemoveAllParams) Size() (n int) {
	var l int
	_ = l
	if m.RemoveAllParams != nil {
		l = m.RemoveAllParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteDirectResponse) Size() (n int) {
	var l int
	_ = l
	if m.ResponseCode != 0 {
		n += 1 + sovTypes(uint64(m.ResponseCode))
	}
	l = len(m.ResponseBody)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ServicePolicyInfo) Size() (n int) {
	var l int
	_ = l
	if m.Disable {
		n += 2
	}
	return n
}

func (m *RouteType) Size() (n int) {
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, e := range m.Match {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RouteAction != nil {
		n += m.RouteAction.Size()
	}
	if m.DisableCustomScript {
		n += 2
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServicePolicy != nil {
		l = m.ServicePolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DisableLocationAdd {
		n += 2
	}
	return n
}

func (m *RouteType_RouteDestination) Size() (n int) {
	var l int
	_ = l
	if m.RouteDestination != nil {
		l = m.RouteDestination.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType_RouteRedirect) Size() (n int) {
	var l int
	_ = l
	if m.RouteRedirect != nil {
		l = m.RouteRedirect.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType_RouteDirectResponse) Size() (n int) {
	var l int
	_ = l
	if m.RouteDirectResponse != nil {
		l = m.RouteDirectResponse.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RouteDestination) String() string {
	if this == nil {
		return "nil"
	}
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%v: %v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	s := strings.Join([]string{`&RouteDestination{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`Weight:` + fmt.Sprintf("%v", this.Weight) + `,`,
		`EndpointSubsets:` + mapStringForEndpointSubsets + `,`,
		`}`,
	}, "")
	return s
}
func (this *MirrorPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MirrorPolicyType{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`Percent:` + strings.Replace(fmt.Sprintf("%v", this.Percent), "FractionalPercent", "ves_io_schema4.FractionalPercent", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpdyConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpdyConfigType{`,
		`UseSpdy:` + fmt.Sprintf("%v", this.UseSpdy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebsocketConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebsocketConfigType{`,
		`UseWebsocket:` + fmt.Sprintf("%v", this.UseWebsocket) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`MaxConnectAttempts:` + fmt.Sprintf("%v", this.MaxConnectAttempts) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Ttl:` + fmt.Sprintf("%v", this.Ttl) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType{`,
		`PolicySpecifier:` + fmt.Sprintf("%v", this.PolicySpecifier) + `,`,
		`Terminal:` + fmt.Sprintf("%v", this.Terminal) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType_HeaderName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType_HeaderName{`,
		`HeaderName:` + fmt.Sprintf("%v", this.HeaderName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType_Cookie) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType_Cookie{`,
		`Cookie:` + strings.Replace(fmt.Sprintf("%v", this.Cookie), "CookieForHashing", "CookieForHashing", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType_SourceIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType_SourceIp{`,
		`SourceIp:` + fmt.Sprintf("%v", this.SourceIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList) String() string {
	if this == nil {
		return "nil"
	}
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%v: %v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	s := strings.Join([]string{`&RouteDestinationList{`,
		`Destinations:` + strings.Replace(fmt.Sprintf("%v", this.Destinations), "RouteDestination", "RouteDestination", 1) + `,`,
		`PrefixRewrite:` + fmt.Sprintf("%v", this.PrefixRewrite) + `,`,
		`HostRewriteParams:` + fmt.Sprintf("%v", this.HostRewriteParams) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "ves_io_schema4.RetryPolicyType", 1) + `,`,
		`EndpointSubsets:` + mapStringForEndpointSubsets + `,`,
		`MirrorPolicy:` + strings.Replace(fmt.Sprintf("%v", this.MirrorPolicy), "MirrorPolicyType", "MirrorPolicyType", 1) + `,`,
		`WebSocketConfig:` + strings.Replace(fmt.Sprintf("%v", this.WebSocketConfig), "WebsocketConfigType", "WebsocketConfigType", 1) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "ves_io_schema4.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "ves_io_schema4.CorsPolicy", 1) + `,`,
		`HashPolicy:` + strings.Replace(fmt.Sprintf("%v", this.HashPolicy), "HashPolicyType", "HashPolicyType", 1) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`SpdyConfig:` + strings.Replace(fmt.Sprintf("%v", this.SpdyConfig), "SpdyConfigType", "SpdyConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_HostRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_HostRewrite{`,
		`HostRewrite:` + fmt.Sprintf("%v", this.HostRewrite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_AutoHostRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_AutoHostRewrite{`,
		`AutoHostRewrite:` + fmt.Sprintf("%v", this.AutoHostRewrite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteQueryParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteQueryParams{`,
		`QueryParams:` + fmt.Sprintf("%v", this.QueryParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect{`,
		`HostRedirect:` + fmt.Sprintf("%v", this.HostRedirect) + `,`,
		`PathRedirect:` + fmt.Sprintf("%v", this.PathRedirect) + `,`,
		`ProtoRedirect:` + fmt.Sprintf("%v", this.ProtoRedirect) + `,`,
		`QueryParams:` + fmt.Sprintf("%v", this.QueryParams) + `,`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_StripQueryParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_StripQueryParams{`,
		`StripQueryParams:` + strings.Replace(fmt.Sprintf("%v", this.StripQueryParams), "RouteQueryParams", "RouteQueryParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_AllParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_AllParams{`,
		`AllParams:` + fmt.Sprintf("%v", this.AllParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_RetainAllParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_RetainAllParams{`,
		`RetainAllParams:` + strings.Replace(fmt.Sprintf("%v", this.RetainAllParams), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_RemoveAllParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_RemoveAllParams{`,
		`RemoveAllParams:` + strings.Replace(fmt.Sprintf("%v", this.RemoveAllParams), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDirectResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDirectResponse{`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`ResponseBody:` + fmt.Sprintf("%v", this.ResponseBody) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicePolicyInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicePolicyInfo{`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType{`,
		`Match:` + strings.Replace(fmt.Sprintf("%v", this.Match), "RouteMatch", "ves_io_schema4.RouteMatch", 1) + `,`,
		`RouteAction:` + fmt.Sprintf("%v", this.RouteAction) + `,`,
		`DisableCustomScript:` + fmt.Sprintf("%v", this.DisableCustomScript) + `,`,
		`RequestHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.RequestHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`ResponseHeadersToAdd:` + strings.Replace(fmt.Sprintf("%v", this.ResponseHeadersToAdd), "HeaderManipulationOptionType", "ves_io_schema4.HeaderManipulationOptionType", 1) + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "ves_io_schema4.WafType", 1) + `,`,
		`ServicePolicy:` + strings.Replace(fmt.Sprintf("%v", this.ServicePolicy), "ServicePolicyInfo", "ServicePolicyInfo", 1) + `,`,
		`DisableLocationAdd:` + fmt.Sprintf("%v", this.DisableLocationAdd) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_RouteDestination) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_RouteDestination{`,
		`RouteDestination:` + strings.Replace(fmt.Sprintf("%v", this.RouteDestination), "RouteDestinationList", "RouteDestinationList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_RouteRedirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_RouteRedirect{`,
		`RouteRedirect:` + strings.Replace(fmt.Sprintf("%v", this.RouteRedirect), "RouteRedirect", "RouteRedirect", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_RouteDirectResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_RouteDirectResponse{`,
		`RouteDirectResponse:` + strings.Replace(fmt.Sprintf("%v", this.RouteDirectResponse), "RouteDirectResponse", "RouteDirectResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Routes:` + strings.Replace(fmt.Sprintf("%v", this.Routes), "RouteType", "RouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Routes:` + strings.Replace(fmt.Sprintf("%v", this.Routes), "RouteType", "RouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Routes:` + strings.Replace(fmt.Sprintf("%v", this.Routes), "RouteType", "RouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Routes:` + strings.Replace(fmt.Sprintf("%v", this.Routes), "RouteType", "RouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *RouteDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = append(m.Cluster, &ves_io_schema4.ObjectRefType{})
			if err := m.Cluster[len(m.Cluster)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointSubsets == nil {
				m.EndpointSubsets = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EndpointSubsets[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = append(m.Cluster, &ves_io_schema4.ObjectRefType{})
			if err := m.Cluster[len(m.Cluster)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Percent == nil {
				m.Percent = &ves_io_schema4.FractionalPercent{}
			}
			if err := m.Percent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpdyConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpdyConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpdyConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSpdy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSpdy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebsocketConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebsocketConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebsocketConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseWebsocket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseWebsocket = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnectAttempts", wireType)
			}
			m.MaxConnectAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConnectAttempts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieForHashing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieForHashing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieForHashing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicySpecifier = &HashPolicyType_HeaderName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CookieForHashing{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicySpecifier = &HashPolicyType_Cookie{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PolicySpecifier = &HashPolicyType_SourceIp{b}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDestinationList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDestinationList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDestinationList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, &RouteDestination{})
			if err := m.Destinations[len(m.Destinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixRewrite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRewriteParams = &RouteDestinationList_HostRewrite{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoHostRewrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HostRewriteParams = &RouteDestinationList_AutoHostRewrite{b}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &ves_io_schema4.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointSubsets == nil {
				m.EndpointSubsets = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EndpointSubsets[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MirrorPolicy == nil {
				m.MirrorPolicy = &MirrorPolicyType{}
			}
			if err := m.MirrorPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebSocketConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebSocketConfig == nil {
				m.WebSocketConfig = &WebsocketConfigType{}
			}
			if err := m.WebSocketConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &ves_io_schema4.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &ves_io_schema4.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashPolicy = append(m.HashPolicy, &HashPolicyType{})
			if err := m.HashPolicy[len(m.HashPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (ves_io_schema4.RoutingPriority(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpdyConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpdyConfig == nil {
				m.SpdyConfig = &SpdyConfigType{}
			}
			if err := m.SpdyConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteQueryParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteQueryParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteQueryParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteRedirect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteRedirect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtoRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripQueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteQueryParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParams = &RouteRedirect_StripQueryParams{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllParams", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryParams = &RouteRedirect_AllParams{b}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetainAllParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParams = &RouteRedirect_RetainAllParams{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveAllParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParams = &RouteRedirect_RemoveAllParams{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDirectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDirectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDirectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServicePolicyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServicePolicyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServicePolicyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, &ves_io_schema4.RouteMatch{})
			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteDestination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteDestinationList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteAction = &RouteType_RouteDestination{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteRedirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteRedirect{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteAction = &RouteType_RouteRedirect{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteDirectResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteDirectResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteAction = &RouteType_RouteDirectResponse{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableCustomScript", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableCustomScript = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &ves_io_schema4.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &ves_io_schema4.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServicePolicy == nil {
				m.ServicePolicy = &ServicePolicyInfo{}
			}
			if err := m.ServicePolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableLocationAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableLocationAdd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/route/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/route/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 2223 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0xf0, 0x43, 0x24, 0x1f, 0x3f, 0x44, 0x8d, 0x64, 0x87, 0x52, 0x1c, 0x86, 0xa0, 0xe3,
	0x56, 0x8e, 0xd7, 0x52, 0x28, 0x59, 0xfe, 0x50, 0x01, 0xd5, 0xa2, 0x6a, 0x5b, 0x56, 0xed, 0x58,
	0x5d, 0x19, 0x70, 0x9b, 0x83, 0x17, 0xcb, 0xdd, 0x21, 0xb9, 0x35, 0xc9, 0x59, 0xef, 0x0e, 0x25,
	0xf3, 0x60, 0xc0, 0xbd, 0x15, 0xed, 0xa5, 0xc8, 0xd1, 0xe8, 0x25, 0x28, 0x8a, 0x16, 0xfd, 0x0b,
	0x8a, 0xb2, 0x07, 0x41, 0x40, 0x81, 0xa2, 0x27, 0xdd, 0xe2, 0x63, 0xcc, 0x5c, 0xd2, 0x9b, 0xe1,
	0x43, 0xe1, 0x63, 0xb1, 0x33, 0xb3, 0xe4, 0x92, 0x66, 0x1c, 0x07, 0x70, 0x2e, 0x02, 0x77, 0xde,
	0xef, 0xfd, 0xde, 0xc7, 0xcc, 0x7b, 0xf3, 0x46, 0xf0, 0xe1, 0x3e, 0x71, 0x97, 0x2c, 0xba, 0xec,
	0x1a, 0x0d, 0xd2, 0xd2, 0x97, 0x1d, 0xda, 0x61, 0x64, 0x99, 0x75, 0x6d, 0xe2, 0x2e, 0xd9, 0x0e,
	0x65, 0x14, 0xcf, 0x0a, 0xc0, 0x92, 0x00, 0x2c, 0x71, 0xc0, 0xc2, 0xf9, 0xba, 0xc5, 0x1a, 0x9d,
	0xea, 0x92, 0x41, 0x5b, 0xcb, 0x75, 0x5a, 0xa7, 0xcb, 0x1c, 0x5b, 0xed, 0xd4, 0xf8, 0x17, 0xff,
	0xe0, 0xbf, 0x04, 0xc7, 0xc2, 0xfb, 0xa3, 0x46, 0xa8, 0xcd, 0x2c, 0xda, 0x96, 0x06, 0x16, 0xe6,
	0x47, 0x85, 0x01, 0xdb, 0x0b, 0xa7, 0x46, 0x45, 0xfb, 0x7a, 0xd3, 0x32, 0x75, 0x46, 0xa4, 0xb4,
	0x38, 0x26, 0xb5, 0xc8, 0x81, 0x36, 0x42, 0x5d, 0xfa, 0x5f, 0x18, 0x72, 0xaa, 0xe7, 0xf0, 0xcf,
	0x88, 0xcb, 0xac, 0xb6, 0xee, 0xc9, 0xf0, 0x2d, 0x88, 0x1b, 0xcd, 0x8e, 0xcb, 0x88, 0x93, 0x47,
	0xc5, 0xc8, 0x62, 0x6a, 0xe5, 0xd4, 0xd2, 0x68, 0x88, 0x77, 0xaa, 0xbf, 0x26, 0x06, 0x53, 0x49,
	0xed, 0x6e, 0xd7, 0x26, 0x95, 0xb9, 0xbf, 0x3d, 0xf6, 0xf1, 0xff, 0xf8, 0xef, 0x61, 0x24, 0xf6,
	0x39, 0x0a, 0xe7, 0x90, 0xea, 0x2f, 0xe1, 0x53, 0x30, 0x75, 0x40, 0xac, 0x7a, 0x83, 0xe5, 0x23,
	0x45, 0xb4, 0x98, 0xa9, 0x44, 0x5f, 0xf5, 0x50, 0x48, 0x95, 0x6b, 0xf8, 0x09, 0x82, 0x1c, 0x69,
	0x9b, 0x36, 0xb5, 0xda, 0x4c, 0x73, 0x3b, 0x55, 0x97, 0x30, 0x37, 0x1f, 0xe5, 0x56, 0xd7, 0x97,
	0x26, 0x24, 0x76, 0x69, 0xdc, 0xdb, 0xa5, 0x6b, 0x52, 0x7b, 0x4f, 0x28, 0x5f, 0x6b, 0x33, 0xa7,
	0x5b, 0x99, 0x3f, 0xec, 0x21, 0xc4, 0xbd, 0x79, 0x8a, 0xc2, 0xb9, 0x5c, 0xff, 0xab, 0x7f, 0x45,
	0xa6, 0x7e, 0xf7, 0x4f, 0x14, 0x4e, 0x84, 0xd4, 0x69, 0x32, 0xaa, 0xb0, 0x50, 0x81, 0xb9, 0x49,
	0x1c, 0x38, 0x07, 0x91, 0x07, 0xa4, 0x9b, 0x47, 0x45, 0xb4, 0x98, 0x54, 0xbd, 0x9f, 0x78, 0x0e,
	0x62, 0xfb, 0x7a, 0xb3, 0x43, 0xf2, 0x61, 0xbe, 0x26, 0x3e, 0xd6, 0xc3, 0x97, 0xd1, 0xfa, 0xd9,
	0x97, 0x1b, 0xb1, 0xb2, 0xb2, 0xaa, 0x5c, 0x38, 0xea, 0xa1, 0x0f, 0xe0, 0x7d, 0xc0, 0x5b, 0x22,
	0xfa, 0xa2, 0xde, 0x36, 0x8b, 0xf7, 0x44, 0xa8, 0x02, 0xb0, 0x13, 0x4d, 0x84, 0x73, 0x91, 0xd2,
	0x1f, 0x11, 0xe4, 0x6e, 0x5b, 0x8e, 0x43, 0x9d, 0x5d, 0xda, 0xb4, 0x8c, 0xae, 0x97, 0xc9, 0x77,
	0x9c, 0xf8, 0x75, 0x88, 0xdb, 0xc4, 0x31, 0x48, 0x9b, 0x71, 0x7f, 0x53, 0x2b, 0xc5, 0x31, 0xb6,
	0xeb, 0x8e, 0x6e, 0x78, 0x29, 0xd4, 0x9b, 0xbb, 0x02, 0xa7, 0xfa, 0x0a, 0xa5, 0x73, 0x90, 0xdd,
	0xb3, 0xcd, 0xee, 0x16, 0x6d, 0xd7, 0xac, 0x3a, 0xf7, 0x6d, 0x1e, 0x12, 0x1d, 0x97, 0x68, 0xae,
	0x6d, 0x8a, 0x94, 0x24, 0xd4, 0x78, 0xc7, 0x25, 0x1e, 0xa8, 0xf4, 0x67, 0x04, 0xb3, 0xf7, 0x48,
	0xd5, 0xa5, 0xc6, 0x03, 0xc2, 0x02, 0x2a, 0xa7, 0x21, 0xe3, 0xa9, 0x1c, 0xf8, 0x22, 0xa9, 0x97,
	0xee, 0xb8, 0x64, 0x00, 0xc7, 0x0a, 0xa4, 0x2d, 0xb3, 0x49, 0x34, 0x66, 0xb5, 0x08, 0xed, 0x08,
	0x57, 0x33, 0x95, 0xe4, 0xb3, 0xc7, 0xe8, 0x9b, 0x1e, 0x42, 0x79, 0xa4, 0xa6, 0x3c, 0xf1, 0x5d,
	0x21, 0xc5, 0x3f, 0x81, 0xb9, 0x96, 0xfe, 0x48, 0x33, 0x68, 0xbb, 0x4d, 0x0c, 0xa6, 0xe9, 0x8c,
	0x91, 0x96, 0xcd, 0x5c, 0x79, 0xb4, 0x02, 0x5a, 0xb8, 0xa5, 0x3f, 0xda, 0x12, 0xa8, 0x4d, 0x09,
	0x2a, 0xdd, 0x87, 0xdc, 0x16, 0xa5, 0x0f, 0x2c, 0x72, 0x9d, 0x3a, 0xdb, 0xba, 0xdb, 0xb0, 0xda,
	0x75, 0xfc, 0x11, 0x44, 0xdb, 0x7a, 0x8b, 0x88, 0x5d, 0xae, 0xe4, 0xbc, 0xb3, 0xe9, 0xe5, 0x32,
	0xee, 0xc4, 0x72, 0x28, 0xff, 0x24, 0xac, 0x72, 0xa9, 0x77, 0x14, 0x18, 0x6b, 0x0a, 0xdf, 0x54,
	0xef, 0x27, 0xc6, 0x10, 0xb5, 0x75, 0xd6, 0xe0, 0x86, 0x93, 0x2a, 0xff, 0x5d, 0x7a, 0x1a, 0x86,
	0xac, 0xc7, 0x1b, 0xd8, 0xd1, 0x55, 0x48, 0x35, 0x88, 0x6e, 0x12, 0x47, 0x7b, 0x93, 0x95, 0xed,
	0x90, 0x0a, 0x02, 0xf6, 0xa9, 0x67, 0xed, 0xa7, 0x30, 0x65, 0x70, 0x3f, 0xe5, 0xbe, 0x9d, 0x99,
	0x58, 0x08, 0xe3, 0xa1, 0x6c, 0x87, 0x54, 0xa9, 0x86, 0x4f, 0x43, 0xd2, 0xa5, 0x1d, 0xc7, 0x20,
	0x9a, 0x65, 0x73, 0x0f, 0x13, 0xa2, 0xea, 0xb6, 0x43, 0x6a, 0x42, 0x08, 0x6e, 0xda, 0xb8, 0x08,
	0x09, 0x46, 0x9c, 0x96, 0xd5, 0xd6, 0x9b, 0xf9, 0xe8, 0x10, 0xa3, 0x0e, 0x56, 0xd7, 0x0b, 0x47,
	0x3d, 0xb4, 0x00, 0x79, 0x98, 0xf1, 0x2c, 0x14, 0x45, 0x54, 0x45, 0xb5, 0xd3, 0x24, 0x2e, 0x8e,
	0xac, 0x29, 0x17, 0x2a, 0x67, 0x20, 0x67, 0xf3, 0x45, 0xcd, 0xb5, 0x89, 0x61, 0xd5, 0x2c, 0xe2,
	0xe0, 0x99, 0xc3, 0x1e, 0x0a, 0x1f, 0xf7, 0x50, 0xac, 0xdf, 0x43, 0xb1, 0x15, 0xa5, 0xac, 0xac,
	0xee, 0x44, 0x13, 0xb1, 0xdc, 0x54, 0xe9, 0x0b, 0x80, 0xb9, 0xf1, 0xda, 0xbd, 0x65, 0xb9, 0x0c,
	0xff, 0x0a, 0xd2, 0xe6, 0x70, 0xc9, 0x95, 0x27, 0xff, 0xcc, 0x5b, 0x15, 0x7f, 0x25, 0x7b, 0xec,
	0xd7, 0xb9, 0x77, 0xf8, 0x73, 0xea, 0x08, 0x15, 0x3e, 0x07, 0x59, 0xdb, 0x21, 0x35, 0xeb, 0x91,
	0xe6, 0x90, 0x03, 0xc7, 0x62, 0x24, 0x1f, 0xe3, 0x1b, 0x20, 0x02, 0xcd, 0x08, 0x99, 0x2a, 0x44,
	0xf8, 0x2c, 0xa4, 0x1b, 0xd4, 0x65, 0x03, 0xe8, 0xd4, 0x10, 0xba, 0x1d, 0x52, 0x53, 0x9e, 0xcc,
	0x87, 0xae, 0xc0, 0x8c, 0xde, 0x61, 0x54, 0x1b, 0xc1, 0xc7, 0x47, 0xf2, 0x3c, 0xed, 0x01, 0xb6,
	0x03, 0x3a, 0x05, 0x88, 0xfb, 0x47, 0x3c, 0x11, 0xe8, 0x83, 0xfe, 0x22, 0xbe, 0x01, 0x69, 0x87,
	0x30, 0xa7, 0xab, 0x89, 0x94, 0xe6, 0x93, 0x7c, 0xeb, 0x0b, 0x63, 0x69, 0x50, 0x3d, 0xc8, 0xf0,
	0x7c, 0x55, 0xa2, 0x5e, 0xfc, 0x6a, 0xca, 0x19, 0x2e, 0xe3, 0xdf, 0x4e, 0xea, 0xa8, 0xc0, 0x93,
	0xba, 0xf1, 0x56, 0x49, 0xf5, 0x76, 0x65, 0x72, 0x57, 0xfd, 0xc0, 0xeb, 0xaa, 0xc7, 0x6f, 0xdd,
	0x59, 0xf1, 0x2e, 0x64, 0x5a, 0xbc, 0xc7, 0xf9, 0x41, 0xa5, 0xde, 0x70, 0x9e, 0xc7, 0xbb, 0x61,
	0x25, 0xea, 0x59, 0x53, 0xd3, 0xad, 0xc0, 0x3a, 0xfe, 0x0c, 0x66, 0x0e, 0x48, 0x55, 0x13, 0xbd,
	0xc3, 0x6b, 0x03, 0x35, 0xab, 0x9e, 0xcf, 0x70, 0xd6, 0xc5, 0x89, 0xac, 0x13, 0xfa, 0x92, 0x24,
	0x9e, 0x3e, 0x20, 0xd5, 0xbd, 0x80, 0x08, 0xef, 0x40, 0xa6, 0xda, 0xa9, 0xd5, 0xc8, 0xc0, 0xdb,
	0x2c, 0xe7, 0xfd, 0x70, 0x8c, 0xb7, 0xc2, 0x31, 0xaf, 0xd1, 0xa5, 0x85, 0xae, 0xf4, 0xf3, 0x2a,
	0xa4, 0x0c, 0xea, 0xb8, 0x3e, 0xd3, 0x34, 0x67, 0x9a, 0x1f, 0x63, 0xda, 0xa2, 0x8e, 0x2b, 0xf0,
	0x92, 0x03, 0x8c, 0xc1, 0x0a, 0xfe, 0x14, 0x52, 0x0d, 0xdd, 0x6d, 0xf8, 0x0c, 0x39, 0xbe, 0x81,
	0xa7, 0x27, 0xc6, 0x38, 0xda, 0x73, 0x2a, 0x09, 0x7f, 0x97, 0x54, 0x68, 0x0c, 0x24, 0xf8, 0x2a,
	0x24, 0x6c, 0xc7, 0xa2, 0x8e, 0xc5, 0xba, 0x79, 0x5c, 0x44, 0x8b, 0xd9, 0xd7, 0xcf, 0x16, 0xed,
	0x30, 0xab, 0x5d, 0xdf, 0x95, 0x28, 0xe9, 0xd3, 0x40, 0xcb, 0xf3, 0xc8, 0xeb, 0xfe, 0x7e, 0xd6,
	0x67, 0x79, 0x4c, 0x93, 0x3d, 0x1a, 0xbd, 0x3b, 0x84, 0x47, 0x2f, 0xb8, 0x47, 0xee, 0x40, 0xf2,
	0x4e, 0xee, 0xdd, 0xdf, 0xa0, 0x97, 0x1b, 0xa5, 0xb2, 0x72, 0x59, 0xb9, 0xa2, 0xac, 0x29, 0x2b,
	0x9f, 0x28, 0xe5, 0x4f, 0x94, 0x72, 0x59, 0x29, 0xaf, 0x2a, 0xe5, 0x0b, 0x4a, 0x79, 0x4d, 0x29,
	0x5f, 0x54, 0xca, 0x97, 0x95, 0xf2, 0x95, 0xa3, 0x1e, 0xfa, 0x25, 0x7c, 0x00, 0xf9, 0x3b, 0x8e,
	0x55, 0xb7, 0xda, 0xc5, 0x5d, 0x4a, 0x9b, 0x6e, 0xe0, 0x6a, 0x76, 0x31, 0x2a, 0xc3, 0x25, 0x98,
	0x0d, 0x14, 0x41, 0x71, 0xd3, 0x10, 0x3d, 0xa4, 0xf8, 0x5d, 0xdc, 0x95, 0x8f, 0x60, 0x26, 0x50,
	0xe8, 0xbb, 0xba, 0xa3, 0xb7, 0x5c, 0x3c, 0x7d, 0xd8, 0x43, 0xf1, 0xe3, 0x1e, 0x9a, 0xeb, 0xf7,
	0x50, 0xe4, 0x92, 0x72, 0x51, 0x5c, 0xfb, 0x3b, 0xd1, 0x44, 0x24, 0x17, 0xdd, 0x89, 0x26, 0xa2,
	0xb9, 0xd8, 0x4e, 0x34, 0x31, 0x93, 0xc3, 0x3b, 0xd1, 0xc4, 0x5c, 0xee, 0xc4, 0x4e, 0x34, 0x91,
	0xce, 0x65, 0x4a, 0xd7, 0xe4, 0x30, 0xf6, 0x8b, 0x0e, 0x71, 0xba, 0x92, 0xa8, 0x0c, 0xe9, 0x87,
	0xde, 0xa7, 0x66, 0xf3, 0x6f, 0xde, 0x1e, 0x93, 0x95, 0xac, 0x7f, 0x85, 0xf0, 0xbe, 0x57, 0x54,
	0x53, 0x0f, 0x87, 0x2a, 0xa5, 0x3f, 0x45, 0x21, 0xc3, 0x79, 0x54, 0x62, 0x5a, 0x0e, 0x31, 0x18,
	0x3e, 0x0b, 0x19, 0xd9, 0xab, 0xc4, 0x82, 0xbc, 0x88, 0x44, 0x0b, 0x4a, 0x8b, 0xd6, 0x36, 0x84,
	0x7a, 0x97, 0xd9, 0x10, 0x1a, 0x1e, 0x40, 0x91, 0x9a, 0xf6, 0x44, 0x03, 0xe8, 0xa6, 0xd7, 0x5e,
	0x29, 0xa3, 0x43, 0x2c, 0xbf, 0x0d, 0x2b, 0x0b, 0xbe, 0x73, 0x33, 0xce, 0xb4, 0x1a, 0x52, 0xa3,
	0x0d, 0xc6, 0x6c, 0x35, 0xe6, 0xfd, 0x75, 0xbd, 0xa6, 0x4b, 0x19, 0x1d, 0x50, 0xdc, 0x07, 0xec,
	0x32, 0xc7, 0xb2, 0xb5, 0x91, 0x18, 0xa3, 0x6f, 0x68, 0x13, 0xe3, 0x09, 0xaa, 0xc4, 0xe5, 0xa5,
	0xbf, 0x1d, 0x52, 0x73, 0x9c, 0x2b, 0x98, 0xbd, 0x45, 0x00, 0xbd, 0xd9, 0xf4, 0x79, 0x63, 0xbc,
	0x45, 0x07, 0x14, 0x92, 0x7a, 0xb3, 0x29, 0x91, 0xab, 0x90, 0x71, 0x88, 0x6b, 0xd3, 0xb6, 0x4b,
	0x34, 0x83, 0x9a, 0xa2, 0xff, 0x67, 0x02, 0x89, 0xfe, 0x38, 0x92, 0xff, 0x32, 0xaa, 0xa6, 0x7d,
	0xd0, 0x16, 0x35, 0x09, 0xae, 0xc0, 0x8c, 0x43, 0x98, 0x6e, 0xb5, 0xb5, 0x80, 0x95, 0x04, 0xf7,
	0x7e, 0x6e, 0xcc, 0xfb, 0x6b, 0x2d, 0x9b, 0x75, 0xbd, 0x8b, 0x41, 0x28, 0x6c, 0x0e, 0x0c, 0x73,
	0x8e, 0x16, 0xdd, 0x27, 0x41, 0x8e, 0xe4, 0x77, 0x71, 0x78, 0x0a, 0x03, 0x8e, 0xf5, 0xf4, 0xcb,
	0x8d, 0xe4, 0xaa, 0x52, 0x56, 0x56, 0x94, 0x8b, 0xca, 0xa5, 0x4a, 0x01, 0x52, 0xc1, 0x1c, 0x78,
	0x47, 0x31, 0x71, 0xdc, 0x43, 0x71, 0xef, 0x28, 0x5e, 0x56, 0xae, 0xec, 0x44, 0x13, 0xf1, 0x5c,
	0xa2, 0xf4, 0x05, 0x82, 0x59, 0xd1, 0xfa, 0xf9, 0x56, 0xa8, 0x32, 0x2e, 0xbc, 0x36, 0x9e, 0x08,
	0xc4, 0x13, 0x31, 0x1c, 0x5a, 0x3e, 0x8e, 0xe5, 0xbf, 0x8c, 0x2e, 0x9a, 0x63, 0xa9, 0x08, 0xaa,
	0x55, 0xa9, 0xd9, 0x95, 0xe7, 0xc6, 0x53, 0x8b, 0xc8, 0x59, 0xa7, 0x88, 0x16, 0x9f, 0x5c, 0x1d,
	0xaa, 0x55, 0xa8, 0xd9, 0x5d, 0x3f, 0x75, 0xd4, 0x43, 0x79, 0x38, 0x09, 0xd3, 0xc2, 0x8b, 0xe2,
	0xc0, 0x8d, 0x48, 0x59, 0x59, 0x29, 0x9d, 0x87, 0x99, 0x3d, 0xe2, 0xec, 0x5b, 0x06, 0x11, 0x5d,
	0xec, 0x66, 0xbb, 0x46, 0x71, 0x1e, 0xe2, 0xa6, 0xe5, 0xea, 0xd5, 0x26, 0xf1, 0x07, 0x51, 0xf9,
	0x59, 0xfa, 0x4b, 0x12, 0x92, 0x3c, 0x24, 0x3e, 0x7b, 0xad, 0x41, 0xac, 0xa5, 0x33, 0xa3, 0x21,
	0x27, 0x8a, 0xf9, 0x09, 0xed, 0x8e, 0xdc, 0xf6, 0x00, 0xf2, 0x16, 0x15, 0x68, 0x7c, 0x1f, 0x66,
	0xf8, 0x49, 0xd3, 0x02, 0xa3, 0x84, 0x1c, 0xc4, 0xce, 0xbe, 0xf5, 0xfd, 0x29, 0x28, 0xbd, 0x23,
	0xe9, 0x8c, 0xbf, 0xae, 0x7e, 0x0e, 0x59, 0xc1, 0x3f, 0x52, 0x35, 0xa9, 0x95, 0xd2, 0xb7, 0x93,
	0xfb, 0xe5, 0xb2, 0x1d, 0x52, 0x33, 0xce, 0x48, 0x61, 0x9b, 0x70, 0x42, 0x3a, 0xcb, 0xbf, 0x35,
	0x3f, 0xb7, 0xb2, 0x84, 0x16, 0xdf, 0xe0, 0xf0, 0xc8, 0xae, 0x0f, 0xfc, 0x9d, 0x75, 0x26, 0x1c,
	0x89, 0xab, 0x70, 0x42, 0xa6, 0x58, 0x33, 0x3a, 0x2e, 0xa3, 0x2d, 0xcd, 0x35, 0x1c, 0xcb, 0x66,
	0xb2, 0xa0, 0xd2, 0x5e, 0x7b, 0xf7, 0x2a, 0x8a, 0xb7, 0x93, 0x59, 0x09, 0xdd, 0xe2, 0xc8, 0x3d,
	0x0e, 0xc4, 0x0c, 0x4e, 0x3a, 0xe4, 0x61, 0x87, 0xb8, 0x4c, 0x13, 0x83, 0xae, 0xab, 0x31, 0xaa,
	0xe9, 0xa6, 0x99, 0x8f, 0xf3, 0xcd, 0x39, 0x37, 0xe6, 0xe8, 0x36, 0x07, 0xdd, 0xd6, 0xdb, 0x96,
	0xdd, 0x69, 0xf2, 0xbc, 0xdd, 0xe1, 0xef, 0x56, 0x7e, 0x9d, 0xe0, 0x91, 0x31, 0x44, 0x34, 0xc0,
	0x59, 0x49, 0x2f, 0x14, 0xdd, 0xbb, 0x74, 0xd3, 0x34, 0xf1, 0x3e, 0xbc, 0x37, 0x38, 0x93, 0x63,
	0x66, 0x13, 0xef, 0xc6, 0xec, 0x9c, 0xcf, 0x3f, 0x62, 0xb7, 0x0a, 0xf3, 0x13, 0xa2, 0x15, 0x45,
	0x9b, 0x4f, 0xf2, 0x06, 0xfe, 0x63, 0x9f, 0xec, 0x95, 0x24, 0x4c, 0x7f, 0x8e, 0x92, 0x25, 0x59,
	0x24, 0xe1, 0x80, 0x85, 0x93, 0xe3, 0x81, 0xa9, 0x9c, 0x06, 0x9b, 0xb0, 0x30, 0x29, 0x36, 0x69,
	0x04, 0xbe, 0x9f, 0x91, 0xf7, 0x5e, 0x0b, 0x43, 0x5a, 0xb9, 0x04, 0x89, 0x03, 0xbd, 0xa6, 0xb1,
	0xae, 0x4d, 0xe4, 0xf0, 0x76, 0x72, 0x2c, 0x65, 0xf7, 0xf4, 0x5a, 0x60, 0x0a, 0x8a, 0x1f, 0x88,
	0x4f, 0xbc, 0x07, 0x59, 0x57, 0x54, 0xae, 0x3f, 0xc1, 0xa4, 0xb9, 0xfa, 0x8f, 0x26, 0xcf, 0x0b,
	0xe3, 0x45, 0x2e, 0xe9, 0x32, 0x6e, 0x50, 0x80, 0x2f, 0xc2, 0x9c, 0x7f, 0x0e, 0x9b, 0xd4, 0xe0,
	0xfb, 0xc3, 0x37, 0x33, 0x13, 0x78, 0xbe, 0x60, 0x89, 0xb8, 0x25, 0x01, 0x9b, 0xa6, 0xb9, 0xde,
	0x78, 0xb9, 0x91, 0x2f, 0xf3, 0x6b, 0x7b, 0x55, 0x29, 0xaf, 0x78, 0xb7, 0xf8, 0x25, 0xe5, 0x8a,
	0x72, 0xd9, 0xbb, 0xd1, 0xd7, 0x8e, 0x7a, 0xe8, 0x26, 0x60, 0xc8, 0xa8, 0x22, 0xcd, 0x45, 0xde,
	0x11, 0xbc, 0x79, 0x20, 0x0f, 0x53, 0x62, 0x06, 0xc0, 0xd9, 0xf2, 0x85, 0xa1, 0x42, 0x79, 0x15,
	0xe6, 0x21, 0xbb, 0x69, 0xee, 0xeb, 0x6d, 0x83, 0xc8, 0x29, 0x01, 0xc7, 0xbd, 0xc1, 0x60, 0x45,
	0x59, 0xab, 0x14, 0x21, 0xc5, 0xab, 0x4b, 0xae, 0xfb, 0xaf, 0xa1, 0xac, 0x78, 0x0d, 0x89, 0xe7,
	0x7f, 0x36, 0x37, 0x5d, 0x72, 0x21, 0x7b, 0xa3, 0x49, 0xab, 0x7a, 0x73, 0xcf, 0x26, 0x06, 0x4f,
	0xd8, 0x75, 0x98, 0xe2, 0xb9, 0xf0, 0x1f, 0x40, 0x85, 0x6f, 0x2f, 0x5d, 0x9e, 0xef, 0xf1, 0x97,
	0x8f, 0xd4, 0x5e, 0x9f, 0x3f, 0xea, 0xa1, 0x13, 0x30, 0x0b, 0x59, 0xaf, 0x0d, 0x15, 0x69, 0xad,
	0x28, 0xd6, 0x31, 0x2a, 0x97, 0x6a, 0x90, 0xdd, 0x72, 0x88, 0xce, 0xc8, 0xc0, 0xe8, 0xe6, 0xf7,
	0x34, 0x9a, 0x7c, 0xfa, 0x58, 0x2a, 0x0c, 0xec, 0xcd, 0xfc, 0x67, 0x63, 0x2c, 0x94, 0x52, 0x1d,
	0xa6, 0x55, 0x62, 0x37, 0x75, 0xe3, 0x87, 0x36, 0x64, 0x40, 0xea, 0x06, 0x61, 0x3f, 0xac, 0x91,
	0xca, 0xef, 0xd1, 0xf1, 0xf3, 0x42, 0xe8, 0xd9, 0xf3, 0x42, 0xe8, 0xc5, 0xf3, 0x02, 0x7a, 0xf5,
	0xbc, 0x80, 0x9e, 0xf4, 0x0b, 0xe8, 0xaf, 0xfd, 0x02, 0xfa, 0x7b, 0xbf, 0x80, 0x0e, 0xfb, 0x05,
	0xf4, 0xef, 0x7e, 0x01, 0x1d, 0xf7, 0x0b, 0xe8, 0x59, 0xbf, 0x80, 0xbe, 0xea, 0x17, 0xd0, 0x37,
	0xfd, 0x42, 0xe8, 0x45, 0xbf, 0x80, 0xfe, 0xf0, 0x75, 0x21, 0x74, 0xf8, 0x75, 0x01, 0x7d, 0x76,
	0xb3, 0x4e, 0xed, 0x07, 0xf5, 0xa5, 0x7d, 0xda, 0x64, 0xc4, 0x71, 0xf4, 0xa5, 0x8e, 0xbb, 0xcc,
	0x7f, 0xd4, 0xa8, 0xd3, 0x3a, 0x6f, 0x3b, 0x74, 0xdf, 0x32, 0x89, 0x73, 0xde, 0x17, 0x2f, 0xdb,
	0xd5, 0x3a, 0x5d, 0x26, 0x8f, 0x98, 0xfc, 0xb7, 0x5d, 0xf0, 0x1f, 0x8f, 0xd5, 0x29, 0x3e, 0x3f,
	0xad, 0xfe, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xa3, 0x22, 0x44, 0xe0, 0x96, 0x14, 0x00, 0x00,
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/protocol_policer/types.proto

package protocol_policer

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TCP Flags
//
// x-displayName: "TCP Flags"
// TCP flags indicate a particular connection state
type TcpFlags int32

const (
	// x-displayName: "Finished"
	// FIN flag which indicates that there is no more data from the sender, used in the last packet sent from the sender
	FIN TcpFlags = 0
	// x-displayName: "Synchronisation"
	// SYN flag set in the first packet from sender and receiver while establishing three way handshake between two hosts
	SYN TcpFlags = 1
	// x-displayName: "Reset"
	// RST flag that resets a connection when the host receives an unexpected packet
	RST TcpFlags = 2
	// x-displayName: "Push"
	// PSH flag that tells the receiver to process packets as they are received, instead of buffering them
	PSH TcpFlags = 3
	// x-displayName: "Acknowledgment"
	// ACK flag that acknowledges successful receipt of a packet
	ACK TcpFlags = 4
	// x-displayName: "Urgent"
	// URG flag that notifies the receiver about urgent packets that need to processed before other packets
	URG TcpFlags = 5
	// x-displayName: "Keepalive"
	// Keepalive flag tracks the keepalive packets for tcp connection liveness
	KEEPALIVE TcpFlags = 7
	// x-displayName: "All"
	// Match any TCP Flag - FIN / SYN / RST / PSH / ACK / URG / KEEPALIVE
	ALL_TCP_FLAGS TcpFlags = 6
)

var TcpFlags_name = map[int32]string{
	0: "FIN",
	1: "SYN",
	2: "RST",
	3: "PSH",
	4: "ACK",
	5: "URG",
	7: "KEEPALIVE",
	6: "ALL_TCP_FLAGS",
}

var TcpFlags_value = map[string]int32{
	"FIN":           0,
	"SYN":           1,
	"RST":           2,
	"PSH":           3,
	"ACK":           4,
	"URG":           5,
	"KEEPALIVE":     7,
	"ALL_TCP_FLAGS": 6,
}

func (TcpFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{0}
}

// ICMP Message types
//
// x-displayName: "ICMP Message Types"
type IcmpMsgType int32

const (
	// x-displayName: "Echo Reply"
	// ICMP echo request packet which is sent by originator of Ping packet
	ECHO_REPLY IcmpMsgType = 0
	// x-displayName: "Echo Request"
	// ICMP echo reply packet which is sent in responce to ICMP echo request packet
	ECHO_REQUEST IcmpMsgType = 1
	// x-displayName: "All ICMP packets"
	// All ICMP packet types including TTL exceeded, destination
	// unreachable and source quench etc
	ALL_ICMP_MSG IcmpMsgType = 2
)

var IcmpMsgType_name = map[int32]string{
	0: "ECHO_REPLY",
	1: "ECHO_REQUEST",
	2: "ALL_ICMP_MSG",
}

var IcmpMsgType_value = map[string]int32{
	"ECHO_REPLY":   0,
	"ECHO_REQUEST": 1,
	"ALL_ICMP_MSG": 2,
}

func (IcmpMsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{1}
}

// TCP packet type
//
// x-displayName: "TCP Packet Type"
// Specification of TCP flag to be matched in a TCP packet
type TcpType struct {
	// flags
	//
	// x-displayName: "TCP flags"
	// TCP flag to be matched in a TCP packet
	Flags []TcpFlags `protobuf:"varint,1,rep,packed,name=flags,proto3,enum=ves.io.schema.protocol_policer.TcpFlags" json:"flags,omitempty"`
}

func (m *TcpType) Reset()      { *m = TcpType{} }
func (*TcpType) ProtoMessage() {}
func (*TcpType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{0}
}
func (m *TcpType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TcpType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpType.Merge(m, src)
}
func (m *TcpType) XXX_Size() int {
	return m.Size()
}
func (m *TcpType) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpType.DiscardUnknown(m)
}

var xxx_messageInfo_TcpType proto.InternalMessageInfo

func (m *TcpType) GetFlags() []TcpFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

// All UDP packets
//
// x-displayName: "UDP Packets"
// Match all UDP packets
type UdpType struct {
}

func (m *UdpType) Reset()      { *m = UdpType{} }
func (*UdpType) ProtoMessage() {}
func (*UdpType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{1}
}
func (m *UdpType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UdpType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UdpType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UdpType.Merge(m, src)
}
func (m *UdpType) XXX_Size() int {
	return m.Size()
}
func (m *UdpType) XXX_DiscardUnknown() {
	xxx_messageInfo_UdpType.DiscardUnknown(m)
}

var xxx_messageInfo_UdpType proto.InternalMessageInfo

// ICMP packet type
//
// x-displayName: "ICMP Packet Type"
// ICMP message type to match in packet
type IcmpType struct {
	// type
	//
	// x-displayName: "ICMP type"
	// ICMP message type to be matched in packet
	Type []IcmpMsgType `protobuf:"varint,1,rep,packed,name=type,proto3,enum=ves.io.schema.protocol_policer.IcmpMsgType" json:"type,omitempty"`
}

func (m *IcmpType) Reset()      { *m = IcmpType{} }
func (*IcmpType) ProtoMessage() {}
func (*IcmpType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{2}
}
func (m *IcmpType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IcmpType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IcmpType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IcmpType.Merge(m, src)
}
func (m *IcmpType) XXX_Size() int {
	return m.Size()
}
func (m *IcmpType) XXX_DiscardUnknown() {
	xxx_messageInfo_IcmpType.DiscardUnknown(m)
}

var xxx_messageInfo_IcmpType proto.InternalMessageInfo

func (m *IcmpType) GetType() []IcmpMsgType {
	if m != nil {
		return m.Type
	}
	return nil
}

// DNS packets
//
// x-displayName: "DNS Packets"
// Match all DNS packets inclusing UDP and TCP
type DnsType struct {
}

func (m *DnsType) Reset()      { *m = DnsType{} }
func (*DnsType) ProtoMessage() {}
func (*DnsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{3}
}
func (m *DnsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DnsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsType.Merge(m, src)
}
func (m *DnsType) XXX_Size() int {
	return m.Size()
}
func (m *DnsType) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsType.DiscardUnknown(m)
}

var xxx_messageInfo_DnsType proto.InternalMessageInfo

// Protocol type
//
// x-displayName: "Protocol Type"
// Protocol and protocol specific flags to be matched in packet
type ProtocolType struct {
	// Type
	//
	// x-displayName: "Packet Type"
	// Provide various protocol specific match conditions
	//
	// Types that are valid to be assigned to Type:
	//	*ProtocolType_Tcp
	//	*ProtocolType_Icmp
	//	*ProtocolType_Udp
	//	*ProtocolType_Dns
	Type isProtocolType_Type `protobuf_oneof:"type"`
}

func (m *ProtocolType) Reset()      { *m = ProtocolType{} }
func (*ProtocolType) ProtoMessage() {}
func (*ProtocolType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{4}
}
func (m *ProtocolType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtocolType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolType.Merge(m, src)
}
func (m *ProtocolType) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolType) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolType.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolType proto.InternalMessageInfo

type isProtocolType_Type interface {
	isProtocolType_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProtocolType_Tcp struct {
	Tcp *TcpType `protobuf:"bytes,1,opt,name=tcp,proto3,oneof" json:"tcp,omitempty"`
}
type ProtocolType_Icmp struct {
	Icmp *IcmpType `protobuf:"bytes,2,opt,name=icmp,proto3,oneof" json:"icmp,omitempty"`
}
type ProtocolType_Udp struct {
	Udp *UdpType `protobuf:"bytes,3,opt,name=udp,proto3,oneof" json:"udp,omitempty"`
}
type ProtocolType_Dns struct {
	Dns *DnsType `protobuf:"bytes,4,opt,name=dns,proto3,oneof" json:"dns,omitempty"`
}

func (*ProtocolType_Tcp) isProtocolType_Type()  {}
func (*ProtocolType_Icmp) isProtocolType_Type() {}
func (*ProtocolType_Udp) isProtocolType_Type()  {}
func (*ProtocolType_Dns) isProtocolType_Type()  {}

func (m *ProtocolType) GetType() isProtocolType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ProtocolType) GetTcp() *TcpType {
	if x, ok := m.GetType().(*ProtocolType_Tcp); ok {
		return x.Tcp
	}
	return nil
}

func (m *ProtocolType) GetIcmp() *IcmpType {
	if x, ok := m.GetType().(*ProtocolType_Icmp); ok {
		return x.Icmp
	}
	return nil
}

func (m *ProtocolType) GetUdp() *UdpType {
	if x, ok := m.GetType().(*ProtocolType_Udp); ok {
		return x.Udp
	}
	return nil
}

func (m *ProtocolType) GetDns() *DnsType {
	if x, ok := m.GetType().(*ProtocolType_Dns); ok {
		return x.Dns
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProtocolType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProtocolType_Tcp)(nil),
		(*ProtocolType_Icmp)(nil),
		(*ProtocolType_Udp)(nil),
		(*ProtocolType_Dns)(nil),
	}
}

// Protocol Policer Type
//
// x-displayName: "Protocol Policer"
// Protocol policer has set or network protocol fields and flags to be match on
// a layer 4 packet and corresponding rate limit to be applied, this would be
// useful in specifying
// * Ratelimiting TCP sessions accepted from in a given duration
// * Ratelimiting various ICMP message type packets
// * Ratelimiting all UDP traffic
// * Ratelimting DNS traffic
type ProtocolPolicerType struct {
	// protocol
	//
	// x-displayName: "Protocol"
	// x-required
	// Protocol specifys L4 match criteria in a packet
	Protocol *ProtocolType `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// policer
	//
	// x-displayName: "Policer"
	// x-required
	// Reference to policer object to apply traffic rate limits
	Policer []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=policer,proto3" json:"policer,omitempty"`
}

func (m *ProtocolPolicerType) Reset()      { *m = ProtocolPolicerType{} }
func (*ProtocolPolicerType) ProtoMessage() {}
func (*ProtocolPolicerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{5}
}
func (m *ProtocolPolicerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolPolicerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtocolPolicerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolPolicerType.Merge(m, src)
}
func (m *ProtocolPolicerType) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolPolicerType) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolPolicerType.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolPolicerType proto.InternalMessageInfo

func (m *ProtocolPolicerType) GetProtocol() *ProtocolType {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *ProtocolPolicerType) GetPolicer() []*schema.ObjectRefType {
	if m != nil {
		return m.Policer
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for protocol policer
type GlobalSpecType struct {
	// Protocol policer
	//
	// x-displayName: "Protocol Policer"
	// List of L4 protocol match condition and associated traffic rate limits
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer,proto3" json:"protocol_policer,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{6}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

// Create a Protocol policer object
//
// x-displayName: "Create Protocol Policer"
// Create a protocol_policer object, protocol_policer object contains list
// of L4 protocol match condition and corresponding traffic rate limits
type CreateSpecType struct {
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer,proto3" json:"protocol_policer,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{7}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

// Replace a Protocol policer object
//
// x-displayName: "Replace Protocol Policer"
// Replace a protocol_policer object with new L4 protocol match condition and
// corresponding traffic rate limits
type ReplaceSpecType struct {
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer,proto3" json:"protocol_policer,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{8}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

// Get a Protocol policer object
//
// x-displayName: "Get Protocol Policer"
// Get specification of a protocol_policer object with L4 protocol match condition and
// corresponding traffic rate limits
type GetSpecType struct {
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer,proto3" json:"protocol_policer,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_29e7a12da6b870e2, []int{9}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.protocol_policer.TcpFlags", TcpFlags_name, TcpFlags_value)
	proto.RegisterEnum("ves.io.schema.protocol_policer.IcmpMsgType", IcmpMsgType_name, IcmpMsgType_value)
	proto.RegisterType((*TcpType)(nil), "ves.io.schema.protocol_policer.TcpType")
	proto.RegisterType((*UdpType)(nil), "ves.io.schema.protocol_policer.UdpType")
	proto.RegisterType((*IcmpType)(nil), "ves.io.schema.protocol_policer.IcmpType")
	proto.RegisterType((*DnsType)(nil), "ves.io.schema.protocol_policer.DnsType")
	proto.RegisterType((*ProtocolType)(nil), "ves.io.schema.protocol_policer.ProtocolType")
	proto.RegisterType((*ProtocolPolicerType)(nil), "ves.io.schema.protocol_policer.ProtocolPolicerType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.protocol_policer.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.protocol_policer.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.protocol_policer.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.protocol_policer.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/protocol_policer/types.proto", fileDescriptor_29e7a12da6b870e2)
}

var fileDescriptor_29e7a12da6b870e2 = []byte{
	// 859 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xf7, 0xc4, 0x49, 0x93, 0x7d, 0x69, 0xbb, 0x83, 0x97, 0xd5, 0x86, 0xb0, 0x1a, 0x45, 0xb9,
	0x10, 0x05, 0xea, 0x2c, 0xd9, 0x0b, 0x2a, 0x52, 0x21, 0x4d, 0xd3, 0x34, 0x34, 0xed, 0x06, 0x27,
	0xad, 0x58, 0x10, 0x44, 0x89, 0x3d, 0xcd, 0x06, 0x92, 0xcc, 0xc8, 0x76, 0x0a, 0x7b, 0x40, 0xe2,
	0x80, 0x00, 0x09, 0x09, 0x21, 0xee, 0xdc, 0x11, 0x1f, 0x81, 0x5e, 0xf6, 0x88, 0x56, 0x1c, 0xca,
	0xad, 0x47, 0xea, 0x5e, 0xe0, 0xb6, 0xe2, 0x13, 0xa0, 0x19, 0xdb, 0x51, 0x1c, 0x04, 0x9b, 0xc3,
	0x4a, 0x7b, 0x7b, 0x9e, 0xf7, 0x7e, 0x7f, 0xe6, 0x37, 0x63, 0x1b, 0x8a, 0xa7, 0xd4, 0xd1, 0x87,
	0xac, 0xe4, 0x98, 0x0f, 0xe8, 0xb8, 0x57, 0xe2, 0x36, 0x73, 0x99, 0xc9, 0x46, 0x5d, 0xce, 0x46,
	0x43, 0x93, 0xda, 0x25, 0xf7, 0x21, 0xa7, 0x8e, 0x2e, 0x97, 0x35, 0xe2, 0xcf, 0xea, 0xfe, 0xac,
	0xbe, 0x38, 0x9b, 0xdd, 0x18, 0x0c, 0xdd, 0x07, 0xd3, 0xbe, 0x6e, 0xb2, 0x71, 0x69, 0xc0, 0x06,
	0xcc, 0x67, 0xeb, 0x4f, 0x4f, 0xe4, 0x93, 0x7c, 0x90, 0x95, 0x8f, 0xcc, 0xde, 0x8a, 0x4a, 0x4f,
	0xa8, 0x1b, 0x34, 0x5e, 0x8e, 0x36, 0x18, 0x77, 0x87, 0x6c, 0x12, 0x98, 0xc8, 0xbe, 0x14, 0x6d,
	0xce, 0xf9, 0xcb, 0xde, 0x8e, 0xb6, 0x4e, 0x7b, 0xa3, 0xa1, 0xd5, 0x73, 0x69, 0xd0, 0xcd, 0x2d,
	0x74, 0x87, 0xf4, 0xd3, 0x6e, 0x84, 0x3a, 0xdf, 0x80, 0x64, 0xc7, 0xe4, 0x9d, 0x87, 0x9c, 0x6a,
	0x5b, 0x90, 0x38, 0x19, 0xf5, 0x06, 0x4e, 0x06, 0xe5, 0xd4, 0xc2, 0x7a, 0xb9, 0xa0, 0xff, 0xff,
	0xd6, 0xf5, 0x8e, 0xc9, 0x77, 0xc5, 0xbc, 0xe1, 0xc3, 0xf2, 0xd7, 0x20, 0x79, 0x64, 0x49, 0xaa,
	0xfc, 0x3e, 0xa4, 0x1a, 0xe6, 0xd8, 0xa7, 0x7d, 0x0b, 0xe2, 0xc2, 0x70, 0xc0, 0xfa, 0xea, 0xd3,
	0x58, 0x05, 0xee, 0xc0, 0x19, 0x08, 0xa8, 0x21, 0x81, 0x82, 0x77, 0x67, 0xe2, 0x48, 0xde, 0x1f,
	0x63, 0xb0, 0xda, 0x0a, 0x10, 0x92, 0xfc, 0x4d, 0x50, 0x5d, 0x93, 0x67, 0x50, 0x0e, 0x15, 0xd2,
	0xe5, 0x57, 0x96, 0x70, 0x2c, 0x50, 0x7b, 0x8a, 0x21, 0x50, 0xda, 0x16, 0xc4, 0x87, 0xe6, 0x98,
	0x67, 0x62, 0x12, 0x5d, 0x58, 0xc6, 0x59, 0x00, 0x97, 0x38, 0x21, 0x3e, 0xb5, 0x78, 0x46, 0x5d,
	0x4e, 0x3c, 0xc8, 0x46, 0x88, 0x4f, 0x2d, 0x09, 0xb6, 0x26, 0x4e, 0x26, 0xbe, 0x1c, 0x38, 0x08,
	0x40, 0x80, 0xad, 0x89, 0xb3, 0x8d, 0xfd, 0x4c, 0xb5, 0xd4, 0xa3, 0x33, 0x84, 0xce, 0xcf, 0x50,
	0xe2, 0x9d, 0x78, 0x2a, 0x81, 0x57, 0xf2, 0xdf, 0xaa, 0x70, 0x23, 0xcc, 0xa7, 0xe5, 0x43, 0x65,
	0x4c, 0x7b, 0x90, 0x0a, 0x29, 0x83, 0xac, 0x5e, 0x7b, 0x9a, 0xe2, 0x7c, 0xcc, 0xc6, 0x0c, 0xad,
	0x1d, 0x43, 0x32, 0x98, 0xc8, 0xc4, 0x72, 0x6a, 0x21, 0x5d, 0xbe, 0xbd, 0x40, 0x74, 0xaf, 0xff,
	0x31, 0x35, 0x5d, 0x83, 0x9e, 0x08, 0xe0, 0x36, 0xf9, 0xf9, 0xf3, 0x70, 0xfe, 0x97, 0xbf, 0x1e,
	0xa9, 0x89, 0x1f, 0x50, 0x0c, 0xa3, 0xb0, 0x4a, 0x21, 0x23, 0x6c, 0x6e, 0xfe, 0x8e, 0x1e, 0x9f,
	0xa1, 0xdf, 0x10, 0x58, 0x90, 0x0a, 0x95, 0x8b, 0xef, 0xc1, 0x31, 0xdc, 0x80, 0xd5, 0x50, 0x5b,
	0x77, 0x4d, 0x5e, 0x56, 0x3b, 0xd5, 0x16, 0xdc, 0x84, 0xb5, 0xd9, 0xa2, 0x38, 0x89, 0x72, 0xbc,
	0x51, 0x3d, 0x68, 0x45, 0x66, 0xa7, 0x16, 0x2f, 0xab, 0x47, 0x3b, 0xd1, 0x45, 0x6b, 0xe2, 0x94,
	0xd5, 0x9d, 0xc3, 0x36, 0xec, 0xc3, 0x9a, 0xb0, 0xe7, 0xe4, 0x4a, 0x39, 0x79, 0x85, 0x8b, 0x9b,
	0xf0, 0x06, 0x64, 0x41, 0x9b, 0x97, 0xd2, 0xfd, 0x5b, 0x1d, 0xc7, 0xf1, 0x3b, 0x28, 0xd2, 0x13,
	0x8a, 0xba, 0xbc, 0x99, 0x7e, 0xef, 0x16, 0x24, 0x83, 0xac, 0xb3, 0xab, 0x00, 0xc1, 0x86, 0x3e,
	0xb8, 0xf3, 0x61, 0xfe, 0x2b, 0x04, 0xeb, 0xf5, 0x11, 0xeb, 0xf7, 0x46, 0x6d, 0x4e, 0x4d, 0x79,
	0x10, 0x2e, 0xe0, 0xc5, 0xa4, 0xe5, 0x8b, 0x91, 0x2e, 0xdf, 0x5d, 0xf6, 0x40, 0xe6, 0xce, 0x75,
	0xfb, 0xc5, 0x59, 0xa8, 0x6f, 0x87, 0x55, 0x06, 0x19, 0xd7, 0x79, 0x74, 0x34, 0xff, 0x35, 0x82,
	0xf5, 0xaa, 0x4d, 0x7b, 0x2e, 0x9d, 0x19, 0xf9, 0xe8, 0x99, 0x1a, 0xf9, 0x97, 0xe4, 0xe6, 0xcd,
	0xc7, 0x5b, 0x0b, 0x7b, 0xff, 0x7b, 0x0b, 0xbd, 0x9e, 0xff, 0x06, 0xc1, 0x75, 0x83, 0xf2, 0x51,
	0xcf, 0x7c, 0xee, 0x56, 0xbe, 0x44, 0x90, 0xae, 0x53, 0xf7, 0x39, 0xdb, 0x28, 0xf6, 0x21, 0x15,
	0x7e, 0x48, 0xb5, 0x24, 0xa8, 0xbb, 0x8d, 0x43, 0xac, 0x88, 0xa2, 0x7d, 0xff, 0x10, 0x23, 0x51,
	0x18, 0xed, 0x0e, 0x8e, 0x89, 0xa2, 0xd5, 0xde, 0xc3, 0xaa, 0x28, 0x2a, 0xd5, 0x7d, 0x1c, 0x17,
	0xc5, 0x91, 0x51, 0xc7, 0x09, 0x6d, 0x0d, 0xae, 0xed, 0xd7, 0x6a, 0xad, 0x4a, 0xb3, 0x71, 0x5c,
	0xc3, 0x49, 0xed, 0x05, 0x58, 0xab, 0x34, 0x9b, 0xdd, 0x4e, 0xb5, 0xd5, 0xdd, 0x6d, 0x56, 0xea,
	0x6d, 0xbc, 0x52, 0xac, 0x40, 0x7a, 0xee, 0xb3, 0xaa, 0xad, 0x03, 0xd4, 0xaa, 0x7b, 0xf7, 0xba,
	0x46, 0xad, 0xd5, 0xbc, 0x8f, 0x15, 0x0d, 0xc3, 0x6a, 0xf0, 0xfc, 0xee, 0x51, 0xad, 0xdd, 0xc1,
	0x48, 0xac, 0x08, 0x0e, 0xf1, 0x56, 0x75, 0x0f, 0xda, 0x75, 0x1c, 0xdb, 0xfe, 0x0e, 0x9d, 0x5f,
	0x12, 0xe5, 0xe2, 0x92, 0x28, 0x4f, 0x2e, 0x09, 0xfa, 0xc2, 0x23, 0xe8, 0x27, 0x8f, 0xa0, 0x5f,
	0x3d, 0x82, 0xce, 0x3d, 0x82, 0x2e, 0x3c, 0x82, 0xfe, 0xf0, 0x08, 0xfa, 0xd3, 0x23, 0xca, 0x13,
	0x8f, 0xa0, 0xef, 0xaf, 0x88, 0x72, 0x7e, 0x45, 0x94, 0x8b, 0x2b, 0xa2, 0xbc, 0xdf, 0x19, 0x30,
	0xfe, 0xc9, 0x40, 0x3f, 0x65, 0x23, 0x97, 0xda, 0x76, 0x4f, 0x9f, 0x3a, 0x25, 0x59, 0x9c, 0x30,
	0x7b, 0xbc, 0xc1, 0x6d, 0x76, 0x3a, 0xb4, 0xa8, 0xbd, 0x11, 0xb6, 0x4b, 0xbc, 0x3f, 0x60, 0x25,
	0xfa, 0x99, 0x1b, 0xfc, 0xb3, 0xfe, 0xe3, 0x27, 0xdd, 0x5f, 0x91, 0x2b, 0x77, 0xff, 0x09, 0x00,
	0x00, 0xff, 0xff, 0x38, 0x92, 0x90, 0xb4, 0xcd, 0x07, 0x00, 0x00,
}

func (x TcpFlags) String() string {
	s, ok := TcpFlags_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x IcmpMsgType) String() string {
	s, ok := IcmpMsgType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TcpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpType)
	if !ok {
		that2, ok := that.(TcpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Flags) != len(that1.Flags) {
		return false
	}
	for i := range this.Flags {
		if this.Flags[i] != that1.Flags[i] {
			return false
		}
	}
	return true
}
func (this *UdpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UdpType)
	if !ok {
		that2, ok := that.(UdpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *IcmpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IcmpType)
	if !ok {
		that2, ok := that.(IcmpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Type) != len(that1.Type) {
		return false
	}
	for i := range this.Type {
		if this.Type[i] != that1.Type[i] {
			return false
		}
	}
	return true
}
func (this *DnsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DnsType)
	if !ok {
		that2, ok := that.(DnsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ProtocolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType)
	if !ok {
		that2, ok := that.(ProtocolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *ProtocolType_Tcp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Tcp)
	if !ok {
		that2, ok := that.(ProtocolType_Tcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tcp.Equal(that1.Tcp) {
		return false
	}
	return true
}
func (this *ProtocolType_Icmp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Icmp)
	if !ok {
		that2, ok := that.(ProtocolType_Icmp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Icmp.Equal(that1.Icmp) {
		return false
	}
	return true
}
func (this *ProtocolType_Udp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Udp)
	if !ok {
		that2, ok := that.(ProtocolType_Udp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Udp.Equal(that1.Udp) {
		return false
	}
	return true
}
func (this *ProtocolType_Dns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Dns)
	if !ok {
		that2, ok := that.(ProtocolType_Dns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dns.Equal(that1.Dns) {
		return false
	}
	return true
}
func (this *ProtocolPolicerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolPolicerType)
	if !ok {
		that2, ok := that.(ProtocolPolicerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Protocol.Equal(that1.Protocol) {
		return false
	}
	if len(this.Policer) != len(that1.Policer) {
		return false
	}
	for i := range this.Policer {
		if !this.Policer[i].Equal(that1.Policer[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *TcpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.TcpType{")
	s = append(s, "Flags: "+fmt.Sprintf("%#v", this.Flags)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UdpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&protocol_policer.UdpType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IcmpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.IcmpType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DnsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&protocol_policer.DnsType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&protocol_policer.ProtocolType{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolType_Tcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Tcp{` +
		`Tcp:` + fmt.Sprintf("%#v", this.Tcp) + `}`}, ", ")
	return s
}
func (this *ProtocolType_Icmp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Icmp{` +
		`Icmp:` + fmt.Sprintf("%#v", this.Icmp) + `}`}, ", ")
	return s
}
func (this *ProtocolType_Udp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Udp{` +
		`Udp:` + fmt.Sprintf("%#v", this.Udp) + `}`}, ", ")
	return s
}
func (this *ProtocolType_Dns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Dns{` +
		`Dns:` + fmt.Sprintf("%#v", this.Dns) + `}`}, ", ")
	return s
}
func (this *ProtocolPolicerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&protocol_policer.ProtocolPolicerType{")
	if this.Protocol != nil {
		s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	}
	if this.Policer != nil {
		s = append(s, "Policer: "+fmt.Sprintf("%#v", this.Policer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.GlobalSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.CreateSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.ReplaceSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.GetSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TcpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Flags) > 0 {
		dAtA2 := make([]byte, len(m.Flags)*10)
		var j1 int
		for _, num := range m.Flags {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UdpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UdpType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UdpType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *IcmpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IcmpType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IcmpType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA4 := make([]byte, len(m.Type)*10)
		var j3 int
		for _, num := range m.Type {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DnsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ProtocolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolType_Tcp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolType_Tcp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tcp != nil {
		{
			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ProtocolType_Icmp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolType_Icmp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Icmp != nil {
		{
			size, err := m.Icmp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ProtocolType_Udp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolType_Udp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Udp != nil {
		{
			size, err := m.Udp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProtocolType_Dns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolType_Dns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dns != nil {
		{
			size, err := m.Dns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ProtocolPolicerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolPolicerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolPolicerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Policer) > 0 {
		for iNdEx := len(m.Policer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Policer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Protocol != nil {
		{
			size, err := m.Protocol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for iNdEx := len(m.ProtocolPolicer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtocolPolicer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for iNdEx := len(m.ProtocolPolicer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtocolPolicer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for iNdEx := len(m.ProtocolPolicer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtocolPolicer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for iNdEx := len(m.ProtocolPolicer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtocolPolicer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TcpType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Flags) > 0 {
		l = 0
		for _, e := range m.Flags {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *UdpType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *IcmpType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Type) > 0 {
		l = 0
		for _, e := range m.Type {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *DnsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ProtocolType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *ProtocolType_Tcp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolType_Icmp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Icmp != nil {
		l = m.Icmp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolType_Udp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Udp != nil {
		l = m.Udp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolType_Dns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dns != nil {
		l = m.Dns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolPolicerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != nil {
		l = m.Protocol.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Policer) > 0 {
		for _, e := range m.Policer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TcpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TcpType{`,
		`Flags:` + fmt.Sprintf("%v", this.Flags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UdpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UdpType{`,
		`}`,
	}, "")
	return s
}
func (this *IcmpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IcmpType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DnsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DnsType{`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Tcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Tcp{`,
		`Tcp:` + strings.Replace(fmt.Sprintf("%v", this.Tcp), "TcpType", "TcpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Icmp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Icmp{`,
		`Icmp:` + strings.Replace(fmt.Sprintf("%v", this.Icmp), "IcmpType", "IcmpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Udp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Udp{`,
		`Udp:` + strings.Replace(fmt.Sprintf("%v", this.Udp), "UdpType", "UdpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Dns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Dns{`,
		`Dns:` + strings.Replace(fmt.Sprintf("%v", this.Dns), "DnsType", "DnsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolPolicerType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPolicer := "[]*ObjectRefType{"
	for _, f := range this.Policer {
		repeatedStringForPolicer += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForPolicer += "}"
	s := strings.Join([]string{`&ProtocolPolicerType{`,
		`Protocol:` + strings.Replace(this.Protocol.String(), "ProtocolType", "ProtocolType", 1) + `,`,
		`Policer:` + repeatedStringForPolicer + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProtocolPolicer := "[]*ProtocolPolicerType{"
	for _, f := range this.ProtocolPolicer {
		repeatedStringForProtocolPolicer += strings.Replace(f.String(), "ProtocolPolicerType", "ProtocolPolicerType", 1) + ","
	}
	repeatedStringForProtocolPolicer += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`ProtocolPolicer:` + repeatedStringForProtocolPolicer + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProtocolPolicer := "[]*ProtocolPolicerType{"
	for _, f := range this.ProtocolPolicer {
		repeatedStringForProtocolPolicer += strings.Replace(f.String(), "ProtocolPolicerType", "ProtocolPolicerType", 1) + ","
	}
	repeatedStringForProtocolPolicer += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`ProtocolPolicer:` + repeatedStringForProtocolPolicer + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProtocolPolicer := "[]*ProtocolPolicerType{"
	for _, f := range this.ProtocolPolicer {
		repeatedStringForProtocolPolicer += strings.Replace(f.String(), "ProtocolPolicerType", "ProtocolPolicerType", 1) + ","
	}
	repeatedStringForProtocolPolicer += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`ProtocolPolicer:` + repeatedStringForProtocolPolicer + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProtocolPolicer := "[]*ProtocolPolicerType{"
	for _, f := range this.ProtocolPolicer {
		repeatedStringForProtocolPolicer += strings.Replace(f.String(), "ProtocolPolicerType", "ProtocolPolicerType", 1) + ","
	}
	repeatedStringForProtocolPolicer += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`ProtocolPolicer:` + repeatedStringForProtocolPolicer + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TcpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v TcpFlags
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TcpFlags(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Flags = append(m.Flags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Flags) == 0 {
					m.Flags = make([]TcpFlags, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TcpFlags
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TcpFlags(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Flags = append(m.Flags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UdpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UdpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UdpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IcmpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IcmpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IcmpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v IcmpMsgType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= IcmpMsgType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Type = append(m.Type, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Type) == 0 {
					m.Type = make([]IcmpMsgType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v IcmpMsgType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= IcmpMsgType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Type = append(m.Type, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TcpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Tcp{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IcmpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Icmp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Udp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UdpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Udp{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Dns{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolPolicerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolPolicerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolPolicerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protocol == nil {
				m.Protocol = &ProtocolType{}
			}
			if err := m.Protocol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policer = append(m.Policer, &schema.ObjectRefType{})
			if err := m.Policer[len(m.Policer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)

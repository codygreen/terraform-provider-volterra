// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/protocol_policer/types.proto

package protocol_policer

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

import strconv "strconv"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// TCP Flags
//
// x-displayName: "TCP Flags"
// TCP flags indicate a particular connection state
type TcpFlags int32

const (
	// x-displayName: "Finished"
	// FIN flag which indicates that there is no more data from the sender, used in the last packet sent from the sender
	FIN TcpFlags = 0
	// x-displayName: "Synchronisation"
	// SYN flag set in the first packet from sender and receiver while establishing three way handshake between two hosts
	SYN TcpFlags = 1
	// x-displayName: "Reset"
	// RST flag that resets a connection when the host receives an unexpected packet
	RST TcpFlags = 2
	// x-displayName: "Push"
	// PSH flag that tells the receiver to process packets as they are received, instead of buffering them
	PSH TcpFlags = 3
	// x-displayName: "Acknowledgment"
	// ACK flag that acknowledges successful receipt of a packet
	ACK TcpFlags = 4
	// x-displayName: "Urgent"
	// URG flag that notifies the receiver about urgent packets that need to processed before other packets
	URG TcpFlags = 5
	// x-displayName: "Keepalive"
	// Keepalive flag tracks the keepalive packets for tcp connection liveness
	KEEPALIVE TcpFlags = 7
	// x-displayName: "All"
	// Match any TCP Flag - FIN / SYN / RST / PSH / ACK / URG / KEEPALIVE
	ALL_TCP_FLAGS TcpFlags = 6
)

var TcpFlags_name = map[int32]string{
	0: "FIN",
	1: "SYN",
	2: "RST",
	3: "PSH",
	4: "ACK",
	5: "URG",
	7: "KEEPALIVE",
	6: "ALL_TCP_FLAGS",
}
var TcpFlags_value = map[string]int32{
	"FIN":           0,
	"SYN":           1,
	"RST":           2,
	"PSH":           3,
	"ACK":           4,
	"URG":           5,
	"KEEPALIVE":     7,
	"ALL_TCP_FLAGS": 6,
}

func (TcpFlags) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// ICMP Message types
//
// x-displayName: "ICMP Message Types"
type IcmpMsgType int32

const (
	// x-displayName: "Echo Reply"
	// ICMP echo request packet which is sent by originator of Ping packet
	ECHO_REPLY IcmpMsgType = 0
	// x-displayName: "Echo Request"
	// ICMP echo reply packet which is sent in responce to ICMP echo request packet
	ECHO_REQUEST IcmpMsgType = 1
	// x-displayName: "All ICMP packets"
	// All ICMP packet types including TTL exceeded, destination
	// unreachable and source quench etc
	ALL_ICMP_MSG IcmpMsgType = 2
)

var IcmpMsgType_name = map[int32]string{
	0: "ECHO_REPLY",
	1: "ECHO_REQUEST",
	2: "ALL_ICMP_MSG",
}
var IcmpMsgType_value = map[string]int32{
	"ECHO_REPLY":   0,
	"ECHO_REQUEST": 1,
	"ALL_ICMP_MSG": 2,
}

func (IcmpMsgType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// TCP packet type
//
// x-displayName: "TCP Packet Type"
// Specification of TCP flag to be matched in a TCP packet
type TcpType struct {
	// flags
	//
	// x-displayName: "TCP flags"
	// TCP flag to be matched in a TCP packet
	Flags []TcpFlags `protobuf:"varint,1,rep,packed,name=flags,enum=ves.io.schema.protocol_policer.TcpFlags" json:"flags,omitempty"`
}

func (m *TcpType) Reset()                    { *m = TcpType{} }
func (*TcpType) ProtoMessage()               {}
func (*TcpType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *TcpType) GetFlags() []TcpFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

// All UDP packets
//
// x-displayName: "UDP Packets"
// Match all UDP packets
type UdpType struct {
}

func (m *UdpType) Reset()                    { *m = UdpType{} }
func (*UdpType) ProtoMessage()               {}
func (*UdpType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// ICMP packet type
//
// x-displayName: "ICMP Packet Type"
// ICMP message type to match in packet
type IcmpType struct {
	// type
	//
	// x-displayName: "ICMP type"
	// ICMP message type to be matched in packet
	Type []IcmpMsgType `protobuf:"varint,1,rep,packed,name=type,enum=ves.io.schema.protocol_policer.IcmpMsgType" json:"type,omitempty"`
}

func (m *IcmpType) Reset()                    { *m = IcmpType{} }
func (*IcmpType) ProtoMessage()               {}
func (*IcmpType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *IcmpType) GetType() []IcmpMsgType {
	if m != nil {
		return m.Type
	}
	return nil
}

// DNS packets
//
// x-displayName: "DNS Packets"
// Match all DNS packets inclusing UDP and TCP
type DnsType struct {
}

func (m *DnsType) Reset()                    { *m = DnsType{} }
func (*DnsType) ProtoMessage()               {}
func (*DnsType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// Protocol type
//
// x-displayName: "Protocol Type"
// Protocol and protocol specific flags to be matched in packet
type ProtocolType struct {
	// Type
	//
	// x-displayName: "Packet Type"
	// Provide various protocol specific match conditions
	//
	// Types that are valid to be assigned to Type:
	//	*ProtocolType_Tcp
	//	*ProtocolType_Icmp
	//	*ProtocolType_Udp
	//	*ProtocolType_Dns
	Type isProtocolType_Type `protobuf_oneof:"type"`
}

func (m *ProtocolType) Reset()                    { *m = ProtocolType{} }
func (*ProtocolType) ProtoMessage()               {}
func (*ProtocolType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isProtocolType_Type interface {
	isProtocolType_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProtocolType_Tcp struct {
	Tcp *TcpType `protobuf:"bytes,1,opt,name=tcp,oneof"`
}
type ProtocolType_Icmp struct {
	Icmp *IcmpType `protobuf:"bytes,2,opt,name=icmp,oneof"`
}
type ProtocolType_Udp struct {
	Udp *UdpType `protobuf:"bytes,3,opt,name=udp,oneof"`
}
type ProtocolType_Dns struct {
	Dns *DnsType `protobuf:"bytes,4,opt,name=dns,oneof"`
}

func (*ProtocolType_Tcp) isProtocolType_Type()  {}
func (*ProtocolType_Icmp) isProtocolType_Type() {}
func (*ProtocolType_Udp) isProtocolType_Type()  {}
func (*ProtocolType_Dns) isProtocolType_Type()  {}

func (m *ProtocolType) GetType() isProtocolType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ProtocolType) GetTcp() *TcpType {
	if x, ok := m.GetType().(*ProtocolType_Tcp); ok {
		return x.Tcp
	}
	return nil
}

func (m *ProtocolType) GetIcmp() *IcmpType {
	if x, ok := m.GetType().(*ProtocolType_Icmp); ok {
		return x.Icmp
	}
	return nil
}

func (m *ProtocolType) GetUdp() *UdpType {
	if x, ok := m.GetType().(*ProtocolType_Udp); ok {
		return x.Udp
	}
	return nil
}

func (m *ProtocolType) GetDns() *DnsType {
	if x, ok := m.GetType().(*ProtocolType_Dns); ok {
		return x.Dns
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ProtocolType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ProtocolType_OneofMarshaler, _ProtocolType_OneofUnmarshaler, _ProtocolType_OneofSizer, []interface{}{
		(*ProtocolType_Tcp)(nil),
		(*ProtocolType_Icmp)(nil),
		(*ProtocolType_Udp)(nil),
		(*ProtocolType_Dns)(nil),
	}
}

func _ProtocolType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ProtocolType)
	// type
	switch x := m.Type.(type) {
	case *ProtocolType_Tcp:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Tcp); err != nil {
			return err
		}
	case *ProtocolType_Icmp:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case *ProtocolType_Udp:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Udp); err != nil {
			return err
		}
	case *ProtocolType_Dns:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dns); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ProtocolType.Type has unexpected type %T", x)
	}
	return nil
}

func _ProtocolType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ProtocolType)
	switch tag {
	case 1: // type.tcp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TcpType)
		err := b.DecodeMessage(msg)
		m.Type = &ProtocolType_Tcp{msg}
		return true, err
	case 2: // type.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IcmpType)
		err := b.DecodeMessage(msg)
		m.Type = &ProtocolType_Icmp{msg}
		return true, err
	case 3: // type.udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UdpType)
		err := b.DecodeMessage(msg)
		m.Type = &ProtocolType_Udp{msg}
		return true, err
	case 4: // type.dns
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DnsType)
		err := b.DecodeMessage(msg)
		m.Type = &ProtocolType_Dns{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ProtocolType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ProtocolType)
	// type
	switch x := m.Type.(type) {
	case *ProtocolType_Tcp:
		s := proto.Size(x.Tcp)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ProtocolType_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ProtocolType_Udp:
		s := proto.Size(x.Udp)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ProtocolType_Dns:
		s := proto.Size(x.Dns)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Protocol Policer Type
//
// x-displayName: "Protocol Policer"
// Protocol policer has set or network protocol fields and flags to be match on
// a layer 4 packet and corresponding rate limit to be applied, this would be
// useful in specifying
// * Ratelimiting TCP sessions accepted from in a given duration
// * Ratelimiting various ICMP message type packets
// * Ratelimiting all UDP traffic
// * Ratelimting DNS traffic
type ProtocolPolicerType struct {
	// protocol
	//
	// x-displayName: "Protocol"
	// x-required
	// Protocol specifys L4 match criteria in a packet
	Protocol *ProtocolType `protobuf:"bytes,1,opt,name=protocol" json:"protocol,omitempty"`
	// policer
	//
	// x-displayName: "Policer"
	// x-required
	// Reference to policer object to apply traffic rate limits
	Policer []*ves_io_schema4.ObjectRefType `protobuf:"bytes,2,rep,name=policer" json:"policer,omitempty"`
}

func (m *ProtocolPolicerType) Reset()                    { *m = ProtocolPolicerType{} }
func (*ProtocolPolicerType) ProtoMessage()               {}
func (*ProtocolPolicerType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *ProtocolPolicerType) GetProtocol() *ProtocolType {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *ProtocolPolicerType) GetPolicer() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Policer
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for protocol policer
type GlobalSpecType struct {
	// Protocol policer
	//
	// x-displayName: "Protocol Policer"
	// List of L4 protocol match condition and associated traffic rate limits
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer" json:"protocol_policer,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *GlobalSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

// Create a Protocol policer object
//
// x-displayName: "Create Protocol Policer"
// Create a protocol_policer object, protocol_policer object contains list
// of L4 protocol match condition and corresponding traffic rate limits
type CreateSpecType struct {
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer" json:"protocol_policer,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *CreateSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

// Replace a Protocol policer object
//
// x-displayName: "Replace Protocol Policer"
// Replace a protocol_policer object with new L4 protocol match condition and
// corresponding traffic rate limits
type ReplaceSpecType struct {
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer" json:"protocol_policer,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *ReplaceSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

// Get a Protocol policer object
//
// x-displayName: "Get Protocol Policer"
// Get specification of a protocol_policer object with L4 protocol match condition and
// corresponding traffic rate limits
type GetSpecType struct {
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer" json:"protocol_policer,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *GetSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

func init() {
	proto.RegisterType((*TcpType)(nil), "ves.io.schema.protocol_policer.TcpType")
	proto.RegisterType((*UdpType)(nil), "ves.io.schema.protocol_policer.UdpType")
	proto.RegisterType((*IcmpType)(nil), "ves.io.schema.protocol_policer.IcmpType")
	proto.RegisterType((*DnsType)(nil), "ves.io.schema.protocol_policer.DnsType")
	proto.RegisterType((*ProtocolType)(nil), "ves.io.schema.protocol_policer.ProtocolType")
	proto.RegisterType((*ProtocolPolicerType)(nil), "ves.io.schema.protocol_policer.ProtocolPolicerType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.protocol_policer.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.protocol_policer.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.protocol_policer.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.protocol_policer.GetSpecType")
	proto.RegisterEnum("ves.io.schema.protocol_policer.TcpFlags", TcpFlags_name, TcpFlags_value)
	proto.RegisterEnum("ves.io.schema.protocol_policer.IcmpMsgType", IcmpMsgType_name, IcmpMsgType_value)
}
func (x TcpFlags) String() string {
	s, ok := TcpFlags_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x IcmpMsgType) String() string {
	s, ok := IcmpMsgType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TcpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpType)
	if !ok {
		that2, ok := that.(TcpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Flags) != len(that1.Flags) {
		return false
	}
	for i := range this.Flags {
		if this.Flags[i] != that1.Flags[i] {
			return false
		}
	}
	return true
}
func (this *UdpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UdpType)
	if !ok {
		that2, ok := that.(UdpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *IcmpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IcmpType)
	if !ok {
		that2, ok := that.(IcmpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Type) != len(that1.Type) {
		return false
	}
	for i := range this.Type {
		if this.Type[i] != that1.Type[i] {
			return false
		}
	}
	return true
}
func (this *DnsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DnsType)
	if !ok {
		that2, ok := that.(DnsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ProtocolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType)
	if !ok {
		that2, ok := that.(ProtocolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *ProtocolType_Tcp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Tcp)
	if !ok {
		that2, ok := that.(ProtocolType_Tcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tcp.Equal(that1.Tcp) {
		return false
	}
	return true
}
func (this *ProtocolType_Icmp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Icmp)
	if !ok {
		that2, ok := that.(ProtocolType_Icmp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Icmp.Equal(that1.Icmp) {
		return false
	}
	return true
}
func (this *ProtocolType_Udp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Udp)
	if !ok {
		that2, ok := that.(ProtocolType_Udp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Udp.Equal(that1.Udp) {
		return false
	}
	return true
}
func (this *ProtocolType_Dns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Dns)
	if !ok {
		that2, ok := that.(ProtocolType_Dns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dns.Equal(that1.Dns) {
		return false
	}
	return true
}
func (this *ProtocolPolicerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolPolicerType)
	if !ok {
		that2, ok := that.(ProtocolPolicerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Protocol.Equal(that1.Protocol) {
		return false
	}
	if len(this.Policer) != len(that1.Policer) {
		return false
	}
	for i := range this.Policer {
		if !this.Policer[i].Equal(that1.Policer[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *TcpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.TcpType{")
	s = append(s, "Flags: "+fmt.Sprintf("%#v", this.Flags)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UdpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&protocol_policer.UdpType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IcmpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.IcmpType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DnsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&protocol_policer.DnsType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&protocol_policer.ProtocolType{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolType_Tcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Tcp{` +
		`Tcp:` + fmt.Sprintf("%#v", this.Tcp) + `}`}, ", ")
	return s
}
func (this *ProtocolType_Icmp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Icmp{` +
		`Icmp:` + fmt.Sprintf("%#v", this.Icmp) + `}`}, ", ")
	return s
}
func (this *ProtocolType_Udp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Udp{` +
		`Udp:` + fmt.Sprintf("%#v", this.Udp) + `}`}, ", ")
	return s
}
func (this *ProtocolType_Dns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Dns{` +
		`Dns:` + fmt.Sprintf("%#v", this.Dns) + `}`}, ", ")
	return s
}
func (this *ProtocolPolicerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&protocol_policer.ProtocolPolicerType{")
	if this.Protocol != nil {
		s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	}
	if this.Policer != nil {
		s = append(s, "Policer: "+fmt.Sprintf("%#v", this.Policer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.GlobalSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.CreateSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.ReplaceSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.GetSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TcpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Flags) > 0 {
		dAtA2 := make([]byte, len(m.Flags)*10)
		var j1 int
		for _, num := range m.Flags {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *UdpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UdpType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *IcmpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IcmpType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA4 := make([]byte, len(m.Type)*10)
		var j3 int
		for _, num := range m.Type {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *DnsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ProtocolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn5, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *ProtocolType_Tcp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Tcp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Tcp.Size()))
		n6, err := m.Tcp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *ProtocolType_Icmp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Icmp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Icmp.Size()))
		n7, err := m.Icmp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *ProtocolType_Udp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Udp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Udp.Size()))
		n8, err := m.Udp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ProtocolType_Dns) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dns != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Dns.Size()))
		n9, err := m.Dns.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *ProtocolPolicerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolPolicerType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Protocol != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Protocol.Size()))
		n10, err := m.Protocol.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Policer) > 0 {
		for _, msg := range m.Policer {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, msg := range m.ProtocolPolicer {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, msg := range m.ProtocolPolicer {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, msg := range m.ProtocolPolicer {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, msg := range m.ProtocolPolicer {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TcpType) Size() (n int) {
	var l int
	_ = l
	if len(m.Flags) > 0 {
		l = 0
		for _, e := range m.Flags {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *UdpType) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *IcmpType) Size() (n int) {
	var l int
	_ = l
	if len(m.Type) > 0 {
		l = 0
		for _, e := range m.Type {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *DnsType) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ProtocolType) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *ProtocolType_Tcp) Size() (n int) {
	var l int
	_ = l
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolType_Icmp) Size() (n int) {
	var l int
	_ = l
	if m.Icmp != nil {
		l = m.Icmp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolType_Udp) Size() (n int) {
	var l int
	_ = l
	if m.Udp != nil {
		l = m.Udp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolType_Dns) Size() (n int) {
	var l int
	_ = l
	if m.Dns != nil {
		l = m.Dns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolPolicerType) Size() (n int) {
	var l int
	_ = l
	if m.Protocol != nil {
		l = m.Protocol.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Policer) > 0 {
		for _, e := range m.Policer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TcpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TcpType{`,
		`Flags:` + fmt.Sprintf("%v", this.Flags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UdpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UdpType{`,
		`}`,
	}, "")
	return s
}
func (this *IcmpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IcmpType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DnsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DnsType{`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Tcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Tcp{`,
		`Tcp:` + strings.Replace(fmt.Sprintf("%v", this.Tcp), "TcpType", "TcpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Icmp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Icmp{`,
		`Icmp:` + strings.Replace(fmt.Sprintf("%v", this.Icmp), "IcmpType", "IcmpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Udp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Udp{`,
		`Udp:` + strings.Replace(fmt.Sprintf("%v", this.Udp), "UdpType", "UdpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Dns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Dns{`,
		`Dns:` + strings.Replace(fmt.Sprintf("%v", this.Dns), "DnsType", "DnsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolPolicerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolPolicerType{`,
		`Protocol:` + strings.Replace(fmt.Sprintf("%v", this.Protocol), "ProtocolType", "ProtocolType", 1) + `,`,
		`Policer:` + strings.Replace(fmt.Sprintf("%v", this.Policer), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`ProtocolPolicer:` + strings.Replace(fmt.Sprintf("%v", this.ProtocolPolicer), "ProtocolPolicerType", "ProtocolPolicerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`ProtocolPolicer:` + strings.Replace(fmt.Sprintf("%v", this.ProtocolPolicer), "ProtocolPolicerType", "ProtocolPolicerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`ProtocolPolicer:` + strings.Replace(fmt.Sprintf("%v", this.ProtocolPolicer), "ProtocolPolicerType", "ProtocolPolicerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`ProtocolPolicer:` + strings.Replace(fmt.Sprintf("%v", this.ProtocolPolicer), "ProtocolPolicerType", "ProtocolPolicerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TcpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v TcpFlags
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (TcpFlags(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Flags = append(m.Flags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v TcpFlags
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (TcpFlags(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Flags = append(m.Flags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UdpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UdpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UdpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IcmpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IcmpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IcmpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v IcmpMsgType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (IcmpMsgType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Type = append(m.Type, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v IcmpMsgType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (IcmpMsgType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Type = append(m.Type, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TcpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Tcp{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IcmpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Icmp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Udp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UdpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Udp{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Dns{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolPolicerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolPolicerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolPolicerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protocol == nil {
				m.Protocol = &ProtocolType{}
			}
			if err := m.Protocol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policer = append(m.Policer, &ves_io_schema4.ObjectRefType{})
			if err := m.Policer[len(m.Policer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/protocol_policer/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 743 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x95, 0x4f, 0x6f, 0x1a, 0x47,
	0x18, 0xc6, 0x19, 0xfe, 0x18, 0x3c, 0xd8, 0x78, 0xba, 0x6d, 0x55, 0x4a, 0xad, 0x15, 0xe2, 0x52,
	0xe4, 0xd6, 0x8b, 0x8a, 0x6f, 0xad, 0x44, 0x0b, 0x14, 0x03, 0x35, 0xb6, 0xe9, 0x82, 0x2d, 0xb9,
	0x87, 0xa2, 0x65, 0x19, 0xd6, 0x9b, 0x2c, 0xcc, 0x68, 0x77, 0x21, 0xf1, 0x21, 0x52, 0x0e, 0x91,
	0x93, 0x63, 0x94, 0x7b, 0xee, 0x51, 0xbe, 0x40, 0xa4, 0xf8, 0xe2, 0x63, 0x94, 0x93, 0x8f, 0x3e,
	0xc6, 0x9b, 0x4b, 0x72, 0xb3, 0xf2, 0x09, 0xa2, 0x99, 0xdd, 0xb5, 0x80, 0x28, 0x31, 0x87, 0x48,
	0xbe, 0x3d, 0x33, 0xef, 0xfb, 0x7b, 0xde, 0x67, 0x5f, 0xa1, 0x01, 0xae, 0x8d, 0xb1, 0x25, 0xe9,
	0x24, 0x67, 0xa9, 0x87, 0x78, 0xa0, 0xe4, 0xa8, 0x49, 0x6c, 0xa2, 0x12, 0xa3, 0x43, 0x89, 0xa1,
	0xab, 0xd8, 0xcc, 0xd9, 0x47, 0x14, 0x5b, 0x12, 0xbf, 0x16, 0x44, 0xb7, 0x57, 0x72, 0x7b, 0xa5,
	0xd9, 0xde, 0xd4, 0xba, 0xa6, 0xdb, 0x87, 0xa3, 0xae, 0xa4, 0x92, 0x41, 0x4e, 0x23, 0x1a, 0x71,
	0xdd, 0xba, 0xa3, 0x3e, 0x3f, 0xf1, 0x03, 0x57, 0x2e, 0x99, 0xfa, 0x61, 0x7a, 0xf4, 0x10, 0xdb,
	0x5e, 0xe1, 0xa7, 0xe9, 0x02, 0xa1, 0xb6, 0x4e, 0x86, 0x5e, 0x88, 0xd4, 0x8f, 0xd3, 0xc5, 0x89,
	0x7c, 0xa9, 0xd5, 0xe9, 0xd2, 0x58, 0x31, 0xf4, 0x9e, 0x62, 0x63, 0xaf, 0x9a, 0x9e, 0xa9, 0xea,
	0xf8, 0x4e, 0x67, 0xca, 0x3a, 0x53, 0x87, 0xd1, 0xb6, 0x4a, 0xdb, 0x47, 0x14, 0x0b, 0x05, 0x18,
	0xe9, 0x1b, 0x8a, 0x66, 0x25, 0x41, 0x3a, 0x94, 0x4d, 0xe4, 0xb3, 0xd2, 0x97, 0x3f, 0x5d, 0x6a,
	0xab, 0x74, 0x93, 0xf5, 0xcb, 0x2e, 0x96, 0x59, 0x84, 0xd1, 0xbd, 0x1e, 0xb7, 0xca, 0x6c, 0xc1,
	0x58, 0x5d, 0x1d, 0xb8, 0xb6, 0x7f, 0xc2, 0x30, 0x0b, 0xec, 0xb9, 0xfe, 0x72, 0x9d, 0x2b, 0xe3,
	0xb6, 0x2d, 0x8d, 0xa1, 0x32, 0x07, 0x99, 0xef, 0xdf, 0x43, 0x8b, 0xfb, 0x3e, 0x0d, 0xc2, 0xa5,
	0xa6, 0x47, 0x70, 0xf3, 0x3f, 0x60, 0xc8, 0x56, 0x69, 0x12, 0xa4, 0x41, 0x36, 0x9e, 0xff, 0x79,
	0x8e, 0xc4, 0x8c, 0xaa, 0x05, 0x64, 0x46, 0x09, 0x05, 0x18, 0xd6, 0xd5, 0x01, 0x4d, 0x06, 0x39,
	0x9d, 0x9d, 0x27, 0x99, 0x87, 0x73, 0x8e, 0x0d, 0x1f, 0xf5, 0x68, 0x32, 0x34, 0xdf, 0x70, 0x6f,
	0x37, 0x6c, 0xf8, 0xa8, 0xc7, 0xe1, 0xde, 0xd0, 0x4a, 0x86, 0xe7, 0x83, 0xbd, 0x05, 0x30, 0xb8,
	0x37, 0xb4, 0x4a, 0xc8, 0xdd, 0xa9, 0x10, 0x3b, 0x3d, 0x01, 0xe0, 0xec, 0x04, 0x44, 0xfe, 0x09,
	0xc7, 0x22, 0x68, 0x21, 0xf3, 0x02, 0xc0, 0x6f, 0xfd, 0xfd, 0x34, 0x5d, 0x94, 0xaf, 0xa9, 0x06,
	0x63, 0xbe, 0xa5, 0xb7, 0xab, 0x5f, 0xaf, 0x9b, 0x38, 0xb9, 0x66, 0xf9, 0x8a, 0x16, 0xf6, 0x61,
	0xd4, 0xeb, 0x48, 0x06, 0xd3, 0xa1, 0x6c, 0x3c, 0xbf, 0x3a, 0x63, 0xb4, 0xdb, 0xbd, 0x85, 0x55,
	0x5b, 0xc6, 0x7d, 0x06, 0x96, 0xc4, 0xe7, 0xf7, 0xfc, 0xfe, 0x97, 0xef, 0x4f, 0x43, 0x91, 0x27,
	0x20, 0x88, 0x80, 0xaf, 0x62, 0x40, 0xf6, 0x8b, 0x99, 0x63, 0x00, 0x13, 0x55, 0x83, 0x74, 0x15,
	0xa3, 0x45, 0xb1, 0xca, 0x43, 0xdb, 0x10, 0xcd, 0xa6, 0xe2, 0x3f, 0xa2, 0x78, 0x7e, 0x63, 0xde,
	0xf0, 0x13, 0x3b, 0x28, 0x7d, 0x77, 0x15, 0xe0, 0x2f, 0x5f, 0x25, 0x81, 0xbc, 0x42, 0xa7, 0x5b,
	0x33, 0x0f, 0x01, 0x4c, 0x94, 0x4d, 0xac, 0xd8, 0xf8, 0x2a, 0xc8, 0xff, 0x5f, 0x35, 0xc8, 0x27,
	0x23, 0x7f, 0xff, 0xfe, 0x75, 0x61, 0xe6, 0xdb, 0x3f, 0x14, 0xc0, 0x6f, 0x99, 0x47, 0x00, 0xae,
	0xc8, 0x98, 0x1a, 0x8a, 0x7a, 0xe3, 0x51, 0x1e, 0x00, 0x18, 0xaf, 0x62, 0xfb, 0x86, 0x63, 0xac,
	0x75, 0x61, 0xcc, 0x7f, 0x74, 0x84, 0x28, 0x0c, 0x6d, 0xd6, 0x77, 0x50, 0x80, 0x89, 0xd6, 0xc1,
	0x0e, 0x02, 0x4c, 0xc8, 0xad, 0x36, 0x0a, 0x32, 0xd1, 0x6c, 0xd5, 0x50, 0x88, 0x89, 0x62, 0x79,
	0x0b, 0x85, 0x99, 0xd8, 0x93, 0xab, 0x28, 0x22, 0x2c, 0xc3, 0xc5, 0xad, 0x4a, 0xa5, 0x59, 0x6c,
	0xd4, 0xf7, 0x2b, 0x28, 0x2a, 0x7c, 0x03, 0x97, 0x8b, 0x8d, 0x46, 0xa7, 0x5d, 0x6e, 0x76, 0x36,
	0x1b, 0xc5, 0x6a, 0x0b, 0x2d, 0xac, 0x15, 0x61, 0x7c, 0xe2, 0x09, 0x12, 0x12, 0x10, 0x56, 0xca,
	0xb5, 0xdd, 0x8e, 0x5c, 0x69, 0x36, 0x0e, 0x50, 0x40, 0x40, 0x70, 0xc9, 0x3b, 0xff, 0xbb, 0x57,
	0x69, 0xb5, 0x11, 0x60, 0x37, 0xcc, 0xa3, 0x5e, 0xde, 0x6e, 0x76, 0xb6, 0x5b, 0x55, 0x14, 0x2c,
	0x1d, 0x83, 0xb3, 0x0b, 0x31, 0x70, 0x7e, 0x21, 0x06, 0x2e, 0x2f, 0x44, 0x70, 0xdf, 0x11, 0xc1,
	0x33, 0x47, 0x04, 0xaf, 0x1c, 0x11, 0x9c, 0x39, 0x22, 0x38, 0x77, 0x44, 0xf0, 0xc6, 0x11, 0xc1,
	0x3b, 0x47, 0x0c, 0x5c, 0x3a, 0x22, 0x78, 0xfc, 0x56, 0x0c, 0xfc, 0xd7, 0xd6, 0x08, 0xbd, 0xad,
	0x49, 0x63, 0x62, 0xd8, 0xd8, 0x34, 0x15, 0x69, 0x64, 0xe5, 0xb8, 0xe8, 0x13, 0x73, 0xb0, 0x4e,
	0x4d, 0x32, 0xd6, 0x7b, 0xd8, 0x5c, 0xf7, 0xcb, 0x39, 0xda, 0xd5, 0x48, 0x0e, 0xdf, 0xb5, 0xbd,
	0x77, 0xfd, 0x33, 0x7f, 0x64, 0xdd, 0x05, 0x7e, 0xb3, 0xf1, 0x31, 0x00, 0x00, 0xff, 0xff, 0xc5,
	0x63, 0xfc, 0xff, 0xf1, 0x06, 0x00, 0x00,
}

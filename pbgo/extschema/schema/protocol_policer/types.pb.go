// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/protocol_policer/types.proto

package protocol_policer

import (
	fmt "fmt"

	proto "github.com/gogo/protobuf/proto"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// TCP Flags
//
// x-displayName: "TCP Flags"
// TCP flags indicate a particular connection state
type TcpFlags int32

const (
	// "Finished" flag indicates there will be no more data from the sender
	FIN TcpFlags = 0
	// "Synchronisation" flag, is first step in establishing in TCP connection
	SYN TcpFlags = 1
	// "Reset" flag gets sent from the server to the client upon receiving unexpected
	// data
	RST TcpFlags = 2
	// "Push" flag indicates receiver to not buffer data
	PSH TcpFlags = 3
	// "Acknowledgment" to the successful receipt of data
	ACK TcpFlags = 4
	// "Urgent" flag is used to notify the receiver to process the urgent packets before
	// processing all other packets.
	URG TcpFlags = 5
	// All of the above flags in union
	ALL_TCP_FLAGS TcpFlags = 6
)

var TcpFlags_name = map[int32]string{
	0: "FIN",
	1: "SYN",
	2: "RST",
	3: "PSH",
	4: "ACK",
	5: "URG",
	6: "ALL_TCP_FLAGS",
}
var TcpFlags_value = map[string]int32{
	"FIN":           0,
	"SYN":           1,
	"RST":           2,
	"PSH":           3,
	"ACK":           4,
	"URG":           5,
	"ALL_TCP_FLAGS": 6,
}

func (TcpFlags) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// ICMP Message types
//
// x-displayName: "ICMP Message Types"
type IcmpMsgType int32

const (
	// ICMP echo request packet which is sent by originator of Ping packet
	ECHO_REPLY IcmpMsgType = 0
	// ICMP echo reply packet which is sent in responce to ICMP echo request packet
	ECHO_REQUEST IcmpMsgType = 1
	// All ICMP packet types including TTL exceeded, destination
	// unreachable and source quench etc
	ALL_ICMP_MSG IcmpMsgType = 2
)

var IcmpMsgType_name = map[int32]string{
	0: "ECHO_REPLY",
	1: "ECHO_REQUEST",
	2: "ALL_ICMP_MSG",
}
var IcmpMsgType_value = map[string]int32{
	"ECHO_REPLY":   0,
	"ECHO_REQUEST": 1,
	"ALL_ICMP_MSG": 2,
}

func (IcmpMsgType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// TCP packet type
//
// x-displayName: "TCP Packet Type"
// Specification of TCP flag to be matched in a TCP packet
type TcpType struct {
	Flags []TcpFlags `protobuf:"varint,1,rep,packed,name=flags,enum=ves.io.schema.protocol_policer.TcpFlags" json:"flags,omitempty"`
}

func (m *TcpType) Reset()                    { *m = TcpType{} }
func (*TcpType) ProtoMessage()               {}
func (*TcpType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *TcpType) GetFlags() []TcpFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

// All UDP packets
//
// x-displayName: "UDP Packets"
// Match all UDP packets
type UdpType struct {
}

func (m *UdpType) Reset()                    { *m = UdpType{} }
func (*UdpType) ProtoMessage()               {}
func (*UdpType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// ICMP packet type
//
// x-displayName: "ICMP Packet Type"
// ICMP message type to match in packet
type IcmpType struct {
	Type []IcmpMsgType `protobuf:"varint,1,rep,packed,name=type,enum=ves.io.schema.protocol_policer.IcmpMsgType" json:"type,omitempty"`
}

func (m *IcmpType) Reset()                    { *m = IcmpType{} }
func (*IcmpType) ProtoMessage()               {}
func (*IcmpType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *IcmpType) GetType() []IcmpMsgType {
	if m != nil {
		return m.Type
	}
	return nil
}

// DNS packets
//
// x-displayName: "DNS Packets"
// Match all DNS packets inclusing UDP and TCP
type DnsType struct {
}

func (m *DnsType) Reset()                    { *m = DnsType{} }
func (*DnsType) ProtoMessage()               {}
func (*DnsType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// Protocol type
//
// x-displayName: "Protocol Type"
// Protocol and protocol specific flags to be matched in packet
type ProtocolType struct {
	// Type
	//
	// x-displayName: "Packet Type"
	// Provide various protocol specific match conditions
	//
	// Types that are valid to be assigned to Type:
	//	*ProtocolType_Tcp
	//	*ProtocolType_Icmp
	//	*ProtocolType_Udp
	//	*ProtocolType_Dns
	Type isProtocolType_Type `protobuf_oneof:"Type"`
}

func (m *ProtocolType) Reset()                    { *m = ProtocolType{} }
func (*ProtocolType) ProtoMessage()               {}
func (*ProtocolType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isProtocolType_Type interface {
	isProtocolType_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProtocolType_Tcp struct {
	Tcp *TcpType `protobuf:"bytes,1,opt,name=tcp,oneof"`
}
type ProtocolType_Icmp struct {
	Icmp *IcmpType `protobuf:"bytes,2,opt,name=icmp,oneof"`
}
type ProtocolType_Udp struct {
	Udp *UdpType `protobuf:"bytes,3,opt,name=udp,oneof"`
}
type ProtocolType_Dns struct {
	Dns *DnsType `protobuf:"bytes,4,opt,name=dns,oneof"`
}

func (*ProtocolType_Tcp) isProtocolType_Type()  {}
func (*ProtocolType_Icmp) isProtocolType_Type() {}
func (*ProtocolType_Udp) isProtocolType_Type()  {}
func (*ProtocolType_Dns) isProtocolType_Type()  {}

func (m *ProtocolType) GetType() isProtocolType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ProtocolType) GetTcp() *TcpType {
	if x, ok := m.GetType().(*ProtocolType_Tcp); ok {
		return x.Tcp
	}
	return nil
}

func (m *ProtocolType) GetIcmp() *IcmpType {
	if x, ok := m.GetType().(*ProtocolType_Icmp); ok {
		return x.Icmp
	}
	return nil
}

func (m *ProtocolType) GetUdp() *UdpType {
	if x, ok := m.GetType().(*ProtocolType_Udp); ok {
		return x.Udp
	}
	return nil
}

func (m *ProtocolType) GetDns() *DnsType {
	if x, ok := m.GetType().(*ProtocolType_Dns); ok {
		return x.Dns
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ProtocolType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ProtocolType_OneofMarshaler, _ProtocolType_OneofUnmarshaler, _ProtocolType_OneofSizer, []interface{}{
		(*ProtocolType_Tcp)(nil),
		(*ProtocolType_Icmp)(nil),
		(*ProtocolType_Udp)(nil),
		(*ProtocolType_Dns)(nil),
	}
}

func _ProtocolType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ProtocolType)
	// Type
	switch x := m.Type.(type) {
	case *ProtocolType_Tcp:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Tcp); err != nil {
			return err
		}
	case *ProtocolType_Icmp:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case *ProtocolType_Udp:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Udp); err != nil {
			return err
		}
	case *ProtocolType_Dns:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dns); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ProtocolType.Type has unexpected type %T", x)
	}
	return nil
}

func _ProtocolType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ProtocolType)
	switch tag {
	case 1: // Type.tcp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TcpType)
		err := b.DecodeMessage(msg)
		m.Type = &ProtocolType_Tcp{msg}
		return true, err
	case 2: // Type.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IcmpType)
		err := b.DecodeMessage(msg)
		m.Type = &ProtocolType_Icmp{msg}
		return true, err
	case 3: // Type.udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UdpType)
		err := b.DecodeMessage(msg)
		m.Type = &ProtocolType_Udp{msg}
		return true, err
	case 4: // Type.dns
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DnsType)
		err := b.DecodeMessage(msg)
		m.Type = &ProtocolType_Dns{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ProtocolType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ProtocolType)
	// Type
	switch x := m.Type.(type) {
	case *ProtocolType_Tcp:
		s := proto.Size(x.Tcp)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ProtocolType_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ProtocolType_Udp:
		s := proto.Size(x.Udp)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ProtocolType_Dns:
		s := proto.Size(x.Dns)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Protocol Policer Type
//
// x-displayName: "Protocol Policer"
// Protocol policer has set or network protocol fields and flags to be match on
// a layer 4 packet and corresponding rate limit to be applied, this would be
// useful in specifying
// * Ratelimiting TCP sessions accepted from in a given duration
// * Ratelimiting various ICMP message type packets
// * Ratelimiting all UDP traffic
// * Ratelimting DNS traffic
type ProtocolPolicerType struct {
	// protocol
	//
	// x-displayName: "Protocol"
	// x-required
	// Protocol specifys L4 match criteria in a packet
	Protocol *ProtocolType `protobuf:"bytes,1,opt,name=protocol" json:"protocol,omitempty"`
	// policer
	//
	// x-displayName: "Policer"
	// x-required
	// Reference to policer object to apply traffic rate limits
	Policer []*ves_io_schema4.ObjectRefType `protobuf:"bytes,2,rep,name=policer" json:"policer,omitempty"`
}

func (m *ProtocolPolicerType) Reset()                    { *m = ProtocolPolicerType{} }
func (*ProtocolPolicerType) ProtoMessage()               {}
func (*ProtocolPolicerType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *ProtocolPolicerType) GetProtocol() *ProtocolType {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *ProtocolPolicerType) GetPolicer() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Policer
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for protocol policer
type GlobalSpecType struct {
	// Protocol policer
	//
	// x-displayName: "Protocol Policer"
	// List of L4 protocol match condition and associated traffic rate limits
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer" json:"protocol_policer,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *GlobalSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

// Create a Protocol policer object
//
// x-displayName: "Create a Protocol Policer Object"
// Create a protocol_policer object, protocol_policer object contains list
// of L4 protocol match condition and corresponding traffic rate limits
type CreateSpecType struct {
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer" json:"protocol_policer,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *CreateSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

// Replace a Protocol policer object
//
// x-displayName: "Replace a Protocol Policer Object"
// Replace a protocol_policer object with new L4 protocol match condition and
// corresponding traffic rate limits
type ReplaceSpecType struct {
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer" json:"protocol_policer,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *ReplaceSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

// Get a Protocol policer object
//
// x-displayName: "Get a Protocol Policer Object"
// Get specification of a protocol_policer object with L4 protocol match condition and
// corresponding traffic rate limits
type GetSpecType struct {
	ProtocolPolicer []*ProtocolPolicerType `protobuf:"bytes,1,rep,name=protocol_policer,json=protocolPolicer" json:"protocol_policer,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *GetSpecType) GetProtocolPolicer() []*ProtocolPolicerType {
	if m != nil {
		return m.ProtocolPolicer
	}
	return nil
}

func init() {
	proto.RegisterType((*TcpType)(nil), "ves.io.schema.protocol_policer.TcpType")
	proto.RegisterType((*UdpType)(nil), "ves.io.schema.protocol_policer.UdpType")
	proto.RegisterType((*IcmpType)(nil), "ves.io.schema.protocol_policer.IcmpType")
	proto.RegisterType((*DnsType)(nil), "ves.io.schema.protocol_policer.DnsType")
	proto.RegisterType((*ProtocolType)(nil), "ves.io.schema.protocol_policer.ProtocolType")
	proto.RegisterType((*ProtocolPolicerType)(nil), "ves.io.schema.protocol_policer.ProtocolPolicerType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.protocol_policer.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.protocol_policer.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.protocol_policer.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.protocol_policer.GetSpecType")
	proto.RegisterEnum("ves.io.schema.protocol_policer.TcpFlags", TcpFlags_name, TcpFlags_value)
	proto.RegisterEnum("ves.io.schema.protocol_policer.IcmpMsgType", IcmpMsgType_name, IcmpMsgType_value)
}
func (x TcpFlags) String() string {
	s, ok := TcpFlags_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x IcmpMsgType) String() string {
	s, ok := IcmpMsgType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TcpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpType)
	if !ok {
		that2, ok := that.(TcpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Flags) != len(that1.Flags) {
		return false
	}
	for i := range this.Flags {
		if this.Flags[i] != that1.Flags[i] {
			return false
		}
	}
	return true
}
func (this *UdpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UdpType)
	if !ok {
		that2, ok := that.(UdpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *IcmpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IcmpType)
	if !ok {
		that2, ok := that.(IcmpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Type) != len(that1.Type) {
		return false
	}
	for i := range this.Type {
		if this.Type[i] != that1.Type[i] {
			return false
		}
	}
	return true
}
func (this *DnsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DnsType)
	if !ok {
		that2, ok := that.(DnsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ProtocolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType)
	if !ok {
		that2, ok := that.(ProtocolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *ProtocolType_Tcp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Tcp)
	if !ok {
		that2, ok := that.(ProtocolType_Tcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tcp.Equal(that1.Tcp) {
		return false
	}
	return true
}
func (this *ProtocolType_Icmp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Icmp)
	if !ok {
		that2, ok := that.(ProtocolType_Icmp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Icmp.Equal(that1.Icmp) {
		return false
	}
	return true
}
func (this *ProtocolType_Udp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Udp)
	if !ok {
		that2, ok := that.(ProtocolType_Udp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Udp.Equal(that1.Udp) {
		return false
	}
	return true
}
func (this *ProtocolType_Dns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolType_Dns)
	if !ok {
		that2, ok := that.(ProtocolType_Dns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dns.Equal(that1.Dns) {
		return false
	}
	return true
}
func (this *ProtocolPolicerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolPolicerType)
	if !ok {
		that2, ok := that.(ProtocolPolicerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Protocol.Equal(that1.Protocol) {
		return false
	}
	if len(this.Policer) != len(that1.Policer) {
		return false
	}
	for i := range this.Policer {
		if !this.Policer[i].Equal(that1.Policer[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtocolPolicer) != len(that1.ProtocolPolicer) {
		return false
	}
	for i := range this.ProtocolPolicer {
		if !this.ProtocolPolicer[i].Equal(that1.ProtocolPolicer[i]) {
			return false
		}
	}
	return true
}
func (this *TcpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.TcpType{")
	s = append(s, "Flags: "+fmt.Sprintf("%#v", this.Flags)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UdpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&protocol_policer.UdpType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IcmpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.IcmpType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DnsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&protocol_policer.DnsType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&protocol_policer.ProtocolType{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolType_Tcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Tcp{` +
		`Tcp:` + fmt.Sprintf("%#v", this.Tcp) + `}`}, ", ")
	return s
}
func (this *ProtocolType_Icmp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Icmp{` +
		`Icmp:` + fmt.Sprintf("%#v", this.Icmp) + `}`}, ", ")
	return s
}
func (this *ProtocolType_Udp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Udp{` +
		`Udp:` + fmt.Sprintf("%#v", this.Udp) + `}`}, ", ")
	return s
}
func (this *ProtocolType_Dns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&protocol_policer.ProtocolType_Dns{` +
		`Dns:` + fmt.Sprintf("%#v", this.Dns) + `}`}, ", ")
	return s
}
func (this *ProtocolPolicerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&protocol_policer.ProtocolPolicerType{")
	if this.Protocol != nil {
		s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	}
	if this.Policer != nil {
		s = append(s, "Policer: "+fmt.Sprintf("%#v", this.Policer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.GlobalSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.CreateSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.ReplaceSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&protocol_policer.GetSpecType{")
	if this.ProtocolPolicer != nil {
		s = append(s, "ProtocolPolicer: "+fmt.Sprintf("%#v", this.ProtocolPolicer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TcpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Flags) > 0 {
		dAtA2 := make([]byte, len(m.Flags)*10)
		var j1 int
		for _, num := range m.Flags {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *UdpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UdpType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *IcmpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IcmpType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA4 := make([]byte, len(m.Type)*10)
		var j3 int
		for _, num := range m.Type {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *DnsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ProtocolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn5, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *ProtocolType_Tcp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Tcp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Tcp.Size()))
		n6, err := m.Tcp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *ProtocolType_Icmp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Icmp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Icmp.Size()))
		n7, err := m.Icmp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *ProtocolType_Udp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Udp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Udp.Size()))
		n8, err := m.Udp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ProtocolType_Dns) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dns != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Dns.Size()))
		n9, err := m.Dns.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *ProtocolPolicerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolPolicerType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Protocol != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Protocol.Size()))
		n10, err := m.Protocol.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Policer) > 0 {
		for _, msg := range m.Policer {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, msg := range m.ProtocolPolicer {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, msg := range m.ProtocolPolicer {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, msg := range m.ProtocolPolicer {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, msg := range m.ProtocolPolicer {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedTcpType(r randyTypes, easy bool) *TcpType {
	this := &TcpType{}
	v1 := r.Intn(10)
	this.Flags = make([]TcpFlags, v1)
	for i := 0; i < v1; i++ {
		this.Flags[i] = TcpFlags([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUdpType(r randyTypes, easy bool) *UdpType {
	this := &UdpType{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIcmpType(r randyTypes, easy bool) *IcmpType {
	this := &IcmpType{}
	v2 := r.Intn(10)
	this.Type = make([]IcmpMsgType, v2)
	for i := 0; i < v2; i++ {
		this.Type[i] = IcmpMsgType([]int32{0, 1, 2}[r.Intn(3)])
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDnsType(r randyTypes, easy bool) *DnsType {
	this := &DnsType{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProtocolType(r randyTypes, easy bool) *ProtocolType {
	this := &ProtocolType{}
	oneofNumber_Type := []int32{1, 2, 3, 4}[r.Intn(4)]
	switch oneofNumber_Type {
	case 1:
		this.Type = NewPopulatedProtocolType_Tcp(r, easy)
	case 2:
		this.Type = NewPopulatedProtocolType_Icmp(r, easy)
	case 3:
		this.Type = NewPopulatedProtocolType_Udp(r, easy)
	case 4:
		this.Type = NewPopulatedProtocolType_Dns(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProtocolType_Tcp(r randyTypes, easy bool) *ProtocolType_Tcp {
	this := &ProtocolType_Tcp{}
	this.Tcp = NewPopulatedTcpType(r, easy)
	return this
}
func NewPopulatedProtocolType_Icmp(r randyTypes, easy bool) *ProtocolType_Icmp {
	this := &ProtocolType_Icmp{}
	this.Icmp = NewPopulatedIcmpType(r, easy)
	return this
}
func NewPopulatedProtocolType_Udp(r randyTypes, easy bool) *ProtocolType_Udp {
	this := &ProtocolType_Udp{}
	this.Udp = NewPopulatedUdpType(r, easy)
	return this
}
func NewPopulatedProtocolType_Dns(r randyTypes, easy bool) *ProtocolType_Dns {
	this := &ProtocolType_Dns{}
	this.Dns = NewPopulatedDnsType(r, easy)
	return this
}
func NewPopulatedProtocolPolicerType(r randyTypes, easy bool) *ProtocolPolicerType {
	this := &ProtocolPolicerType{}
	if r.Intn(10) != 0 {
		this.Protocol = NewPopulatedProtocolType(r, easy)
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Policer = make([]*ves_io_schema4.ObjectRefType, v3)
		for i := 0; i < v3; i++ {
			this.Policer[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.ProtocolPolicer = make([]*ProtocolPolicerType, v4)
		for i := 0; i < v4; i++ {
			this.ProtocolPolicer[i] = NewPopulatedProtocolPolicerType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.ProtocolPolicer = make([]*ProtocolPolicerType, v5)
		for i := 0; i < v5; i++ {
			this.ProtocolPolicer[i] = NewPopulatedProtocolPolicerType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.ProtocolPolicer = make([]*ProtocolPolicerType, v6)
		for i := 0; i < v6; i++ {
			this.ProtocolPolicer[i] = NewPopulatedProtocolPolicerType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.ProtocolPolicer = make([]*ProtocolPolicerType, v7)
		for i := 0; i < v7; i++ {
			this.ProtocolPolicer[i] = NewPopulatedProtocolPolicerType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v8 := r.Intn(100)
	tmps := make([]rune, v8)
	for i := 0; i < v8; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v9 := r.Int63()
		if r.Intn(2) == 0 {
			v9 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v9))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *TcpType) Size() (n int) {
	var l int
	_ = l
	if len(m.Flags) > 0 {
		l = 0
		for _, e := range m.Flags {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *UdpType) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *IcmpType) Size() (n int) {
	var l int
	_ = l
	if len(m.Type) > 0 {
		l = 0
		for _, e := range m.Type {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *DnsType) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ProtocolType) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *ProtocolType_Tcp) Size() (n int) {
	var l int
	_ = l
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolType_Icmp) Size() (n int) {
	var l int
	_ = l
	if m.Icmp != nil {
		l = m.Icmp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolType_Udp) Size() (n int) {
	var l int
	_ = l
	if m.Udp != nil {
		l = m.Udp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolType_Dns) Size() (n int) {
	var l int
	_ = l
	if m.Dns != nil {
		l = m.Dns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtocolPolicerType) Size() (n int) {
	var l int
	_ = l
	if m.Protocol != nil {
		l = m.Protocol.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Policer) > 0 {
		for _, e := range m.Policer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtocolPolicer) > 0 {
		for _, e := range m.ProtocolPolicer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TcpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TcpType{`,
		`Flags:` + fmt.Sprintf("%v", this.Flags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UdpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UdpType{`,
		`}`,
	}, "")
	return s
}
func (this *IcmpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IcmpType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DnsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DnsType{`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Tcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Tcp{`,
		`Tcp:` + strings.Replace(fmt.Sprintf("%v", this.Tcp), "TcpType", "TcpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Icmp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Icmp{`,
		`Icmp:` + strings.Replace(fmt.Sprintf("%v", this.Icmp), "IcmpType", "IcmpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Udp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Udp{`,
		`Udp:` + strings.Replace(fmt.Sprintf("%v", this.Udp), "UdpType", "UdpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolType_Dns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolType_Dns{`,
		`Dns:` + strings.Replace(fmt.Sprintf("%v", this.Dns), "DnsType", "DnsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolPolicerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolPolicerType{`,
		`Protocol:` + strings.Replace(fmt.Sprintf("%v", this.Protocol), "ProtocolType", "ProtocolType", 1) + `,`,
		`Policer:` + strings.Replace(fmt.Sprintf("%v", this.Policer), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`ProtocolPolicer:` + strings.Replace(fmt.Sprintf("%v", this.ProtocolPolicer), "ProtocolPolicerType", "ProtocolPolicerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`ProtocolPolicer:` + strings.Replace(fmt.Sprintf("%v", this.ProtocolPolicer), "ProtocolPolicerType", "ProtocolPolicerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`ProtocolPolicer:` + strings.Replace(fmt.Sprintf("%v", this.ProtocolPolicer), "ProtocolPolicerType", "ProtocolPolicerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`ProtocolPolicer:` + strings.Replace(fmt.Sprintf("%v", this.ProtocolPolicer), "ProtocolPolicerType", "ProtocolPolicerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TcpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v TcpFlags
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (TcpFlags(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Flags = append(m.Flags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v TcpFlags
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (TcpFlags(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Flags = append(m.Flags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UdpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UdpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UdpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IcmpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IcmpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IcmpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v IcmpMsgType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (IcmpMsgType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Type = append(m.Type, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v IcmpMsgType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (IcmpMsgType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Type = append(m.Type, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TcpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Tcp{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IcmpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Icmp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Udp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UdpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Udp{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ProtocolType_Dns{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolPolicerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolPolicerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolPolicerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protocol == nil {
				m.Protocol = &ProtocolType{}
			}
			if err := m.Protocol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policer = append(m.Policer, &ves_io_schema4.ObjectRefType{})
			if err := m.Policer[len(m.Policer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolPolicer = append(m.ProtocolPolicer, &ProtocolPolicerType{})
			if err := m.ProtocolPolicer[len(m.ProtocolPolicer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/protocol_policer/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 741 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x95, 0xbf, 0x6f, 0x1a, 0x49,
	0x14, 0xc7, 0x19, 0x7e, 0x18, 0x6e, 0xf0, 0xe1, 0xbd, 0xbd, 0x3b, 0x1d, 0xc7, 0x59, 0x23, 0x44,
	0x73, 0xc8, 0x77, 0x5e, 0x74, 0xb8, 0xbb, 0x93, 0xb8, 0x03, 0xce, 0x06, 0x62, 0x6c, 0x93, 0x5d,
	0x1c, 0xc9, 0x29, 0x82, 0x96, 0x65, 0x58, 0x6f, 0xb2, 0x30, 0xa3, 0xdd, 0x85, 0xc4, 0x45, 0xa4,
	0x14, 0x51, 0x92, 0x32, 0x72, 0x9f, 0x3e, 0xca, 0x3f, 0x90, 0x28, 0x6e, 0x5c, 0x46, 0xa9, 0x5c,
	0xba, 0x0c, 0x9b, 0x26, 0xe9, 0xac, 0x54, 0x29, 0xa3, 0x19, 0x76, 0x2d, 0x20, 0x4a, 0x4c, 0x11,
	0xc9, 0xdd, 0x77, 0xe7, 0xbd, 0xcf, 0xf7, 0x7d, 0xe7, 0x09, 0x0d, 0x70, 0x65, 0x88, 0x6d, 0xc9,
	0x20, 0x39, 0x5b, 0xdb, 0xc7, 0x3d, 0x35, 0x47, 0x2d, 0xe2, 0x10, 0x8d, 0x98, 0x2d, 0x4a, 0x4c,
	0x43, 0xc3, 0x56, 0xce, 0x39, 0xa0, 0xd8, 0x96, 0xf8, 0xb1, 0x88, 0xc6, 0xbd, 0xd2, 0xb8, 0x57,
	0x9a, 0xed, 0x4d, 0xad, 0xea, 0x86, 0xb3, 0x3f, 0x68, 0x4b, 0x1a, 0xe9, 0xe5, 0x74, 0xa2, 0x93,
	0xb1, 0x5b, 0x7b, 0xd0, 0xe5, 0x5f, 0xfc, 0x83, 0xab, 0x31, 0x99, 0xfa, 0x65, 0x7a, 0x74, 0x1f,
	0x3b, 0x5e, 0xe1, 0xb7, 0xe9, 0x02, 0xa1, 0x8e, 0x41, 0xfa, 0x5e, 0x88, 0xd4, 0xaf, 0xd3, 0xc5,
	0x89, 0x7c, 0xa9, 0xe5, 0xe9, 0xd2, 0x50, 0x35, 0x8d, 0x8e, 0xea, 0x60, 0xaf, 0x9a, 0x9e, 0xa9,
	0x1a, 0xf8, 0x76, 0x6b, 0xca, 0x3a, 0x53, 0x83, 0xd1, 0xa6, 0x46, 0x9b, 0x07, 0x14, 0x8b, 0x05,
	0x18, 0xe9, 0x9a, 0xaa, 0x6e, 0x27, 0x41, 0x3a, 0x94, 0x4d, 0xe4, 0xb3, 0xd2, 0xd7, 0xaf, 0x2e,
	0x35, 0x35, 0xba, 0xc1, 0xfa, 0xe5, 0x31, 0x96, 0xf9, 0x0e, 0x46, 0x77, 0x3b, 0xdc, 0x2a, 0xb3,
	0x09, 0x63, 0x35, 0xad, 0x37, 0xb6, 0xfd, 0x17, 0x86, 0x59, 0x60, 0xcf, 0xf5, 0x8f, 0x8b, 0x5c,
	0x19, 0xb7, 0x65, 0xeb, 0x0c, 0x95, 0x39, 0xc8, 0x7c, 0xff, 0xef, 0xdb, 0xdc, 0xf7, 0x49, 0x10,
	0x2e, 0x36, 0x3c, 0x82, 0x9b, 0xff, 0x03, 0x43, 0x8e, 0x46, 0x93, 0x20, 0x0d, 0xb2, 0xf1, 0xfc,
	0xef, 0x73, 0x24, 0x66, 0x54, 0x35, 0x20, 0x33, 0x4a, 0x2c, 0xc0, 0xb0, 0xa1, 0xf5, 0x68, 0x32,
	0xc8, 0xe9, 0xec, 0x3c, 0xc9, 0x3c, 0x9c, 0x73, 0x6c, 0xf8, 0xa0, 0x43, 0x93, 0xa1, 0xf9, 0x86,
	0x7b, 0xbb, 0x61, 0xc3, 0x07, 0x1d, 0x0e, 0x77, 0xfa, 0x76, 0x32, 0x3c, 0x1f, 0xec, 0x2d, 0x80,
	0xc1, 0x9d, 0xbe, 0x5d, 0x12, 0x60, 0x98, 0x5f, 0x3f, 0x76, 0x7c, 0x04, 0xc0, 0xc9, 0x11, 0x88,
	0x5c, 0x09, 0xc7, 0x22, 0xc2, 0x42, 0xe6, 0x39, 0x80, 0x3f, 0xfa, 0xfb, 0x69, 0x8c, 0x51, 0xde,
	0x57, 0x85, 0x31, 0xdf, 0xd2, 0xdb, 0xd5, 0x9f, 0x17, 0x4d, 0x9c, 0x5c, 0xb3, 0x7c, 0x4e, 0x8b,
	0xd7, 0x60, 0xd4, 0xeb, 0x48, 0x06, 0xd3, 0xa1, 0x6c, 0x3c, 0xbf, 0x3c, 0x63, 0xb4, 0xd3, 0xbe,
	0x89, 0x35, 0x47, 0xc6, 0x5d, 0x06, 0x96, 0xd0, 0xb3, 0xbb, 0x7e, 0xff, 0xcb, 0xf7, 0xc7, 0xa1,
	0xc8, 0x21, 0x08, 0x0a, 0xc0, 0x57, 0x31, 0x20, 0xfb, 0xc5, 0xcc, 0x03, 0x00, 0x13, 0x15, 0x93,
	0xb4, 0x55, 0x53, 0xa1, 0x58, 0xe3, 0xa1, 0x1d, 0x28, 0xcc, 0xa6, 0xe2, 0x3f, 0xa2, 0x78, 0x7e,
	0x6d, 0xde, 0xf0, 0x13, 0x3b, 0x28, 0xfd, 0x74, 0x1e, 0xe0, 0x3f, 0x5f, 0x25, 0x81, 0xbc, 0x44,
	0xa7, 0x5b, 0x33, 0x0f, 0x01, 0x4c, 0x94, 0x2d, 0xac, 0x3a, 0xf8, 0x3c, 0xc8, 0x8d, 0x6f, 0x1a,
	0xe4, 0xb3, 0x91, 0x7f, 0xff, 0xfc, 0xba, 0x30, 0x73, 0xf7, 0x0f, 0x05, 0xf0, 0x57, 0xe6, 0x11,
	0x80, 0x4b, 0x32, 0xa6, 0xa6, 0xaa, 0x5d, 0x7a, 0x94, 0xfb, 0x00, 0xc6, 0x2b, 0xd8, 0xb9, 0xe4,
	0x18, 0x2b, 0x0a, 0x8c, 0xf9, 0x8f, 0x8e, 0x18, 0x85, 0xa1, 0x8d, 0xda, 0xb6, 0x10, 0x60, 0x42,
	0xd9, 0xdb, 0x16, 0x00, 0x13, 0xb2, 0xd2, 0x14, 0x82, 0x4c, 0x34, 0x94, 0xaa, 0x10, 0x62, 0xa2,
	0x58, 0xde, 0x14, 0xc2, 0x4c, 0xec, 0xca, 0x15, 0x21, 0x22, 0xfe, 0x00, 0xbf, 0x2f, 0xd6, 0xeb,
	0xad, 0x66, 0xb9, 0xd1, 0xda, 0xa8, 0x17, 0x2b, 0x8a, 0xb0, 0xb0, 0x52, 0x84, 0xf1, 0x89, 0x37,
	0x47, 0x4c, 0x40, 0xb8, 0x5e, 0xae, 0xee, 0xb4, 0xe4, 0xf5, 0x46, 0x7d, 0x4f, 0x08, 0x88, 0x02,
	0x5c, 0xf4, 0xbe, 0xaf, 0xee, 0xae, 0x2b, 0x4d, 0x01, 0xb0, 0x13, 0xe6, 0x51, 0x2b, 0x6f, 0x35,
	0x5a, 0x5b, 0x4a, 0x45, 0x08, 0x96, 0x0e, 0xc1, 0xc9, 0x08, 0x05, 0x4e, 0x47, 0x28, 0x70, 0x36,
	0x42, 0xe0, 0xe3, 0x08, 0x81, 0x7b, 0x2e, 0x02, 0x4f, 0x5d, 0x04, 0x5e, 0xb8, 0x08, 0x1c, 0xbb,
	0x08, 0xbc, 0x72, 0x11, 0x38, 0x71, 0x11, 0x38, 0x75, 0x11, 0x78, 0xe3, 0x22, 0xf0, 0xce, 0x45,
	0x81, 0x33, 0x17, 0x81, 0xc7, 0x6f, 0x51, 0xe0, 0x7a, 0x53, 0x27, 0xf4, 0x96, 0x2e, 0x0d, 0x89,
	0xe9, 0x60, 0xcb, 0x52, 0xa5, 0x81, 0x9d, 0xe3, 0xa2, 0x4b, 0xac, 0xde, 0x2a, 0xb5, 0xc8, 0xd0,
	0xe8, 0x60, 0x6b, 0xd5, 0x2f, 0xe7, 0x68, 0x5b, 0x27, 0x39, 0x7c, 0xc7, 0xf1, 0x1e, 0xf5, 0x2f,
	0xfc, 0x8b, 0xb5, 0x17, 0xf8, 0xc9, 0xda, 0xa7, 0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x66, 0xc4,
	0xcf, 0xee, 0x06, 0x00, 0x00,
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/api_credential/types.proto

package api_credential

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/gogo/protobuf/types"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

import strconv "strconv"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// API Credential type
//
// x-displayName: "Credential Type"
// Types of API credential given when requesting credentials from volterra
type APICredentialType int32

const (
	// x-displayName: "User Certificate"
	// Volterra user certificate to access Volterra public API using mTLS
	API_CERTIFICATE APICredentialType = 0
	// x-displayName: "Kubernetes Config File"
	// Kubernetes config file to access Virtual Kubernetes API in Volterra
	KUBE_CONFIG APICredentialType = 1
	// x-displayName: "API Token"
	// API token to access Volterra public API
	API_TOKEN APICredentialType = 2
	// x-displayName: "Service API Token"
	// API token for service credentials
	SERVICE_API_TOKEN APICredentialType = 3
	// x-displayName: "Service API Certificate"
	// API certificate for service credentials
	SERVICE_API_CERTIFICATE APICredentialType = 4
	// x-displayName: "API Certificate for Kubernetes Config File"
	// API certificate for kube config
	SERVICE_KUBE_CONFIG APICredentialType = 5
)

var APICredentialType_name = map[int32]string{
	0: "API_CERTIFICATE",
	1: "KUBE_CONFIG",
	2: "API_TOKEN",
	3: "SERVICE_API_TOKEN",
	4: "SERVICE_API_CERTIFICATE",
	5: "SERVICE_KUBE_CONFIG",
}
var APICredentialType_value = map[string]int32{
	"API_CERTIFICATE":         0,
	"KUBE_CONFIG":             1,
	"API_TOKEN":               2,
	"SERVICE_API_TOKEN":       3,
	"SERVICE_API_CERTIFICATE": 4,
	"SERVICE_KUBE_CONFIG":     5,
}

func (APICredentialType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// API credentials
//
// x-displayName: "API Credentials"
// Keeps track of user requested API credentials
type GlobalSpecType struct {
	// API Credential type
	//
	// x-displayName: "Credential Type"
	// Type of API credential
	Type APICredentialType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.api_credential.APICredentialType" json:"type,omitempty"`
	// user requesting credential
	//
	// x-displayName: "User"
	// Reference to user for whom API credential is created
	Users []*ves_io_schema4.ObjectRefType `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
	// Virtual K8s namespace
	//
	// x-displayName: "Namespace"
	// Namespace of virtual_k8s
	VirtualK8SNamespace string `protobuf:"bytes,3,opt,name=virtual_k8s_namespace,json=virtualK8sNamespace,proto3" json:"virtual_k8s_namespace,omitempty"`
	// Virtual K8s
	//
	// x-displayName: "Virtual K8s"
	// Name of virtual K8s cluster
	VirtualK8SName string `protobuf:"bytes,4,opt,name=virtual_k8s_name,json=virtualK8sName,proto3" json:"virtual_k8s_name,omitempty"`
	// Digest sha1
	//
	// x-displayName: "Digest sha1"
	// Digest sha1 of credential
	Digest string `protobuf:"bytes,5,opt,name=digest,proto3" json:"digest,omitempty"`
	// Created timestamp
	//
	// x-displayName: "Created timestamp"
	// Timestamp of credential creation
	CreatedTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,6,opt,name=created_timestamp,json=createdTimestamp" json:"created_timestamp,omitempty"`
	// Expiry timestamp
	//
	// x-displayName: "Expiry timestamp"
	// Timestamp of credential expiration
	ExpirationTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,7,opt,name=expiration_timestamp,json=expirationTimestamp" json:"expiration_timestamp,omitempty"`
	// Active
	//
	// x-displayName: "Active"
	// Possibility to deactivate/activate credential with no deletion
	Active bool `protobuf:"varint,8,opt,name=active,proto3" json:"active,omitempty"`
	// Certificate Serial Number
	//
	// x-displayName: "Certificate Serial Number"
	// Serial number of the client certificate part of credential type API Certificate or Kubeconfig
	CertificateSerialNum string `protobuf:"bytes,9,opt,name=certificate_serial_num,json=certificateSerialNum,proto3" json:"certificate_serial_num,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *GlobalSpecType) GetType() APICredentialType {
	if m != nil {
		return m.Type
	}
	return API_CERTIFICATE
}

func (m *GlobalSpecType) GetUsers() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *GlobalSpecType) GetVirtualK8SNamespace() string {
	if m != nil {
		return m.VirtualK8SNamespace
	}
	return ""
}

func (m *GlobalSpecType) GetVirtualK8SName() string {
	if m != nil {
		return m.VirtualK8SName
	}
	return ""
}

func (m *GlobalSpecType) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

func (m *GlobalSpecType) GetCreatedTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreatedTimestamp
	}
	return nil
}

func (m *GlobalSpecType) GetExpirationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *GlobalSpecType) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *GlobalSpecType) GetCertificateSerialNum() string {
	if m != nil {
		return m.CertificateSerialNum
	}
	return ""
}

func init() {
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.api_credential.GlobalSpecType")
	proto.RegisterEnum("ves.io.schema.api_credential.APICredentialType", APICredentialType_name, APICredentialType_value)
}
func (x APICredentialType) String() string {
	s, ok := APICredentialType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Users) != len(that1.Users) {
		return false
	}
	for i := range this.Users {
		if !this.Users[i].Equal(that1.Users[i]) {
			return false
		}
	}
	if this.VirtualK8SNamespace != that1.VirtualK8SNamespace {
		return false
	}
	if this.VirtualK8SName != that1.VirtualK8SName {
		return false
	}
	if this.Digest != that1.Digest {
		return false
	}
	if !this.CreatedTimestamp.Equal(that1.CreatedTimestamp) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if this.Active != that1.Active {
		return false
	}
	if this.CertificateSerialNum != that1.CertificateSerialNum {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&api_credential.GlobalSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Users != nil {
		s = append(s, "Users: "+fmt.Sprintf("%#v", this.Users)+",\n")
	}
	s = append(s, "VirtualK8SNamespace: "+fmt.Sprintf("%#v", this.VirtualK8SNamespace)+",\n")
	s = append(s, "VirtualK8SName: "+fmt.Sprintf("%#v", this.VirtualK8SName)+",\n")
	s = append(s, "Digest: "+fmt.Sprintf("%#v", this.Digest)+",\n")
	if this.CreatedTimestamp != nil {
		s = append(s, "CreatedTimestamp: "+fmt.Sprintf("%#v", this.CreatedTimestamp)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	s = append(s, "Active: "+fmt.Sprintf("%#v", this.Active)+",\n")
	s = append(s, "CertificateSerialNum: "+fmt.Sprintf("%#v", this.CertificateSerialNum)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VirtualK8SNamespace) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VirtualK8SNamespace)))
		i += copy(dAtA[i:], m.VirtualK8SNamespace)
	}
	if len(m.VirtualK8SName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VirtualK8SName)))
		i += copy(dAtA[i:], m.VirtualK8SName)
	}
	if len(m.Digest) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Digest)))
		i += copy(dAtA[i:], m.Digest)
	}
	if m.CreatedTimestamp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedTimestamp.Size()))
		n1, err := m.CreatedTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ExpirationTimestamp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTimestamp.Size()))
		n2, err := m.ExpirationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Active {
		dAtA[i] = 0x40
		i++
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CertificateSerialNum) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CertificateSerialNum)))
		i += copy(dAtA[i:], m.CertificateSerialNum)
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.VirtualK8SNamespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VirtualK8SName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreatedTimestamp != nil {
		l = m.CreatedTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Active {
		n += 2
	}
	l = len(m.CertificateSerialNum)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Users:` + strings.Replace(fmt.Sprintf("%v", this.Users), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`VirtualK8SNamespace:` + fmt.Sprintf("%v", this.VirtualK8SNamespace) + `,`,
		`VirtualK8SName:` + fmt.Sprintf("%v", this.VirtualK8SName) + `,`,
		`Digest:` + fmt.Sprintf("%v", this.Digest) + `,`,
		`CreatedTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreatedTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`Active:` + fmt.Sprintf("%v", this.Active) + `,`,
		`CertificateSerialNum:` + fmt.Sprintf("%v", this.CertificateSerialNum) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (APICredentialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &ves_io_schema4.ObjectRefType{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualK8SNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualK8SNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualK8SName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualK8SName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTimestamp == nil {
				m.CreatedTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.CreatedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateSerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateSerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/api_credential/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 620 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0x3f, 0x6f, 0xd3, 0x40,
	0x18, 0xc6, 0x73, 0xf9, 0x47, 0x73, 0x15, 0x6d, 0x72, 0xe9, 0x1f, 0x93, 0x56, 0x26, 0x62, 0x8a,
	0x90, 0x6a, 0x4b, 0x61, 0xe9, 0x86, 0x9a, 0xc8, 0xad, 0xa2, 0x8a, 0xb4, 0x72, 0x03, 0x03, 0x8b,
	0x75, 0x71, 0xde, 0xb8, 0x47, 0xed, 0x9c, 0x75, 0x3e, 0x47, 0xed, 0x80, 0x84, 0x04, 0x1f, 0x00,
	0x21, 0xf1, 0x1d, 0x10, 0x1f, 0x81, 0x89, 0x91, 0xb1, 0x63, 0x47, 0x6a, 0x16, 0xd8, 0xfa, 0x11,
	0x90, 0x1d, 0xa7, 0x49, 0x0a, 0x82, 0xcd, 0xef, 0x3d, 0xbf, 0xe7, 0xd1, 0x7b, 0x7e, 0x74, 0xb8,
	0x31, 0x86, 0x40, 0x63, 0x5c, 0x0f, 0xec, 0x53, 0xf0, 0xa8, 0x4e, 0x7d, 0x66, 0xd9, 0x02, 0x06,
	0x30, 0x92, 0x8c, 0xba, 0xba, 0xbc, 0xf0, 0x21, 0xd0, 0x7c, 0xc1, 0x25, 0x27, 0xdb, 0x13, 0x52,
	0x9b, 0x90, 0xda, 0x22, 0x59, 0xdb, 0x71, 0x98, 0x3c, 0x0d, 0xfb, 0x9a, 0xcd, 0x3d, 0xdd, 0xe1,
	0x0e, 0xd7, 0x13, 0x53, 0x3f, 0x1c, 0x26, 0x53, 0x32, 0x24, 0x5f, 0x93, 0xb0, 0xda, 0x43, 0x87,
	0x73, 0xc7, 0x85, 0x19, 0x25, 0x99, 0x07, 0x81, 0xa4, 0x9e, 0x9f, 0x02, 0x5b, 0x8b, 0x7b, 0x71,
	0x5f, 0x32, 0x3e, 0x4a, 0x57, 0xa9, 0x3d, 0x58, 0x14, 0xe7, 0xb6, 0xac, 0x6d, 0x2f, 0x4a, 0x63,
	0xea, 0xb2, 0x01, 0x95, 0x30, 0x51, 0x1f, 0xbd, 0xcd, 0xe3, 0x95, 0x03, 0x97, 0xf7, 0xa9, 0x7b,
	0xe2, 0x83, 0xdd, 0xbb, 0xf0, 0x81, 0xb4, 0x71, 0x3e, 0xf6, 0x2b, 0xa8, 0x8e, 0x1a, 0x2b, 0x4d,
	0x5d, 0xfb, 0xd7, 0x2d, 0xb5, 0xbd, 0xe3, 0x4e, 0xfb, 0x76, 0x8a, 0xed, 0x66, 0x62, 0x26, 0x06,
	0x2e, 0x84, 0x01, 0x88, 0x40, 0xc9, 0xd6, 0x73, 0x8d, 0xe5, 0xe6, 0xf6, 0x9d, 0x94, 0xa3, 0xfe,
	0x2b, 0xb0, 0xa5, 0x09, 0xc3, 0xd8, 0xd2, 0xaa, 0x7c, 0x7e, 0x9d, 0x8f, 0xe9, 0x2f, 0xbf, 0xbe,
	0xe6, 0x0a, 0x1f, 0x50, 0xb6, 0x8c, 0xcc, 0x89, 0x9b, 0x34, 0xf1, 0xfa, 0x98, 0x09, 0x19, 0x52,
	0xd7, 0x3a, 0xdb, 0x0d, 0xac, 0x11, 0xf5, 0x20, 0xf0, 0xa9, 0x0d, 0x4a, 0xae, 0x8e, 0x1a, 0x25,
	0xb3, 0x9a, 0x8a, 0x87, 0xbb, 0x41, 0x77, 0x2a, 0x91, 0x06, 0x2e, 0xdf, 0xf5, 0x28, 0xf9, 0x04,
	0x5f, 0x59, 0xc4, 0xc9, 0x06, 0x2e, 0x0e, 0x98, 0x03, 0x81, 0x54, 0x0a, 0x89, 0x9e, 0x4e, 0xe4,
	0x00, 0x57, 0x6c, 0x01, 0x54, 0xc2, 0xc0, 0xba, 0x6d, 0x41, 0x29, 0xd6, 0x51, 0x63, 0xb9, 0x59,
	0xd3, 0x26, 0x3d, 0x69, 0xd3, 0x9e, 0xb4, 0xde, 0x94, 0x30, 0xcb, 0xa9, 0xe9, 0xf6, 0x84, 0x3c,
	0xc3, 0x6b, 0x70, 0xee, 0x33, 0x41, 0xe3, 0xae, 0xe6, 0xb2, 0xee, 0xfd, 0x37, 0xab, 0x3a, 0xf3,
	0xcd, 0xe2, 0x36, 0x70, 0x91, 0xda, 0x92, 0x8d, 0x41, 0x59, 0xaa, 0xa3, 0xc6, 0x92, 0x99, 0x4e,
	0xe4, 0x29, 0xde, 0xb0, 0x41, 0x48, 0x36, 0x64, 0x36, 0x95, 0x60, 0x05, 0x20, 0x18, 0x75, 0xad,
	0x51, 0xe8, 0x29, 0xa5, 0xf8, 0x5e, 0xad, 0x52, 0xfc, 0x63, 0xf3, 0x22, 0xab, 0xd4, 0xcd, 0xb5,
	0x39, 0xf0, 0x24, 0xe1, 0xba, 0xa1, 0xf7, 0xf8, 0x23, 0xc2, 0x95, 0x3f, 0x9a, 0x24, 0x55, 0xbc,
	0xba, 0x77, 0xdc, 0xb1, 0xda, 0x86, 0xd9, 0xeb, 0xec, 0x77, 0xda, 0x7b, 0x3d, 0xa3, 0x9c, 0x21,
	0xab, 0x78, 0xf9, 0xf0, 0x79, 0xcb, 0xb0, 0xda, 0x47, 0xdd, 0xfd, 0xce, 0x41, 0x19, 0x91, 0xfb,
	0xb8, 0x14, 0x53, 0xbd, 0xa3, 0x43, 0xa3, 0x5b, 0xce, 0x92, 0x75, 0x5c, 0x39, 0x31, 0xcc, 0x17,
	0x9d, 0xb6, 0x61, 0xcd, 0x8e, 0x73, 0x64, 0x0b, 0x6f, 0xce, 0x1f, 0xcf, 0x67, 0xe6, 0xc9, 0x26,
	0xae, 0x4e, 0xc5, 0xf9, 0xec, 0x42, 0xeb, 0x1d, 0xba, 0xbc, 0x56, 0x33, 0x57, 0xd7, 0x6a, 0xe6,
	0xe6, 0x5a, 0x45, 0x6f, 0x22, 0x15, 0x7d, 0x8a, 0x54, 0xf4, 0x2d, 0x52, 0xd1, 0x65, 0xa4, 0xa2,
	0xab, 0x48, 0x45, 0xdf, 0x23, 0x15, 0xfd, 0x8c, 0xd4, 0xcc, 0x4d, 0xa4, 0xa2, 0xf7, 0x3f, 0xd4,
	0xcc, 0x4b, 0xd3, 0xe1, 0xfe, 0x99, 0xa3, 0x8d, 0xb9, 0x2b, 0x41, 0x08, 0xaa, 0x85, 0x81, 0x9e,
	0x7c, 0x0c, 0xb9, 0xf0, 0x76, 0x7c, 0xc1, 0xc7, 0x6c, 0x00, 0x62, 0x67, 0x2a, 0xeb, 0x7e, 0xdf,
	0xe1, 0x3a, 0x9c, 0xcb, 0xf4, 0x75, 0xfc, 0xf5, 0xd1, 0xf7, 0x8b, 0x49, 0x41, 0x4f, 0x7e, 0x07,
	0x00, 0x00, 0xff, 0xff, 0x2e, 0x9d, 0x57, 0x3d, 0x1b, 0x04, 0x00, 0x00,
}

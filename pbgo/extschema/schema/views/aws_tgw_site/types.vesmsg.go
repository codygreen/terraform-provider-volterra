//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package aws_tgw_site

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AWSVPNTunnelConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPNTunnelConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPNTunnelConfigType) DeepCopy() *AWSVPNTunnelConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPNTunnelConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPNTunnelConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPNTunnelConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPNTunnelConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPNTunnelConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPNTunnelConfigType) NodeNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_name")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPNTunnelConfigType) TunnelRemoteIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for tunnel_remote_ip")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tunnel_remote_ip")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tunnel_remote_ip")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tunnel_remote_ip")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPNTunnelConfigType) NodeIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_id")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPNTunnelConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPNTunnelConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPNTunnelConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["node_id"]; exists {

		vOpts := append(opts, db.WithValidateField("node_id"))
		if err := fv(ctx, m.GetNodeId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_name"]; exists {

		vOpts := append(opts, db.WithValidateField("node_name"))
		if err := fv(ctx, m.GetNodeName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_remote_ip"]; exists {
		vOpts := append(opts, db.WithValidateField("tunnel_remote_ip"))
		if err := fv(ctx, m.GetTunnelRemoteIp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPNTunnelConfigTypeValidator = func() *ValidateAWSVPNTunnelConfigType {
	v := &ValidateAWSVPNTunnelConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeName := v.NodeNameValidationRuleHandler
	rulesNodeName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhNodeName(rulesNodeName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPNTunnelConfigType.node_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_name"] = vFn

	vrhTunnelRemoteIp := v.TunnelRemoteIpValidationRuleHandler
	rulesTunnelRemoteIp := map[string]string{
		"ves.io.schema.rules.message.required":           "true",
		"ves.io.schema.rules.repeated.items.string.ipv4": "true",
		"ves.io.schema.rules.repeated.max_items":         "2",
		"ves.io.schema.rules.repeated.min_items":         "1",
	}
	vFn, err = vrhTunnelRemoteIp(rulesTunnelRemoteIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPNTunnelConfigType.tunnel_remote_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_remote_ip"] = vFn

	vrhNodeId := v.NodeIdValidationRuleHandler
	rulesNodeId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhNodeId(rulesNodeId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPNTunnelConfigType.node_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_id"] = vFn

	return v
}()

func AWSVPNTunnelConfigTypeValidator() db.Validator {
	return DefaultAWSVPNTunnelConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAwsParametersDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTgwSecurityDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVnConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetAwsParametersDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.AwsParameters == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.AwsParameters.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "aws_parameters." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetTgwSecurityDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.TgwSecurity == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.TgwSecurity.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "tgw_security." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetVnConfigDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.VnConfig == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.VnConfig.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "vn_config." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) AwsParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_parameters")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ServicesVPCTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_parameters"))
		if err := fv(ctx, m.GetAwsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_security"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_security"))
		if err := fv(ctx, m.GetTgwSecurity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vn_config"]; exists {

		vOpts := append(opts, db.WithValidateField("vn_config"))
		if err := fv(ctx, m.GetVnConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_attachments"))
		if err := fv(ctx, m.GetVpcAttachments(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAwsParameters := v.AwsParametersValidationRuleHandler
	rulesAwsParameters := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsParameters(rulesAwsParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.aws_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_parameters"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	v.FldValidators["vpc_attachments"] = VPCAttachmentListTypeValidator().Validate

	v.FldValidators["tgw_security"] = SecurityConfigTypeValidator().Validate

	v.FldValidators["vn_config"] = VnConfigurationValidator().Validate

	v.FldValidators["coordinates"] = ves_io_schema_site.CoordinatesValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ExistingTGWType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ExistingTGWType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ExistingTGWType) DeepCopy() *ExistingTGWType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ExistingTGWType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ExistingTGWType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ExistingTGWType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ExistingTGWTypeValidator().Validate(ctx, m, opts...)
}

type ValidateExistingTGWType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateExistingTGWType) TgwIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_id")
	}

	return validatorFn, nil
}

func (v *ValidateExistingTGWType) TgwAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_asn")
	}

	return validatorFn, nil
}

func (v *ValidateExistingTGWType) VolterraSiteAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_site_asn")
	}

	return validatorFn, nil
}

func (v *ValidateExistingTGWType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ExistingTGWType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ExistingTGWType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tgw_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_asn"))
		if err := fv(ctx, m.GetTgwAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_id"))
		if err := fv(ctx, m.GetTgwId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_site_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_site_asn"))
		if err := fv(ctx, m.GetVolterraSiteAsn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultExistingTGWTypeValidator = func() *ValidateExistingTGWType {
	v := &ValidateExistingTGWType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTgwId := v.TgwIdValidationRuleHandler
	rulesTgwId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(tgw-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhTgwId(rulesTgwId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ExistingTGWType.tgw_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_id"] = vFn

	vrhTgwAsn := v.TgwAsnValidationRuleHandler
	rulesTgwAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt":  "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhTgwAsn(rulesTgwAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ExistingTGWType.tgw_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_asn"] = vFn

	vrhVolterraSiteAsn := v.VolterraSiteAsnValidationRuleHandler
	rulesVolterraSiteAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt":  "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhVolterraSiteAsn(rulesVolterraSiteAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ExistingTGWType.volterra_site_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_site_asn"] = vFn

	return v
}()

func ExistingTGWTypeValidator() db.Validator {
	return DefaultExistingTGWTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAwsParametersDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTgwSecurityDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVnConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetAwsParametersDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.AwsParameters == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.AwsParameters.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "aws_parameters." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetTgwSecurityDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.TgwSecurity == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.TgwSecurity.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "tgw_security." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetVnConfigDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.VnConfig == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.VnConfig.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "vn_config." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) AwsParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_parameters")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ServicesVPCTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_parameters"))
		if err := fv(ctx, m.GetAwsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_security"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_security"))
		if err := fv(ctx, m.GetTgwSecurity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnels"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnels"))
		for idx, item := range m.GetTunnels() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vn_config"]; exists {

		vOpts := append(opts, db.WithValidateField("vn_config"))
		if err := fv(ctx, m.GetVnConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_attachments"))
		if err := fv(ctx, m.GetVpcAttachments(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_ip_prefixes"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_ip_prefixes"))
		for key, value := range m.GetVpcIpPrefixes() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAwsParameters := v.AwsParametersValidationRuleHandler
	rulesAwsParameters := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsParameters(rulesAwsParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.aws_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_parameters"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	v.FldValidators["vpc_attachments"] = VPCAttachmentListTypeValidator().Validate

	v.FldValidators["tgw_security"] = SecurityConfigTypeValidator().Validate

	v.FldValidators["vpc_ip_prefixes"] = VPCIpPrefixesTypeValidator().Validate

	v.FldValidators["vn_config"] = VnConfigurationValidator().Validate

	v.FldValidators["coordinates"] = ves_io_schema_site.CoordinatesValidator().Validate

	v.FldValidators["tunnels"] = AWSVPNTunnelConfigTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAwsParametersDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTfParamsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTgwSecurityDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetViewInternalDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVnConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetAwsParametersDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.AwsParameters == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.AwsParameters.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "aws_parameters." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *GlobalSpecType) GetTfParamsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}

	vref := m.GetTfParams()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("terraform_parameters.Object")
	drInfos = append(drInfos, db.DRefInfo{
		RefdType:   "terraform_parameters.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "tf_params",
		Ref:        vdRef,
	})

	return drInfos, nil
}

// GetTfParamsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetTfParamsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "terraform_parameters.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: terraform_parameters")
	}

	vref := m.GetTfParams()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "terraform_parameters.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetTgwSecurityDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.TgwSecurity == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.TgwSecurity.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "tgw_security." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *GlobalSpecType) GetViewInternalDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("view_internal.Object")
	drInfos = append(drInfos, db.DRefInfo{
		RefdType:   "view_internal.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "view_internal",
		Ref:        vdRef,
	})

	return drInfos, nil
}

// GetViewInternalDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetViewInternalDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "view_internal.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: view_internal")
	}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "view_internal.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetVnConfigDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.VnConfig == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.VnConfig.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "vn_config." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) AwsParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_parameters")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ServicesVPCTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_parameters"))
		if err := fv(ctx, m.GetAwsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tf_params"]; exists {

		vOpts := append(opts, db.WithValidateField("tf_params"))
		if err := fv(ctx, m.GetTfParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_security"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_security"))
		if err := fv(ctx, m.GetTgwSecurity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnels"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnels"))
		for idx, item := range m.GetTunnels() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["view_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("view_internal"))
		if err := fv(ctx, m.GetViewInternal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vn_config"]; exists {

		vOpts := append(opts, db.WithValidateField("vn_config"))
		if err := fv(ctx, m.GetVnConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_attachments"))
		if err := fv(ctx, m.GetVpcAttachments(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_ip_prefixes"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_ip_prefixes"))
		for key, value := range m.GetVpcIpPrefixes() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAwsParameters := v.AwsParametersValidationRuleHandler
	rulesAwsParameters := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsParameters(rulesAwsParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.aws_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_parameters"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	v.FldValidators["vpc_attachments"] = VPCAttachmentListTypeValidator().Validate

	v.FldValidators["tgw_security"] = SecurityConfigTypeValidator().Validate

	v.FldValidators["vpc_ip_prefixes"] = VPCIpPrefixesTypeValidator().Validate

	v.FldValidators["vn_config"] = VnConfigurationValidator().Validate

	v.FldValidators["coordinates"] = ves_io_schema_site.CoordinatesValidator().Validate

	v.FldValidators["tunnels"] = AWSVPNTunnelConfigTypeValidator().Validate

	v.FldValidators["tf_params"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["view_internal"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetTgwSecurityDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVnConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetTgwSecurityDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.TgwSecurity == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.TgwSecurity.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "tgw_security." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetVnConfigDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.VnConfig == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.VnConfig.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "vn_config." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_security"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_security"))
		if err := fv(ctx, m.GetTgwSecurity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vn_config"]; exists {

		vOpts := append(opts, db.WithValidateField("vn_config"))
		if err := fv(ctx, m.GetVnConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_attachments"))
		if err := fv(ctx, m.GetVpcAttachments(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	v.FldValidators["vpc_attachments"] = VPCAttachmentListTypeValidator().Validate

	v.FldValidators["tgw_security"] = SecurityConfigTypeValidator().Validate

	v.FldValidators["vn_config"] = VnConfigurationValidator().Validate

	v.FldValidators["coordinates"] = ves_io_schema_site.CoordinatesValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityConfigType) DeepCopy() *SecurityConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityConfigTypeValidator().Validate(ctx, m, opts...)
}

func (m *SecurityConfigType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetForwardProxyChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkPolicyChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *SecurityConfigType) GetForwardProxyChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.ForwardProxyChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetForwardProxyChoice().(type) {
	case *SecurityConfigType_NoForwardProxy:

	case *SecurityConfigType_ActiveForwardProxyPolicies:
		odrInfos, err = m.GetActiveForwardProxyPolicies().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "active_forward_proxy_policies." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *SecurityConfigType_ForwardProxyAllowAll:

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *SecurityConfigType) GetNetworkPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.NetworkPolicyChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetNetworkPolicyChoice().(type) {
	case *SecurityConfigType_NoNetworkPolicy:

	case *SecurityConfigType_ActiveNetworkPolicies:
		odrInfos, err = m.GetActiveNetworkPolicies().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "active_network_policies." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

type ValidateSecurityConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityConfigType) ForwardProxyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for forward_proxy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSecurityConfigType) NetworkPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSecurityConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["forward_proxy_choice"]; exists {
		val := m.GetForwardProxyChoice()
		vOpts := append(opts,
			db.WithValidateField("forward_proxy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetForwardProxyChoice().(type) {
	case *SecurityConfigType_NoForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.no_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*SecurityConfigType_NoForwardProxy).NoForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("no_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityConfigType_ActiveForwardProxyPolicies:
		if fv, exists := v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"]; exists {
			val := m.GetForwardProxyChoice().(*SecurityConfigType_ActiveForwardProxyPolicies).ActiveForwardProxyPolicies
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("active_forward_proxy_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityConfigType_ForwardProxyAllowAll:
		if fv, exists := v.FldValidators["forward_proxy_choice.forward_proxy_allow_all"]; exists {
			val := m.GetForwardProxyChoice().(*SecurityConfigType_ForwardProxyAllowAll).ForwardProxyAllowAll
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("forward_proxy_allow_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_policy_choice"]; exists {
		val := m.GetNetworkPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("network_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkPolicyChoice().(type) {
	case *SecurityConfigType_NoNetworkPolicy:
		if fv, exists := v.FldValidators["network_policy_choice.no_network_policy"]; exists {
			val := m.GetNetworkPolicyChoice().(*SecurityConfigType_NoNetworkPolicy).NoNetworkPolicy
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("no_network_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityConfigType_ActiveNetworkPolicies:
		if fv, exists := v.FldValidators["network_policy_choice.active_network_policies"]; exists {
			val := m.GetNetworkPolicyChoice().(*SecurityConfigType_ActiveNetworkPolicies).ActiveNetworkPolicies
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("active_network_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityConfigTypeValidator = func() *ValidateSecurityConfigType {
	v := &ValidateSecurityConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhForwardProxyChoice := v.ForwardProxyChoiceValidationRuleHandler
	rulesForwardProxyChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhForwardProxyChoice(rulesForwardProxyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityConfigType.forward_proxy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["forward_proxy_choice"] = vFn

	vrhNetworkPolicyChoice := v.NetworkPolicyChoiceValidationRuleHandler
	rulesNetworkPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetworkPolicyChoice(rulesNetworkPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityConfigType.network_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_policy_choice"] = vFn

	v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"] = ves_io_schema_network_firewall.ActiveForwardProxyPoliciesTypeValidator().Validate

	v.FldValidators["network_policy_choice.active_network_policies"] = ves_io_schema_network_firewall.ActiveNetworkPoliciesTypeValidator().Validate

	return v
}()

func SecurityConfigTypeValidator() db.Validator {
	return DefaultSecurityConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServicesVPCType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServicesVPCType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServicesVPCType) DeepCopy() *ServicesVPCType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServicesVPCType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServicesVPCType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServicesVPCType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServicesVPCTypeValidator().Validate(ctx, m, opts...)
}

func (m *ServicesVPCType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDeploymentDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *ServicesVPCType) GetDeploymentDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetDeployment().(type) {
	case *ServicesVPCType_AwsCred:

		vref := m.GetAwsCred()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("cloud_credentials.Object")
		odri := db.DRefInfo{
			RefdType:   "cloud_credentials.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "aws_cred",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	case *ServicesVPCType_Assisted:

	}

	return odrInfos, nil
}

// GetDeploymentDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ServicesVPCType) GetDeploymentDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetDeployment().(type) {
	case *ServicesVPCType_AwsCred:
		refdType, err := d.TypeForEntryKind("", "", "cloud_credentials.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: cloud_credentials")
		}

		vref := m.GetAwsCred()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "cloud_credentials.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *ServicesVPCType_Assisted:

	}

	return entries, nil
}

type ValidateServicesVPCType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServicesVPCType) DeploymentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for deployment")
	}
	return validatorFn, nil
}

func (v *ValidateServicesVPCType) ServiceVpcChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_vpc_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServicesVPCType) ServiceVpcChoiceVpcIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VpcId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vpc_id")
	}
	return oValidatorFn_VpcId, nil
}

func (v *ValidateServicesVPCType) TgwChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServicesVPCType) AwsRegionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_region")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) AwsCertifiedHwValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_certified_hw")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) InstanceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for instance_type")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) SshKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_key")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) AzNodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.AWSVPCTwoInterfaceNodeType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema_views.AWSVPCTwoInterfaceNodeTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for az_nodes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.AWSVPCTwoInterfaceNodeType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.AWSVPCTwoInterfaceNodeType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated az_nodes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items az_nodes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) NodesPerAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nodes_per_az")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServicesVPCType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServicesVPCType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_certified_hw"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_certified_hw"))
		if err := fv(ctx, m.GetAwsCertifiedHw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_region"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_region"))
		if err := fv(ctx, m.GetAwsRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["az_nodes"]; exists {
		vOpts := append(opts, db.WithValidateField("az_nodes"))
		if err := fv(ctx, m.GetAzNodes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment"]; exists {
		val := m.GetDeployment()
		vOpts := append(opts,
			db.WithValidateField("deployment"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDeployment().(type) {
	case *ServicesVPCType_AwsCred:
		if fv, exists := v.FldValidators["deployment.aws_cred"]; exists {
			val := m.GetDeployment().(*ServicesVPCType_AwsCred).AwsCred
			vOpts := append(opts,
				db.WithValidateField("deployment"),
				db.WithValidateField("aws_cred"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCType_Assisted:
		if fv, exists := v.FldValidators["deployment.assisted"]; exists {
			val := m.GetDeployment().(*ServicesVPCType_Assisted).Assisted
			vOpts := append(opts,
				db.WithValidateField("deployment"),
				db.WithValidateField("assisted"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["instance_type"]; exists {

		vOpts := append(opts, db.WithValidateField("instance_type"))
		if err := fv(ctx, m.GetInstanceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nodes_per_az"]; exists {

		vOpts := append(opts, db.WithValidateField("nodes_per_az"))
		if err := fv(ctx, m.GetNodesPerAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_vpc_choice"]; exists {
		val := m.GetServiceVpcChoice()
		vOpts := append(opts,
			db.WithValidateField("service_vpc_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServiceVpcChoice().(type) {
	case *ServicesVPCType_NewVpc:
		if fv, exists := v.FldValidators["service_vpc_choice.new_vpc"]; exists {
			val := m.GetServiceVpcChoice().(*ServicesVPCType_NewVpc).NewVpc
			vOpts := append(opts,
				db.WithValidateField("service_vpc_choice"),
				db.WithValidateField("new_vpc"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCType_VpcId:
		if fv, exists := v.FldValidators["service_vpc_choice.vpc_id"]; exists {
			val := m.GetServiceVpcChoice().(*ServicesVPCType_VpcId).VpcId
			vOpts := append(opts,
				db.WithValidateField("service_vpc_choice"),
				db.WithValidateField("vpc_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ssh_key"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_key"))
		if err := fv(ctx, m.GetSshKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_choice"]; exists {
		val := m.GetTgwChoice()
		vOpts := append(opts,
			db.WithValidateField("tgw_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTgwChoice().(type) {
	case *ServicesVPCType_NewTgw:
		if fv, exists := v.FldValidators["tgw_choice.new_tgw"]; exists {
			val := m.GetTgwChoice().(*ServicesVPCType_NewTgw).NewTgw
			vOpts := append(opts,
				db.WithValidateField("tgw_choice"),
				db.WithValidateField("new_tgw"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCType_ExistingTgw:
		if fv, exists := v.FldValidators["tgw_choice.existing_tgw"]; exists {
			val := m.GetTgwChoice().(*ServicesVPCType_ExistingTgw).ExistingTgw
			vOpts := append(opts,
				db.WithValidateField("tgw_choice"),
				db.WithValidateField("existing_tgw"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServicesVPCTypeValidator = func() *ValidateServicesVPCType {
	v := &ValidateServicesVPCType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDeployment := v.DeploymentValidationRuleHandler
	rulesDeployment := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDeployment(rulesDeployment)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.deployment: %s", err)
		panic(errMsg)
	}
	v.FldValidators["deployment"] = vFn

	vrhServiceVpcChoice := v.ServiceVpcChoiceValidationRuleHandler
	rulesServiceVpcChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhServiceVpcChoice(rulesServiceVpcChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.service_vpc_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_vpc_choice"] = vFn

	vrhServiceVpcChoiceVpcId := v.ServiceVpcChoiceVpcIdValidationRuleHandler
	rulesServiceVpcChoiceVpcId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(vpc-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFnMap["service_vpc_choice.vpc_id"], err = vrhServiceVpcChoiceVpcId(rulesServiceVpcChoiceVpcId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServicesVPCType.service_vpc_choice_vpc_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["service_vpc_choice.vpc_id"] = vFnMap["service_vpc_choice.vpc_id"]

	vrhTgwChoice := v.TgwChoiceValidationRuleHandler
	rulesTgwChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTgwChoice(rulesTgwChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.tgw_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_choice"] = vFn

	vrhAwsRegion := v.AwsRegionValidationRuleHandler
	rulesAwsRegion := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"ap-northeast-1\",\"ap-southeast-1\",\"eu-central-1\",\"eu-west-1\",\"eu-west-3\",\"sa-east-1\",\"us-east-1\",\"us-east-2\",\"us-west-2\"]",
	}
	vFn, err = vrhAwsRegion(rulesAwsRegion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.aws_region: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_region"] = vFn

	vrhAwsCertifiedHw := v.AwsCertifiedHwValidationRuleHandler
	rulesAwsCertifiedHw := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"aws-byol-multi-nic-voltmesh\"]",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhAwsCertifiedHw(rulesAwsCertifiedHw)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.aws_certified_hw: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_certified_hw"] = vFn

	vrhInstanceType := v.InstanceTypeValidationRuleHandler
	rulesInstanceType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhInstanceType(rulesInstanceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.instance_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["instance_type"] = vFn

	vrhSshKey := v.SshKeyValidationRuleHandler
	rulesSshKey := map[string]string{
		"ves.io.schema.rules.string.max_len": "8192",
	}
	vFn, err = vrhSshKey(rulesSshKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.ssh_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_key"] = vFn

	vrhAzNodes := v.AzNodesValidationRuleHandler
	rulesAzNodes := map[string]string{
		"ves.io.schema.rules.repeated.num_items": "1,3",
	}
	vFn, err = vrhAzNodes(rulesAzNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.az_nodes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["az_nodes"] = vFn

	vrhNodesPerAz := v.NodesPerAzValidationRuleHandler
	rulesNodesPerAz := map[string]string{
		"ves.io.schema.rules.uint32.lte": "21",
	}
	vFn, err = vrhNodesPerAz(rulesNodesPerAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.nodes_per_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nodes_per_az"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "64000",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["deployment.aws_cred"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["service_vpc_choice.new_vpc"] = ves_io_schema_views.AWSVPCParamsTypeValidator().Validate

	v.FldValidators["tgw_choice.new_tgw"] = TGWParamsTypeValidator().Validate
	v.FldValidators["tgw_choice.existing_tgw"] = ExistingTGWTypeValidator().Validate

	return v
}()

func ServicesVPCTypeValidator() db.Validator {
	return DefaultServicesVPCTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TGWAssignedASNType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TGWAssignedASNType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TGWAssignedASNType) DeepCopy() *TGWAssignedASNType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TGWAssignedASNType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TGWAssignedASNType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TGWAssignedASNType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TGWAssignedASNTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTGWAssignedASNType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTGWAssignedASNType) TgwAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_asn")
	}

	return validatorFn, nil
}

func (v *ValidateTGWAssignedASNType) VolterraSiteAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_site_asn")
	}

	return validatorFn, nil
}

func (v *ValidateTGWAssignedASNType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TGWAssignedASNType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TGWAssignedASNType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tgw_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_asn"))
		if err := fv(ctx, m.GetTgwAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_site_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_site_asn"))
		if err := fv(ctx, m.GetVolterraSiteAsn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTGWAssignedASNTypeValidator = func() *ValidateTGWAssignedASNType {
	v := &ValidateTGWAssignedASNType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTgwAsn := v.TgwAsnValidationRuleHandler
	rulesTgwAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt":  "64512",
		"ves.io.schema.rules.uint32.lte": "65534",
	}
	vFn, err = vrhTgwAsn(rulesTgwAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TGWAssignedASNType.tgw_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_asn"] = vFn

	vrhVolterraSiteAsn := v.VolterraSiteAsnValidationRuleHandler
	rulesVolterraSiteAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt":  "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhVolterraSiteAsn(rulesVolterraSiteAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TGWAssignedASNType.volterra_site_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_site_asn"] = vFn

	return v
}()

func TGWAssignedASNTypeValidator() db.Validator {
	return DefaultTGWAssignedASNTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TGWParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TGWParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TGWParamsType) DeepCopy() *TGWParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TGWParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TGWParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TGWParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TGWParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTGWParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTGWParamsType) AsnChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for asn_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTGWParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TGWParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TGWParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn_choice"]; exists {
		val := m.GetAsnChoice()
		vOpts := append(opts,
			db.WithValidateField("asn_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAsnChoice().(type) {
	case *TGWParamsType_SystemGenerated:
		if fv, exists := v.FldValidators["asn_choice.system_generated"]; exists {
			val := m.GetAsnChoice().(*TGWParamsType_SystemGenerated).SystemGenerated
			vOpts := append(opts,
				db.WithValidateField("asn_choice"),
				db.WithValidateField("system_generated"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TGWParamsType_UserAssigned:
		if fv, exists := v.FldValidators["asn_choice.user_assigned"]; exists {
			val := m.GetAsnChoice().(*TGWParamsType_UserAssigned).UserAssigned
			vOpts := append(opts,
				db.WithValidateField("asn_choice"),
				db.WithValidateField("user_assigned"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTGWParamsTypeValidator = func() *ValidateTGWParamsType {
	v := &ValidateTGWParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsnChoice := v.AsnChoiceValidationRuleHandler
	rulesAsnChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAsnChoice(rulesAsnChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TGWParamsType.asn_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn_choice"] = vFn

	v.FldValidators["asn_choice.user_assigned"] = TGWAssignedASNTypeValidator().Validate

	return v
}()

func TGWParamsTypeValidator() db.Validator {
	return DefaultTGWParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VPCAttachmentListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VPCAttachmentListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VPCAttachmentListType) DeepCopy() *VPCAttachmentListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VPCAttachmentListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VPCAttachmentListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VPCAttachmentListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VPCAttachmentListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVPCAttachmentListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVPCAttachmentListType) VpcListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*VPCAttachmentType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := VPCAttachmentTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vpc_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*VPCAttachmentType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*VPCAttachmentType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vpc_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vpc_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVPCAttachmentListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VPCAttachmentListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VPCAttachmentListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["vpc_list"]; exists {
		vOpts := append(opts, db.WithValidateField("vpc_list"))
		if err := fv(ctx, m.GetVpcList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVPCAttachmentListTypeValidator = func() *ValidateVPCAttachmentListType {
	v := &ValidateVPCAttachmentListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVpcList := v.VpcListValidationRuleHandler
	rulesVpcList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.min_items": "0",
	}
	vFn, err = vrhVpcList(rulesVpcList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VPCAttachmentListType.vpc_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vpc_list"] = vFn

	return v
}()

func VPCAttachmentListTypeValidator() db.Validator {
	return DefaultVPCAttachmentListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VPCAttachmentType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VPCAttachmentType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VPCAttachmentType) DeepCopy() *VPCAttachmentType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VPCAttachmentType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VPCAttachmentType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VPCAttachmentType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VPCAttachmentTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVPCAttachmentType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVPCAttachmentType) VpcIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vpc_id")
	}

	return validatorFn, nil
}

func (v *ValidateVPCAttachmentType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VPCAttachmentType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VPCAttachmentType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_id"))
		if err := fv(ctx, m.GetVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVPCAttachmentTypeValidator = func() *ValidateVPCAttachmentType {
	v := &ValidateVPCAttachmentType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVpcId := v.VpcIdValidationRuleHandler
	rulesVpcId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(vpc-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhVpcId(rulesVpcId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VPCAttachmentType.vpc_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vpc_id"] = vFn

	return v
}()

func VPCAttachmentTypeValidator() db.Validator {
	return DefaultVPCAttachmentTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VPCIpPrefixesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VPCIpPrefixesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VPCIpPrefixesType) DeepCopy() *VPCIpPrefixesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VPCIpPrefixesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VPCIpPrefixesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VPCIpPrefixesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VPCIpPrefixesTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVPCIpPrefixesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVPCIpPrefixesType) PrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVPCIpPrefixesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VPCIpPrefixesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VPCIpPrefixesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("prefixes"))
		if err := fv(ctx, m.GetPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVPCIpPrefixesTypeValidator = func() *ValidateVPCIpPrefixesType {
	v := &ValidateVPCIpPrefixesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixes := v.PrefixesValidationRuleHandler
	rulesPrefixes := map[string]string{
		"ves.io.schema.rules.message.required":                  "true",
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "1024",
		"ves.io.schema.rules.repeated.min_items":                "1",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhPrefixes(rulesPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VPCIpPrefixesType.prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefixes"] = vFn

	return v
}()

func VPCIpPrefixesTypeValidator() db.Validator {
	return DefaultVPCIpPrefixesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VnConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VnConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VnConfiguration) DeepCopy() *VnConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VnConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VnConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VnConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VnConfigurationValidator().Validate(ctx, m, opts...)
}

func (m *VnConfiguration) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetGlobalNetworkChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInsideStaticRouteChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOutsideStaticRouteChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *VnConfiguration) GetGlobalNetworkChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GlobalNetworkChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetGlobalNetworkChoice().(type) {
	case *VnConfiguration_NoGlobalNetwork:

	case *VnConfiguration_GlobalNetworkList:
		odrInfos, err = m.GetGlobalNetworkList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "global_network_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *VnConfiguration) GetInsideStaticRouteChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.InsideStaticRouteChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetInsideStaticRouteChoice().(type) {
	case *VnConfiguration_NoInsideStaticRoutes:

	case *VnConfiguration_InsideStaticRoutes:
		odrInfos, err = m.GetInsideStaticRoutes().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "inside_static_routes." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *VnConfiguration) GetOutsideStaticRouteChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.OutsideStaticRouteChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetOutsideStaticRouteChoice().(type) {
	case *VnConfiguration_NoOutsideStaticRoutes:

	case *VnConfiguration_OutsideStaticRoutes:
		odrInfos, err = m.GetOutsideStaticRoutes().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "outside_static_routes." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

type ValidateVnConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVnConfiguration) GlobalNetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for global_network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVnConfiguration) InsideStaticRouteChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_static_route_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVnConfiguration) OutsideStaticRouteChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_static_route_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVnConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VnConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VnConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["global_network_choice"]; exists {
		val := m.GetGlobalNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("global_network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGlobalNetworkChoice().(type) {
	case *VnConfiguration_NoGlobalNetwork:
		if fv, exists := v.FldValidators["global_network_choice.no_global_network"]; exists {
			val := m.GetGlobalNetworkChoice().(*VnConfiguration_NoGlobalNetwork).NoGlobalNetwork
			vOpts := append(opts,
				db.WithValidateField("global_network_choice"),
				db.WithValidateField("no_global_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VnConfiguration_GlobalNetworkList:
		if fv, exists := v.FldValidators["global_network_choice.global_network_list"]; exists {
			val := m.GetGlobalNetworkChoice().(*VnConfiguration_GlobalNetworkList).GlobalNetworkList
			vOpts := append(opts,
				db.WithValidateField("global_network_choice"),
				db.WithValidateField("global_network_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["inside_static_route_choice"]; exists {
		val := m.GetInsideStaticRouteChoice()
		vOpts := append(opts,
			db.WithValidateField("inside_static_route_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInsideStaticRouteChoice().(type) {
	case *VnConfiguration_NoInsideStaticRoutes:
		if fv, exists := v.FldValidators["inside_static_route_choice.no_inside_static_routes"]; exists {
			val := m.GetInsideStaticRouteChoice().(*VnConfiguration_NoInsideStaticRoutes).NoInsideStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("inside_static_route_choice"),
				db.WithValidateField("no_inside_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VnConfiguration_InsideStaticRoutes:
		if fv, exists := v.FldValidators["inside_static_route_choice.inside_static_routes"]; exists {
			val := m.GetInsideStaticRouteChoice().(*VnConfiguration_InsideStaticRoutes).InsideStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("inside_static_route_choice"),
				db.WithValidateField("inside_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["outside_static_route_choice"]; exists {
		val := m.GetOutsideStaticRouteChoice()
		vOpts := append(opts,
			db.WithValidateField("outside_static_route_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOutsideStaticRouteChoice().(type) {
	case *VnConfiguration_NoOutsideStaticRoutes:
		if fv, exists := v.FldValidators["outside_static_route_choice.no_outside_static_routes"]; exists {
			val := m.GetOutsideStaticRouteChoice().(*VnConfiguration_NoOutsideStaticRoutes).NoOutsideStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("outside_static_route_choice"),
				db.WithValidateField("no_outside_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VnConfiguration_OutsideStaticRoutes:
		if fv, exists := v.FldValidators["outside_static_route_choice.outside_static_routes"]; exists {
			val := m.GetOutsideStaticRouteChoice().(*VnConfiguration_OutsideStaticRoutes).OutsideStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("outside_static_route_choice"),
				db.WithValidateField("outside_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVnConfigurationValidator = func() *ValidateVnConfiguration {
	v := &ValidateVnConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhGlobalNetworkChoice := v.GlobalNetworkChoiceValidationRuleHandler
	rulesGlobalNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhGlobalNetworkChoice(rulesGlobalNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VnConfiguration.global_network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["global_network_choice"] = vFn

	vrhInsideStaticRouteChoice := v.InsideStaticRouteChoiceValidationRuleHandler
	rulesInsideStaticRouteChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInsideStaticRouteChoice(rulesInsideStaticRouteChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VnConfiguration.inside_static_route_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_static_route_choice"] = vFn

	vrhOutsideStaticRouteChoice := v.OutsideStaticRouteChoiceValidationRuleHandler
	rulesOutsideStaticRouteChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOutsideStaticRouteChoice(rulesOutsideStaticRouteChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VnConfiguration.outside_static_route_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_static_route_choice"] = vFn

	v.FldValidators["global_network_choice.global_network_list"] = ves_io_schema_views.GlobalNetworkConnectionListTypeValidator().Validate

	v.FldValidators["inside_static_route_choice.inside_static_routes"] = ves_io_schema_views.SiteStaticRoutesListTypeValidator().Validate

	v.FldValidators["outside_static_route_choice.outside_static_routes"] = ves_io_schema_views.SiteStaticRoutesListTypeValidator().Validate

	return v
}()

func VnConfigurationValidator() db.Validator {
	return DefaultVnConfigurationValidator
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.AwsParameters = f.GetAwsParameters()
	m.Coordinates = f.GetCoordinates()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.TgwSecurity = f.GetTgwSecurity()
	m.VnConfig = f.GetVnConfig()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
	m.VpcAttachments = f.GetVpcAttachments()
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Address = m1.Address
	f.AwsParameters = m1.AwsParameters
	f.Coordinates = m1.Coordinates
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.TgwSecurity = m1.TgwSecurity
	f.VnConfig = m1.VnConfig
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
	f.VpcAttachments = m1.VpcAttachments
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.AwsParameters = f.GetAwsParameters()
	m.Coordinates = f.GetCoordinates()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.TgwSecurity = f.GetTgwSecurity()
	m.Tunnels = f.GetTunnels()
	m.VnConfig = f.GetVnConfig()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
	m.VpcAttachments = f.GetVpcAttachments()
	m.VpcIpPrefixes = f.GetVpcIpPrefixes()
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Address = m1.Address
	f.AwsParameters = m1.AwsParameters
	f.Coordinates = m1.Coordinates
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.TgwSecurity = m1.TgwSecurity
	f.Tunnels = m1.Tunnels
	f.VnConfig = m1.VnConfig
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
	f.VpcAttachments = m1.VpcAttachments
	f.VpcIpPrefixes = m1.VpcIpPrefixes
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.Coordinates = f.GetCoordinates()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.TgwSecurity = f.GetTgwSecurity()
	m.VnConfig = f.GetVnConfig()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
	m.VpcAttachments = f.GetVpcAttachments()
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Address = m1.Address
	f.Coordinates = m1.Coordinates
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.TgwSecurity = m1.TgwSecurity
	f.VnConfig = m1.VnConfig
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
	f.VpcAttachments = m1.VpcAttachments
}

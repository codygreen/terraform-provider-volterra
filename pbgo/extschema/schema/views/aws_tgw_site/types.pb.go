// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/aws_tgw_site/types.proto

package aws_tgw_site

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/gogo/protobuf/types"
import ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema_views1 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
import ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// TGW Assigned ASN Type
//
// x-displayName: "TGW Assigned ASN Type"
// Information needed when ASNs are assigned by the user
type TGWAssignedASNType struct {
	// TGW ASN
	//
	// x-displayName: "Enter TGW ASN"
	// x-example: "64512"
	// TGW ASN. Allowed range for 16-bit private ASNs include 64512 to 65534.
	TgwAsn uint32 `protobuf:"varint,1,opt,name=tgw_asn,json=tgwAsn,proto3" json:"tgw_asn,omitempty"`
	// Volterra Site ASN
	//
	// x-displayName: "Enter Volterra Site ASN"
	// x-example: "64500"
	// Volterra Site ASN.
	VolterraSiteAsn uint32 `protobuf:"varint,2,opt,name=volterra_site_asn,json=volterraSiteAsn,proto3" json:"volterra_site_asn,omitempty"`
}

func (m *TGWAssignedASNType) Reset()                    { *m = TGWAssignedASNType{} }
func (*TGWAssignedASNType) ProtoMessage()               {}
func (*TGWAssignedASNType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *TGWAssignedASNType) GetTgwAsn() uint32 {
	if m != nil {
		return m.TgwAsn
	}
	return 0
}

func (m *TGWAssignedASNType) GetVolterraSiteAsn() uint32 {
	if m != nil {
		return m.VolterraSiteAsn
	}
	return 0
}

// Existing TGW Type
//
// x-displayName: "Existing TGW Type"
// Information needed for existing TGW
type ExistingTGWType struct {
	// Existing TGW ID
	//
	// x-displayName: "Existing TGW ID"
	// x-example: "tgw-12345678901234567"
	// Existing TGW ID
	TgwId string `protobuf:"bytes,1,opt,name=tgw_id,json=tgwId,proto3" json:"tgw_id,omitempty"`
	// TGW ASN
	//
	// x-displayName: "Enter TGW ASN"
	// x-example: "64500"
	// TGW ASN.
	TgwAsn uint32 `protobuf:"varint,2,opt,name=tgw_asn,json=tgwAsn,proto3" json:"tgw_asn,omitempty"`
	// Volterra Site ASN
	//
	// x-displayName: "Enter Volterra Site ASN"
	// x-example: "64501"
	// Volterra Site ASN.
	VolterraSiteAsn uint32 `protobuf:"varint,3,opt,name=volterra_site_asn,json=volterraSiteAsn,proto3" json:"volterra_site_asn,omitempty"`
}

func (m *ExistingTGWType) Reset()                    { *m = ExistingTGWType{} }
func (*ExistingTGWType) ProtoMessage()               {}
func (*ExistingTGWType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *ExistingTGWType) GetTgwId() string {
	if m != nil {
		return m.TgwId
	}
	return ""
}

func (m *ExistingTGWType) GetTgwAsn() uint32 {
	if m != nil {
		return m.TgwAsn
	}
	return 0
}

func (m *ExistingTGWType) GetVolterraSiteAsn() uint32 {
	if m != nil {
		return m.VolterraSiteAsn
	}
	return 0
}

type TGWParamsType struct {
	// BGP ASN config
	//
	// x-displayName: "Select BGP ASN"
	// x-required
	// Select BGP ASN config mode
	//
	// Types that are valid to be assigned to AsnChoice:
	//	*TGWParamsType_SystemGenerated
	//	*TGWParamsType_UserAssigned
	AsnChoice isTGWParamsType_AsnChoice `protobuf_oneof:"asn_choice"`
}

func (m *TGWParamsType) Reset()                    { *m = TGWParamsType{} }
func (*TGWParamsType) ProtoMessage()               {}
func (*TGWParamsType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isTGWParamsType_AsnChoice interface {
	isTGWParamsType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TGWParamsType_SystemGenerated struct {
	SystemGenerated *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=system_generated,json=systemGenerated,oneof"`
}
type TGWParamsType_UserAssigned struct {
	UserAssigned *TGWAssignedASNType `protobuf:"bytes,3,opt,name=user_assigned,json=userAssigned,oneof"`
}

func (*TGWParamsType_SystemGenerated) isTGWParamsType_AsnChoice() {}
func (*TGWParamsType_UserAssigned) isTGWParamsType_AsnChoice()    {}

func (m *TGWParamsType) GetAsnChoice() isTGWParamsType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}

func (m *TGWParamsType) GetSystemGenerated() *ves_io_schema4.Empty {
	if x, ok := m.GetAsnChoice().(*TGWParamsType_SystemGenerated); ok {
		return x.SystemGenerated
	}
	return nil
}

func (m *TGWParamsType) GetUserAssigned() *TGWAssignedASNType {
	if x, ok := m.GetAsnChoice().(*TGWParamsType_UserAssigned); ok {
		return x.UserAssigned
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TGWParamsType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TGWParamsType_OneofMarshaler, _TGWParamsType_OneofUnmarshaler, _TGWParamsType_OneofSizer, []interface{}{
		(*TGWParamsType_SystemGenerated)(nil),
		(*TGWParamsType_UserAssigned)(nil),
	}
}

func _TGWParamsType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TGWParamsType)
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *TGWParamsType_SystemGenerated:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SystemGenerated); err != nil {
			return err
		}
	case *TGWParamsType_UserAssigned:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UserAssigned); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TGWParamsType.AsnChoice has unexpected type %T", x)
	}
	return nil
}

func _TGWParamsType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TGWParamsType)
	switch tag {
	case 2: // asn_choice.system_generated
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &TGWParamsType_SystemGenerated{msg}
		return true, err
	case 3: // asn_choice.user_assigned
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TGWAssignedASNType)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &TGWParamsType_UserAssigned{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TGWParamsType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TGWParamsType)
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *TGWParamsType_SystemGenerated:
		s := proto.Size(x.SystemGenerated)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TGWParamsType_UserAssigned:
		s := proto.Size(x.UserAssigned)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AWS Service VPC and TGW
//
// x-displayName: "AWS Service VPC and TGW"
// Setup AWS services VPC, transit gateway and site
type ServicesVPCType struct {
	// AWS Region
	//
	// x-displayName: "AWS Region"
	// x-example: "us-east-1"
	// x-required
	// Name for AWS Region.
	AwsRegion string `protobuf:"bytes,1,opt,name=aws_region,json=awsRegion,proto3" json:"aws_region,omitempty"`
	// Choice of existing or new Services VPC
	//
	// x-displayName: "Select Services VPC"
	// x-required
	// Choice of using existing or create new services VPC
	//
	// Types that are valid to be assigned to ServiceVpcChoice:
	//	*ServicesVPCType_NewVpc
	//	*ServicesVPCType_VpcId
	ServiceVpcChoice isServicesVPCType_ServiceVpcChoice `protobuf_oneof:"service_vpc_choice"`
	// TGW
	//
	// x-displayName: "Select Transit Gateway"
	// x-required
	// Choice of using existing TGW or create new TGW
	//
	// Types that are valid to be assigned to TgwChoice:
	//	*ServicesVPCType_NewTgw
	//	*ServicesVPCType_ExistingTgw
	TgwChoice isServicesVPCType_TgwChoice `protobuf_oneof:"tgw_choice"`
	// AWS Certified Hardware
	//
	// x-displayName: "AWS Certified Hardware"
	// x-example: "aws-byol-multi-nic-voltmesh"
	// x-required
	// Name for AWS certified hardware.
	AwsCertifiedHw string `protobuf:"bytes,8,opt,name=aws_certified_hw,json=awsCertifiedHw,proto3" json:"aws_certified_hw,omitempty"`
	// Instance Type
	//
	// x-displayName: "AWS Instance Type for Node"
	// x-example: "a1.xlarge"
	// x-required
	// Select Instance size based on performance needed
	InstanceType string `protobuf:"bytes,9,opt,name=instance_type,json=instanceType,proto3" json:"instance_type,omitempty"`
	// Public SSH key
	//
	// x-displayName: "Public SSH key"
	// x-example: "ssh-rsa AAAAB..."
	// Public SSH key for accessing nodes of the site.
	SshKey string `protobuf:"bytes,10,opt,name=ssh_key,json=sshKey,proto3" json:"ssh_key,omitempty"`
	// Nodes
	//
	// x-displayName: "Ingress/Egress Gateway (two Interface) Nodes in AZ"
	// Only Single AZ or Three AZ(s) nodes are supported currently.
	AzNodes []*ves_io_schema_views1.AWSVPCTwoInterfaceNodeType `protobuf:"bytes,11,rep,name=az_nodes,json=azNodes" json:"az_nodes,omitempty"`
	// Desired Worker Nodes Selection
	//
	// x-displayName: "Desired Worker Nodes Selection"
	// x-required
	// Choice of deploying desired number of worker nodes.
	//
	// Types that are valid to be assigned to WorkerNodes:
	//	*ServicesVPCType_NodesPerAz
	//	*ServicesVPCType_TotalNodes
	//	*ServicesVPCType_NoWorkerNodes
	WorkerNodes isServicesVPCType_WorkerNodes `protobuf_oneof:"worker_nodes"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example: "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,22,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// Automatic Deployment
	//
	// x-displayName: "Select Automatic or Assisted Deployment"
	// x-required
	// Choice of deploying automatic via volterra or Assisted using volterra generated parameters.
	//
	// Types that are valid to be assigned to Deployment:
	//	*ServicesVPCType_AwsCred
	//	*ServicesVPCType_Assisted
	Deployment isServicesVPCType_Deployment `protobuf_oneof:"deployment"`
}

func (m *ServicesVPCType) Reset()                    { *m = ServicesVPCType{} }
func (*ServicesVPCType) ProtoMessage()               {}
func (*ServicesVPCType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

type isServicesVPCType_ServiceVpcChoice interface {
	isServicesVPCType_ServiceVpcChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isServicesVPCType_TgwChoice interface {
	isServicesVPCType_TgwChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isServicesVPCType_WorkerNodes interface {
	isServicesVPCType_WorkerNodes()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isServicesVPCType_Deployment interface {
	isServicesVPCType_Deployment()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ServicesVPCType_NewVpc struct {
	NewVpc *ves_io_schema_views1.AWSVPCParamsType `protobuf:"bytes,3,opt,name=new_vpc,json=newVpc,oneof"`
}
type ServicesVPCType_VpcId struct {
	VpcId string `protobuf:"bytes,4,opt,name=vpc_id,json=vpcId,proto3,oneof"`
}
type ServicesVPCType_NewTgw struct {
	NewTgw *TGWParamsType `protobuf:"bytes,6,opt,name=new_tgw,json=newTgw,oneof"`
}
type ServicesVPCType_ExistingTgw struct {
	ExistingTgw *ExistingTGWType `protobuf:"bytes,7,opt,name=existing_tgw,json=existingTgw,oneof"`
}
type ServicesVPCType_NodesPerAz struct {
	NodesPerAz uint32 `protobuf:"varint,12,opt,name=nodes_per_az,json=nodesPerAz,proto3,oneof"`
}
type ServicesVPCType_TotalNodes struct {
	TotalNodes uint32 `protobuf:"varint,27,opt,name=total_nodes,json=totalNodes,proto3,oneof"`
}
type ServicesVPCType_NoWorkerNodes struct {
	NoWorkerNodes *ves_io_schema4.Empty `protobuf:"bytes,28,opt,name=no_worker_nodes,json=noWorkerNodes,oneof"`
}
type ServicesVPCType_AwsCred struct {
	AwsCred *ves_io_schema_views.ObjectRefType `protobuf:"bytes,14,opt,name=aws_cred,json=awsCred,oneof"`
}
type ServicesVPCType_Assisted struct {
	Assisted *ves_io_schema4.Empty `protobuf:"bytes,15,opt,name=assisted,oneof"`
}

func (*ServicesVPCType_NewVpc) isServicesVPCType_ServiceVpcChoice()   {}
func (*ServicesVPCType_VpcId) isServicesVPCType_ServiceVpcChoice()    {}
func (*ServicesVPCType_NewTgw) isServicesVPCType_TgwChoice()          {}
func (*ServicesVPCType_ExistingTgw) isServicesVPCType_TgwChoice()     {}
func (*ServicesVPCType_NodesPerAz) isServicesVPCType_WorkerNodes()    {}
func (*ServicesVPCType_TotalNodes) isServicesVPCType_WorkerNodes()    {}
func (*ServicesVPCType_NoWorkerNodes) isServicesVPCType_WorkerNodes() {}
func (*ServicesVPCType_AwsCred) isServicesVPCType_Deployment()        {}
func (*ServicesVPCType_Assisted) isServicesVPCType_Deployment()       {}

func (m *ServicesVPCType) GetServiceVpcChoice() isServicesVPCType_ServiceVpcChoice {
	if m != nil {
		return m.ServiceVpcChoice
	}
	return nil
}
func (m *ServicesVPCType) GetTgwChoice() isServicesVPCType_TgwChoice {
	if m != nil {
		return m.TgwChoice
	}
	return nil
}
func (m *ServicesVPCType) GetWorkerNodes() isServicesVPCType_WorkerNodes {
	if m != nil {
		return m.WorkerNodes
	}
	return nil
}
func (m *ServicesVPCType) GetDeployment() isServicesVPCType_Deployment {
	if m != nil {
		return m.Deployment
	}
	return nil
}

func (m *ServicesVPCType) GetAwsRegion() string {
	if m != nil {
		return m.AwsRegion
	}
	return ""
}

func (m *ServicesVPCType) GetNewVpc() *ves_io_schema_views1.AWSVPCParamsType {
	if x, ok := m.GetServiceVpcChoice().(*ServicesVPCType_NewVpc); ok {
		return x.NewVpc
	}
	return nil
}

func (m *ServicesVPCType) GetVpcId() string {
	if x, ok := m.GetServiceVpcChoice().(*ServicesVPCType_VpcId); ok {
		return x.VpcId
	}
	return ""
}

func (m *ServicesVPCType) GetNewTgw() *TGWParamsType {
	if x, ok := m.GetTgwChoice().(*ServicesVPCType_NewTgw); ok {
		return x.NewTgw
	}
	return nil
}

func (m *ServicesVPCType) GetExistingTgw() *ExistingTGWType {
	if x, ok := m.GetTgwChoice().(*ServicesVPCType_ExistingTgw); ok {
		return x.ExistingTgw
	}
	return nil
}

func (m *ServicesVPCType) GetAwsCertifiedHw() string {
	if m != nil {
		return m.AwsCertifiedHw
	}
	return ""
}

func (m *ServicesVPCType) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

func (m *ServicesVPCType) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func (m *ServicesVPCType) GetAzNodes() []*ves_io_schema_views1.AWSVPCTwoInterfaceNodeType {
	if m != nil {
		return m.AzNodes
	}
	return nil
}

func (m *ServicesVPCType) GetNodesPerAz() uint32 {
	if x, ok := m.GetWorkerNodes().(*ServicesVPCType_NodesPerAz); ok {
		return x.NodesPerAz
	}
	return 0
}

func (m *ServicesVPCType) GetTotalNodes() uint32 {
	if x, ok := m.GetWorkerNodes().(*ServicesVPCType_TotalNodes); ok {
		return x.TotalNodes
	}
	return 0
}

func (m *ServicesVPCType) GetNoWorkerNodes() *ves_io_schema4.Empty {
	if x, ok := m.GetWorkerNodes().(*ServicesVPCType_NoWorkerNodes); ok {
		return x.NoWorkerNodes
	}
	return nil
}

func (m *ServicesVPCType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

func (m *ServicesVPCType) GetAwsCred() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetDeployment().(*ServicesVPCType_AwsCred); ok {
		return x.AwsCred
	}
	return nil
}

func (m *ServicesVPCType) GetAssisted() *ves_io_schema4.Empty {
	if x, ok := m.GetDeployment().(*ServicesVPCType_Assisted); ok {
		return x.Assisted
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ServicesVPCType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ServicesVPCType_OneofMarshaler, _ServicesVPCType_OneofUnmarshaler, _ServicesVPCType_OneofSizer, []interface{}{
		(*ServicesVPCType_NewVpc)(nil),
		(*ServicesVPCType_VpcId)(nil),
		(*ServicesVPCType_NewTgw)(nil),
		(*ServicesVPCType_ExistingTgw)(nil),
		(*ServicesVPCType_NodesPerAz)(nil),
		(*ServicesVPCType_TotalNodes)(nil),
		(*ServicesVPCType_NoWorkerNodes)(nil),
		(*ServicesVPCType_AwsCred)(nil),
		(*ServicesVPCType_Assisted)(nil),
	}
}

func _ServicesVPCType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ServicesVPCType)
	// service_vpc_choice
	switch x := m.ServiceVpcChoice.(type) {
	case *ServicesVPCType_NewVpc:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewVpc); err != nil {
			return err
		}
	case *ServicesVPCType_VpcId:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.VpcId)
	case nil:
	default:
		return fmt.Errorf("ServicesVPCType.ServiceVpcChoice has unexpected type %T", x)
	}
	// tgw_choice
	switch x := m.TgwChoice.(type) {
	case *ServicesVPCType_NewTgw:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewTgw); err != nil {
			return err
		}
	case *ServicesVPCType_ExistingTgw:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExistingTgw); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServicesVPCType.TgwChoice has unexpected type %T", x)
	}
	// worker_nodes
	switch x := m.WorkerNodes.(type) {
	case *ServicesVPCType_NodesPerAz:
		_ = b.EncodeVarint(12<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.NodesPerAz))
	case *ServicesVPCType_TotalNodes:
		_ = b.EncodeVarint(27<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.TotalNodes))
	case *ServicesVPCType_NoWorkerNodes:
		_ = b.EncodeVarint(28<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoWorkerNodes); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServicesVPCType.WorkerNodes has unexpected type %T", x)
	}
	// deployment
	switch x := m.Deployment.(type) {
	case *ServicesVPCType_AwsCred:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AwsCred); err != nil {
			return err
		}
	case *ServicesVPCType_Assisted:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Assisted); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServicesVPCType.Deployment has unexpected type %T", x)
	}
	return nil
}

func _ServicesVPCType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ServicesVPCType)
	switch tag {
	case 3: // service_vpc_choice.new_vpc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views1.AWSVPCParamsType)
		err := b.DecodeMessage(msg)
		m.ServiceVpcChoice = &ServicesVPCType_NewVpc{msg}
		return true, err
	case 4: // service_vpc_choice.vpc_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServiceVpcChoice = &ServicesVPCType_VpcId{x}
		return true, err
	case 6: // tgw_choice.new_tgw
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TGWParamsType)
		err := b.DecodeMessage(msg)
		m.TgwChoice = &ServicesVPCType_NewTgw{msg}
		return true, err
	case 7: // tgw_choice.existing_tgw
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExistingTGWType)
		err := b.DecodeMessage(msg)
		m.TgwChoice = &ServicesVPCType_ExistingTgw{msg}
		return true, err
	case 12: // worker_nodes.nodes_per_az
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WorkerNodes = &ServicesVPCType_NodesPerAz{uint32(x)}
		return true, err
	case 27: // worker_nodes.total_nodes
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WorkerNodes = &ServicesVPCType_TotalNodes{uint32(x)}
		return true, err
	case 28: // worker_nodes.no_worker_nodes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.WorkerNodes = &ServicesVPCType_NoWorkerNodes{msg}
		return true, err
	case 14: // deployment.aws_cred
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.Deployment = &ServicesVPCType_AwsCred{msg}
		return true, err
	case 15: // deployment.assisted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Deployment = &ServicesVPCType_Assisted{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ServicesVPCType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ServicesVPCType)
	// service_vpc_choice
	switch x := m.ServiceVpcChoice.(type) {
	case *ServicesVPCType_NewVpc:
		s := proto.Size(x.NewVpc)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServicesVPCType_VpcId:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.VpcId)))
		n += len(x.VpcId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tgw_choice
	switch x := m.TgwChoice.(type) {
	case *ServicesVPCType_NewTgw:
		s := proto.Size(x.NewTgw)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServicesVPCType_ExistingTgw:
		s := proto.Size(x.ExistingTgw)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// worker_nodes
	switch x := m.WorkerNodes.(type) {
	case *ServicesVPCType_NodesPerAz:
		n += proto.SizeVarint(12<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.NodesPerAz))
	case *ServicesVPCType_TotalNodes:
		n += proto.SizeVarint(27<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.TotalNodes))
	case *ServicesVPCType_NoWorkerNodes:
		s := proto.Size(x.NoWorkerNodes)
		n += proto.SizeVarint(28<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// deployment
	switch x := m.Deployment.(type) {
	case *ServicesVPCType_AwsCred:
		s := proto.Size(x.AwsCred)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServicesVPCType_Assisted:
		s := proto.Size(x.Assisted)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Virtual Network Configuration
//
// x-displayName: "Virtual Network Configuration"
// Virtual Network Configuration
type VnConfiguration struct {
	// Manage Static Routes for Inside Network
	//
	// x-displayName: "Manage Static Routes for Inside Network"
	// x-required
	// Add static routes to inside network. Used to reach indirectly connected subnets.
	//
	// Types that are valid to be assigned to InsideStaticRouteChoice:
	//	*VnConfiguration_NoInsideStaticRoutes
	//	*VnConfiguration_InsideStaticRoutes
	InsideStaticRouteChoice isVnConfiguration_InsideStaticRouteChoice `protobuf_oneof:"inside_static_route_choice"`
	// Manage Static Routes for Outside Network
	//
	// x-displayName: "Manage Static Routes for Outside Network"
	// x-required
	// Add static routes to outside network. Used to reach indirectly connected subnets.
	//
	// Types that are valid to be assigned to OutsideStaticRouteChoice:
	//	*VnConfiguration_NoOutsideStaticRoutes
	//	*VnConfiguration_OutsideStaticRoutes
	OutsideStaticRouteChoice isVnConfiguration_OutsideStaticRouteChoice `protobuf_oneof:"outside_static_route_choice"`
	// Connect to Global Network
	//
	// x-displayName: "Select Global Networks to Connect"
	// x-required
	// Select global networks to connect to inside or outside network
	//
	// Types that are valid to be assigned to GlobalNetworkChoice:
	//	*VnConfiguration_NoGlobalNetwork
	//	*VnConfiguration_GlobalNetworkList
	GlobalNetworkChoice isVnConfiguration_GlobalNetworkChoice `protobuf_oneof:"global_network_choice"`
	// Allowed VIP Port Configuration
	//
	// x-displayName: "Allowed VIP Port Configuration"
	// Allowed VIP Port Configuration
	AllowedVipPort *ves_io_schema_views1.AllowedVIPPorts `protobuf:"bytes,10,opt,name=allowed_vip_port,json=allowedVipPort" json:"allowed_vip_port,omitempty"`
}

func (m *VnConfiguration) Reset()                    { *m = VnConfiguration{} }
func (*VnConfiguration) ProtoMessage()               {}
func (*VnConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isVnConfiguration_InsideStaticRouteChoice interface {
	isVnConfiguration_InsideStaticRouteChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isVnConfiguration_OutsideStaticRouteChoice interface {
	isVnConfiguration_OutsideStaticRouteChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isVnConfiguration_GlobalNetworkChoice interface {
	isVnConfiguration_GlobalNetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VnConfiguration_NoInsideStaticRoutes struct {
	NoInsideStaticRoutes *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=no_inside_static_routes,json=noInsideStaticRoutes,oneof"`
}
type VnConfiguration_InsideStaticRoutes struct {
	InsideStaticRoutes *ves_io_schema_views1.SiteStaticRoutesListType `protobuf:"bytes,3,opt,name=inside_static_routes,json=insideStaticRoutes,oneof"`
}
type VnConfiguration_NoOutsideStaticRoutes struct {
	NoOutsideStaticRoutes *ves_io_schema4.Empty `protobuf:"bytes,5,opt,name=no_outside_static_routes,json=noOutsideStaticRoutes,oneof"`
}
type VnConfiguration_OutsideStaticRoutes struct {
	OutsideStaticRoutes *ves_io_schema_views1.SiteStaticRoutesListType `protobuf:"bytes,6,opt,name=outside_static_routes,json=outsideStaticRoutes,oneof"`
}
type VnConfiguration_NoGlobalNetwork struct {
	NoGlobalNetwork *ves_io_schema4.Empty `protobuf:"bytes,8,opt,name=no_global_network,json=noGlobalNetwork,oneof"`
}
type VnConfiguration_GlobalNetworkList struct {
	GlobalNetworkList *ves_io_schema_views1.GlobalNetworkConnectionListType `protobuf:"bytes,9,opt,name=global_network_list,json=globalNetworkList,oneof"`
}

func (*VnConfiguration_NoInsideStaticRoutes) isVnConfiguration_InsideStaticRouteChoice()   {}
func (*VnConfiguration_InsideStaticRoutes) isVnConfiguration_InsideStaticRouteChoice()     {}
func (*VnConfiguration_NoOutsideStaticRoutes) isVnConfiguration_OutsideStaticRouteChoice() {}
func (*VnConfiguration_OutsideStaticRoutes) isVnConfiguration_OutsideStaticRouteChoice()   {}
func (*VnConfiguration_NoGlobalNetwork) isVnConfiguration_GlobalNetworkChoice()            {}
func (*VnConfiguration_GlobalNetworkList) isVnConfiguration_GlobalNetworkChoice()          {}

func (m *VnConfiguration) GetInsideStaticRouteChoice() isVnConfiguration_InsideStaticRouteChoice {
	if m != nil {
		return m.InsideStaticRouteChoice
	}
	return nil
}
func (m *VnConfiguration) GetOutsideStaticRouteChoice() isVnConfiguration_OutsideStaticRouteChoice {
	if m != nil {
		return m.OutsideStaticRouteChoice
	}
	return nil
}
func (m *VnConfiguration) GetGlobalNetworkChoice() isVnConfiguration_GlobalNetworkChoice {
	if m != nil {
		return m.GlobalNetworkChoice
	}
	return nil
}

func (m *VnConfiguration) GetNoInsideStaticRoutes() *ves_io_schema4.Empty {
	if x, ok := m.GetInsideStaticRouteChoice().(*VnConfiguration_NoInsideStaticRoutes); ok {
		return x.NoInsideStaticRoutes
	}
	return nil
}

func (m *VnConfiguration) GetInsideStaticRoutes() *ves_io_schema_views1.SiteStaticRoutesListType {
	if x, ok := m.GetInsideStaticRouteChoice().(*VnConfiguration_InsideStaticRoutes); ok {
		return x.InsideStaticRoutes
	}
	return nil
}

func (m *VnConfiguration) GetNoOutsideStaticRoutes() *ves_io_schema4.Empty {
	if x, ok := m.GetOutsideStaticRouteChoice().(*VnConfiguration_NoOutsideStaticRoutes); ok {
		return x.NoOutsideStaticRoutes
	}
	return nil
}

func (m *VnConfiguration) GetOutsideStaticRoutes() *ves_io_schema_views1.SiteStaticRoutesListType {
	if x, ok := m.GetOutsideStaticRouteChoice().(*VnConfiguration_OutsideStaticRoutes); ok {
		return x.OutsideStaticRoutes
	}
	return nil
}

func (m *VnConfiguration) GetNoGlobalNetwork() *ves_io_schema4.Empty {
	if x, ok := m.GetGlobalNetworkChoice().(*VnConfiguration_NoGlobalNetwork); ok {
		return x.NoGlobalNetwork
	}
	return nil
}

func (m *VnConfiguration) GetGlobalNetworkList() *ves_io_schema_views1.GlobalNetworkConnectionListType {
	if x, ok := m.GetGlobalNetworkChoice().(*VnConfiguration_GlobalNetworkList); ok {
		return x.GlobalNetworkList
	}
	return nil
}

func (m *VnConfiguration) GetAllowedVipPort() *ves_io_schema_views1.AllowedVIPPorts {
	if m != nil {
		return m.AllowedVipPort
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VnConfiguration) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VnConfiguration_OneofMarshaler, _VnConfiguration_OneofUnmarshaler, _VnConfiguration_OneofSizer, []interface{}{
		(*VnConfiguration_NoInsideStaticRoutes)(nil),
		(*VnConfiguration_InsideStaticRoutes)(nil),
		(*VnConfiguration_NoOutsideStaticRoutes)(nil),
		(*VnConfiguration_OutsideStaticRoutes)(nil),
		(*VnConfiguration_NoGlobalNetwork)(nil),
		(*VnConfiguration_GlobalNetworkList)(nil),
	}
}

func _VnConfiguration_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VnConfiguration)
	// inside_static_route_choice
	switch x := m.InsideStaticRouteChoice.(type) {
	case *VnConfiguration_NoInsideStaticRoutes:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoInsideStaticRoutes); err != nil {
			return err
		}
	case *VnConfiguration_InsideStaticRoutes:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InsideStaticRoutes); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VnConfiguration.InsideStaticRouteChoice has unexpected type %T", x)
	}
	// outside_static_route_choice
	switch x := m.OutsideStaticRouteChoice.(type) {
	case *VnConfiguration_NoOutsideStaticRoutes:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoOutsideStaticRoutes); err != nil {
			return err
		}
	case *VnConfiguration_OutsideStaticRoutes:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OutsideStaticRoutes); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VnConfiguration.OutsideStaticRouteChoice has unexpected type %T", x)
	}
	// global_network_choice
	switch x := m.GlobalNetworkChoice.(type) {
	case *VnConfiguration_NoGlobalNetwork:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoGlobalNetwork); err != nil {
			return err
		}
	case *VnConfiguration_GlobalNetworkList:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GlobalNetworkList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VnConfiguration.GlobalNetworkChoice has unexpected type %T", x)
	}
	return nil
}

func _VnConfiguration_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VnConfiguration)
	switch tag {
	case 2: // inside_static_route_choice.no_inside_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InsideStaticRouteChoice = &VnConfiguration_NoInsideStaticRoutes{msg}
		return true, err
	case 3: // inside_static_route_choice.inside_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views1.SiteStaticRoutesListType)
		err := b.DecodeMessage(msg)
		m.InsideStaticRouteChoice = &VnConfiguration_InsideStaticRoutes{msg}
		return true, err
	case 5: // outside_static_route_choice.no_outside_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.OutsideStaticRouteChoice = &VnConfiguration_NoOutsideStaticRoutes{msg}
		return true, err
	case 6: // outside_static_route_choice.outside_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views1.SiteStaticRoutesListType)
		err := b.DecodeMessage(msg)
		m.OutsideStaticRouteChoice = &VnConfiguration_OutsideStaticRoutes{msg}
		return true, err
	case 8: // global_network_choice.no_global_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GlobalNetworkChoice = &VnConfiguration_NoGlobalNetwork{msg}
		return true, err
	case 9: // global_network_choice.global_network_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views1.GlobalNetworkConnectionListType)
		err := b.DecodeMessage(msg)
		m.GlobalNetworkChoice = &VnConfiguration_GlobalNetworkList{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VnConfiguration_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VnConfiguration)
	// inside_static_route_choice
	switch x := m.InsideStaticRouteChoice.(type) {
	case *VnConfiguration_NoInsideStaticRoutes:
		s := proto.Size(x.NoInsideStaticRoutes)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VnConfiguration_InsideStaticRoutes:
		s := proto.Size(x.InsideStaticRoutes)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// outside_static_route_choice
	switch x := m.OutsideStaticRouteChoice.(type) {
	case *VnConfiguration_NoOutsideStaticRoutes:
		s := proto.Size(x.NoOutsideStaticRoutes)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VnConfiguration_OutsideStaticRoutes:
		s := proto.Size(x.OutsideStaticRoutes)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// global_network_choice
	switch x := m.GlobalNetworkChoice.(type) {
	case *VnConfiguration_NoGlobalNetwork:
		s := proto.Size(x.NoGlobalNetwork)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VnConfiguration_GlobalNetworkList:
		s := proto.Size(x.GlobalNetworkList)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// VPC attachment
//
// x-displayName: "VPC"
// VPC attachments to transit gateway
type VPCAttachmentType struct {
	// VPC ID
	//
	// x-displayName: "VPC ID"
	// x-example: "vpc-12345678901234567"
	// Information about existing VPC
	VpcId string `protobuf:"bytes,1,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// Labels For VPC ID
	//
	// x-displayName: "Labels For VPC ID"
	// Add Labels for each of the VPC ID, these labels can be used in network policy
	// These labels used must be from known key and label defined in shared namespace
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VPCAttachmentType) Reset()                    { *m = VPCAttachmentType{} }
func (*VPCAttachmentType) ProtoMessage()               {}
func (*VPCAttachmentType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *VPCAttachmentType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

func (m *VPCAttachmentType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// VPC IP prefixes
//
// x-displayName: "VPC IP prefixes"
// VPC IP prefixes
type VPCIpPrefixesType struct {
	// IP prefixes
	//
	// x-displayName: "Prefixes"
	// x-required
	// x-example: "['10.2.1.0/24', '192.168.8.0/29', '10.7.64.160/27']"
	// An unordered list of IP prefixes.
	Prefixes []string `protobuf:"bytes,1,rep,name=prefixes" json:"prefixes,omitempty"`
}

func (m *VPCIpPrefixesType) Reset()                    { *m = VPCIpPrefixesType{} }
func (*VPCIpPrefixesType) ProtoMessage()               {}
func (*VPCIpPrefixesType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *VPCIpPrefixesType) GetPrefixes() []string {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

// VPC attachments
//
// x-displayName: "VPC attachments"
// VPC attachments to transit gateway
type VPCAttachmentListType struct {
	// vpc_list
	//
	// x-displayName: "VPC List"
	// List of VPC attachments to transit gateway
	VpcList []*VPCAttachmentType `protobuf:"bytes,1,rep,name=vpc_list,json=vpcList" json:"vpc_list,omitempty"`
}

func (m *VPCAttachmentListType) Reset()                    { *m = VPCAttachmentListType{} }
func (*VPCAttachmentListType) ProtoMessage()               {}
func (*VPCAttachmentListType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *VPCAttachmentListType) GetVpcList() []*VPCAttachmentType {
	if m != nil {
		return m.VpcList
	}
	return nil
}

// Active Service Policies
//
// x-displayName: "Active Service Policies"
// Active service policies for the east-west  proxy
type ActiveServicePoliciesType struct {
	// service_policies
	//
	// x-displayName: "Service Policies"
	// A list of references to service_policy objects.
	ServicePolicies []*ves_io_schema_views.ObjectRefType `protobuf:"bytes,1,rep,name=service_policies,json=servicePolicies" json:"service_policies,omitempty"`
}

func (m *ActiveServicePoliciesType) Reset()                    { *m = ActiveServicePoliciesType{} }
func (*ActiveServicePoliciesType) ProtoMessage()               {}
func (*ActiveServicePoliciesType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *ActiveServicePoliciesType) GetServicePolicies() []*ves_io_schema_views.ObjectRefType {
	if m != nil {
		return m.ServicePolicies
	}
	return nil
}

// TGW Security Configuration
//
// x-displayName: "TGW Security Configuration"
// Security Configuration for transit gateway
type SecurityConfigType struct {
	// Manage Forward Proxy
	//
	// x-displayName: "Manage Forward Proxy"
	// x-required
	// Manage Forward Proxy for this site
	//
	// Types that are valid to be assigned to ForwardProxyChoice:
	//	*SecurityConfigType_NoForwardProxy
	//	*SecurityConfigType_ActiveForwardProxyPolicies
	//	*SecurityConfigType_ForwardProxyAllowAll
	ForwardProxyChoice isSecurityConfigType_ForwardProxyChoice `protobuf_oneof:"forward_proxy_choice"`
	// Manage East-West Service Policy
	//
	// x-displayName: "Manage East-West Service Policy"
	// x-required
	// Select service policy between east-west traffic between spoke VPC(s), traffic goes via proxy when service policy is enabled.
	//
	// Types that are valid to be assigned to EastWestServicePolicyChoice:
	//	*SecurityConfigType_NoEastWestPolicy
	//	*SecurityConfigType_ActiveEastWestServicePolicies
	//	*SecurityConfigType_EastWestServicePolicyAllowAll
	EastWestServicePolicyChoice isSecurityConfigType_EastWestServicePolicyChoice `protobuf_oneof:"east_west_service_policy_choice"`
	// Manage Network Policy
	//
	// x-displayName: "Manage Network Policy"
	// x-required
	// Manage Network Policy via this view
	//
	// Types that are valid to be assigned to NetworkPolicyChoice:
	//	*SecurityConfigType_NoNetworkPolicy
	//	*SecurityConfigType_ActiveNetworkPolicies
	NetworkPolicyChoice isSecurityConfigType_NetworkPolicyChoice `protobuf_oneof:"network_policy_choice"`
}

func (m *SecurityConfigType) Reset()                    { *m = SecurityConfigType{} }
func (*SecurityConfigType) ProtoMessage()               {}
func (*SecurityConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

type isSecurityConfigType_ForwardProxyChoice interface {
	isSecurityConfigType_ForwardProxyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isSecurityConfigType_EastWestServicePolicyChoice interface {
	isSecurityConfigType_EastWestServicePolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isSecurityConfigType_NetworkPolicyChoice interface {
	isSecurityConfigType_NetworkPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SecurityConfigType_NoForwardProxy struct {
	NoForwardProxy *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=no_forward_proxy,json=noForwardProxy,oneof"`
}
type SecurityConfigType_ActiveForwardProxyPolicies struct {
	ActiveForwardProxyPolicies *ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType `protobuf:"bytes,3,opt,name=active_forward_proxy_policies,json=activeForwardProxyPolicies,oneof"`
}
type SecurityConfigType_ForwardProxyAllowAll struct {
	ForwardProxyAllowAll *ves_io_schema4.Empty `protobuf:"bytes,7,opt,name=forward_proxy_allow_all,json=forwardProxyAllowAll,oneof"`
}
type SecurityConfigType_NoEastWestPolicy struct {
	NoEastWestPolicy *ves_io_schema4.Empty `protobuf:"bytes,9,opt,name=no_east_west_policy,json=noEastWestPolicy,oneof"`
}
type SecurityConfigType_ActiveEastWestServicePolicies struct {
	ActiveEastWestServicePolicies *ActiveServicePoliciesType `protobuf:"bytes,10,opt,name=active_east_west_service_policies,json=activeEastWestServicePolicies,oneof"`
}
type SecurityConfigType_EastWestServicePolicyAllowAll struct {
	EastWestServicePolicyAllowAll *ves_io_schema4.Empty `protobuf:"bytes,11,opt,name=east_west_service_policy_allow_all,json=eastWestServicePolicyAllowAll,oneof"`
}
type SecurityConfigType_NoNetworkPolicy struct {
	NoNetworkPolicy *ves_io_schema4.Empty `protobuf:"bytes,5,opt,name=no_network_policy,json=noNetworkPolicy,oneof"`
}
type SecurityConfigType_ActiveNetworkPolicies struct {
	ActiveNetworkPolicies *ves_io_schema_network_firewall.ActiveNetworkPoliciesType `protobuf:"bytes,6,opt,name=active_network_policies,json=activeNetworkPolicies,oneof"`
}

func (*SecurityConfigType_NoForwardProxy) isSecurityConfigType_ForwardProxyChoice()             {}
func (*SecurityConfigType_ActiveForwardProxyPolicies) isSecurityConfigType_ForwardProxyChoice() {}
func (*SecurityConfigType_ForwardProxyAllowAll) isSecurityConfigType_ForwardProxyChoice()       {}
func (*SecurityConfigType_NoEastWestPolicy) isSecurityConfigType_EastWestServicePolicyChoice()  {}
func (*SecurityConfigType_ActiveEastWestServicePolicies) isSecurityConfigType_EastWestServicePolicyChoice() {
}
func (*SecurityConfigType_EastWestServicePolicyAllowAll) isSecurityConfigType_EastWestServicePolicyChoice() {
}
func (*SecurityConfigType_NoNetworkPolicy) isSecurityConfigType_NetworkPolicyChoice()       {}
func (*SecurityConfigType_ActiveNetworkPolicies) isSecurityConfigType_NetworkPolicyChoice() {}

func (m *SecurityConfigType) GetForwardProxyChoice() isSecurityConfigType_ForwardProxyChoice {
	if m != nil {
		return m.ForwardProxyChoice
	}
	return nil
}
func (m *SecurityConfigType) GetEastWestServicePolicyChoice() isSecurityConfigType_EastWestServicePolicyChoice {
	if m != nil {
		return m.EastWestServicePolicyChoice
	}
	return nil
}
func (m *SecurityConfigType) GetNetworkPolicyChoice() isSecurityConfigType_NetworkPolicyChoice {
	if m != nil {
		return m.NetworkPolicyChoice
	}
	return nil
}

func (m *SecurityConfigType) GetNoForwardProxy() *ves_io_schema4.Empty {
	if x, ok := m.GetForwardProxyChoice().(*SecurityConfigType_NoForwardProxy); ok {
		return x.NoForwardProxy
	}
	return nil
}

func (m *SecurityConfigType) GetActiveForwardProxyPolicies() *ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType {
	if x, ok := m.GetForwardProxyChoice().(*SecurityConfigType_ActiveForwardProxyPolicies); ok {
		return x.ActiveForwardProxyPolicies
	}
	return nil
}

func (m *SecurityConfigType) GetForwardProxyAllowAll() *ves_io_schema4.Empty {
	if x, ok := m.GetForwardProxyChoice().(*SecurityConfigType_ForwardProxyAllowAll); ok {
		return x.ForwardProxyAllowAll
	}
	return nil
}

func (m *SecurityConfigType) GetNoEastWestPolicy() *ves_io_schema4.Empty {
	if x, ok := m.GetEastWestServicePolicyChoice().(*SecurityConfigType_NoEastWestPolicy); ok {
		return x.NoEastWestPolicy
	}
	return nil
}

func (m *SecurityConfigType) GetActiveEastWestServicePolicies() *ActiveServicePoliciesType {
	if x, ok := m.GetEastWestServicePolicyChoice().(*SecurityConfigType_ActiveEastWestServicePolicies); ok {
		return x.ActiveEastWestServicePolicies
	}
	return nil
}

func (m *SecurityConfigType) GetEastWestServicePolicyAllowAll() *ves_io_schema4.Empty {
	if x, ok := m.GetEastWestServicePolicyChoice().(*SecurityConfigType_EastWestServicePolicyAllowAll); ok {
		return x.EastWestServicePolicyAllowAll
	}
	return nil
}

func (m *SecurityConfigType) GetNoNetworkPolicy() *ves_io_schema4.Empty {
	if x, ok := m.GetNetworkPolicyChoice().(*SecurityConfigType_NoNetworkPolicy); ok {
		return x.NoNetworkPolicy
	}
	return nil
}

func (m *SecurityConfigType) GetActiveNetworkPolicies() *ves_io_schema_network_firewall.ActiveNetworkPoliciesType {
	if x, ok := m.GetNetworkPolicyChoice().(*SecurityConfigType_ActiveNetworkPolicies); ok {
		return x.ActiveNetworkPolicies
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SecurityConfigType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SecurityConfigType_OneofMarshaler, _SecurityConfigType_OneofUnmarshaler, _SecurityConfigType_OneofSizer, []interface{}{
		(*SecurityConfigType_NoForwardProxy)(nil),
		(*SecurityConfigType_ActiveForwardProxyPolicies)(nil),
		(*SecurityConfigType_ForwardProxyAllowAll)(nil),
		(*SecurityConfigType_NoEastWestPolicy)(nil),
		(*SecurityConfigType_ActiveEastWestServicePolicies)(nil),
		(*SecurityConfigType_EastWestServicePolicyAllowAll)(nil),
		(*SecurityConfigType_NoNetworkPolicy)(nil),
		(*SecurityConfigType_ActiveNetworkPolicies)(nil),
	}
}

func _SecurityConfigType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SecurityConfigType)
	// forward_proxy_choice
	switch x := m.ForwardProxyChoice.(type) {
	case *SecurityConfigType_NoForwardProxy:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoForwardProxy); err != nil {
			return err
		}
	case *SecurityConfigType_ActiveForwardProxyPolicies:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ActiveForwardProxyPolicies); err != nil {
			return err
		}
	case *SecurityConfigType_ForwardProxyAllowAll:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ForwardProxyAllowAll); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SecurityConfigType.ForwardProxyChoice has unexpected type %T", x)
	}
	// east_west_service_policy_choice
	switch x := m.EastWestServicePolicyChoice.(type) {
	case *SecurityConfigType_NoEastWestPolicy:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoEastWestPolicy); err != nil {
			return err
		}
	case *SecurityConfigType_ActiveEastWestServicePolicies:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ActiveEastWestServicePolicies); err != nil {
			return err
		}
	case *SecurityConfigType_EastWestServicePolicyAllowAll:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EastWestServicePolicyAllowAll); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SecurityConfigType.EastWestServicePolicyChoice has unexpected type %T", x)
	}
	// network_policy_choice
	switch x := m.NetworkPolicyChoice.(type) {
	case *SecurityConfigType_NoNetworkPolicy:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoNetworkPolicy); err != nil {
			return err
		}
	case *SecurityConfigType_ActiveNetworkPolicies:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ActiveNetworkPolicies); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SecurityConfigType.NetworkPolicyChoice has unexpected type %T", x)
	}
	return nil
}

func _SecurityConfigType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SecurityConfigType)
	switch tag {
	case 2: // forward_proxy_choice.no_forward_proxy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ForwardProxyChoice = &SecurityConfigType_NoForwardProxy{msg}
		return true, err
	case 3: // forward_proxy_choice.active_forward_proxy_policies
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType)
		err := b.DecodeMessage(msg)
		m.ForwardProxyChoice = &SecurityConfigType_ActiveForwardProxyPolicies{msg}
		return true, err
	case 7: // forward_proxy_choice.forward_proxy_allow_all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ForwardProxyChoice = &SecurityConfigType_ForwardProxyAllowAll{msg}
		return true, err
	case 9: // east_west_service_policy_choice.no_east_west_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.EastWestServicePolicyChoice = &SecurityConfigType_NoEastWestPolicy{msg}
		return true, err
	case 10: // east_west_service_policy_choice.active_east_west_service_policies
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ActiveServicePoliciesType)
		err := b.DecodeMessage(msg)
		m.EastWestServicePolicyChoice = &SecurityConfigType_ActiveEastWestServicePolicies{msg}
		return true, err
	case 11: // east_west_service_policy_choice.east_west_service_policy_allow_all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.EastWestServicePolicyChoice = &SecurityConfigType_EastWestServicePolicyAllowAll{msg}
		return true, err
	case 5: // network_policy_choice.no_network_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NetworkPolicyChoice = &SecurityConfigType_NoNetworkPolicy{msg}
		return true, err
	case 6: // network_policy_choice.active_network_policies
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_network_firewall.ActiveNetworkPoliciesType)
		err := b.DecodeMessage(msg)
		m.NetworkPolicyChoice = &SecurityConfigType_ActiveNetworkPolicies{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SecurityConfigType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SecurityConfigType)
	// forward_proxy_choice
	switch x := m.ForwardProxyChoice.(type) {
	case *SecurityConfigType_NoForwardProxy:
		s := proto.Size(x.NoForwardProxy)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityConfigType_ActiveForwardProxyPolicies:
		s := proto.Size(x.ActiveForwardProxyPolicies)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityConfigType_ForwardProxyAllowAll:
		s := proto.Size(x.ForwardProxyAllowAll)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// east_west_service_policy_choice
	switch x := m.EastWestServicePolicyChoice.(type) {
	case *SecurityConfigType_NoEastWestPolicy:
		s := proto.Size(x.NoEastWestPolicy)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityConfigType_ActiveEastWestServicePolicies:
		s := proto.Size(x.ActiveEastWestServicePolicies)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityConfigType_EastWestServicePolicyAllowAll:
		s := proto.Size(x.EastWestServicePolicyAllowAll)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// network_policy_choice
	switch x := m.NetworkPolicyChoice.(type) {
	case *SecurityConfigType_NoNetworkPolicy:
		s := proto.Size(x.NoNetworkPolicy)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityConfigType_ActiveNetworkPolicies:
		s := proto.Size(x.ActiveNetworkPolicies)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AWS VPN Tunnel Config
//
// x-displayName: "AWS VPN Tunnel Config"
// Remote IP for VPN tunnels of a node
type AWSVPNTunnelConfigType struct {
	// Name of the Node
	//
	// x-displayName: "Name of the Node"
	// x-example: "master-0"
	// x-required
	// Name of the node for which this tunnel is configured
	NodeName string `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// Remote IP(s)
	//
	// x-displayName: "Remote IP(s)"
	// x-example: "3.4.5.6"
	// x-required
	// Remote IP(s) for up to two tunnels
	TunnelRemoteIp []string `protobuf:"bytes,2,rep,name=tunnel_remote_ip,json=tunnelRemoteIp" json:"tunnel_remote_ip,omitempty"`
	// Volterra Node ID
	//
	// x-displayName: "Volterra Node ID"
	// x-example: "ves-node-id-xxxxxx"
	// x-required
	// Volterra Node ID for which this tunnel is configured
	NodeId string `protobuf:"bytes,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *AWSVPNTunnelConfigType) Reset()                    { *m = AWSVPNTunnelConfigType{} }
func (*AWSVPNTunnelConfigType) ProtoMessage()               {}
func (*AWSVPNTunnelConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *AWSVPNTunnelConfigType) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *AWSVPNTunnelConfigType) GetTunnelRemoteIp() []string {
	if m != nil {
		return m.TunnelRemoteIp
	}
	return nil
}

func (m *AWSVPNTunnelConfigType) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

// AWS TGW Information Config
//
// x-displayName: "AWS TGW Information Config"
// AWS tgw information like tgw-id and site's vpc-id
type AWSTGWInfoConfigType struct {
	// TGW ID
	//
	// x-displayName: "TGW ID"
	// x-example: "tgw-12345678"
	// x-required
	// TGW ID populated by AWS
	TgwId string `protobuf:"bytes,1,opt,name=tgw_id,json=tgwId,proto3" json:"tgw_id,omitempty"`
	// VPC ID
	//
	// x-displayName: "VPC ID"
	// x-example: "vpc-12345678"
	// x-required
	// VPC ID where the volterra site exists
	VpcId string `protobuf:"bytes,2,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
}

func (m *AWSTGWInfoConfigType) Reset()                    { *m = AWSTGWInfoConfigType{} }
func (*AWSTGWInfoConfigType) ProtoMessage()               {}
func (*AWSTGWInfoConfigType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *AWSTGWInfoConfigType) GetTgwId() string {
	if m != nil {
		return m.TgwId
	}
	return ""
}

func (m *AWSTGWInfoConfigType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Shape of the AWS TGW site specification
type GlobalSpecType struct {
	// AWS TGW, Services VPC and Nodes
	//
	// x-displayName: "AWS TGW, Services VPC and Nodes"
	// x-required
	// Configure AWS TGW, services VPC and site nodes parameters.
	AwsParameters *ServicesVPCType `protobuf:"bytes,1,opt,name=aws_parameters,json=awsParameters" json:"aws_parameters,omitempty"`
	// VPC attachments
	//
	// x-displayName: "VPC attachments"
	// VPC attachments to transit gateway
	VpcAttachments *VPCAttachmentListType `protobuf:"bytes,2,opt,name=vpc_attachments,json=vpcAttachments" json:"vpc_attachments,omitempty"`
	// TGW Security Configuration
	//
	// x-displayName: "TGW Security Configuration"
	// Security Configuration for transit gateway
	TgwSecurity *SecurityConfigType `protobuf:"bytes,3,opt,name=tgw_security,json=tgwSecurity" json:"tgw_security,omitempty"`
	// volterra_software_version
	//
	// x-displayName: "Software Version"
	// x-example: "value"
	// Desired Volterra software version for this site, a string matching released set of software components.
	VolterraSoftwareVersion string `protobuf:"bytes,4,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	// operating_system_version
	//
	// x-displayName: "Operating System Version"
	// x-example: "value"
	// Desired Operating System version for this site.
	OperatingSystemVersion string `protobuf:"bytes,5,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	// VPC IP Prefixes
	//
	// x-displayName: "VPC IP Prefixes"
	// All IP prefixes of subnets in the VPC. These are managed by custom API.
	VpcIpPrefixes map[string]*VPCIpPrefixesType `protobuf:"bytes,6,rep,name=vpc_ip_prefixes,json=vpcIpPrefixes" json:"vpc_ip_prefixes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// TGW Virtual Network Configuration
	//
	// x-displayName: "TGW Virtual Network Configuration"
	// Virtual Network Configuration for transit gateway
	VnConfig *VnConfiguration `protobuf:"bytes,7,opt,name=vn_config,json=vnConfig" json:"vn_config,omitempty"`
	// address
	//
	// x-displayName: "Geographical Address"
	// x-example: "123 Street, city, country, postal code"
	// Site's geographical address that can be used determine its latitude and longitude.
	Address string `protobuf:"bytes,8,opt,name=address,proto3" json:"address,omitempty"`
	// coordinates
	//
	// x-displayName: "Co-ordinates"
	// Site longitude and latitude co-ordinates
	Coordinates *ves_io_schema_site.Coordinates `protobuf:"bytes,9,opt,name=coordinates" json:"coordinates,omitempty"`
	// user_modification_timestamp
	//
	// x-displayName: "User Modification Timestamp"
	// ModificationTimestamp is a timestamp representing time when the user
	// last modified the object.
	UserModificationTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,10,opt,name=user_modification_timestamp,json=userModificationTimestamp" json:"user_modification_timestamp,omitempty"`
	// TGW information
	//
	// x-displayName: "TGW Site Information"
	// TGW Site information obtained after creating the site and TGW
	TgwInfo *AWSTGWInfoConfigType `protobuf:"bytes,11,opt,name=tgw_info,json=tgwInfo" json:"tgw_info,omitempty"`
	// Logs Streaming
	//
	// x-displayName: "Logs Streaming"
	// x-required
	// Select Logs receiver for logs streaming
	//
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*GlobalSpecType_LogsStreamingDisabled
	//	*GlobalSpecType_LogReceiver
	LogsReceiverChoice isGlobalSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// Volterra Software
	//
	// x-displayName: "Volterra Software"
	// Volterra Software Details
	Sw *ves_io_schema_views.VolterraSoftwareType `protobuf:"bytes,15,opt,name=sw" json:"sw,omitempty"`
	// Operating System
	//
	// x-displayName: "Operating System"
	// Operating System Details
	Os *ves_io_schema_views.OperatingSystemType `protobuf:"bytes,16,opt,name=os" json:"os,omitempty"`
	// VIP Params Per Az
	//
	// x-displayName: "VIP Params Per AZ"
	// VIP Parameters Per AZ.
	VipParamsPerAz []*ves_io_schema_site.PublishVIPParamsPerAz `protobuf:"bytes,17,rep,name=vip_params_per_az,json=vipParamsPerAz" json:"vip_params_per_az,omitempty"`
	// AWS VPN tunnel config
	//
	// x-displayName: "AWS VPN Tunnel Config"
	// AWS VPN Tunner Config
	Tunnels []*AWSVPNTunnelConfigType `protobuf:"bytes,998,rep,name=tunnels" json:"tunnels,omitempty"`
	// Reference to terraform parameters
	//
	// x-displayName: "Terraform Parameters"
	// Reference to terraform parameters object
	TfParams *ves_io_schema_views.ObjectRefType `protobuf:"bytes,999,opt,name=tf_params,json=tfParams" json:"tf_params,omitempty"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *ves_io_schema_views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal" json:"view_internal,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

type isGlobalSpecType_LogsReceiverChoice interface {
	isGlobalSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *ves_io_schema4.Empty `protobuf:"bytes,13,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,oneof"`
}
type GlobalSpecType_LogReceiver struct {
	LogReceiver *ves_io_schema_views.ObjectRefType `protobuf:"bytes,14,opt,name=log_receiver,json=logReceiver,oneof"`
}

func (*GlobalSpecType_LogsStreamingDisabled) isGlobalSpecType_LogsReceiverChoice() {}
func (*GlobalSpecType_LogReceiver) isGlobalSpecType_LogsReceiverChoice()           {}

func (m *GlobalSpecType) GetLogsReceiverChoice() isGlobalSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}

func (m *GlobalSpecType) GetAwsParameters() *ServicesVPCType {
	if m != nil {
		return m.AwsParameters
	}
	return nil
}

func (m *GlobalSpecType) GetVpcAttachments() *VPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *GlobalSpecType) GetTgwSecurity() *SecurityConfigType {
	if m != nil {
		return m.TgwSecurity
	}
	return nil
}

func (m *GlobalSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GlobalSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GlobalSpecType) GetVpcIpPrefixes() map[string]*VPCIpPrefixesType {
	if m != nil {
		return m.VpcIpPrefixes
	}
	return nil
}

func (m *GlobalSpecType) GetVnConfig() *VnConfiguration {
	if m != nil {
		return m.VnConfig
	}
	return nil
}

func (m *GlobalSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GlobalSpecType) GetCoordinates() *ves_io_schema_site.Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *GlobalSpecType) GetUserModificationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.UserModificationTimestamp
	}
	return nil
}

func (m *GlobalSpecType) GetTgwInfo() *AWSTGWInfoConfigType {
	if m != nil {
		return m.TgwInfo
	}
	return nil
}

func (m *GlobalSpecType) GetLogsStreamingDisabled() *ves_io_schema4.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*GlobalSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *GlobalSpecType) GetLogReceiver() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*GlobalSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *GlobalSpecType) GetSw() *ves_io_schema_views.VolterraSoftwareType {
	if m != nil {
		return m.Sw
	}
	return nil
}

func (m *GlobalSpecType) GetOs() *ves_io_schema_views.OperatingSystemType {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *GlobalSpecType) GetVipParamsPerAz() []*ves_io_schema_site.PublishVIPParamsPerAz {
	if m != nil {
		return m.VipParamsPerAz
	}
	return nil
}

func (m *GlobalSpecType) GetTunnels() []*AWSVPNTunnelConfigType {
	if m != nil {
		return m.Tunnels
	}
	return nil
}

func (m *GlobalSpecType) GetTfParams() *ves_io_schema_views.ObjectRefType {
	if m != nil {
		return m.TfParams
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *ves_io_schema_views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_LogsStreamingDisabled)(nil),
		(*GlobalSpecType_LogReceiver)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *GlobalSpecType_LogsStreamingDisabled:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogsStreamingDisabled); err != nil {
			return err
		}
	case *GlobalSpecType_LogReceiver:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogReceiver); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.LogsReceiverChoice has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 13: // logs_receiver_choice.logs_streaming_disabled
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{msg}
		return true, err
	case 14: // logs_receiver_choice.log_receiver
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &GlobalSpecType_LogReceiver{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *GlobalSpecType_LogsStreamingDisabled:
		s := proto.Size(x.LogsStreamingDisabled)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_LogReceiver:
		s := proto.Size(x.LogReceiver)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// CreateSpecType
//
// x-displayName: "Create AWS TGW site"
// Shape of the AWS TGW site specification
type CreateSpecType struct {
	AwsParameters  *ServicesVPCType                `protobuf:"bytes,1,opt,name=aws_parameters,json=awsParameters" json:"aws_parameters,omitempty"`
	VpcAttachments *VPCAttachmentListType          `protobuf:"bytes,2,opt,name=vpc_attachments,json=vpcAttachments" json:"vpc_attachments,omitempty"`
	VnConfig       *VnConfiguration                `protobuf:"bytes,7,opt,name=vn_config,json=vnConfig" json:"vn_config,omitempty"`
	TgwSecurity    *SecurityConfigType             `protobuf:"bytes,3,opt,name=tgw_security,json=tgwSecurity" json:"tgw_security,omitempty"`
	Address        string                          `protobuf:"bytes,8,opt,name=address,proto3" json:"address,omitempty"`
	Coordinates    *ves_io_schema_site.Coordinates `protobuf:"bytes,9,opt,name=coordinates" json:"coordinates,omitempty"`
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*CreateSpecType_LogsStreamingDisabled
	//	*CreateSpecType_LogReceiver
	LogsReceiverChoice isCreateSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// Volterra Software
	//
	// x-displayName: "Volterra Software"
	// Volterra Software Details
	Sw *ves_io_schema_views.VolterraSoftwareType `protobuf:"bytes,15,opt,name=sw" json:"sw,omitempty"`
	// Operating System
	//
	// x-displayName: "Operating System"
	// Operating System Details
	Os *ves_io_schema_views.OperatingSystemType `protobuf:"bytes,16,opt,name=os" json:"os,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

type isCreateSpecType_LogsReceiverChoice interface {
	isCreateSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *ves_io_schema4.Empty `protobuf:"bytes,13,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,oneof"`
}
type CreateSpecType_LogReceiver struct {
	LogReceiver *ves_io_schema_views.ObjectRefType `protobuf:"bytes,14,opt,name=log_receiver,json=logReceiver,oneof"`
}

func (*CreateSpecType_LogsStreamingDisabled) isCreateSpecType_LogsReceiverChoice() {}
func (*CreateSpecType_LogReceiver) isCreateSpecType_LogsReceiverChoice()           {}

func (m *CreateSpecType) GetLogsReceiverChoice() isCreateSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}

func (m *CreateSpecType) GetAwsParameters() *ServicesVPCType {
	if m != nil {
		return m.AwsParameters
	}
	return nil
}

func (m *CreateSpecType) GetVpcAttachments() *VPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *CreateSpecType) GetVnConfig() *VnConfiguration {
	if m != nil {
		return m.VnConfig
	}
	return nil
}

func (m *CreateSpecType) GetTgwSecurity() *SecurityConfigType {
	if m != nil {
		return m.TgwSecurity
	}
	return nil
}

func (m *CreateSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CreateSpecType) GetCoordinates() *ves_io_schema_site.Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *CreateSpecType) GetLogsStreamingDisabled() *ves_io_schema4.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*CreateSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *CreateSpecType) GetLogReceiver() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*CreateSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *CreateSpecType) GetSw() *ves_io_schema_views.VolterraSoftwareType {
	if m != nil {
		return m.Sw
	}
	return nil
}

func (m *CreateSpecType) GetOs() *ves_io_schema_views.OperatingSystemType {
	if m != nil {
		return m.Os
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_LogsStreamingDisabled)(nil),
		(*CreateSpecType_LogReceiver)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *CreateSpecType_LogsStreamingDisabled:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogsStreamingDisabled); err != nil {
			return err
		}
	case *CreateSpecType_LogReceiver:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogReceiver); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.LogsReceiverChoice has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 13: // logs_receiver_choice.logs_streaming_disabled
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &CreateSpecType_LogsStreamingDisabled{msg}
		return true, err
	case 14: // logs_receiver_choice.log_receiver
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &CreateSpecType_LogReceiver{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *CreateSpecType_LogsStreamingDisabled:
		s := proto.Size(x.LogsStreamingDisabled)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_LogReceiver:
		s := proto.Size(x.LogReceiver)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ReplaceSpecType
//
// x-displayName: "Replace AWS TGW site"
// Shape of the AWS TGW site replace specification
type ReplaceSpecType struct {
	VpcAttachments *VPCAttachmentListType          `protobuf:"bytes,2,opt,name=vpc_attachments,json=vpcAttachments" json:"vpc_attachments,omitempty"`
	VnConfig       *VnConfiguration                `protobuf:"bytes,7,opt,name=vn_config,json=vnConfig" json:"vn_config,omitempty"`
	TgwSecurity    *SecurityConfigType             `protobuf:"bytes,3,opt,name=tgw_security,json=tgwSecurity" json:"tgw_security,omitempty"`
	Address        string                          `protobuf:"bytes,8,opt,name=address,proto3" json:"address,omitempty"`
	Coordinates    *ves_io_schema_site.Coordinates `protobuf:"bytes,9,opt,name=coordinates" json:"coordinates,omitempty"`
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*ReplaceSpecType_LogsStreamingDisabled
	//	*ReplaceSpecType_LogReceiver
	LogsReceiverChoice isReplaceSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

type isReplaceSpecType_LogsReceiverChoice interface {
	isReplaceSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *ves_io_schema4.Empty `protobuf:"bytes,13,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,oneof"`
}
type ReplaceSpecType_LogReceiver struct {
	LogReceiver *ves_io_schema_views.ObjectRefType `protobuf:"bytes,14,opt,name=log_receiver,json=logReceiver,oneof"`
}

func (*ReplaceSpecType_LogsStreamingDisabled) isReplaceSpecType_LogsReceiverChoice() {}
func (*ReplaceSpecType_LogReceiver) isReplaceSpecType_LogsReceiverChoice()           {}

func (m *ReplaceSpecType) GetLogsReceiverChoice() isReplaceSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetVpcAttachments() *VPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *ReplaceSpecType) GetVnConfig() *VnConfiguration {
	if m != nil {
		return m.VnConfig
	}
	return nil
}

func (m *ReplaceSpecType) GetTgwSecurity() *SecurityConfigType {
	if m != nil {
		return m.TgwSecurity
	}
	return nil
}

func (m *ReplaceSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ReplaceSpecType) GetCoordinates() *ves_io_schema_site.Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *ReplaceSpecType) GetLogsStreamingDisabled() *ves_io_schema4.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *ReplaceSpecType) GetLogReceiver() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_LogsStreamingDisabled)(nil),
		(*ReplaceSpecType_LogReceiver)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogsStreamingDisabled); err != nil {
			return err
		}
	case *ReplaceSpecType_LogReceiver:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogReceiver); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.LogsReceiverChoice has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 13: // logs_receiver_choice.logs_streaming_disabled
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &ReplaceSpecType_LogsStreamingDisabled{msg}
		return true, err
	case 14: // logs_receiver_choice.log_receiver
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &ReplaceSpecType_LogReceiver{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:
		s := proto.Size(x.LogsStreamingDisabled)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_LogReceiver:
		s := proto.Size(x.LogReceiver)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GetSpecType
//
// x-displayName: "Get AWS TGW site"
// Shape of the AWS TGW site specification
type GetSpecType struct {
	AwsParameters             *ServicesVPCType                `protobuf:"bytes,1,opt,name=aws_parameters,json=awsParameters" json:"aws_parameters,omitempty"`
	VpcAttachments            *VPCAttachmentListType          `protobuf:"bytes,2,opt,name=vpc_attachments,json=vpcAttachments" json:"vpc_attachments,omitempty"`
	VnConfig                  *VnConfiguration                `protobuf:"bytes,7,opt,name=vn_config,json=vnConfig" json:"vn_config,omitempty"`
	TgwSecurity               *SecurityConfigType             `protobuf:"bytes,3,opt,name=tgw_security,json=tgwSecurity" json:"tgw_security,omitempty"`
	VolterraSoftwareVersion   string                          `protobuf:"bytes,4,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	OperatingSystemVersion    string                          `protobuf:"bytes,5,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	VpcIpPrefixes             map[string]*VPCIpPrefixesType   `protobuf:"bytes,6,rep,name=vpc_ip_prefixes,json=vpcIpPrefixes" json:"vpc_ip_prefixes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Tunnels                   []*AWSVPNTunnelConfigType       `protobuf:"bytes,998,rep,name=tunnels" json:"tunnels,omitempty"`
	Address                   string                          `protobuf:"bytes,8,opt,name=address,proto3" json:"address,omitempty"`
	Coordinates               *ves_io_schema_site.Coordinates `protobuf:"bytes,9,opt,name=coordinates" json:"coordinates,omitempty"`
	UserModificationTimestamp *google_protobuf1.Timestamp     `protobuf:"bytes,10,opt,name=user_modification_timestamp,json=userModificationTimestamp" json:"user_modification_timestamp,omitempty"`
	TgwInfo                   *AWSTGWInfoConfigType           `protobuf:"bytes,11,opt,name=tgw_info,json=tgwInfo" json:"tgw_info,omitempty"`
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*GetSpecType_LogsStreamingDisabled
	//	*GetSpecType_LogReceiver
	LogsReceiverChoice isGetSpecType_LogsReceiverChoice            `protobuf_oneof:"logs_receiver_choice"`
	SiteState          ves_io_schema_site.SiteState                `protobuf:"varint,15,opt,name=site_state,json=siteState,proto3,enum=ves.io.schema.site.SiteState" json:"site_state,omitempty"`
	VipParamsPerAz     []*ves_io_schema_site.PublishVIPParamsPerAz `protobuf:"bytes,17,rep,name=vip_params_per_az,json=vipParamsPerAz" json:"vip_params_per_az,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

type isGetSpecType_LogsReceiverChoice interface {
	isGetSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *ves_io_schema4.Empty `protobuf:"bytes,13,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,oneof"`
}
type GetSpecType_LogReceiver struct {
	LogReceiver *ves_io_schema_views.ObjectRefType `protobuf:"bytes,14,opt,name=log_receiver,json=logReceiver,oneof"`
}

func (*GetSpecType_LogsStreamingDisabled) isGetSpecType_LogsReceiverChoice() {}
func (*GetSpecType_LogReceiver) isGetSpecType_LogsReceiverChoice()           {}

func (m *GetSpecType) GetLogsReceiverChoice() isGetSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}

func (m *GetSpecType) GetAwsParameters() *ServicesVPCType {
	if m != nil {
		return m.AwsParameters
	}
	return nil
}

func (m *GetSpecType) GetVpcAttachments() *VPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *GetSpecType) GetVnConfig() *VnConfiguration {
	if m != nil {
		return m.VnConfig
	}
	return nil
}

func (m *GetSpecType) GetTgwSecurity() *SecurityConfigType {
	if m != nil {
		return m.TgwSecurity
	}
	return nil
}

func (m *GetSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GetSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GetSpecType) GetVpcIpPrefixes() map[string]*VPCIpPrefixesType {
	if m != nil {
		return m.VpcIpPrefixes
	}
	return nil
}

func (m *GetSpecType) GetTunnels() []*AWSVPNTunnelConfigType {
	if m != nil {
		return m.Tunnels
	}
	return nil
}

func (m *GetSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GetSpecType) GetCoordinates() *ves_io_schema_site.Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *GetSpecType) GetUserModificationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.UserModificationTimestamp
	}
	return nil
}

func (m *GetSpecType) GetTgwInfo() *AWSTGWInfoConfigType {
	if m != nil {
		return m.TgwInfo
	}
	return nil
}

func (m *GetSpecType) GetLogsStreamingDisabled() *ves_io_schema4.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*GetSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *GetSpecType) GetLogReceiver() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*GetSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *GetSpecType) GetSiteState() ves_io_schema_site.SiteState {
	if m != nil {
		return m.SiteState
	}
	return ves_io_schema_site.ONLINE
}

func (m *GetSpecType) GetVipParamsPerAz() []*ves_io_schema_site.PublishVIPParamsPerAz {
	if m != nil {
		return m.VipParamsPerAz
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_LogsStreamingDisabled)(nil),
		(*GetSpecType_LogReceiver)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *GetSpecType_LogsStreamingDisabled:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogsStreamingDisabled); err != nil {
			return err
		}
	case *GetSpecType_LogReceiver:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogReceiver); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.LogsReceiverChoice has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 13: // logs_receiver_choice.logs_streaming_disabled
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &GetSpecType_LogsStreamingDisabled{msg}
		return true, err
	case 14: // logs_receiver_choice.log_receiver
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &GetSpecType_LogReceiver{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *GetSpecType_LogsStreamingDisabled:
		s := proto.Size(x.LogsStreamingDisabled)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_LogReceiver:
		s := proto.Size(x.LogReceiver)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*TGWAssignedASNType)(nil), "ves.io.schema.views.aws_tgw_site.TGWAssignedASNType")
	golang_proto.RegisterType((*TGWAssignedASNType)(nil), "ves.io.schema.views.aws_tgw_site.TGWAssignedASNType")
	proto.RegisterType((*ExistingTGWType)(nil), "ves.io.schema.views.aws_tgw_site.ExistingTGWType")
	golang_proto.RegisterType((*ExistingTGWType)(nil), "ves.io.schema.views.aws_tgw_site.ExistingTGWType")
	proto.RegisterType((*TGWParamsType)(nil), "ves.io.schema.views.aws_tgw_site.TGWParamsType")
	golang_proto.RegisterType((*TGWParamsType)(nil), "ves.io.schema.views.aws_tgw_site.TGWParamsType")
	proto.RegisterType((*ServicesVPCType)(nil), "ves.io.schema.views.aws_tgw_site.ServicesVPCType")
	golang_proto.RegisterType((*ServicesVPCType)(nil), "ves.io.schema.views.aws_tgw_site.ServicesVPCType")
	proto.RegisterType((*VnConfiguration)(nil), "ves.io.schema.views.aws_tgw_site.VnConfiguration")
	golang_proto.RegisterType((*VnConfiguration)(nil), "ves.io.schema.views.aws_tgw_site.VnConfiguration")
	proto.RegisterType((*VPCAttachmentType)(nil), "ves.io.schema.views.aws_tgw_site.VPCAttachmentType")
	golang_proto.RegisterType((*VPCAttachmentType)(nil), "ves.io.schema.views.aws_tgw_site.VPCAttachmentType")
	proto.RegisterType((*VPCIpPrefixesType)(nil), "ves.io.schema.views.aws_tgw_site.VPCIpPrefixesType")
	golang_proto.RegisterType((*VPCIpPrefixesType)(nil), "ves.io.schema.views.aws_tgw_site.VPCIpPrefixesType")
	proto.RegisterType((*VPCAttachmentListType)(nil), "ves.io.schema.views.aws_tgw_site.VPCAttachmentListType")
	golang_proto.RegisterType((*VPCAttachmentListType)(nil), "ves.io.schema.views.aws_tgw_site.VPCAttachmentListType")
	proto.RegisterType((*ActiveServicePoliciesType)(nil), "ves.io.schema.views.aws_tgw_site.ActiveServicePoliciesType")
	golang_proto.RegisterType((*ActiveServicePoliciesType)(nil), "ves.io.schema.views.aws_tgw_site.ActiveServicePoliciesType")
	proto.RegisterType((*SecurityConfigType)(nil), "ves.io.schema.views.aws_tgw_site.SecurityConfigType")
	golang_proto.RegisterType((*SecurityConfigType)(nil), "ves.io.schema.views.aws_tgw_site.SecurityConfigType")
	proto.RegisterType((*AWSVPNTunnelConfigType)(nil), "ves.io.schema.views.aws_tgw_site.AWSVPNTunnelConfigType")
	golang_proto.RegisterType((*AWSVPNTunnelConfigType)(nil), "ves.io.schema.views.aws_tgw_site.AWSVPNTunnelConfigType")
	proto.RegisterType((*AWSTGWInfoConfigType)(nil), "ves.io.schema.views.aws_tgw_site.AWSTGWInfoConfigType")
	golang_proto.RegisterType((*AWSTGWInfoConfigType)(nil), "ves.io.schema.views.aws_tgw_site.AWSTGWInfoConfigType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.aws_tgw_site.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.aws_tgw_site.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.aws_tgw_site.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.aws_tgw_site.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.aws_tgw_site.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.aws_tgw_site.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.aws_tgw_site.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.aws_tgw_site.GetSpecType")
}
func (this *TGWAssignedASNType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TGWAssignedASNType)
	if !ok {
		that2, ok := that.(TGWAssignedASNType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TgwAsn != that1.TgwAsn {
		return false
	}
	if this.VolterraSiteAsn != that1.VolterraSiteAsn {
		return false
	}
	return true
}
func (this *ExistingTGWType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExistingTGWType)
	if !ok {
		that2, ok := that.(ExistingTGWType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TgwId != that1.TgwId {
		return false
	}
	if this.TgwAsn != that1.TgwAsn {
		return false
	}
	if this.VolterraSiteAsn != that1.VolterraSiteAsn {
		return false
	}
	return true
}
func (this *TGWParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TGWParamsType)
	if !ok {
		that2, ok := that.(TGWParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	return true
}
func (this *TGWParamsType_SystemGenerated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TGWParamsType_SystemGenerated)
	if !ok {
		that2, ok := that.(TGWParamsType_SystemGenerated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SystemGenerated.Equal(that1.SystemGenerated) {
		return false
	}
	return true
}
func (this *TGWParamsType_UserAssigned) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TGWParamsType_UserAssigned)
	if !ok {
		that2, ok := that.(TGWParamsType_UserAssigned)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UserAssigned.Equal(that1.UserAssigned) {
		return false
	}
	return true
}
func (this *ServicesVPCType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType)
	if !ok {
		that2, ok := that.(ServicesVPCType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AwsRegion != that1.AwsRegion {
		return false
	}
	if that1.ServiceVpcChoice == nil {
		if this.ServiceVpcChoice != nil {
			return false
		}
	} else if this.ServiceVpcChoice == nil {
		return false
	} else if !this.ServiceVpcChoice.Equal(that1.ServiceVpcChoice) {
		return false
	}
	if that1.TgwChoice == nil {
		if this.TgwChoice != nil {
			return false
		}
	} else if this.TgwChoice == nil {
		return false
	} else if !this.TgwChoice.Equal(that1.TgwChoice) {
		return false
	}
	if this.AwsCertifiedHw != that1.AwsCertifiedHw {
		return false
	}
	if this.InstanceType != that1.InstanceType {
		return false
	}
	if this.SshKey != that1.SshKey {
		return false
	}
	if len(this.AzNodes) != len(that1.AzNodes) {
		return false
	}
	for i := range this.AzNodes {
		if !this.AzNodes[i].Equal(that1.AzNodes[i]) {
			return false
		}
	}
	if that1.WorkerNodes == nil {
		if this.WorkerNodes != nil {
			return false
		}
	} else if this.WorkerNodes == nil {
		return false
	} else if !this.WorkerNodes.Equal(that1.WorkerNodes) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	if that1.Deployment == nil {
		if this.Deployment != nil {
			return false
		}
	} else if this.Deployment == nil {
		return false
	} else if !this.Deployment.Equal(that1.Deployment) {
		return false
	}
	return true
}
func (this *ServicesVPCType_NewVpc) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType_NewVpc)
	if !ok {
		that2, ok := that.(ServicesVPCType_NewVpc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVpc.Equal(that1.NewVpc) {
		return false
	}
	return true
}
func (this *ServicesVPCType_VpcId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType_VpcId)
	if !ok {
		that2, ok := that.(ServicesVPCType_VpcId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	return true
}
func (this *ServicesVPCType_NewTgw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType_NewTgw)
	if !ok {
		that2, ok := that.(ServicesVPCType_NewTgw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewTgw.Equal(that1.NewTgw) {
		return false
	}
	return true
}
func (this *ServicesVPCType_ExistingTgw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType_ExistingTgw)
	if !ok {
		that2, ok := that.(ServicesVPCType_ExistingTgw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingTgw.Equal(that1.ExistingTgw) {
		return false
	}
	return true
}
func (this *ServicesVPCType_NodesPerAz) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType_NodesPerAz)
	if !ok {
		that2, ok := that.(ServicesVPCType_NodesPerAz)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodesPerAz != that1.NodesPerAz {
		return false
	}
	return true
}
func (this *ServicesVPCType_TotalNodes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType_TotalNodes)
	if !ok {
		that2, ok := that.(ServicesVPCType_TotalNodes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalNodes != that1.TotalNodes {
		return false
	}
	return true
}
func (this *ServicesVPCType_NoWorkerNodes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType_NoWorkerNodes)
	if !ok {
		that2, ok := that.(ServicesVPCType_NoWorkerNodes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoWorkerNodes.Equal(that1.NoWorkerNodes) {
		return false
	}
	return true
}
func (this *ServicesVPCType_AwsCred) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType_AwsCred)
	if !ok {
		that2, ok := that.(ServicesVPCType_AwsCred)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsCred.Equal(that1.AwsCred) {
		return false
	}
	return true
}
func (this *ServicesVPCType_Assisted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicesVPCType_Assisted)
	if !ok {
		that2, ok := that.(ServicesVPCType_Assisted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Assisted.Equal(that1.Assisted) {
		return false
	}
	return true
}
func (this *VnConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VnConfiguration)
	if !ok {
		that2, ok := that.(VnConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InsideStaticRouteChoice == nil {
		if this.InsideStaticRouteChoice != nil {
			return false
		}
	} else if this.InsideStaticRouteChoice == nil {
		return false
	} else if !this.InsideStaticRouteChoice.Equal(that1.InsideStaticRouteChoice) {
		return false
	}
	if that1.OutsideStaticRouteChoice == nil {
		if this.OutsideStaticRouteChoice != nil {
			return false
		}
	} else if this.OutsideStaticRouteChoice == nil {
		return false
	} else if !this.OutsideStaticRouteChoice.Equal(that1.OutsideStaticRouteChoice) {
		return false
	}
	if that1.GlobalNetworkChoice == nil {
		if this.GlobalNetworkChoice != nil {
			return false
		}
	} else if this.GlobalNetworkChoice == nil {
		return false
	} else if !this.GlobalNetworkChoice.Equal(that1.GlobalNetworkChoice) {
		return false
	}
	if !this.AllowedVipPort.Equal(that1.AllowedVipPort) {
		return false
	}
	return true
}
func (this *VnConfiguration_NoInsideStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VnConfiguration_NoInsideStaticRoutes)
	if !ok {
		that2, ok := that.(VnConfiguration_NoInsideStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoInsideStaticRoutes.Equal(that1.NoInsideStaticRoutes) {
		return false
	}
	return true
}
func (this *VnConfiguration_InsideStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VnConfiguration_InsideStaticRoutes)
	if !ok {
		that2, ok := that.(VnConfiguration_InsideStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideStaticRoutes.Equal(that1.InsideStaticRoutes) {
		return false
	}
	return true
}
func (this *VnConfiguration_NoOutsideStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VnConfiguration_NoOutsideStaticRoutes)
	if !ok {
		that2, ok := that.(VnConfiguration_NoOutsideStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoOutsideStaticRoutes.Equal(that1.NoOutsideStaticRoutes) {
		return false
	}
	return true
}
func (this *VnConfiguration_OutsideStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VnConfiguration_OutsideStaticRoutes)
	if !ok {
		that2, ok := that.(VnConfiguration_OutsideStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OutsideStaticRoutes.Equal(that1.OutsideStaticRoutes) {
		return false
	}
	return true
}
func (this *VnConfiguration_NoGlobalNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VnConfiguration_NoGlobalNetwork)
	if !ok {
		that2, ok := that.(VnConfiguration_NoGlobalNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoGlobalNetwork.Equal(that1.NoGlobalNetwork) {
		return false
	}
	return true
}
func (this *VnConfiguration_GlobalNetworkList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VnConfiguration_GlobalNetworkList)
	if !ok {
		that2, ok := that.(VnConfiguration_GlobalNetworkList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GlobalNetworkList.Equal(that1.GlobalNetworkList) {
		return false
	}
	return true
}
func (this *VPCAttachmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VPCAttachmentType)
	if !ok {
		that2, ok := that.(VPCAttachmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *VPCIpPrefixesType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VPCIpPrefixesType)
	if !ok {
		that2, ok := that.(VPCIpPrefixesType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Prefixes) != len(that1.Prefixes) {
		return false
	}
	for i := range this.Prefixes {
		if this.Prefixes[i] != that1.Prefixes[i] {
			return false
		}
	}
	return true
}
func (this *VPCAttachmentListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VPCAttachmentListType)
	if !ok {
		that2, ok := that.(VPCAttachmentListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VpcList) != len(that1.VpcList) {
		return false
	}
	for i := range this.VpcList {
		if !this.VpcList[i].Equal(that1.VpcList[i]) {
			return false
		}
	}
	return true
}
func (this *ActiveServicePoliciesType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActiveServicePoliciesType)
	if !ok {
		that2, ok := that.(ActiveServicePoliciesType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ServicePolicies) != len(that1.ServicePolicies) {
		return false
	}
	for i := range this.ServicePolicies {
		if !this.ServicePolicies[i].Equal(that1.ServicePolicies[i]) {
			return false
		}
	}
	return true
}
func (this *SecurityConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityConfigType)
	if !ok {
		that2, ok := that.(SecurityConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ForwardProxyChoice == nil {
		if this.ForwardProxyChoice != nil {
			return false
		}
	} else if this.ForwardProxyChoice == nil {
		return false
	} else if !this.ForwardProxyChoice.Equal(that1.ForwardProxyChoice) {
		return false
	}
	if that1.EastWestServicePolicyChoice == nil {
		if this.EastWestServicePolicyChoice != nil {
			return false
		}
	} else if this.EastWestServicePolicyChoice == nil {
		return false
	} else if !this.EastWestServicePolicyChoice.Equal(that1.EastWestServicePolicyChoice) {
		return false
	}
	if that1.NetworkPolicyChoice == nil {
		if this.NetworkPolicyChoice != nil {
			return false
		}
	} else if this.NetworkPolicyChoice == nil {
		return false
	} else if !this.NetworkPolicyChoice.Equal(that1.NetworkPolicyChoice) {
		return false
	}
	return true
}
func (this *SecurityConfigType_NoForwardProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityConfigType_NoForwardProxy)
	if !ok {
		that2, ok := that.(SecurityConfigType_NoForwardProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoForwardProxy.Equal(that1.NoForwardProxy) {
		return false
	}
	return true
}
func (this *SecurityConfigType_ActiveForwardProxyPolicies) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityConfigType_ActiveForwardProxyPolicies)
	if !ok {
		that2, ok := that.(SecurityConfigType_ActiveForwardProxyPolicies)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ActiveForwardProxyPolicies.Equal(that1.ActiveForwardProxyPolicies) {
		return false
	}
	return true
}
func (this *SecurityConfigType_ForwardProxyAllowAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityConfigType_ForwardProxyAllowAll)
	if !ok {
		that2, ok := that.(SecurityConfigType_ForwardProxyAllowAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ForwardProxyAllowAll.Equal(that1.ForwardProxyAllowAll) {
		return false
	}
	return true
}
func (this *SecurityConfigType_NoEastWestPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityConfigType_NoEastWestPolicy)
	if !ok {
		that2, ok := that.(SecurityConfigType_NoEastWestPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoEastWestPolicy.Equal(that1.NoEastWestPolicy) {
		return false
	}
	return true
}
func (this *SecurityConfigType_ActiveEastWestServicePolicies) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityConfigType_ActiveEastWestServicePolicies)
	if !ok {
		that2, ok := that.(SecurityConfigType_ActiveEastWestServicePolicies)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ActiveEastWestServicePolicies.Equal(that1.ActiveEastWestServicePolicies) {
		return false
	}
	return true
}
func (this *SecurityConfigType_EastWestServicePolicyAllowAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityConfigType_EastWestServicePolicyAllowAll)
	if !ok {
		that2, ok := that.(SecurityConfigType_EastWestServicePolicyAllowAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EastWestServicePolicyAllowAll.Equal(that1.EastWestServicePolicyAllowAll) {
		return false
	}
	return true
}
func (this *SecurityConfigType_NoNetworkPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityConfigType_NoNetworkPolicy)
	if !ok {
		that2, ok := that.(SecurityConfigType_NoNetworkPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoNetworkPolicy.Equal(that1.NoNetworkPolicy) {
		return false
	}
	return true
}
func (this *SecurityConfigType_ActiveNetworkPolicies) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityConfigType_ActiveNetworkPolicies)
	if !ok {
		that2, ok := that.(SecurityConfigType_ActiveNetworkPolicies)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ActiveNetworkPolicies.Equal(that1.ActiveNetworkPolicies) {
		return false
	}
	return true
}
func (this *AWSVPNTunnelConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPNTunnelConfigType)
	if !ok {
		that2, ok := that.(AWSVPNTunnelConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeName != that1.NodeName {
		return false
	}
	if len(this.TunnelRemoteIp) != len(that1.TunnelRemoteIp) {
		return false
	}
	for i := range this.TunnelRemoteIp {
		if this.TunnelRemoteIp[i] != that1.TunnelRemoteIp[i] {
			return false
		}
	}
	if this.NodeId != that1.NodeId {
		return false
	}
	return true
}
func (this *AWSTGWInfoConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWInfoConfigType)
	if !ok {
		that2, ok := that.(AWSTGWInfoConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TgwId != that1.TgwId {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsParameters.Equal(that1.AwsParameters) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.TgwSecurity.Equal(that1.TgwSecurity) {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.VpcIpPrefixes) != len(that1.VpcIpPrefixes) {
		return false
	}
	for i := range this.VpcIpPrefixes {
		if !this.VpcIpPrefixes[i].Equal(that1.VpcIpPrefixes[i]) {
			return false
		}
	}
	if !this.VnConfig.Equal(that1.VnConfig) {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if !this.UserModificationTimestamp.Equal(that1.UserModificationTimestamp) {
		return false
	}
	if !this.TgwInfo.Equal(that1.TgwInfo) {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if !this.Sw.Equal(that1.Sw) {
		return false
	}
	if !this.Os.Equal(that1.Os) {
		return false
	}
	if len(this.VipParamsPerAz) != len(that1.VipParamsPerAz) {
		return false
	}
	for i := range this.VipParamsPerAz {
		if !this.VipParamsPerAz[i].Equal(that1.VipParamsPerAz[i]) {
			return false
		}
	}
	if len(this.Tunnels) != len(that1.Tunnels) {
		return false
	}
	for i := range this.Tunnels {
		if !this.Tunnels[i].Equal(that1.Tunnels[i]) {
			return false
		}
	}
	if !this.TfParams.Equal(that1.TfParams) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(GlobalSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(GlobalSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsParameters.Equal(that1.AwsParameters) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.VnConfig.Equal(that1.VnConfig) {
		return false
	}
	if !this.TgwSecurity.Equal(that1.TgwSecurity) {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if !this.Sw.Equal(that1.Sw) {
		return false
	}
	if !this.Os.Equal(that1.Os) {
		return false
	}
	return true
}
func (this *CreateSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(CreateSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *CreateSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(CreateSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.VnConfig.Equal(that1.VnConfig) {
		return false
	}
	if !this.TgwSecurity.Equal(that1.TgwSecurity) {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsParameters.Equal(that1.AwsParameters) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.VnConfig.Equal(that1.VnConfig) {
		return false
	}
	if !this.TgwSecurity.Equal(that1.TgwSecurity) {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.VpcIpPrefixes) != len(that1.VpcIpPrefixes) {
		return false
	}
	for i := range this.VpcIpPrefixes {
		if !this.VpcIpPrefixes[i].Equal(that1.VpcIpPrefixes[i]) {
			return false
		}
	}
	if len(this.Tunnels) != len(that1.Tunnels) {
		return false
	}
	for i := range this.Tunnels {
		if !this.Tunnels[i].Equal(that1.Tunnels[i]) {
			return false
		}
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if !this.UserModificationTimestamp.Equal(that1.UserModificationTimestamp) {
		return false
	}
	if !this.TgwInfo.Equal(that1.TgwInfo) {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if this.SiteState != that1.SiteState {
		return false
	}
	if len(this.VipParamsPerAz) != len(that1.VipParamsPerAz) {
		return false
	}
	for i := range this.VipParamsPerAz {
		if !this.VipParamsPerAz[i].Equal(that1.VipParamsPerAz[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(GetSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *GetSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(GetSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *TGWAssignedASNType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aws_tgw_site.TGWAssignedASNType{")
	s = append(s, "TgwAsn: "+fmt.Sprintf("%#v", this.TgwAsn)+",\n")
	s = append(s, "VolterraSiteAsn: "+fmt.Sprintf("%#v", this.VolterraSiteAsn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExistingTGWType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aws_tgw_site.ExistingTGWType{")
	s = append(s, "TgwId: "+fmt.Sprintf("%#v", this.TgwId)+",\n")
	s = append(s, "TgwAsn: "+fmt.Sprintf("%#v", this.TgwAsn)+",\n")
	s = append(s, "VolterraSiteAsn: "+fmt.Sprintf("%#v", this.VolterraSiteAsn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TGWParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aws_tgw_site.TGWParamsType{")
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TGWParamsType_SystemGenerated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.TGWParamsType_SystemGenerated{` +
		`SystemGenerated:` + fmt.Sprintf("%#v", this.SystemGenerated) + `}`}, ", ")
	return s
}
func (this *TGWParamsType_UserAssigned) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.TGWParamsType_UserAssigned{` +
		`UserAssigned:` + fmt.Sprintf("%#v", this.UserAssigned) + `}`}, ", ")
	return s
}
func (this *ServicesVPCType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&aws_tgw_site.ServicesVPCType{")
	s = append(s, "AwsRegion: "+fmt.Sprintf("%#v", this.AwsRegion)+",\n")
	if this.ServiceVpcChoice != nil {
		s = append(s, "ServiceVpcChoice: "+fmt.Sprintf("%#v", this.ServiceVpcChoice)+",\n")
	}
	if this.TgwChoice != nil {
		s = append(s, "TgwChoice: "+fmt.Sprintf("%#v", this.TgwChoice)+",\n")
	}
	s = append(s, "AwsCertifiedHw: "+fmt.Sprintf("%#v", this.AwsCertifiedHw)+",\n")
	s = append(s, "InstanceType: "+fmt.Sprintf("%#v", this.InstanceType)+",\n")
	s = append(s, "SshKey: "+fmt.Sprintf("%#v", this.SshKey)+",\n")
	if this.AzNodes != nil {
		s = append(s, "AzNodes: "+fmt.Sprintf("%#v", this.AzNodes)+",\n")
	}
	if this.WorkerNodes != nil {
		s = append(s, "WorkerNodes: "+fmt.Sprintf("%#v", this.WorkerNodes)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	if this.Deployment != nil {
		s = append(s, "Deployment: "+fmt.Sprintf("%#v", this.Deployment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServicesVPCType_NewVpc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ServicesVPCType_NewVpc{` +
		`NewVpc:` + fmt.Sprintf("%#v", this.NewVpc) + `}`}, ", ")
	return s
}
func (this *ServicesVPCType_VpcId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ServicesVPCType_VpcId{` +
		`VpcId:` + fmt.Sprintf("%#v", this.VpcId) + `}`}, ", ")
	return s
}
func (this *ServicesVPCType_NewTgw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ServicesVPCType_NewTgw{` +
		`NewTgw:` + fmt.Sprintf("%#v", this.NewTgw) + `}`}, ", ")
	return s
}
func (this *ServicesVPCType_ExistingTgw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ServicesVPCType_ExistingTgw{` +
		`ExistingTgw:` + fmt.Sprintf("%#v", this.ExistingTgw) + `}`}, ", ")
	return s
}
func (this *ServicesVPCType_NodesPerAz) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ServicesVPCType_NodesPerAz{` +
		`NodesPerAz:` + fmt.Sprintf("%#v", this.NodesPerAz) + `}`}, ", ")
	return s
}
func (this *ServicesVPCType_TotalNodes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ServicesVPCType_TotalNodes{` +
		`TotalNodes:` + fmt.Sprintf("%#v", this.TotalNodes) + `}`}, ", ")
	return s
}
func (this *ServicesVPCType_NoWorkerNodes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ServicesVPCType_NoWorkerNodes{` +
		`NoWorkerNodes:` + fmt.Sprintf("%#v", this.NoWorkerNodes) + `}`}, ", ")
	return s
}
func (this *ServicesVPCType_AwsCred) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ServicesVPCType_AwsCred{` +
		`AwsCred:` + fmt.Sprintf("%#v", this.AwsCred) + `}`}, ", ")
	return s
}
func (this *ServicesVPCType_Assisted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ServicesVPCType_Assisted{` +
		`Assisted:` + fmt.Sprintf("%#v", this.Assisted) + `}`}, ", ")
	return s
}
func (this *VnConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&aws_tgw_site.VnConfiguration{")
	if this.InsideStaticRouteChoice != nil {
		s = append(s, "InsideStaticRouteChoice: "+fmt.Sprintf("%#v", this.InsideStaticRouteChoice)+",\n")
	}
	if this.OutsideStaticRouteChoice != nil {
		s = append(s, "OutsideStaticRouteChoice: "+fmt.Sprintf("%#v", this.OutsideStaticRouteChoice)+",\n")
	}
	if this.GlobalNetworkChoice != nil {
		s = append(s, "GlobalNetworkChoice: "+fmt.Sprintf("%#v", this.GlobalNetworkChoice)+",\n")
	}
	if this.AllowedVipPort != nil {
		s = append(s, "AllowedVipPort: "+fmt.Sprintf("%#v", this.AllowedVipPort)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VnConfiguration_NoInsideStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.VnConfiguration_NoInsideStaticRoutes{` +
		`NoInsideStaticRoutes:` + fmt.Sprintf("%#v", this.NoInsideStaticRoutes) + `}`}, ", ")
	return s
}
func (this *VnConfiguration_InsideStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.VnConfiguration_InsideStaticRoutes{` +
		`InsideStaticRoutes:` + fmt.Sprintf("%#v", this.InsideStaticRoutes) + `}`}, ", ")
	return s
}
func (this *VnConfiguration_NoOutsideStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.VnConfiguration_NoOutsideStaticRoutes{` +
		`NoOutsideStaticRoutes:` + fmt.Sprintf("%#v", this.NoOutsideStaticRoutes) + `}`}, ", ")
	return s
}
func (this *VnConfiguration_OutsideStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.VnConfiguration_OutsideStaticRoutes{` +
		`OutsideStaticRoutes:` + fmt.Sprintf("%#v", this.OutsideStaticRoutes) + `}`}, ", ")
	return s
}
func (this *VnConfiguration_NoGlobalNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.VnConfiguration_NoGlobalNetwork{` +
		`NoGlobalNetwork:` + fmt.Sprintf("%#v", this.NoGlobalNetwork) + `}`}, ", ")
	return s
}
func (this *VnConfiguration_GlobalNetworkList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.VnConfiguration_GlobalNetworkList{` +
		`GlobalNetworkList:` + fmt.Sprintf("%#v", this.GlobalNetworkList) + `}`}, ", ")
	return s
}
func (this *VPCAttachmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aws_tgw_site.VPCAttachmentType{")
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VPCIpPrefixesType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aws_tgw_site.VPCIpPrefixesType{")
	s = append(s, "Prefixes: "+fmt.Sprintf("%#v", this.Prefixes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VPCAttachmentListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aws_tgw_site.VPCAttachmentListType{")
	if this.VpcList != nil {
		s = append(s, "VpcList: "+fmt.Sprintf("%#v", this.VpcList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ActiveServicePoliciesType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aws_tgw_site.ActiveServicePoliciesType{")
	if this.ServicePolicies != nil {
		s = append(s, "ServicePolicies: "+fmt.Sprintf("%#v", this.ServicePolicies)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&aws_tgw_site.SecurityConfigType{")
	if this.ForwardProxyChoice != nil {
		s = append(s, "ForwardProxyChoice: "+fmt.Sprintf("%#v", this.ForwardProxyChoice)+",\n")
	}
	if this.EastWestServicePolicyChoice != nil {
		s = append(s, "EastWestServicePolicyChoice: "+fmt.Sprintf("%#v", this.EastWestServicePolicyChoice)+",\n")
	}
	if this.NetworkPolicyChoice != nil {
		s = append(s, "NetworkPolicyChoice: "+fmt.Sprintf("%#v", this.NetworkPolicyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityConfigType_NoForwardProxy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.SecurityConfigType_NoForwardProxy{` +
		`NoForwardProxy:` + fmt.Sprintf("%#v", this.NoForwardProxy) + `}`}, ", ")
	return s
}
func (this *SecurityConfigType_ActiveForwardProxyPolicies) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.SecurityConfigType_ActiveForwardProxyPolicies{` +
		`ActiveForwardProxyPolicies:` + fmt.Sprintf("%#v", this.ActiveForwardProxyPolicies) + `}`}, ", ")
	return s
}
func (this *SecurityConfigType_ForwardProxyAllowAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.SecurityConfigType_ForwardProxyAllowAll{` +
		`ForwardProxyAllowAll:` + fmt.Sprintf("%#v", this.ForwardProxyAllowAll) + `}`}, ", ")
	return s
}
func (this *SecurityConfigType_NoEastWestPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.SecurityConfigType_NoEastWestPolicy{` +
		`NoEastWestPolicy:` + fmt.Sprintf("%#v", this.NoEastWestPolicy) + `}`}, ", ")
	return s
}
func (this *SecurityConfigType_ActiveEastWestServicePolicies) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.SecurityConfigType_ActiveEastWestServicePolicies{` +
		`ActiveEastWestServicePolicies:` + fmt.Sprintf("%#v", this.ActiveEastWestServicePolicies) + `}`}, ", ")
	return s
}
func (this *SecurityConfigType_EastWestServicePolicyAllowAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.SecurityConfigType_EastWestServicePolicyAllowAll{` +
		`EastWestServicePolicyAllowAll:` + fmt.Sprintf("%#v", this.EastWestServicePolicyAllowAll) + `}`}, ", ")
	return s
}
func (this *SecurityConfigType_NoNetworkPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.SecurityConfigType_NoNetworkPolicy{` +
		`NoNetworkPolicy:` + fmt.Sprintf("%#v", this.NoNetworkPolicy) + `}`}, ", ")
	return s
}
func (this *SecurityConfigType_ActiveNetworkPolicies) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.SecurityConfigType_ActiveNetworkPolicies{` +
		`ActiveNetworkPolicies:` + fmt.Sprintf("%#v", this.ActiveNetworkPolicies) + `}`}, ", ")
	return s
}
func (this *AWSVPNTunnelConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aws_tgw_site.AWSVPNTunnelConfigType{")
	s = append(s, "NodeName: "+fmt.Sprintf("%#v", this.NodeName)+",\n")
	s = append(s, "TunnelRemoteIp: "+fmt.Sprintf("%#v", this.TunnelRemoteIp)+",\n")
	s = append(s, "NodeId: "+fmt.Sprintf("%#v", this.NodeId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWInfoConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aws_tgw_site.AWSTGWInfoConfigType{")
	s = append(s, "TgwId: "+fmt.Sprintf("%#v", this.TgwId)+",\n")
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&aws_tgw_site.GlobalSpecType{")
	if this.AwsParameters != nil {
		s = append(s, "AwsParameters: "+fmt.Sprintf("%#v", this.AwsParameters)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.TgwSecurity != nil {
		s = append(s, "TgwSecurity: "+fmt.Sprintf("%#v", this.TgwSecurity)+",\n")
	}
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	keysForVpcIpPrefixes := make([]string, 0, len(this.VpcIpPrefixes))
	for k, _ := range this.VpcIpPrefixes {
		keysForVpcIpPrefixes = append(keysForVpcIpPrefixes, k)
	}
	sortkeys.Strings(keysForVpcIpPrefixes)
	mapStringForVpcIpPrefixes := "map[string]*VPCIpPrefixesType{"
	for _, k := range keysForVpcIpPrefixes {
		mapStringForVpcIpPrefixes += fmt.Sprintf("%#v: %#v,", k, this.VpcIpPrefixes[k])
	}
	mapStringForVpcIpPrefixes += "}"
	if this.VpcIpPrefixes != nil {
		s = append(s, "VpcIpPrefixes: "+mapStringForVpcIpPrefixes+",\n")
	}
	if this.VnConfig != nil {
		s = append(s, "VnConfig: "+fmt.Sprintf("%#v", this.VnConfig)+",\n")
	}
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	if this.UserModificationTimestamp != nil {
		s = append(s, "UserModificationTimestamp: "+fmt.Sprintf("%#v", this.UserModificationTimestamp)+",\n")
	}
	if this.TgwInfo != nil {
		s = append(s, "TgwInfo: "+fmt.Sprintf("%#v", this.TgwInfo)+",\n")
	}
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.Sw != nil {
		s = append(s, "Sw: "+fmt.Sprintf("%#v", this.Sw)+",\n")
	}
	if this.Os != nil {
		s = append(s, "Os: "+fmt.Sprintf("%#v", this.Os)+",\n")
	}
	if this.VipParamsPerAz != nil {
		s = append(s, "VipParamsPerAz: "+fmt.Sprintf("%#v", this.VipParamsPerAz)+",\n")
	}
	if this.Tunnels != nil {
		s = append(s, "Tunnels: "+fmt.Sprintf("%#v", this.Tunnels)+",\n")
	}
	if this.TfParams != nil {
		s = append(s, "TfParams: "+fmt.Sprintf("%#v", this.TfParams)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.GlobalSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.GlobalSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&aws_tgw_site.CreateSpecType{")
	if this.AwsParameters != nil {
		s = append(s, "AwsParameters: "+fmt.Sprintf("%#v", this.AwsParameters)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.VnConfig != nil {
		s = append(s, "VnConfig: "+fmt.Sprintf("%#v", this.VnConfig)+",\n")
	}
	if this.TgwSecurity != nil {
		s = append(s, "TgwSecurity: "+fmt.Sprintf("%#v", this.TgwSecurity)+",\n")
	}
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.Sw != nil {
		s = append(s, "Sw: "+fmt.Sprintf("%#v", this.Sw)+",\n")
	}
	if this.Os != nil {
		s = append(s, "Os: "+fmt.Sprintf("%#v", this.Os)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.CreateSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.CreateSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&aws_tgw_site.ReplaceSpecType{")
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.VnConfig != nil {
		s = append(s, "VnConfig: "+fmt.Sprintf("%#v", this.VnConfig)+",\n")
	}
	if this.TgwSecurity != nil {
		s = append(s, "TgwSecurity: "+fmt.Sprintf("%#v", this.TgwSecurity)+",\n")
	}
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ReplaceSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.ReplaceSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&aws_tgw_site.GetSpecType{")
	if this.AwsParameters != nil {
		s = append(s, "AwsParameters: "+fmt.Sprintf("%#v", this.AwsParameters)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.VnConfig != nil {
		s = append(s, "VnConfig: "+fmt.Sprintf("%#v", this.VnConfig)+",\n")
	}
	if this.TgwSecurity != nil {
		s = append(s, "TgwSecurity: "+fmt.Sprintf("%#v", this.TgwSecurity)+",\n")
	}
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	keysForVpcIpPrefixes := make([]string, 0, len(this.VpcIpPrefixes))
	for k, _ := range this.VpcIpPrefixes {
		keysForVpcIpPrefixes = append(keysForVpcIpPrefixes, k)
	}
	sortkeys.Strings(keysForVpcIpPrefixes)
	mapStringForVpcIpPrefixes := "map[string]*VPCIpPrefixesType{"
	for _, k := range keysForVpcIpPrefixes {
		mapStringForVpcIpPrefixes += fmt.Sprintf("%#v: %#v,", k, this.VpcIpPrefixes[k])
	}
	mapStringForVpcIpPrefixes += "}"
	if this.VpcIpPrefixes != nil {
		s = append(s, "VpcIpPrefixes: "+mapStringForVpcIpPrefixes+",\n")
	}
	if this.Tunnels != nil {
		s = append(s, "Tunnels: "+fmt.Sprintf("%#v", this.Tunnels)+",\n")
	}
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	if this.UserModificationTimestamp != nil {
		s = append(s, "UserModificationTimestamp: "+fmt.Sprintf("%#v", this.UserModificationTimestamp)+",\n")
	}
	if this.TgwInfo != nil {
		s = append(s, "TgwInfo: "+fmt.Sprintf("%#v", this.TgwInfo)+",\n")
	}
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	s = append(s, "SiteState: "+fmt.Sprintf("%#v", this.SiteState)+",\n")
	if this.VipParamsPerAz != nil {
		s = append(s, "VipParamsPerAz: "+fmt.Sprintf("%#v", this.VipParamsPerAz)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.GetSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aws_tgw_site.GetSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TGWAssignedASNType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGWAssignedASNType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TgwAsn != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TgwAsn))
	}
	if m.VolterraSiteAsn != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSiteAsn))
	}
	return i, nil
}

func (m *ExistingTGWType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExistingTGWType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TgwId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TgwId)))
		i += copy(dAtA[i:], m.TgwId)
	}
	if m.TgwAsn != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TgwAsn))
	}
	if m.VolterraSiteAsn != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSiteAsn))
	}
	return i, nil
}

func (m *TGWParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGWParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AsnChoice != nil {
		nn1, err := m.AsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *TGWParamsType_SystemGenerated) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SystemGenerated != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SystemGenerated.Size()))
		n2, err := m.SystemGenerated.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *TGWParamsType_UserAssigned) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UserAssigned != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UserAssigned.Size()))
		n3, err := m.UserAssigned.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *ServicesVPCType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServicesVPCType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AwsRegion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AwsRegion)))
		i += copy(dAtA[i:], m.AwsRegion)
	}
	if m.ServiceVpcChoice != nil {
		nn4, err := m.ServiceVpcChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.TgwChoice != nil {
		nn5, err := m.TgwChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if len(m.AwsCertifiedHw) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AwsCertifiedHw)))
		i += copy(dAtA[i:], m.AwsCertifiedHw)
	}
	if len(m.InstanceType) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceType)))
		i += copy(dAtA[i:], m.InstanceType)
	}
	if len(m.SshKey) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SshKey)))
		i += copy(dAtA[i:], m.SshKey)
	}
	if len(m.AzNodes) > 0 {
		for _, msg := range m.AzNodes {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WorkerNodes != nil {
		nn6, err := m.WorkerNodes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if m.Deployment != nil {
		nn7, err := m.Deployment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if m.DiskSize != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiskSize))
	}
	return i, nil
}

func (m *ServicesVPCType_NewVpc) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewVpc != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NewVpc.Size()))
		n8, err := m.NewVpc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ServicesVPCType_VpcId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
	i += copy(dAtA[i:], m.VpcId)
	return i, nil
}
func (m *ServicesVPCType_NewTgw) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewTgw != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NewTgw.Size()))
		n9, err := m.NewTgw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *ServicesVPCType_ExistingTgw) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExistingTgw != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ExistingTgw.Size()))
		n10, err := m.ExistingTgw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *ServicesVPCType_NodesPerAz) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x60
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.NodesPerAz))
	return i, nil
}
func (m *ServicesVPCType_AwsCred) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AwsCred != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AwsCred.Size()))
		n11, err := m.AwsCred.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *ServicesVPCType_Assisted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Assisted != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Assisted.Size()))
		n12, err := m.Assisted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *ServicesVPCType_TotalNodes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.TotalNodes))
	return i, nil
}
func (m *ServicesVPCType_NoWorkerNodes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoWorkerNodes != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoWorkerNodes.Size()))
		n13, err := m.NoWorkerNodes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *VnConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InsideStaticRouteChoice != nil {
		nn14, err := m.InsideStaticRouteChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.OutsideStaticRouteChoice != nil {
		nn15, err := m.OutsideStaticRouteChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	if m.GlobalNetworkChoice != nil {
		nn16, err := m.GlobalNetworkChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	if m.AllowedVipPort != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AllowedVipPort.Size()))
		n17, err := m.AllowedVipPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *VnConfiguration_NoInsideStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoInsideStaticRoutes != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoInsideStaticRoutes.Size()))
		n18, err := m.NoInsideStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *VnConfiguration_InsideStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InsideStaticRoutes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InsideStaticRoutes.Size()))
		n19, err := m.InsideStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *VnConfiguration_NoOutsideStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoOutsideStaticRoutes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoOutsideStaticRoutes.Size()))
		n20, err := m.NoOutsideStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *VnConfiguration_OutsideStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OutsideStaticRoutes != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OutsideStaticRoutes.Size()))
		n21, err := m.OutsideStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *VnConfiguration_NoGlobalNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoGlobalNetwork != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoGlobalNetwork.Size()))
		n22, err := m.NoGlobalNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *VnConfiguration_GlobalNetworkList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GlobalNetworkList != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.GlobalNetworkList.Size()))
		n23, err := m.GlobalNetworkList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *VPCAttachmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCAttachmentType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VpcId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
		i += copy(dAtA[i:], m.VpcId)
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x12
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *VPCIpPrefixesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCIpPrefixesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for _, s := range m.Prefixes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *VPCAttachmentListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCAttachmentListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for _, msg := range m.VpcList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ActiveServicePoliciesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveServicePoliciesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServicePolicies) > 0 {
		for _, msg := range m.ServicePolicies {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ForwardProxyChoice != nil {
		nn24, err := m.ForwardProxyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	if m.NetworkPolicyChoice != nil {
		nn25, err := m.NetworkPolicyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn25
	}
	if m.EastWestServicePolicyChoice != nil {
		nn26, err := m.EastWestServicePolicyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	return i, nil
}

func (m *SecurityConfigType_NoForwardProxy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoForwardProxy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoForwardProxy.Size()))
		n27, err := m.NoForwardProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *SecurityConfigType_ActiveForwardProxyPolicies) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ActiveForwardProxyPolicies != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ActiveForwardProxyPolicies.Size()))
		n28, err := m.ActiveForwardProxyPolicies.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *SecurityConfigType_NoNetworkPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoNetworkPolicy != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoNetworkPolicy.Size()))
		n29, err := m.NoNetworkPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *SecurityConfigType_ActiveNetworkPolicies) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ActiveNetworkPolicies != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ActiveNetworkPolicies.Size()))
		n30, err := m.ActiveNetworkPolicies.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *SecurityConfigType_ForwardProxyAllowAll) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ForwardProxyAllowAll != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ForwardProxyAllowAll.Size()))
		n31, err := m.ForwardProxyAllowAll.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *SecurityConfigType_NoEastWestPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoEastWestPolicy != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoEastWestPolicy.Size()))
		n32, err := m.NoEastWestPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *SecurityConfigType_ActiveEastWestServicePolicies) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ActiveEastWestServicePolicies != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ActiveEastWestServicePolicies.Size()))
		n33, err := m.ActiveEastWestServicePolicies.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *SecurityConfigType_EastWestServicePolicyAllowAll) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EastWestServicePolicyAllowAll != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EastWestServicePolicyAllowAll.Size()))
		n34, err := m.EastWestServicePolicyAllowAll.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *AWSVPNTunnelConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPNTunnelConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.TunnelRemoteIp) > 0 {
		for _, s := range m.TunnelRemoteIp {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.NodeId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *AWSTGWInfoConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWInfoConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TgwId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TgwId)))
		i += copy(dAtA[i:], m.TgwId)
	}
	if len(m.VpcId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
		i += copy(dAtA[i:], m.VpcId)
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AwsParameters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AwsParameters.Size()))
		n35, err := m.AwsParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.VpcAttachments != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VpcAttachments.Size()))
		n36, err := m.VpcAttachments.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.TgwSecurity != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TgwSecurity.Size()))
		n37, err := m.TgwSecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if len(m.VpcIpPrefixes) > 0 {
		keysForVpcIpPrefixes := make([]string, 0, len(m.VpcIpPrefixes))
		for k, _ := range m.VpcIpPrefixes {
			keysForVpcIpPrefixes = append(keysForVpcIpPrefixes, string(k))
		}
		sortkeys.Strings(keysForVpcIpPrefixes)
		for _, k := range keysForVpcIpPrefixes {
			dAtA[i] = 0x32
			i++
			v := m.VpcIpPrefixes[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n38, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n38
			}
		}
	}
	if m.VnConfig != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VnConfig.Size()))
		n39, err := m.VnConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Coordinates != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Coordinates.Size()))
		n40, err := m.Coordinates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.UserModificationTimestamp != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UserModificationTimestamp.Size()))
		n41, err := m.UserModificationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.TgwInfo != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TgwInfo.Size()))
		n42, err := m.TgwInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.LogsReceiverChoice != nil {
		nn43, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn43
	}
	if m.Sw != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Sw.Size()))
		n44, err := m.Sw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.Os != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Os.Size()))
		n45, err := m.Os.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.VipParamsPerAz) > 0 {
		for _, msg := range m.VipParamsPerAz {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tunnels) > 0 {
		for _, msg := range m.Tunnels {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x3e
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TfParams != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TfParams.Size()))
		n46, err := m.TfParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.ViewInternal != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ViewInternal.Size()))
		n47, err := m.ViewInternal.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *GlobalSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogsStreamingDisabled != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogsStreamingDisabled.Size()))
		n48, err := m.LogsStreamingDisabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *GlobalSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogReceiver != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogReceiver.Size()))
		n49, err := m.LogReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AwsParameters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AwsParameters.Size()))
		n50, err := m.AwsParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.VpcAttachments != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VpcAttachments.Size()))
		n51, err := m.VpcAttachments.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.TgwSecurity != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TgwSecurity.Size()))
		n52, err := m.TgwSecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.VnConfig != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VnConfig.Size()))
		n53, err := m.VnConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Coordinates != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Coordinates.Size()))
		n54, err := m.Coordinates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.LogsReceiverChoice != nil {
		nn55, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn55
	}
	if m.Sw != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Sw.Size()))
		n56, err := m.Sw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.Os != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Os.Size()))
		n57, err := m.Os.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}

func (m *CreateSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogsStreamingDisabled != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogsStreamingDisabled.Size()))
		n58, err := m.LogsStreamingDisabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}
func (m *CreateSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogReceiver != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogReceiver.Size()))
		n59, err := m.LogReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VpcAttachments != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VpcAttachments.Size()))
		n60, err := m.VpcAttachments.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.TgwSecurity != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TgwSecurity.Size()))
		n61, err := m.TgwSecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.VnConfig != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VnConfig.Size()))
		n62, err := m.VnConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Coordinates != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Coordinates.Size()))
		n63, err := m.Coordinates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.LogsReceiverChoice != nil {
		nn64, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn64
	}
	return i, nil
}

func (m *ReplaceSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogsStreamingDisabled != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogsStreamingDisabled.Size()))
		n65, err := m.LogsStreamingDisabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}
func (m *ReplaceSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogReceiver != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogReceiver.Size()))
		n66, err := m.LogReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AwsParameters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AwsParameters.Size()))
		n67, err := m.AwsParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if m.VpcAttachments != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VpcAttachments.Size()))
		n68, err := m.VpcAttachments.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.TgwSecurity != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TgwSecurity.Size()))
		n69, err := m.TgwSecurity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if len(m.VpcIpPrefixes) > 0 {
		keysForVpcIpPrefixes := make([]string, 0, len(m.VpcIpPrefixes))
		for k, _ := range m.VpcIpPrefixes {
			keysForVpcIpPrefixes = append(keysForVpcIpPrefixes, string(k))
		}
		sortkeys.Strings(keysForVpcIpPrefixes)
		for _, k := range keysForVpcIpPrefixes {
			dAtA[i] = 0x32
			i++
			v := m.VpcIpPrefixes[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n70, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n70
			}
		}
	}
	if m.VnConfig != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VnConfig.Size()))
		n71, err := m.VnConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Coordinates != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Coordinates.Size()))
		n72, err := m.Coordinates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.UserModificationTimestamp != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UserModificationTimestamp.Size()))
		n73, err := m.UserModificationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if m.TgwInfo != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TgwInfo.Size()))
		n74, err := m.TgwInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.LogsReceiverChoice != nil {
		nn75, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn75
	}
	if m.SiteState != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteState))
	}
	if len(m.VipParamsPerAz) > 0 {
		for _, msg := range m.VipParamsPerAz {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tunnels) > 0 {
		for _, msg := range m.Tunnels {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x3e
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogsStreamingDisabled != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogsStreamingDisabled.Size()))
		n76, err := m.LogsStreamingDisabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}
func (m *GetSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogReceiver != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogReceiver.Size()))
		n77, err := m.LogReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TGWAssignedASNType) Size() (n int) {
	var l int
	_ = l
	if m.TgwAsn != 0 {
		n += 1 + sovTypes(uint64(m.TgwAsn))
	}
	if m.VolterraSiteAsn != 0 {
		n += 1 + sovTypes(uint64(m.VolterraSiteAsn))
	}
	return n
}

func (m *ExistingTGWType) Size() (n int) {
	var l int
	_ = l
	l = len(m.TgwId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TgwAsn != 0 {
		n += 1 + sovTypes(uint64(m.TgwAsn))
	}
	if m.VolterraSiteAsn != 0 {
		n += 1 + sovTypes(uint64(m.VolterraSiteAsn))
	}
	return n
}

func (m *TGWParamsType) Size() (n int) {
	var l int
	_ = l
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	return n
}

func (m *TGWParamsType_SystemGenerated) Size() (n int) {
	var l int
	_ = l
	if m.SystemGenerated != nil {
		l = m.SystemGenerated.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TGWParamsType_UserAssigned) Size() (n int) {
	var l int
	_ = l
	if m.UserAssigned != nil {
		l = m.UserAssigned.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ServicesVPCType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AwsRegion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServiceVpcChoice != nil {
		n += m.ServiceVpcChoice.Size()
	}
	if m.TgwChoice != nil {
		n += m.TgwChoice.Size()
	}
	l = len(m.AwsCertifiedHw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InstanceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AzNodes) > 0 {
		for _, e := range m.AzNodes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.WorkerNodes != nil {
		n += m.WorkerNodes.Size()
	}
	if m.Deployment != nil {
		n += m.Deployment.Size()
	}
	if m.DiskSize != 0 {
		n += 2 + sovTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *ServicesVPCType_NewVpc) Size() (n int) {
	var l int
	_ = l
	if m.NewVpc != nil {
		l = m.NewVpc.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ServicesVPCType_VpcId) Size() (n int) {
	var l int
	_ = l
	l = len(m.VpcId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ServicesVPCType_NewTgw) Size() (n int) {
	var l int
	_ = l
	if m.NewTgw != nil {
		l = m.NewTgw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ServicesVPCType_ExistingTgw) Size() (n int) {
	var l int
	_ = l
	if m.ExistingTgw != nil {
		l = m.ExistingTgw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ServicesVPCType_NodesPerAz) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.NodesPerAz))
	return n
}
func (m *ServicesVPCType_AwsCred) Size() (n int) {
	var l int
	_ = l
	if m.AwsCred != nil {
		l = m.AwsCred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ServicesVPCType_Assisted) Size() (n int) {
	var l int
	_ = l
	if m.Assisted != nil {
		l = m.Assisted.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ServicesVPCType_TotalNodes) Size() (n int) {
	var l int
	_ = l
	n += 2 + sovTypes(uint64(m.TotalNodes))
	return n
}
func (m *ServicesVPCType_NoWorkerNodes) Size() (n int) {
	var l int
	_ = l
	if m.NoWorkerNodes != nil {
		l = m.NoWorkerNodes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VnConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.InsideStaticRouteChoice != nil {
		n += m.InsideStaticRouteChoice.Size()
	}
	if m.OutsideStaticRouteChoice != nil {
		n += m.OutsideStaticRouteChoice.Size()
	}
	if m.GlobalNetworkChoice != nil {
		n += m.GlobalNetworkChoice.Size()
	}
	if m.AllowedVipPort != nil {
		l = m.AllowedVipPort.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VnConfiguration_NoInsideStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.NoInsideStaticRoutes != nil {
		l = m.NoInsideStaticRoutes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VnConfiguration_InsideStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.InsideStaticRoutes != nil {
		l = m.InsideStaticRoutes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VnConfiguration_NoOutsideStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.NoOutsideStaticRoutes != nil {
		l = m.NoOutsideStaticRoutes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VnConfiguration_OutsideStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.OutsideStaticRoutes != nil {
		l = m.OutsideStaticRoutes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VnConfiguration_NoGlobalNetwork) Size() (n int) {
	var l int
	_ = l
	if m.NoGlobalNetwork != nil {
		l = m.NoGlobalNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VnConfiguration_GlobalNetworkList) Size() (n int) {
	var l int
	_ = l
	if m.GlobalNetworkList != nil {
		l = m.GlobalNetworkList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VPCAttachmentType) Size() (n int) {
	var l int
	_ = l
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VPCIpPrefixesType) Size() (n int) {
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for _, s := range m.Prefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VPCAttachmentListType) Size() (n int) {
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for _, e := range m.VpcList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ActiveServicePoliciesType) Size() (n int) {
	var l int
	_ = l
	if len(m.ServicePolicies) > 0 {
		for _, e := range m.ServicePolicies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SecurityConfigType) Size() (n int) {
	var l int
	_ = l
	if m.ForwardProxyChoice != nil {
		n += m.ForwardProxyChoice.Size()
	}
	if m.NetworkPolicyChoice != nil {
		n += m.NetworkPolicyChoice.Size()
	}
	if m.EastWestServicePolicyChoice != nil {
		n += m.EastWestServicePolicyChoice.Size()
	}
	return n
}

func (m *SecurityConfigType_NoForwardProxy) Size() (n int) {
	var l int
	_ = l
	if m.NoForwardProxy != nil {
		l = m.NoForwardProxy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecurityConfigType_ActiveForwardProxyPolicies) Size() (n int) {
	var l int
	_ = l
	if m.ActiveForwardProxyPolicies != nil {
		l = m.ActiveForwardProxyPolicies.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecurityConfigType_NoNetworkPolicy) Size() (n int) {
	var l int
	_ = l
	if m.NoNetworkPolicy != nil {
		l = m.NoNetworkPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecurityConfigType_ActiveNetworkPolicies) Size() (n int) {
	var l int
	_ = l
	if m.ActiveNetworkPolicies != nil {
		l = m.ActiveNetworkPolicies.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecurityConfigType_ForwardProxyAllowAll) Size() (n int) {
	var l int
	_ = l
	if m.ForwardProxyAllowAll != nil {
		l = m.ForwardProxyAllowAll.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecurityConfigType_NoEastWestPolicy) Size() (n int) {
	var l int
	_ = l
	if m.NoEastWestPolicy != nil {
		l = m.NoEastWestPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecurityConfigType_ActiveEastWestServicePolicies) Size() (n int) {
	var l int
	_ = l
	if m.ActiveEastWestServicePolicies != nil {
		l = m.ActiveEastWestServicePolicies.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecurityConfigType_EastWestServicePolicyAllowAll) Size() (n int) {
	var l int
	_ = l
	if m.EastWestServicePolicyAllowAll != nil {
		l = m.EastWestServicePolicyAllowAll.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPNTunnelConfigType) Size() (n int) {
	var l int
	_ = l
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.TunnelRemoteIp) > 0 {
		for _, s := range m.TunnelRemoteIp {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AWSTGWInfoConfigType) Size() (n int) {
	var l int
	_ = l
	l = len(m.TgwId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.AwsParameters != nil {
		l = m.AwsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TgwSecurity != nil {
		l = m.TgwSecurity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.VpcIpPrefixes) > 0 {
		for k, v := range m.VpcIpPrefixes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.VnConfig != nil {
		l = m.VnConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UserModificationTimestamp != nil {
		l = m.UserModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TgwInfo != nil {
		l = m.TgwInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.Sw != nil {
		l = m.Sw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.VipParamsPerAz) > 0 {
		for _, e := range m.VipParamsPerAz {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Tunnels) > 0 {
		for _, e := range m.Tunnels {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.TfParams != nil {
		l = m.TfParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_LogsStreamingDisabled) Size() (n int) {
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LogReceiver) Size() (n int) {
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.AwsParameters != nil {
		l = m.AwsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TgwSecurity != nil {
		l = m.TgwSecurity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VnConfig != nil {
		l = m.VnConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.Sw != nil {
		l = m.Sw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_LogsStreamingDisabled) Size() (n int) {
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_LogReceiver) Size() (n int) {
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TgwSecurity != nil {
		l = m.TgwSecurity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VnConfig != nil {
		l = m.VnConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_LogsStreamingDisabled) Size() (n int) {
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LogReceiver) Size() (n int) {
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.AwsParameters != nil {
		l = m.AwsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TgwSecurity != nil {
		l = m.TgwSecurity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.VpcIpPrefixes) > 0 {
		for k, v := range m.VpcIpPrefixes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.VnConfig != nil {
		l = m.VnConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UserModificationTimestamp != nil {
		l = m.UserModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TgwInfo != nil {
		l = m.TgwInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.SiteState != 0 {
		n += 1 + sovTypes(uint64(m.SiteState))
	}
	if len(m.VipParamsPerAz) > 0 {
		for _, e := range m.VipParamsPerAz {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Tunnels) > 0 {
		for _, e := range m.Tunnels {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_LogsStreamingDisabled) Size() (n int) {
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LogReceiver) Size() (n int) {
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TGWAssignedASNType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TGWAssignedASNType{`,
		`TgwAsn:` + fmt.Sprintf("%v", this.TgwAsn) + `,`,
		`VolterraSiteAsn:` + fmt.Sprintf("%v", this.VolterraSiteAsn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExistingTGWType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExistingTGWType{`,
		`TgwId:` + fmt.Sprintf("%v", this.TgwId) + `,`,
		`TgwAsn:` + fmt.Sprintf("%v", this.TgwAsn) + `,`,
		`VolterraSiteAsn:` + fmt.Sprintf("%v", this.VolterraSiteAsn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TGWParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TGWParamsType{`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TGWParamsType_SystemGenerated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TGWParamsType_SystemGenerated{`,
		`SystemGenerated:` + strings.Replace(fmt.Sprintf("%v", this.SystemGenerated), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TGWParamsType_UserAssigned) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TGWParamsType_UserAssigned{`,
		`UserAssigned:` + strings.Replace(fmt.Sprintf("%v", this.UserAssigned), "TGWAssignedASNType", "TGWAssignedASNType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType{`,
		`AwsRegion:` + fmt.Sprintf("%v", this.AwsRegion) + `,`,
		`ServiceVpcChoice:` + fmt.Sprintf("%v", this.ServiceVpcChoice) + `,`,
		`TgwChoice:` + fmt.Sprintf("%v", this.TgwChoice) + `,`,
		`AwsCertifiedHw:` + fmt.Sprintf("%v", this.AwsCertifiedHw) + `,`,
		`InstanceType:` + fmt.Sprintf("%v", this.InstanceType) + `,`,
		`SshKey:` + fmt.Sprintf("%v", this.SshKey) + `,`,
		`AzNodes:` + strings.Replace(fmt.Sprintf("%v", this.AzNodes), "AWSVPCTwoInterfaceNodeType", "ves_io_schema_views1.AWSVPCTwoInterfaceNodeType", 1) + `,`,
		`WorkerNodes:` + fmt.Sprintf("%v", this.WorkerNodes) + `,`,
		`Deployment:` + fmt.Sprintf("%v", this.Deployment) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType_NewVpc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType_NewVpc{`,
		`NewVpc:` + strings.Replace(fmt.Sprintf("%v", this.NewVpc), "AWSVPCParamsType", "ves_io_schema_views1.AWSVPCParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType_VpcId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType_VpcId{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType_NewTgw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType_NewTgw{`,
		`NewTgw:` + strings.Replace(fmt.Sprintf("%v", this.NewTgw), "TGWParamsType", "TGWParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType_ExistingTgw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType_ExistingTgw{`,
		`ExistingTgw:` + strings.Replace(fmt.Sprintf("%v", this.ExistingTgw), "ExistingTGWType", "ExistingTGWType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType_NodesPerAz) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType_NodesPerAz{`,
		`NodesPerAz:` + fmt.Sprintf("%v", this.NodesPerAz) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType_AwsCred) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType_AwsCred{`,
		`AwsCred:` + strings.Replace(fmt.Sprintf("%v", this.AwsCred), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType_Assisted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType_Assisted{`,
		`Assisted:` + strings.Replace(fmt.Sprintf("%v", this.Assisted), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType_TotalNodes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType_TotalNodes{`,
		`TotalNodes:` + fmt.Sprintf("%v", this.TotalNodes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicesVPCType_NoWorkerNodes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicesVPCType_NoWorkerNodes{`,
		`NoWorkerNodes:` + strings.Replace(fmt.Sprintf("%v", this.NoWorkerNodes), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VnConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VnConfiguration{`,
		`InsideStaticRouteChoice:` + fmt.Sprintf("%v", this.InsideStaticRouteChoice) + `,`,
		`OutsideStaticRouteChoice:` + fmt.Sprintf("%v", this.OutsideStaticRouteChoice) + `,`,
		`GlobalNetworkChoice:` + fmt.Sprintf("%v", this.GlobalNetworkChoice) + `,`,
		`AllowedVipPort:` + strings.Replace(fmt.Sprintf("%v", this.AllowedVipPort), "AllowedVIPPorts", "ves_io_schema_views1.AllowedVIPPorts", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VnConfiguration_NoInsideStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VnConfiguration_NoInsideStaticRoutes{`,
		`NoInsideStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoInsideStaticRoutes), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VnConfiguration_InsideStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VnConfiguration_InsideStaticRoutes{`,
		`InsideStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.InsideStaticRoutes), "SiteStaticRoutesListType", "ves_io_schema_views1.SiteStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VnConfiguration_NoOutsideStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VnConfiguration_NoOutsideStaticRoutes{`,
		`NoOutsideStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoOutsideStaticRoutes), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VnConfiguration_OutsideStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VnConfiguration_OutsideStaticRoutes{`,
		`OutsideStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.OutsideStaticRoutes), "SiteStaticRoutesListType", "ves_io_schema_views1.SiteStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VnConfiguration_NoGlobalNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VnConfiguration_NoGlobalNetwork{`,
		`NoGlobalNetwork:` + strings.Replace(fmt.Sprintf("%v", this.NoGlobalNetwork), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VnConfiguration_GlobalNetworkList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VnConfiguration_GlobalNetworkList{`,
		`GlobalNetworkList:` + strings.Replace(fmt.Sprintf("%v", this.GlobalNetworkList), "GlobalNetworkConnectionListType", "ves_io_schema_views1.GlobalNetworkConnectionListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VPCAttachmentType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&VPCAttachmentType{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *VPCIpPrefixesType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VPCIpPrefixesType{`,
		`Prefixes:` + fmt.Sprintf("%v", this.Prefixes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VPCAttachmentListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VPCAttachmentListType{`,
		`VpcList:` + strings.Replace(fmt.Sprintf("%v", this.VpcList), "VPCAttachmentType", "VPCAttachmentType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActiveServicePoliciesType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActiveServicePoliciesType{`,
		`ServicePolicies:` + strings.Replace(fmt.Sprintf("%v", this.ServicePolicies), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityConfigType{`,
		`ForwardProxyChoice:` + fmt.Sprintf("%v", this.ForwardProxyChoice) + `,`,
		`NetworkPolicyChoice:` + fmt.Sprintf("%v", this.NetworkPolicyChoice) + `,`,
		`EastWestServicePolicyChoice:` + fmt.Sprintf("%v", this.EastWestServicePolicyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityConfigType_NoForwardProxy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityConfigType_NoForwardProxy{`,
		`NoForwardProxy:` + strings.Replace(fmt.Sprintf("%v", this.NoForwardProxy), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityConfigType_ActiveForwardProxyPolicies) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityConfigType_ActiveForwardProxyPolicies{`,
		`ActiveForwardProxyPolicies:` + strings.Replace(fmt.Sprintf("%v", this.ActiveForwardProxyPolicies), "ActiveForwardProxyPoliciesType", "ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityConfigType_NoNetworkPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityConfigType_NoNetworkPolicy{`,
		`NoNetworkPolicy:` + strings.Replace(fmt.Sprintf("%v", this.NoNetworkPolicy), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityConfigType_ActiveNetworkPolicies) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityConfigType_ActiveNetworkPolicies{`,
		`ActiveNetworkPolicies:` + strings.Replace(fmt.Sprintf("%v", this.ActiveNetworkPolicies), "ActiveNetworkPoliciesType", "ves_io_schema_network_firewall.ActiveNetworkPoliciesType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityConfigType_ForwardProxyAllowAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityConfigType_ForwardProxyAllowAll{`,
		`ForwardProxyAllowAll:` + strings.Replace(fmt.Sprintf("%v", this.ForwardProxyAllowAll), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityConfigType_NoEastWestPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityConfigType_NoEastWestPolicy{`,
		`NoEastWestPolicy:` + strings.Replace(fmt.Sprintf("%v", this.NoEastWestPolicy), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityConfigType_ActiveEastWestServicePolicies) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityConfigType_ActiveEastWestServicePolicies{`,
		`ActiveEastWestServicePolicies:` + strings.Replace(fmt.Sprintf("%v", this.ActiveEastWestServicePolicies), "ActiveServicePoliciesType", "ActiveServicePoliciesType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityConfigType_EastWestServicePolicyAllowAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityConfigType_EastWestServicePolicyAllowAll{`,
		`EastWestServicePolicyAllowAll:` + strings.Replace(fmt.Sprintf("%v", this.EastWestServicePolicyAllowAll), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPNTunnelConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPNTunnelConfigType{`,
		`NodeName:` + fmt.Sprintf("%v", this.NodeName) + `,`,
		`TunnelRemoteIp:` + fmt.Sprintf("%v", this.TunnelRemoteIp) + `,`,
		`NodeId:` + fmt.Sprintf("%v", this.NodeId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWInfoConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSTGWInfoConfigType{`,
		`TgwId:` + fmt.Sprintf("%v", this.TgwId) + `,`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	keysForVpcIpPrefixes := make([]string, 0, len(this.VpcIpPrefixes))
	for k, _ := range this.VpcIpPrefixes {
		keysForVpcIpPrefixes = append(keysForVpcIpPrefixes, k)
	}
	sortkeys.Strings(keysForVpcIpPrefixes)
	mapStringForVpcIpPrefixes := "map[string]*VPCIpPrefixesType{"
	for _, k := range keysForVpcIpPrefixes {
		mapStringForVpcIpPrefixes += fmt.Sprintf("%v: %v,", k, this.VpcIpPrefixes[k])
	}
	mapStringForVpcIpPrefixes += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`AwsParameters:` + strings.Replace(fmt.Sprintf("%v", this.AwsParameters), "ServicesVPCType", "ServicesVPCType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(fmt.Sprintf("%v", this.VpcAttachments), "VPCAttachmentListType", "VPCAttachmentListType", 1) + `,`,
		`TgwSecurity:` + strings.Replace(fmt.Sprintf("%v", this.TgwSecurity), "SecurityConfigType", "SecurityConfigType", 1) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`VpcIpPrefixes:` + mapStringForVpcIpPrefixes + `,`,
		`VnConfig:` + strings.Replace(fmt.Sprintf("%v", this.VnConfig), "VnConfiguration", "VnConfiguration", 1) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "ves_io_schema_site.Coordinates", 1) + `,`,
		`UserModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.UserModificationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`TgwInfo:` + strings.Replace(fmt.Sprintf("%v", this.TgwInfo), "AWSTGWInfoConfigType", "AWSTGWInfoConfigType", 1) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`Sw:` + strings.Replace(fmt.Sprintf("%v", this.Sw), "VolterraSoftwareType", "ves_io_schema_views.VolterraSoftwareType", 1) + `,`,
		`Os:` + strings.Replace(fmt.Sprintf("%v", this.Os), "OperatingSystemType", "ves_io_schema_views.OperatingSystemType", 1) + `,`,
		`VipParamsPerAz:` + strings.Replace(fmt.Sprintf("%v", this.VipParamsPerAz), "PublishVIPParamsPerAz", "ves_io_schema_site.PublishVIPParamsPerAz", 1) + `,`,
		`Tunnels:` + strings.Replace(fmt.Sprintf("%v", this.Tunnels), "AWSVPNTunnelConfigType", "AWSVPNTunnelConfigType", 1) + `,`,
		`TfParams:` + strings.Replace(fmt.Sprintf("%v", this.TfParams), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`AwsParameters:` + strings.Replace(fmt.Sprintf("%v", this.AwsParameters), "ServicesVPCType", "ServicesVPCType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(fmt.Sprintf("%v", this.VpcAttachments), "VPCAttachmentListType", "VPCAttachmentListType", 1) + `,`,
		`TgwSecurity:` + strings.Replace(fmt.Sprintf("%v", this.TgwSecurity), "SecurityConfigType", "SecurityConfigType", 1) + `,`,
		`VnConfig:` + strings.Replace(fmt.Sprintf("%v", this.VnConfig), "VnConfiguration", "VnConfiguration", 1) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "ves_io_schema_site.Coordinates", 1) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`Sw:` + strings.Replace(fmt.Sprintf("%v", this.Sw), "VolterraSoftwareType", "ves_io_schema_views.VolterraSoftwareType", 1) + `,`,
		`Os:` + strings.Replace(fmt.Sprintf("%v", this.Os), "OperatingSystemType", "ves_io_schema_views.OperatingSystemType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`VpcAttachments:` + strings.Replace(fmt.Sprintf("%v", this.VpcAttachments), "VPCAttachmentListType", "VPCAttachmentListType", 1) + `,`,
		`TgwSecurity:` + strings.Replace(fmt.Sprintf("%v", this.TgwSecurity), "SecurityConfigType", "SecurityConfigType", 1) + `,`,
		`VnConfig:` + strings.Replace(fmt.Sprintf("%v", this.VnConfig), "VnConfiguration", "VnConfiguration", 1) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "ves_io_schema_site.Coordinates", 1) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	keysForVpcIpPrefixes := make([]string, 0, len(this.VpcIpPrefixes))
	for k, _ := range this.VpcIpPrefixes {
		keysForVpcIpPrefixes = append(keysForVpcIpPrefixes, k)
	}
	sortkeys.Strings(keysForVpcIpPrefixes)
	mapStringForVpcIpPrefixes := "map[string]*VPCIpPrefixesType{"
	for _, k := range keysForVpcIpPrefixes {
		mapStringForVpcIpPrefixes += fmt.Sprintf("%v: %v,", k, this.VpcIpPrefixes[k])
	}
	mapStringForVpcIpPrefixes += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`AwsParameters:` + strings.Replace(fmt.Sprintf("%v", this.AwsParameters), "ServicesVPCType", "ServicesVPCType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(fmt.Sprintf("%v", this.VpcAttachments), "VPCAttachmentListType", "VPCAttachmentListType", 1) + `,`,
		`TgwSecurity:` + strings.Replace(fmt.Sprintf("%v", this.TgwSecurity), "SecurityConfigType", "SecurityConfigType", 1) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`VpcIpPrefixes:` + mapStringForVpcIpPrefixes + `,`,
		`VnConfig:` + strings.Replace(fmt.Sprintf("%v", this.VnConfig), "VnConfiguration", "VnConfiguration", 1) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "ves_io_schema_site.Coordinates", 1) + `,`,
		`UserModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.UserModificationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`TgwInfo:` + strings.Replace(fmt.Sprintf("%v", this.TgwInfo), "AWSTGWInfoConfigType", "AWSTGWInfoConfigType", 1) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`SiteState:` + fmt.Sprintf("%v", this.SiteState) + `,`,
		`VipParamsPerAz:` + strings.Replace(fmt.Sprintf("%v", this.VipParamsPerAz), "PublishVIPParamsPerAz", "ves_io_schema_site.PublishVIPParamsPerAz", 1) + `,`,
		`Tunnels:` + strings.Replace(fmt.Sprintf("%v", this.Tunnels), "AWSVPNTunnelConfigType", "AWSVPNTunnelConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TGWAssignedASNType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGWAssignedASNType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGWAssignedASNType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAsn", wireType)
			}
			m.TgwAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TgwAsn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSiteAsn", wireType)
			}
			m.VolterraSiteAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSiteAsn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExistingTGWType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExistingTGWType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExistingTGWType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TgwId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAsn", wireType)
			}
			m.TgwAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TgwAsn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSiteAsn", wireType)
			}
			m.VolterraSiteAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSiteAsn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGWParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGWParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGWParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemGenerated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &TGWParamsType_SystemGenerated{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAssigned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TGWAssignedASNType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &TGWParamsType_UserAssigned{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServicesVPCType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServicesVPCType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServicesVPCType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views1.AWSVPCParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServiceVpcChoice = &ServicesVPCType_NewVpc{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceVpcChoice = &ServicesVPCType_VpcId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TGWParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TgwChoice = &ServicesVPCType_NewTgw{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingTgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExistingTGWType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TgwChoice = &ServicesVPCType_ExistingTgw{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsCertifiedHw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsCertifiedHw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzNodes = append(m.AzNodes, &ves_io_schema_views1.AWSVPCTwoInterfaceNodeType{})
			if err := m.AzNodes[len(m.AzNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodesPerAz", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WorkerNodes = &ServicesVPCType_NodesPerAz{v}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsCred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Deployment = &ServicesVPCType_AwsCred{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assisted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Deployment = &ServicesVPCType_Assisted{v}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNodes", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WorkerNodes = &ServicesVPCType_TotalNodes{v}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWorkerNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkerNodes = &ServicesVPCType_NoWorkerNodes{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoInsideStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InsideStaticRouteChoice = &VnConfiguration_NoInsideStaticRoutes{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views1.SiteStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InsideStaticRouteChoice = &VnConfiguration_InsideStaticRoutes{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoOutsideStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutsideStaticRouteChoice = &VnConfiguration_NoOutsideStaticRoutes{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views1.SiteStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutsideStaticRouteChoice = &VnConfiguration_OutsideStaticRoutes{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoGlobalNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GlobalNetworkChoice = &VnConfiguration_NoGlobalNetwork{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalNetworkList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views1.GlobalNetworkConnectionListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GlobalNetworkChoice = &VnConfiguration_GlobalNetworkList{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedVipPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowedVipPort == nil {
				m.AllowedVipPort = &ves_io_schema_views1.AllowedVIPPorts{}
			}
			if err := m.AllowedVipPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCAttachmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCAttachmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCAttachmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCIpPrefixesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCIpPrefixesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCIpPrefixesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCAttachmentListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCAttachmentListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCAttachmentListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcList = append(m.VpcList, &VPCAttachmentType{})
			if err := m.VpcList[len(m.VpcList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveServicePoliciesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveServicePoliciesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveServicePoliciesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicePolicies = append(m.ServicePolicies, &ves_io_schema_views.ObjectRefType{})
			if err := m.ServicePolicies[len(m.ServicePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoForwardProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ForwardProxyChoice = &SecurityConfigType_NoForwardProxy{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveForwardProxyPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ForwardProxyChoice = &SecurityConfigType_ActiveForwardProxyPolicies{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoNetworkPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPolicyChoice = &SecurityConfigType_NoNetworkPolicy{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveNetworkPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPolicyChoice = &SecurityConfigType_ActiveNetworkPolicies{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardProxyAllowAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ForwardProxyChoice = &SecurityConfigType_ForwardProxyAllowAll{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoEastWestPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EastWestServicePolicyChoice = &SecurityConfigType_NoEastWestPolicy{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveEastWestServicePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActiveServicePoliciesType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EastWestServicePolicyChoice = &SecurityConfigType_ActiveEastWestServicePolicies{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EastWestServicePolicyAllowAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EastWestServicePolicyChoice = &SecurityConfigType_EastWestServicePolicyAllowAll{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPNTunnelConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPNTunnelConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPNTunnelConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelRemoteIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TunnelRemoteIp = append(m.TunnelRemoteIp, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWInfoConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWInfoConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWInfoConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TgwId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AwsParameters == nil {
				m.AwsParameters = &ServicesVPCType{}
			}
			if err := m.AwsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &VPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TgwSecurity == nil {
				m.TgwSecurity = &SecurityConfigType{}
			}
			if err := m.TgwSecurity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcIpPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcIpPrefixes == nil {
				m.VpcIpPrefixes = make(map[string]*VPCIpPrefixesType)
			}
			var mapkey string
			var mapvalue *VPCIpPrefixesType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VPCIpPrefixesType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VpcIpPrefixes[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VnConfig == nil {
				m.VnConfig = &VnConfiguration{}
			}
			if err := m.VnConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &ves_io_schema_site.Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserModificationTimestamp == nil {
				m.UserModificationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.UserModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TgwInfo == nil {
				m.TgwInfo = &AWSTGWInfoConfigType{}
			}
			if err := m.TgwInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GlobalSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sw == nil {
				m.Sw = &ves_io_schema_views.VolterraSoftwareType{}
			}
			if err := m.Sw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &ves_io_schema_views.OperatingSystemType{}
			}
			if err := m.Os.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipParamsPerAz", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipParamsPerAz = append(m.VipParamsPerAz, &ves_io_schema_site.PublishVIPParamsPerAz{})
			if err := m.VipParamsPerAz[len(m.VipParamsPerAz)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 998:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tunnels = append(m.Tunnels, &AWSVPNTunnelConfigType{})
			if err := m.Tunnels[len(m.Tunnels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TfParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TfParams == nil {
				m.TfParams = &ves_io_schema_views.ObjectRefType{}
			}
			if err := m.TfParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &ves_io_schema_views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AwsParameters == nil {
				m.AwsParameters = &ServicesVPCType{}
			}
			if err := m.AwsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &VPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TgwSecurity == nil {
				m.TgwSecurity = &SecurityConfigType{}
			}
			if err := m.TgwSecurity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VnConfig == nil {
				m.VnConfig = &VnConfiguration{}
			}
			if err := m.VnConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &ves_io_schema_site.Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &CreateSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &CreateSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sw == nil {
				m.Sw = &ves_io_schema_views.VolterraSoftwareType{}
			}
			if err := m.Sw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &ves_io_schema_views.OperatingSystemType{}
			}
			if err := m.Os.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &VPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TgwSecurity == nil {
				m.TgwSecurity = &SecurityConfigType{}
			}
			if err := m.TgwSecurity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VnConfig == nil {
				m.VnConfig = &VnConfiguration{}
			}
			if err := m.VnConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &ves_io_schema_site.Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &ReplaceSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &ReplaceSpecType_LogReceiver{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AwsParameters == nil {
				m.AwsParameters = &ServicesVPCType{}
			}
			if err := m.AwsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &VPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TgwSecurity == nil {
				m.TgwSecurity = &SecurityConfigType{}
			}
			if err := m.TgwSecurity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcIpPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcIpPrefixes == nil {
				m.VpcIpPrefixes = make(map[string]*VPCIpPrefixesType)
			}
			var mapkey string
			var mapvalue *VPCIpPrefixesType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VPCIpPrefixesType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VpcIpPrefixes[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VnConfig == nil {
				m.VnConfig = &VnConfiguration{}
			}
			if err := m.VnConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &ves_io_schema_site.Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserModificationTimestamp == nil {
				m.UserModificationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.UserModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TgwInfo == nil {
				m.TgwInfo = &AWSTGWInfoConfigType{}
			}
			if err := m.TgwInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GetSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GetSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteState", wireType)
			}
			m.SiteState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteState |= (ves_io_schema_site.SiteState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipParamsPerAz", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipParamsPerAz = append(m.VipParamsPerAz, &ves_io_schema_site.PublishVIPParamsPerAz{})
			if err := m.VipParamsPerAz[len(m.VipParamsPerAz)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 998:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tunnels = append(m.Tunnels, &AWSVPNTunnelConfigType{})
			if err := m.Tunnels[len(m.Tunnels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/views/aws_tgw_site/types.proto", fileDescriptorTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/aws_tgw_site/types.proto", fileDescriptorTypes)
}

var fileDescriptorTypes = []byte{
	// 3614 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x4d, 0x6c, 0x1b, 0x49,
	0x76, 0x56, 0x91, 0x14, 0xd9, 0x7c, 0xfa, 0xa3, 0x5a, 0x94, 0x4d, 0xcb, 0x63, 0x9a, 0x4b, 0x78,
	0x32, 0xb2, 0x97, 0xa4, 0x4c, 0x4a, 0xb6, 0x65, 0x6f, 0xd6, 0x6b, 0x52, 0xe3, 0xe8, 0x27, 0x3b,
	0x1e, 0x6d, 0x4b, 0x23, 0x4d, 0x76, 0xb2, 0xd3, 0xdb, 0x6a, 0x16, 0xa9, 0x5e, 0x93, 0x5d, 0x8d,
	0xae, 0x22, 0x69, 0x39, 0x31, 0xe0, 0x24, 0x87, 0x04, 0xc6, 0x1e, 0x12, 0x23, 0xa7, 0x1c, 0x72,
	0x0c, 0x16, 0xbe, 0xe4, 0x92, 0x53, 0x68, 0x24, 0xce, 0x00, 0x1b, 0x0c, 0x72, 0x89, 0x0f, 0x7b,
	0x18, 0xcc, 0x69, 0x47, 0x0b, 0x24, 0x93, 0x0d, 0x02, 0xcc, 0x21, 0x87, 0x49, 0x02, 0xec, 0x04,
	0x55, 0xdd, 0x4d, 0x36, 0x29, 0xea, 0x67, 0x14, 0x03, 0xc1, 0x2c, 0xe6, 0x22, 0x74, 0x77, 0xbd,
	0xbf, 0x7a, 0xf5, 0xea, 0x7d, 0xef, 0x3d, 0x0a, 0x32, 0x4d, 0x4c, 0x73, 0x06, 0x99, 0xa3, 0xfa,
	0x2e, 0xae, 0x6b, 0x73, 0x4d, 0x03, 0xb7, 0xe8, 0x9c, 0xd6, 0xa2, 0x2a, 0xab, 0xb6, 0x54, 0x6a,
	0x30, 0x3c, 0xc7, 0xf6, 0x2c, 0x4c, 0x73, 0x96, 0x4d, 0x18, 0x91, 0x53, 0x0e, 0x75, 0xce, 0xa1,
	0xce, 0x09, 0xea, 0x9c, 0x9f, 0x7a, 0x26, 0x5b, 0x35, 0xd8, 0x6e, 0x63, 0x27, 0xa7, 0x93, 0xfa,
	0x5c, 0x95, 0x54, 0xc9, 0x9c, 0x60, 0xdc, 0x69, 0x54, 0xc4, 0x9b, 0x78, 0x11, 0x4f, 0x8e, 0xc0,
	0x99, 0x8b, 0x55, 0x42, 0xaa, 0x35, 0xdc, 0xa5, 0x62, 0x46, 0x1d, 0x53, 0xa6, 0xd5, 0x2d, 0x97,
	0xe0, 0x4a, 0xaf, 0x7d, 0x26, 0x66, 0x2d, 0x62, 0xdf, 0x57, 0x2b, 0x86, 0x8d, 0x5b, 0x5a, 0xad,
	0xe6, 0xb7, 0x6e, 0xe6, 0x7c, 0x2f, 0x2d, 0xb1, 0x98, 0x41, 0x4c, 0x6f, 0x31, 0xd9, 0xbb, 0xd8,
	0xbf, 0xb5, 0x99, 0x73, 0xbd, 0xeb, 0xfe, 0xa5, 0xd7, 0xfa, 0x7c, 0xa4, 0xd5, 0x8c, 0xb2, 0xc6,
	0xb0, 0xbb, 0x9a, 0x3a, 0xe8, 0x41, 0xb5, 0x57, 0xf5, 0xa5, 0x41, 0x3e, 0xe6, 0x06, 0xa8, 0x7e,
	0x2d, 0x17, 0x07, 0x51, 0xf9, 0x08, 0xd2, 0x2d, 0x90, 0x37, 0x97, 0xb7, 0x8b, 0x94, 0x1a, 0x55,
	0x13, 0x97, 0x8b, 0x1b, 0xf7, 0x36, 0xf7, 0x2c, 0x2c, 0xcf, 0x42, 0x84, 0x3b, 0x5f, 0xa3, 0x66,
	0x02, 0xa5, 0xd0, 0xec, 0x58, 0x69, 0xe2, 0x6f, 0xff, 0xed, 0x45, 0x10, 0xae, 0x48, 0x89, 0x5f,
	0x7d, 0x11, 0x4c, 0x3d, 0xfe, 0x3c, 0xa8, 0x84, 0x59, 0xb5, 0x55, 0xa4, 0xa6, 0x7c, 0x03, 0x26,
	0x9b, 0xa4, 0xc6, 0xb0, 0x6d, 0x6b, 0xe2, 0xac, 0x04, 0x4f, 0x40, 0xf0, 0x8c, 0x70, 0x9e, 0xf0,
	0x95, 0x50, 0xe2, 0x8b, 0x2f, 0x82, 0xca, 0x84, 0x47, 0xb5, 0x61, 0x30, 0x5c, 0xa4, 0x66, 0xfa,
	0x1f, 0x10, 0x4c, 0xdc, 0x7d, 0x60, 0x50, 0x66, 0x98, 0xd5, 0xcd, 0xe5, 0x6d, 0xa1, 0xf6, 0x6d,
	0xe0, 0x62, 0x55, 0xa3, 0x2c, 0xb4, 0x46, 0x4b, 0x8b, 0x9f, 0xb7, 0xd1, 0x10, 0x97, 0x12, 0xb2,
	0x03, 0x89, 0x3b, 0xfc, 0xe1, 0x37, 0xec, 0x4b, 0x85, 0xf4, 0xfb, 0xb3, 0xac, 0xda, 0xca, 0x5e,
	0x9e, 0x7d, 0x4f, 0xcb, 0x3e, 0xbc, 0x9a, 0xbd, 0xf9, 0x83, 0xdf, 0x5b, 0x7c, 0xf4, 0xfb, 0x9d,
	0xe7, 0xfc, 0x8d, 0x47, 0x97, 0x2f, 0x29, 0xc3, 0xac, 0xda, 0x5a, 0x2d, 0xcb, 0x97, 0xba, 0xfb,
	0x18, 0x60, 0xd3, 0x91, 0x7b, 0x08, 0x9e, 0x60, 0x0f, 0x3f, 0x43, 0x30, 0xb6, 0xb9, 0xbc, 0xbd,
	0xae, 0xd9, 0x5a, 0x9d, 0x8a, 0x1d, 0x14, 0x21, 0x46, 0xf7, 0x28, 0xc3, 0x75, 0xb5, 0x8a, 0x4d,
	0x6c, 0x6b, 0x0c, 0x97, 0x85, 0xe6, 0x91, 0x42, 0x3c, 0xd7, 0x1b, 0xe6, 0x77, 0xeb, 0x16, 0xdb,
	0x5b, 0x19, 0x52, 0x26, 0x1c, 0xfa, 0x65, 0x8f, 0x5c, 0x7e, 0x0f, 0xc6, 0x1a, 0x14, 0xdb, 0xaa,
	0xe6, 0x9e, 0x89, 0xb0, 0x64, 0xa4, 0xb0, 0x90, 0x3b, 0xee, 0x9a, 0xe4, 0x0e, 0x1e, 0xe4, 0xca,
	0x90, 0x32, 0xca, 0x85, 0x79, 0x9f, 0x4b, 0x17, 0x00, 0x34, 0x6a, 0xaa, 0xfa, 0x2e, 0x31, 0x74,
	0x2c, 0x4f, 0xbc, 0x68, 0xa3, 0xc0, 0xcb, 0x36, 0x42, 0xfb, 0x6d, 0x14, 0x2c, 0x64, 0xe6, 0xd7,
	0x42, 0x12, 0x8a, 0x05, 0xd2, 0x7f, 0x30, 0x0e, 0x13, 0x1b, 0xd8, 0x6e, 0x1a, 0x3a, 0xa6, 0x5b,
	0xeb, 0x4b, 0x62, 0x63, 0x3f, 0x09, 0x00, 0x70, 0x65, 0x36, 0xae, 0x1a, 0xc4, 0x74, 0xcf, 0xe7,
	0x4f, 0x02, 0xde, 0x01, 0xfd, 0x0a, 0xd9, 0xff, 0x83, 0x94, 0x71, 0xcd, 0xca, 0x9a, 0xc4, 0x66,
	0xbb, 0x58, 0xa3, 0x2c, 0x9b, 0x17, 0xef, 0x94, 0x34, 0x3a, 0xef, 0xa3, 0xb8, 0x91, 0xd5, 0xb1,
	0xc9, 0x6c, 0xad, 0x96, 0xcd, 0x2b, 0x51, 0xdc, 0xc8, 0xb6, 0xb0, 0x58, 0xe8, 0x3c, 0xce, 0x2b,
	0x51, 0xaa, 0x65, 0x5d, 0xf2, 0x68, 0x83, 0x1e, 0x78, 0x2c, 0x88, 0x47, 0x41, 0x5b, 0x50, 0x46,
	0x75, 0xcd, 0x27, 0x0f, 0xb4, 0x8a, 0xa3, 0x8d, 0xd3, 0x6b, 0x96, 0xc7, 0x0a, 0x9e, 0x11, 0xae,
	0x41, 0x5d, 0x03, 0x0b, 0x7d, 0x06, 0x16, 0x14, 0xc0, 0x8d, 0x0e, 0x2d, 0x7f, 0x16, 0xb4, 0x7e,
	0xfb, 0x0a, 0x0a, 0xd4, 0x71, 0x57, 0x8b, 0x67, 0x0a, 0x57, 0xd8, 0xa2, 0x8a, 0xf0, 0x8d, 0x7c,
	0x07, 0x22, 0x26, 0x6e, 0xa9, 0x4d, 0x4b, 0x77, 0x8f, 0xee, 0xf5, 0x81, 0x47, 0x57, 0xdc, 0xde,
	0xd8, 0x5a, 0x5f, 0xea, 0xc6, 0xce, 0xca, 0x90, 0x12, 0x36, 0x71, 0x6b, 0xcb, 0xd2, 0xe5, 0xef,
	0x41, 0xb8, 0x69, 0xe9, 0xfc, 0x1e, 0x84, 0x8e, 0xbe, 0x07, 0x4d, 0x4b, 0x3f, 0xf2, 0x1e, 0xac,
	0x0c, 0x29, 0xc3, 0x4d, 0x4b, 0x5f, 0x2d, 0xcb, 0x6b, 0x8e, 0x51, 0xac, 0xda, 0x4a, 0x84, 0x85,
	0x51, 0x73, 0x27, 0x8a, 0x27, 0x9f, 0x79, 0x48, 0x98, 0xb7, 0x59, 0x6d, 0xc9, 0x5b, 0x30, 0x8a,
	0xdd, 0x9b, 0x2b, 0x04, 0x46, 0x84, 0xc0, 0xfc, 0xf1, 0x02, 0xfb, 0xee, 0xfb, 0x0a, 0x52, 0x46,
	0x3c, 0x41, 0x5c, 0x2e, 0x85, 0x18, 0x27, 0xd7, 0xb1, 0xcd, 0x8c, 0x8a, 0x81, 0xcb, 0xea, 0x6e,
	0x2b, 0x21, 0x09, 0x07, 0xac, 0x7e, 0xdc, 0x46, 0xe7, 0xb5, 0x16, 0xcd, 0xee, 0xec, 0x91, 0x5a,
	0xb6, 0xde, 0xa8, 0x31, 0x23, 0x6b, 0x1a, 0x7a, 0x96, 0x5f, 0xc8, 0x3a, 0xa6, 0xbb, 0x9e, 0x7f,
	0xbe, 0x61, 0x5f, 0x4c, 0xdc, 0x51, 0x8e, 0xa2, 0x54, 0xc6, 0xb5, 0x16, 0x5d, 0xf2, 0x34, 0xac,
	0xb4, 0xe4, 0x7f, 0x47, 0x30, 0x66, 0x98, 0x94, 0x69, 0xa6, 0xee, 0xa4, 0xce, 0x44, 0x54, 0xa8,
	0xfc, 0x29, 0xfa, 0xb8, 0x8d, 0xa2, 0x6c, 0x3e, 0xf7, 0xa0, 0xa6, 0xd9, 0x55, 0xcc, 0x35, 0x3c,
	0x7d, 0x8e, 0xfe, 0x0a, 0xc1, 0x02, 0x74, 0xbf, 0xca, 0x6f, 0xcc, 0x2e, 0xa4, 0x1e, 0xa4, 0x9a,
	0x4b, 0xeb, 0xef, 0x64, 0x52, 0xf9, 0xeb, 0xcb, 0xa5, 0x94, 0x52, 0x7c, 0xeb, 0x72, 0xaa, 0x8e,
	0xcb, 0x46, 0xa3, 0x9e, 0xb2, 0xb0, 0x5d, 0x21, 0x76, 0x9d, 0x4b, 0x86, 0x79, 0x00, 0x36, 0x9f,
	0x2b, 0xb8, 0x6c, 0xaf, 0xcf, 0x2e, 0x76, 0xd8, 0xe6, 0x0b, 0x1e, 0xdb, 0xae, 0x51, 0xdd, 0xed,
	0x61, 0xba, 0x09, 0x50, 0xbf, 0x96, 0x5b, 0x70, 0x99, 0xbe, 0x39, 0x9b, 0xbf, 0xde, 0xe1, 0xba,
	0xbe, 0xe0, 0x71, 0x35, 0xb1, 0xbd, 0x77, 0x80, 0xb5, 0x13, 0x2c, 0xca, 0xa8, 0xb7, 0x39, 0x71,
	0x8d, 0xdf, 0x80, 0x08, 0xa5, 0xbb, 0xea, 0x7d, 0xbc, 0x97, 0x00, 0xb1, 0xcd, 0xf1, 0xcf, 0xdb,
	0x28, 0xc8, 0xa9, 0x87, 0xed, 0x60, 0xe2, 0xf1, 0x1d, 0x25, 0x4c, 0xe9, 0xee, 0x6f, 0xe3, 0x3d,
	0xf9, 0x77, 0x40, 0xd2, 0x1e, 0xaa, 0x26, 0x29, 0x63, 0x9a, 0x18, 0x49, 0x05, 0x0f, 0x0d, 0x18,
	0x27, 0x8a, 0x37, 0x5b, 0x64, 0xd5, 0x64, 0xd8, 0xae, 0x68, 0x3a, 0xbe, 0x47, 0xca, 0x42, 0x57,
	0x69, 0x8c, 0x8b, 0x95, 0x9e, 0xa2, 0xe1, 0x2b, 0xc1, 0x7c, 0x66, 0x5e, 0x89, 0x68, 0x0f, 0xf9,
	0x12, 0x95, 0xaf, 0xc3, 0xa8, 0x90, 0xab, 0x5a, 0x3c, 0xcb, 0x3d, 0x4c, 0x8c, 0x8a, 0x4c, 0x2b,
	0x7f, 0xdc, 0x46, 0xe8, 0x6a, 0x27, 0xd0, 0xaf, 0x04, 0x12, 0xd3, 0x2b, 0x01, 0x05, 0x04, 0xe5,
	0x3a, 0xb6, 0x8b, 0x0f, 0xe5, 0x77, 0x40, 0x12, 0xe1, 0x61, 0xe3, 0x72, 0x62, 0x5c, 0x84, 0x5c,
	0x7a, 0xa0, 0x49, 0x6f, 0xef, 0xfc, 0x08, 0xeb, 0x4c, 0xc1, 0x15, 0x61, 0x45, 0xfc, 0xd9, 0xa3,
	0x49, 0xbd, 0x46, 0x1a, 0x65, 0xc1, 0x88, 0x4d, 0x66, 0x68, 0x35, 0xba, 0x12, 0x54, 0x22, 0x3c,
	0x0e, 0x6c, 0x5c, 0x96, 0x0b, 0x20, 0xf1, 0x54, 0x4b, 0x79, 0xaa, 0x9e, 0x38, 0x22, 0x55, 0x07,
	0x95, 0x0e, 0x9d, 0x7c, 0x15, 0xa2, 0x65, 0x83, 0xde, 0x57, 0xa9, 0xf1, 0x10, 0x27, 0xce, 0x08,
	0xfb, 0xa7, 0x5e, 0xb4, 0x11, 0xf2, 0xcc, 0xe7, 0x88, 0xf1, 0xf8, 0x3f, 0x83, 0x8a, 0xc4, 0xa9,
	0x36, 0x8c, 0x87, 0x58, 0xbe, 0x06, 0x23, 0x8c, 0x30, 0xad, 0xe6, 0xba, 0xf4, 0xfc, 0x21, 0x7b,
	0xfe, 0x36, 0xdf, 0xb3, 0x20, 0x74, 0x7c, 0x75, 0x1b, 0x26, 0x4c, 0xa2, 0xf2, 0xea, 0x04, 0xdb,
	0x2e, 0xeb, 0x6b, 0x47, 0xd8, 0x18, 0x50, 0xc6, 0x4c, 0xb2, 0x2d, 0xa8, 0x05, 0xff, 0xad, 0x1f,
	0x7d, 0xd0, 0x46, 0x15, 0x98, 0x82, 0x51, 0x2f, 0x9f, 0xa7, 0xb6, 0xd6, 0x97, 0xe4, 0x60, 0x3e,
	0x53, 0x80, 0x38, 0x4c, 0x6c, 0xda, 0x9a, 0x49, 0x0d, 0x96, 0x5a, 0xd6, 0x18, 0x6e, 0x69, 0x7b,
	0x32, 0xba, 0x06, 0x6f, 0x40, 0x9c, 0xa3, 0x5b, 0x8a, 0xb3, 0xa7, 0xc4, 0xed, 0xc7, 0x0c, 0xdb,
	0x54, 0x9e, 0x58, 0xcc, 0xdc, 0xcc, 0xe4, 0xaf, 0x66, 0xf2, 0xf9, 0x4c, 0xa1, 0x90, 0x29, 0xdc,
	0x84, 0x18, 0xc0, 0x9b, 0xd8, 0xaa, 0x91, 0xbd, 0x3a, 0x36, 0x99, 0x1c, 0xc8, 0xcf, 0x97, 0x5e,
	0x07, 0x99, 0x3a, 0x5a, 0x78, 0xee, 0xf3, 0x63, 0x4c, 0xf0, 0x65, 0x1b, 0x05, 0x38, 0xc6, 0xcc,
	0x67, 0x16, 0x38, 0x04, 0xf1, 0x84, 0xe0, 0x5b, 0x0e, 0xbf, 0x6c, 0xa3, 0x61, 0xbe, 0x7c, 0x3d,
	0x73, 0xa3, 0x34, 0x0b, 0xa3, 0xfe, 0xed, 0xca, 0x89, 0x17, 0x6d, 0xf4, 0xda, 0x87, 0x6d, 0x84,
	0x5e, 0xb6, 0xd1, 0x85, 0xfd, 0x36, 0x92, 0xf2, 0x85, 0x4c, 0xe1, 0x46, 0xa6, 0xb0, 0x58, 0xba,
	0x08, 0x50, 0xee, 0x5a, 0x30, 0xf9, 0xa2, 0x8d, 0xc6, 0x5f, 0xb6, 0xd1, 0xd8, 0x7e, 0x1b, 0x0d,
	0xe7, 0x17, 0x32, 0xf9, 0x6b, 0x6b, 0x21, 0x29, 0x10, 0x0b, 0xae, 0x85, 0xa4, 0xe1, 0x58, 0x78,
	0x2d, 0x24, 0x5d, 0x88, 0x25, 0xd7, 0x42, 0xd2, 0x58, 0x6c, 0x7c, 0x2d, 0x24, 0xc5, 0x62, 0x93,
	0x6b, 0x21, 0x69, 0x32, 0x26, 0xaf, 0x85, 0x24, 0x39, 0x36, 0xb5, 0x16, 0x92, 0xa6, 0x62, 0xf1,
	0xb5, 0x90, 0x14, 0x8f, 0x4d, 0xaf, 0x85, 0xa4, 0xe9, 0xd8, 0x99, 0xf4, 0xdf, 0x85, 0x61, 0x62,
	0xcb, 0x5c, 0x22, 0x66, 0xc5, 0xa8, 0x36, 0x6c, 0x8d, 0x57, 0x5e, 0xf2, 0x06, 0x9c, 0x35, 0x89,
	0x6a, 0x98, 0xd4, 0x28, 0x63, 0x95, 0x32, 0x8d, 0x19, 0xba, 0x6a, 0x93, 0x06, 0xc3, 0xf4, 0x28,
	0x8c, 0x2f, 0x85, 0x78, 0x64, 0xac, 0x0c, 0x29, 0x71, 0x93, 0xac, 0x0a, 0xde, 0x0d, 0xc1, 0xaa,
	0x08, 0x4e, 0xb9, 0x0a, 0xf1, 0x81, 0x12, 0x1d, 0xe8, 0xc8, 0x0e, 0x8c, 0x70, 0x7e, 0x42, 0x7e,
	0x21, 0xdf, 0x35, 0x28, 0x13, 0xc1, 0xee, 0xa9, 0x92, 0x8d, 0x83, 0x8a, 0xde, 0x81, 0x84, 0x49,
	0x54, 0xd2, 0x60, 0x03, 0x94, 0x0d, 0x1f, 0x6b, 0x3e, 0x52, 0xa6, 0x4d, 0xf2, 0xb6, 0xc3, 0xdc,
	0x23, 0xd6, 0x80, 0xe9, 0xc1, 0x32, 0xc3, 0xa7, 0xdf, 0x00, 0x52, 0xa6, 0xc8, 0x00, 0x55, 0x25,
	0x98, 0x34, 0x89, 0x5a, 0xad, 0x91, 0x1d, 0x7e, 0x8f, 0x9c, 0xa2, 0x5d, 0x00, 0xc4, 0xe1, 0xd7,
	0x61, 0xc2, 0x24, 0xcb, 0x82, 0xfe, 0x9e, 0x43, 0x2e, 0x57, 0x60, 0xaa, 0x57, 0x80, 0x5a, 0x33,
	0x28, 0x13, 0x39, 0xff, 0xb0, 0x1a, 0xab, 0x47, 0xc0, 0x12, 0x31, 0x4d, 0xac, 0xf3, 0x70, 0xf0,
	0x6c, 0x5e, 0x09, 0x28, 0x93, 0x55, 0x3f, 0x09, 0x5f, 0x90, 0xdf, 0x85, 0x98, 0x56, 0xab, 0x91,
	0x16, 0x2e, 0xab, 0x4d, 0xc3, 0x52, 0x2d, 0x62, 0x33, 0x91, 0x71, 0x47, 0x0a, 0x97, 0x06, 0xe7,
	0x51, 0x87, 0x78, 0x6b, 0x75, 0x7d, 0x9d, 0xd8, 0x8c, 0x96, 0x24, 0xee, 0x88, 0x4f, 0xdb, 0x88,
	0x17, 0x55, 0xee, 0x92, 0x61, 0xf1, 0xa5, 0x52, 0x1e, 0x66, 0x06, 0x04, 0x8c, 0x77, 0x9f, 0x78,
	0x1a, 0x0a, 0xb8, 0xd7, 0xc5, 0x2b, 0xeb, 0x4a, 0x05, 0x38, 0x3f, 0xe8, 0x8c, 0xfc, 0x3c, 0xc3,
	0x2e, 0x4f, 0x88, 0xf3, 0x5c, 0xcb, 0x5c, 0x2f, 0x65, 0x60, 0xba, 0xcf, 0x51, 0x3e, 0x6a, 0xc9,
	0xa5, 0x8e, 0x70, 0xea, 0xc5, 0xcc, 0x4d, 0xa7, 0x70, 0x5c, 0x0b, 0x49, 0xa1, 0xd8, 0xf0, 0x5a,
	0x48, 0x8a, 0xc4, 0xa4, 0xf4, 0x8f, 0x03, 0x30, 0xb9, 0xb5, 0xbe, 0x54, 0x64, 0x4c, 0xd3, 0x77,
	0xf9, 0x0d, 0xf5, 0x2a, 0x7c, 0xb7, 0xb2, 0x41, 0xff, 0xb7, 0xca, 0xc6, 0xab, 0x6b, 0xee, 0x43,
	0xb8, 0xa6, 0xed, 0xe0, 0x1a, 0xbf, 0x82, 0x1c, 0xa5, 0xbe, 0x73, 0x7c, 0x15, 0x72, 0xc0, 0xaa,
	0xdc, 0x77, 0x85, 0x84, 0xbb, 0x26, 0xb3, 0xf7, 0x4a, 0xf2, 0x5f, 0x3c, 0x47, 0x41, 0x40, 0x68,
	0xff, 0xe7, 0x3f, 0x0d, 0x86, 0x9f, 0x3c, 0x47, 0x01, 0x69, 0x48, 0x71, 0x55, 0xcc, 0xdc, 0x84,
	0x11, 0x1f, 0xa9, 0x1c, 0x83, 0x20, 0x07, 0x52, 0xb1, 0x13, 0x85, 0x3f, 0xca, 0x71, 0x18, 0x6e,
	0x6a, 0xb5, 0x06, 0x16, 0xf9, 0x20, 0xaa, 0x38, 0x2f, 0xb7, 0x02, 0x8b, 0x28, 0xad, 0x0a, 0x6f,
	0xac, 0x5a, 0xeb, 0x36, 0xae, 0x18, 0x0f, 0xb0, 0xd3, 0x2d, 0xac, 0x81, 0x64, 0xb9, 0xef, 0x09,
	0x94, 0x0a, 0xce, 0x46, 0x4b, 0x39, 0xd1, 0x67, 0x3d, 0x45, 0x91, 0xf4, 0xb0, 0x1d, 0xfc, 0x1c,
	0x21, 0x01, 0x26, 0x4f, 0x51, 0x30, 0xf6, 0x58, 0x12, 0x20, 0xfd, 0x14, 0x05, 0x24, 0xe4, 0x3d,
	0x25, 0x90, 0xd2, 0xe1, 0x4f, 0xff, 0x39, 0x82, 0xe9, 0x9e, 0x9d, 0x79, 0xf1, 0x29, 0xbf, 0x07,
	0x12, 0xf7, 0xb9, 0x88, 0x73, 0x24, 0x9c, 0x34, 0x7f, 0x0a, 0x27, 0xb9, 0xad, 0x90, 0xb0, 0x05,
	0x29, 0x91, 0xa6, 0xa5, 0x73, 0x05, 0xb7, 0x92, 0x1f, 0xb4, 0xd1, 0x0c, 0x24, 0x60, 0xaa, 0xb8,
	0xbd, 0xc1, 0xb1, 0x25, 0xa5, 0x75, 0xb8, 0xa8, 0x8c, 0xf2, 0xe9, 0x3f, 0x43, 0x70, 0xae, 0xa8,
	0x33, 0xa3, 0x89, 0x5d, 0x04, 0x5a, 0x27, 0x35, 0x43, 0x37, 0x5c, 0x07, 0x30, 0x88, 0x79, 0x90,
	0x61, 0xb9, 0xdf, 0x5d, 0x13, 0x4f, 0x02, 0xed, 0xaf, 0x3f, 0x7b, 0x34, 0xde, 0xc3, 0xbe, 0xe7,
	0x79, 0x26, 0x96, 0xf2, 0xf9, 0x68, 0x82, 0xf6, 0x6a, 0x4e, 0xff, 0x47, 0x04, 0xe4, 0x0d, 0xac,
	0x37, 0x6c, 0x83, 0xed, 0x39, 0x19, 0x5e, 0x18, 0x73, 0x07, 0x62, 0x26, 0x51, 0x2b, 0xc4, 0x6e,
	0x69, 0x76, 0x59, 0xb5, 0x6c, 0xf2, 0x60, 0xef, 0x98, 0xde, 0x6d, 0xdc, 0x24, 0xbf, 0xe5, 0x90,
	0xaf, 0x73, 0x6a, 0xf9, 0x8f, 0x10, 0x5c, 0xd0, 0xc4, 0x66, 0x7b, 0xc5, 0x74, 0x37, 0xe7, 0x64,
	0xf5, 0xdb, 0x7d, 0xf2, 0xfa, 0x07, 0x10, 0x39, 0xc7, 0x63, 0x7e, 0xd9, 0x7e, 0xb7, 0xad, 0x0c,
	0x29, 0x33, 0xda, 0xa1, 0x14, 0x6e, 0x9a, 0xf4, 0x64, 0x3a, 0x8e, 0x39, 0x2a, 0xc3, 0x3b, 0x69,
	0xd2, 0x4d, 0x5e, 0x42, 0xca, 0x9e, 0x4c, 0xe1, 0xac, 0xbb, 0x91, 0x1e, 0x39, 0x46, 0x27, 0xaf,
	0xdf, 0x3c, 0xd9, 0x16, 0xfc, 0x52, 0x3d, 0xeb, 0x03, 0xca, 0xb4, 0x36, 0x68, 0x51, 0x7e, 0x0b,
	0xce, 0xf6, 0xba, 0x4d, 0x64, 0x3e, 0xfe, 0xd7, 0x6d, 0x31, 0x0e, 0x3b, 0x87, 0x78, 0xc5, 0xe7,
	0x07, 0x91, 0x49, 0x8b, 0xb5, 0x9a, 0x7c, 0x17, 0xa6, 0x4c, 0xa2, 0xf2, 0xce, 0x4e, 0xe5, 0x4d,
	0x9a, 0xe7, 0x89, 0xe8, 0x11, 0xa2, 0x90, 0x12, 0x33, 0xc9, 0x5d, 0x8d, 0xb2, 0x6d, 0x4c, 0x99,
	0xeb, 0x8a, 0x3f, 0x46, 0xf0, 0x0d, 0xd7, 0x17, 0x5d, 0x59, 0x07, 0xa2, 0xd6, 0xc9, 0xed, 0xdf,
	0x3a, 0xfe, 0x62, 0x1d, 0x7a, 0x19, 0x56, 0x90, 0xe2, 0x06, 0x8f, 0x67, 0x40, 0x1f, 0x91, 0xac,
	0x41, 0xfa, 0x10, 0x0b, 0xfc, 0xae, 0x1a, 0x39, 0x72, 0x7f, 0x17, 0xf0, 0x00, 0xe1, 0x1d, 0x9f,
	0xdd, 0x5a, 0xf8, 0xa0, 0x8d, 0xae, 0xc2, 0x39, 0x88, 0xbb, 0x91, 0x95, 0x12, 0x2e, 0x4d, 0xb9,
	0xae, 0x40, 0x79, 0x98, 0x82, 0x71, 0xf7, 0xd8, 0x3a, 0x1f, 0x17, 0x4a, 0x97, 0x21, 0xde, 0x7b,
	0x70, 0x2e, 0x54, 0x4c, 0xfa, 0xe6, 0x0b, 0xc3, 0x85, 0xcc, 0x8d, 0xcc, 0x7c, 0xe9, 0x3a, 0x5c,
	0x3c, 0x74, 0x0f, 0x3e, 0x80, 0x89, 0xbe, 0x6c, 0x23, 0x69, 0xbf, 0x8d, 0x22, 0x6e, 0xd1, 0x59,
	0x9a, 0x85, 0xe9, 0xde, 0x88, 0xf6, 0x17, 0x90, 0xc3, 0x3e, 0xe0, 0xea, 0x40, 0x91, 0x14, 0x8b,
	0x3a, 0x80, 0x94, 0x7e, 0x81, 0xe0, 0x8c, 0xe8, 0x53, 0xee, 0x6d, 0x36, 0x4c, 0x13, 0xd7, 0x7c,
	0x77, 0x7e, 0x16, 0xa2, 0xbc, 0xcc, 0x54, 0x4d, 0xad, 0x8e, 0x5d, 0x48, 0x72, 0xf2, 0x9c, 0x1d,
	0x8a, 0xa1, 0xc4, 0x1d, 0x45, 0xe2, 0xab, 0xf7, 0xb4, 0x3a, 0x96, 0xb7, 0x20, 0xc6, 0x04, 0xb7,
	0x6a, 0xe3, 0x3a, 0x61, 0x58, 0x35, 0x2c, 0x01, 0x39, 0xd1, 0x52, 0x86, 0x33, 0x44, 0x9f, 0xa2,
	0x70, 0x3a, 0x64, 0x07, 0x1e, 0x74, 0xb2, 0x73, 0x2c, 0x30, 0x30, 0x63, 0x8f, 0x3b, 0x52, 0x14,
	0x21, 0x64, 0xd5, 0x92, 0x2f, 0x41, 0x44, 0x58, 0x60, 0x38, 0x83, 0x9e, 0x3e, 0xfd, 0x61, 0xbe,
	0xb6, 0x5a, 0x4e, 0xff, 0x25, 0x82, 0x78, 0x71, 0x7b, 0x63, 0x73, 0x79, 0x7b, 0xd5, 0xac, 0x10,
	0xdf, 0x06, 0x4a, 0x7d, 0x23, 0xb3, 0x6f, 0x9e, 0x62, 0x4a, 0x56, 0xea, 0x80, 0x72, 0xe0, 0x80,
	0x8c, 0x13, 0xe2, 0x70, 0xfa, 0x9f, 0x27, 0x61, 0xdc, 0x29, 0x94, 0x36, 0x2c, 0xac, 0x0b, 0xd3,
	0xde, 0x07, 0xde, 0x6b, 0xab, 0x56, 0xa7, 0x89, 0x10, 0x26, 0x9e, 0x68, 0x50, 0xd0, 0x37, 0x7d,
	0x2a, 0x85, 0x78, 0x10, 0x29, 0x63, 0x5a, 0x8b, 0xfa, 0x5a, 0x92, 0x0a, 0x4c, 0x70, 0xb3, 0x7d,
	0x80, 0xe3, 0xa6, 0xeb, 0x1b, 0x5f, 0x12, 0xde, 0xba, 0xd5, 0xa7, 0x50, 0x33, 0xde, 0xb4, 0xf4,
	0xa2, 0x0f, 0xc5, 0x7e, 0x00, 0xa3, 0x82, 0xcf, 0x45, 0x8c, 0x93, 0xcf, 0xe3, 0x0e, 0x62, 0x8c,
	0xab, 0x61, 0x84, 0x55, 0x5b, 0xde, 0xa2, 0xbc, 0x0e, 0xe7, 0xba, 0xd3, 0x47, 0x52, 0x61, 0x2d,
	0xcd, 0xc6, 0x6a, 0x13, 0xdb, 0xd4, 0x20, 0xa6, 0x3b, 0xff, 0x89, 0x7f, 0xf4, 0x48, 0xd4, 0x82,
	0x3d, 0xc5, 0x92, 0x72, 0xb6, 0x33, 0x8e, 0x74, 0xb9, 0xb6, 0x1c, 0x26, 0xf9, 0x1e, 0x24, 0x88,
	0x85, 0x79, 0xd3, 0x62, 0x56, 0x55, 0x77, 0x1c, 0xe9, 0x09, 0x1c, 0x3e, 0x42, 0xe0, 0x99, 0x0e,
	0xd7, 0x86, 0x60, 0xf2, 0xe4, 0xfd, 0x4d, 0xc0, 0xf1, 0x34, 0xaf, 0x63, 0xbd, 0x72, 0x25, 0x2c,
	0x50, 0x7a, 0xe9, 0x78, 0x27, 0xf4, 0x06, 0x45, 0x6e, 0xcb, 0xd2, 0xbb, 0x45, 0x90, 0x53, 0x71,
	0xfd, 0x23, 0x72, 0xad, 0xe1, 0x25, 0x57, 0xfc, 0xc9, 0x73, 0x14, 0x93, 0xc7, 0x7f, 0xd9, 0x46,
	0xe0, 0x55, 0x14, 0xab, 0x6f, 0xfa, 0x16, 0xf6, 0x0f, 0x2c, 0xc0, 0x93, 0xe7, 0x28, 0x2c, 0x87,
	0x3e, 0x6c, 0xa3, 0xa1, 0x6e, 0xcd, 0x26, 0x64, 0x15, 0x9f, 0x3c, 0x47, 0xdf, 0x9e, 0xf9, 0xd6,
	0x2f, 0xdb, 0xe8, 0xc6, 0x06, 0xb3, 0x0d, 0xb3, 0x9a, 0xb2, 0xb1, 0x65, 0x63, 0x8a, 0x4d, 0xbe,
	0xc7, 0x14, 0xb6, 0x6d, 0x62, 0xa7, 0x6c, 0x4c, 0x2d, 0x62, 0x52, 0x9c, 0x49, 0x35, 0x68, 0x43,
	0xab, 0xd5, 0xf6, 0x52, 0x5a, 0x6a, 0x97, 0xd5, 0x6b, 0x29, 0x9d, 0x94, 0x31, 0x97, 0x32, 0xfb,
	0xe4, 0x39, 0xba, 0x34, 0x93, 0xde, 0x6f, 0xa3, 0x24, 0x0f, 0x94, 0x14, 0xa9, 0xa4, 0x68, 0x63,
	0xc7, 0xc4, 0x8c, 0xa6, 0x0c, 0x33, 0xa5, 0xa5, 0xaa, 0x46, 0x13, 0x9b, 0xdc, 0x1e, 0x65, 0xac,
	0xe9, 0xdf, 0x9c, 0xbc, 0x09, 0xd1, 0xa6, 0xa9, 0xea, 0xe2, 0xf0, 0x4f, 0x3e, 0x23, 0xeb, 0x6b,
	0x3a, 0xdd, 0x88, 0x91, 0x9a, 0xee, 0x67, 0x79, 0x16, 0x22, 0x5a, 0xb9, 0x6c, 0x63, 0x4a, 0xdd,
	0xd9, 0xd8, 0x38, 0xef, 0x14, 0x3a, 0x13, 0x9c, 0x80, 0xe2, 0x2d, 0xcb, 0xcb, 0x30, 0xa2, 0x13,
	0x62, 0x97, 0x0d, 0x53, 0xe3, 0xfd, 0x98, 0x83, 0x7b, 0x17, 0xfb, 0x2c, 0x10, 0x3a, 0x97, 0xba,
	0x64, 0x4e, 0x07, 0xa6, 0xf8, 0x39, 0xe5, 0xef, 0xc3, 0x79, 0x31, 0x91, 0xae, 0x93, 0xb2, 0x51,
	0x31, 0x74, 0x61, 0x97, 0xda, 0xf9, 0x4d, 0xc5, 0x85, 0xbe, 0x99, 0x9c, 0xf3, 0xab, 0x4b, 0xce,
	0xfb, 0xd5, 0x25, 0xb7, 0xe9, 0x51, 0x28, 0xe7, 0x38, 0xfb, 0x5b, 0x3e, 0xee, 0xce, 0x92, 0xfc,
	0x3d, 0x90, 0x44, 0xfe, 0x32, 0x2b, 0xc4, 0x45, 0xae, 0xeb, 0x27, 0xc0, 0xd0, 0x01, 0x99, 0x50,
	0x89, 0xf0, 0x64, 0x66, 0x56, 0x88, 0xbc, 0x09, 0x67, 0x6b, 0xa4, 0x4a, 0x55, 0xca, 0x6c, 0xac,
	0xd5, 0xf9, 0x1d, 0x28, 0x1b, 0x54, 0xdb, 0xa9, 0xe1, 0x72, 0x62, 0xec, 0x04, 0x6d, 0xfa, 0x34,
	0x67, 0xde, 0xf0, 0x78, 0xdf, 0x74, 0x59, 0xe5, 0xdf, 0x85, 0xd1, 0x1a, 0xa9, 0xaa, 0x36, 0xd6,
	0xb1, 0xd1, 0xc4, 0xf6, 0x97, 0x98, 0x40, 0x4d, 0x3d, 0x7b, 0xd4, 0xc3, 0xea, 0xea, 0x19, 0xa9,
	0x91, 0xaa, 0xe2, 0x7e, 0x92, 0x97, 0x20, 0x40, 0x5b, 0xee, 0xf8, 0xe9, 0xf2, 0x40, 0x99, 0x5b,
	0x7d, 0x97, 0x5d, 0x88, 0x16, 0x5d, 0xe2, 0x67, 0xfc, 0xc0, 0x02, 0xb4, 0x25, 0x97, 0x20, 0x40,
	0x68, 0x22, 0x26, 0x84, 0xcc, 0x0e, 0x36, 0xac, 0xf7, 0x82, 0xf7, 0xcb, 0x20, 0x54, 0x6e, 0xc2,
	0xa4, 0xe8, 0x57, 0xc5, 0xdc, 0xd7, 0x9b, 0xd0, 0x4d, 0x8a, 0xcb, 0x7e, 0x79, 0x50, 0xe8, 0xac,
	0x37, 0x76, 0x6a, 0x06, 0xdd, 0xe5, 0x7d, 0xab, 0x60, 0x11, 0xa3, 0xba, 0x52, 0xca, 0xbd, 0xd1,
	0x5e, 0x37, 0x73, 0x65, 0xf8, 0x6a, 0x26, 0x9f, 0x99, 0xf7, 0xc3, 0x60, 0xd3, 0xb0, 0x7c, 0x1c,
	0xb2, 0x05, 0x11, 0x07, 0x18, 0x69, 0xe2, 0x5f, 0x22, 0x42, 0xdd, 0xe2, 0x89, 0xe2, 0x60, 0x00,
	0xa8, 0x97, 0xce, 0xfb, 0xb4, 0x0b, 0x24, 0xbe, 0xe3, 0x53, 0xec, 0xa9, 0x91, 0x7f, 0x08, 0x51,
	0x56, 0x71, 0x37, 0x9a, 0xf8, 0xd7, 0xc8, 0x89, 0x8f, 0x33, 0xf9, 0xec, 0x51, 0x5c, 0x9c, 0x44,
	0x85, 0xd8, 0x75, 0x1f, 0xba, 0xb9, 0x4a, 0x15, 0x89, 0x55, 0x9c, 0x8d, 0xc9, 0xef, 0xc3, 0x98,
	0xf8, 0xe1, 0xce, 0x30, 0x19, 0xb6, 0x4d, 0xad, 0x96, 0xf8, 0x34, 0xf2, 0x65, 0xc6, 0x96, 0xbd,
	0xcc, 0x42, 0xf6, 0x28, 0xff, 0xb4, 0xea, 0x7e, 0x99, 0x69, 0x80, 0x7c, 0x30, 0x9d, 0x0e, 0xe8,
	0x4a, 0x57, 0xfd, 0x5d, 0xe9, 0x49, 0xbb, 0xbf, 0xde, 0x56, 0xd5, 0xd7, 0xca, 0xde, 0xfa, 0x6b,
	0xf4, 0x41, 0x1b, 0x3d, 0x43, 0x70, 0x06, 0x26, 0x79, 0x26, 0xee, 0x9d, 0x91, 0xa1, 0x3c, 0xc4,
	0x61, 0xe2, 0x40, 0x23, 0x58, 0x80, 0x19, 0x98, 0xf6, 0x0a, 0xc7, 0x3e, 0x8e, 0x1b, 0x70, 0x1e,
	0xce, 0x78, 0x70, 0xd8, 0xbf, 0x38, 0x0f, 0x17, 0xe0, 0x8c, 0x17, 0xf3, 0x7d, 0x8b, 0xc1, 0xc5,
	0xcc, 0x4d, 0x48, 0xc3, 0x99, 0x62, 0xb9, 0xa9, 0x99, 0x3a, 0x2e, 0xf7, 0x2d, 0x4b, 0xf9, 0x42,
	0x26, 0x7f, 0x2d, 0x93, 0xbf, 0x5e, 0xca, 0x42, 0x5c, 0x64, 0x04, 0xef, 0x06, 0x7a, 0xb5, 0xe3,
	0xf4, 0x8b, 0x36, 0x1a, 0x73, 0x47, 0x19, 0xa3, 0x62, 0x6e, 0x38, 0x9f, 0xc9, 0x2f, 0xac, 0x85,
	0xa4, 0xd1, 0xd8, 0x58, 0xfa, 0x67, 0x61, 0x18, 0x5f, 0xb2, 0xb1, 0xc6, 0x70, 0xa7, 0xa2, 0x79,
	0xf7, 0x95, 0x55, 0x34, 0xfd, 0xb5, 0xcc, 0x0f, 0x5f, 0x75, 0x2d, 0x73, 0xa0, 0x8a, 0xd9, 0x7e,
	0x75, 0x55, 0x4c, 0x6f, 0xfd, 0x72, 0xef, 0x55, 0xc0, 0x9c, 0x0f, 0xe0, 0x12, 0x7d, 0x00, 0xd7,
	0x05, 0xb4, 0xe2, 0x69, 0x00, 0xad, 0x17, 0xca, 0xee, 0x9d, 0x0a, 0x1b, 0x0e, 0x47, 0x85, 0x77,
	0x4f, 0x8d, 0x0a, 0x13, 0x7d, 0xa8, 0xd0, 0x8f, 0x08, 0xdf, 0x39, 0x1d, 0x22, 0x84, 0x3a, 0x68,
	0x70, 0xfb, 0x54, 0x68, 0x10, 0xf2, 0x90, 0xe0, 0xd6, 0xe4, 0x3f, 0xdd, 0xee, 0xab, 0xe8, 0x4b,
	0x57, 0x0f, 0xb9, 0x47, 0x89, 0x3f, 0xfc, 0x6f, 0x34, 0x70, 0xa5, 0x33, 0x11, 0x74, 0x46, 0xf0,
	0xfc, 0x5a, 0x3d, 0x1e, 0x86, 0x09, 0x05, 0x5b, 0x35, 0x4d, 0xef, 0xde, 0xab, 0xaf, 0xa3, 0xff,
	0xeb, 0xe8, 0xef, 0x89, 0xfe, 0x57, 0x15, 0x7c, 0xfe, 0xa1, 0x74, 0x37, 0x04, 0xff, 0x6b, 0x14,
	0x46, 0x96, 0x31, 0xfb, 0x3a, 0xad, 0x1f, 0x15, 0xd8, 0xb7, 0x8e, 0x6d, 0x4b, 0x0f, 0x6f, 0x40,
	0x17, 0x8f, 0x6b, 0x40, 0x0f, 0x6d, 0x35, 0x9f, 0x1d, 0xda, 0x6a, 0xde, 0x39, 0x41, 0xab, 0xd9,
	0x3d, 0xd3, 0x41, 0x7d, 0xe6, 0xdf, 0xff, 0xba, 0x35, 0x98, 0x5f, 0xa9, 0xdc, 0xf3, 0x15, 0x6b,
	0x22, 0xbf, 0x3a, 0x85, 0xc2, 0x6f, 0x02, 0x88, 0x7f, 0x5a, 0xa3, 0x4c, 0x63, 0x58, 0x14, 0x0c,
	0xe3, 0x85, 0x0b, 0x83, 0x8e, 0xc6, 0xfb, 0xd1, 0x15, 0x2b, 0x51, 0xea, 0x3d, 0xca, 0x9b, 0xaf,
	0xa2, 0xdf, 0x3b, 0xd0, 0xcd, 0x6d, 0xbc, 0xba, 0x6e, 0xae, 0xd3, 0xb0, 0xfd, 0x7f, 0xb5, 0x3b,
	0xf1, 0x03, 0x50, 0xf4, 0xe9, 0x6d, 0x74, 0x2a, 0x34, 0x1a, 0x8d, 0x8d, 0x95, 0x7e, 0x8c, 0x5e,
	0x7e, 0x92, 0x1c, 0xfa, 0xe8, 0x93, 0xe4, 0xd0, 0x67, 0x9f, 0x24, 0xd1, 0xe3, 0xfd, 0x24, 0xfa,
	0xc9, 0x7e, 0x12, 0x7d, 0xb8, 0x9f, 0x44, 0x2f, 0xf7, 0x93, 0xe8, 0xa3, 0xfd, 0x24, 0xfa, 0xf9,
	0x7e, 0x12, 0x7d, 0xba, 0x9f, 0x1c, 0xfa, 0x6c, 0x3f, 0x89, 0xfe, 0xf4, 0x17, 0xc9, 0xa1, 0x17,
	0xbf, 0x48, 0xa2, 0xef, 0x6f, 0x55, 0x89, 0x75, 0xbf, 0x9a, 0xf3, 0x12, 0x6e, 0xae, 0x41, 0xe7,
	0x3a, 0x3d, 0x68, 0xd6, 0xb2, 0x49, 0xd3, 0x28, 0x63, 0x3b, 0xeb, 0x2d, 0xcf, 0x59, 0x3b, 0x55,
	0x32, 0x87, 0x1f, 0x30, 0xef, 0xff, 0x52, 0x0f, 0xfb, 0x3f, 0xdc, 0x9d, 0xb0, 0xb8, 0x68, 0xf3,
	0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x65, 0xee, 0x43, 0xfd, 0xb2, 0x2b, 0x00, 0x00,
}

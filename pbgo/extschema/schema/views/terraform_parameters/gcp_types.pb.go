// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/terraform_parameters/gcp_types.proto

package terraform_parameters

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema_views1 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// GCP Terraform Instance Parameters
//
// x-displayName: "GCP Terraform Instance Parameters"
// Shape of the view terraform parameters specification
type GCPInstanceType struct {
	// Volterra Node Id
	//
	// x-displayName: "Volterra Node ID"
	// Volterra Node ID will be used to refer to this node in other TF parameters
	VoltNodeId string `protobuf:"bytes,1,opt,name=volt_node_id,json=voltNodeId,proto3" json:"volt_node_id,omitempty"`
	// Region id
	//
	// x-displayName: "Region id"
	// Region in which Cloud Instance site will be created
	VoltRegionId string `protobuf:"bytes,3,opt,name=volt_region_id,json=voltRegionId,proto3" json:"volt_region_id,omitempty"`
	// Public Subnet
	//
	// x-displayName: "Public Subnet"
	// Public subnet will be used as site local network
	PublicSubnetId *GCPSubnetChoice `protobuf:"bytes,4,opt,name=public_subnet_id,json=publicSubnetId" json:"public_subnet_id,omitempty"`
	// Private Subnet
	//
	// x-displayName: "Private Subnet"
	// Private subnet will be used as site inside network, when node type has two interfaces.
	PrivateSubnetId *GCPSubnetChoice `protobuf:"bytes,5,opt,name=private_subnet_id,json=privateSubnetId" json:"private_subnet_id,omitempty"`
	// Cloud Instance Type
	//
	// x-displayName: "Cloud Instance Type"
	// Cloud instance type like small, medium, large etc
	InstanceType string `protobuf:"bytes,6,opt,name=instance_type,json=instanceType,proto3" json:"instance_type,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// Disk size to be used for this instance
	DiskSize string `protobuf:"bytes,7,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// AMI ID
	//
	// x-displayName: "Image ID"
	// Amazon Machine Image ID
	ImageId string `protobuf:"bytes,8,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	// Volterra Node count
	//
	// x-displayName: "Volterra Node count"
	// Desired number of node count used for worker node scaling
	NodeCount int32 `protobuf:"varint,9,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Zone
	//
	// x-displayName: "Zone"
	// Zone in which Cloud Instance site will be created
	Zone string `protobuf:"bytes,10,opt,name=zone,proto3" json:"zone,omitempty"`
}

func (m *GCPInstanceType) Reset()                    { *m = GCPInstanceType{} }
func (*GCPInstanceType) ProtoMessage()               {}
func (*GCPInstanceType) Descriptor() ([]byte, []int) { return fileDescriptorGcpTypes, []int{0} }

func (m *GCPInstanceType) GetVoltNodeId() string {
	if m != nil {
		return m.VoltNodeId
	}
	return ""
}

func (m *GCPInstanceType) GetVoltRegionId() string {
	if m != nil {
		return m.VoltRegionId
	}
	return ""
}

func (m *GCPInstanceType) GetPublicSubnetId() *GCPSubnetChoice {
	if m != nil {
		return m.PublicSubnetId
	}
	return nil
}

func (m *GCPInstanceType) GetPrivateSubnetId() *GCPSubnetChoice {
	if m != nil {
		return m.PrivateSubnetId
	}
	return nil
}

func (m *GCPInstanceType) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

func (m *GCPInstanceType) GetDiskSize() string {
	if m != nil {
		return m.DiskSize
	}
	return ""
}

func (m *GCPInstanceType) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

func (m *GCPInstanceType) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

func (m *GCPInstanceType) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

// GCP subnet Parameters
//
// x-displayName: "New GCP subetn Parameters"
// parameters to create subnet in VPC network.
type GCPSubnetParamType struct {
	// New Subnet name
	//
	// x-displayName: "subnet name"
	// Name for new subnet
	Subnet *ves_io_schema_views1.GCPSubnetParamsType `protobuf:"bytes,1,opt,name=subnet" json:"subnet,omitempty"`
	// VPC network name
	//
	// x-displayName: "VPC network name"
	// To which VPC network create subnet
	NetworkName string `protobuf:"bytes,2,opt,name=network_name,json=networkName,proto3" json:"network_name,omitempty"`
	// Subnet region
	//
	// x-displayName: "Region name"
	// Subnets region
	Region string `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
}

func (m *GCPSubnetParamType) Reset()                    { *m = GCPSubnetParamType{} }
func (*GCPSubnetParamType) ProtoMessage()               {}
func (*GCPSubnetParamType) Descriptor() ([]byte, []int) { return fileDescriptorGcpTypes, []int{1} }

func (m *GCPSubnetParamType) GetSubnet() *ves_io_schema_views1.GCPSubnetParamsType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *GCPSubnetParamType) GetNetworkName() string {
	if m != nil {
		return m.NetworkName
	}
	return ""
}

func (m *GCPSubnetParamType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

// GCP VPC network choice
//
// x-displayName: "GCP VPC network"
// Parameters for GCP VPC network
type GCPVPCNetworkChoice struct {
	// New VPC Network
	//
	// x-displayName: "New VPC nerwork"
	// Parameters for creating new VPC network
	NetworkParam *ves_io_schema_views1.GCPVPCNetworkParamsType `protobuf:"bytes,1,opt,name=network_param,json=networkParam" json:"network_param,omitempty"`
	// Existing NEtwork Name
	//
	// x-displayName: "Existing VPC network Name"
	// Information about existing VPC network
	ExistingNetwork *ves_io_schema_views1.GCPVPCNetworkType `protobuf:"bytes,2,opt,name=existing_network,json=existingNetwork" json:"existing_network,omitempty"`
	// Interface Type
	//
	// x-displayName: "Interface Type"
	// Interface Type
	InterfaceType InterfaceType `protobuf:"varint,3,opt,name=interface_type,json=interfaceType,proto3,enum=ves.io.schema.views.terraform_parameters.InterfaceType" json:"interface_type,omitempty"`
}

func (m *GCPVPCNetworkChoice) Reset()                    { *m = GCPVPCNetworkChoice{} }
func (*GCPVPCNetworkChoice) ProtoMessage()               {}
func (*GCPVPCNetworkChoice) Descriptor() ([]byte, []int) { return fileDescriptorGcpTypes, []int{2} }

func (m *GCPVPCNetworkChoice) GetNetworkParam() *ves_io_schema_views1.GCPVPCNetworkParamsType {
	if m != nil {
		return m.NetworkParam
	}
	return nil
}

func (m *GCPVPCNetworkChoice) GetExistingNetwork() *ves_io_schema_views1.GCPVPCNetworkType {
	if m != nil {
		return m.ExistingNetwork
	}
	return nil
}

func (m *GCPVPCNetworkChoice) GetInterfaceType() InterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return INTERFACE_INSIDE
}

// GCP Subnet choice
//
// x-displayName: "GCP Subnet"
// Parameters for GCP Subnet
type GCPSubnetChoice struct {
	// New Subnet
	//
	// x-displayName: "New Subnet"
	// Parameters for creating new subnet
	SubnetParam *GCPSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam" json:"subnet_param,omitempty"`
	// Existing NEtwork Name
	//
	// x-displayName: "Existing Subnet"
	// Information about existing subnet
	ExistingSubnet *ves_io_schema_views1.GCPSubnetType `protobuf:"bytes,2,opt,name=existing_subnet,json=existingSubnet" json:"existing_subnet,omitempty"`
	// Interface Type
	//
	// x-displayName: "Interface Type"
	// Interface Type
	InterfaceType InterfaceType `protobuf:"varint,3,opt,name=interface_type,json=interfaceType,proto3,enum=ves.io.schema.views.terraform_parameters.InterfaceType" json:"interface_type,omitempty"`
}

func (m *GCPSubnetChoice) Reset()                    { *m = GCPSubnetChoice{} }
func (*GCPSubnetChoice) ProtoMessage()               {}
func (*GCPSubnetChoice) Descriptor() ([]byte, []int) { return fileDescriptorGcpTypes, []int{3} }

func (m *GCPSubnetChoice) GetSubnetParam() *GCPSubnetParamType {
	if m != nil {
		return m.SubnetParam
	}
	return nil
}

func (m *GCPSubnetChoice) GetExistingSubnet() *ves_io_schema_views1.GCPSubnetType {
	if m != nil {
		return m.ExistingSubnet
	}
	return nil
}

func (m *GCPSubnetChoice) GetInterfaceType() InterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return INTERFACE_INSIDE
}

// Terraform GCP VPC Site Parameters
//
// x-displayName: "Terraform Object Parameters"
// Terraform parameters to create site in GCP.
type GCPVpcSiteType struct {
	// Site Name
	//
	// x-displayName: "Site Name"
	// Name of the site object to be created
	SiteName string `protobuf:"bytes,1,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
	// List of GCP networks
	//
	// x-displayName: "GCP Region"
	// List of GCP network
	GcpVpcNetworks []*GCPVPCNetworkChoice `protobuf:"bytes,2,rep,name=gcp_vpc_networks,json=gcpVpcNetworks" json:"gcp_vpc_networks,omitempty"`
	// Fleet Label
	//
	// x-displayName: "Fleet Label"
	// Fleet Label to identify Fleet for this site. Fleet Label is assigned to site at registration approval
	FleetLabel string `protobuf:"bytes,3,opt,name=fleet_label,json=fleetLabel,proto3" json:"fleet_label,omitempty"`
	// Certified Hardware
	//
	// x-displayName: "Certified Hardware"
	// Certified Hardware to be used to create this site.
	CertifiedHw string `protobuf:"bytes,4,opt,name=certified_hw,json=certifiedHw,proto3" json:"certified_hw,omitempty"`
	// GCP Region
	//
	// x-displayName: "GCP Region"
	// GCP region
	GcpRegion string `protobuf:"bytes,5,opt,name=gcp_region,json=gcpRegion,proto3" json:"gcp_region,omitempty"`
	// // List of Subnets
	// //
	// // x-displayName: "List of Subnets"
	// // List of Subnets that TF script needs
	Subnets []*GCPSubnetChoice `protobuf:"bytes,8,rep,name=subnets" json:"subnets,omitempty"`
	// List of Master Nodes
	//
	// x-displayName: "List of Master Nodes"
	// List of Master Nodes in this Site that TF script needs to instantiate
	MasterNodes []*GCPInstanceType `protobuf:"bytes,9,rep,name=master_nodes,json=masterNodes" json:"master_nodes,omitempty"`
	// Worker Node Scaling
	//
	// x-displayName: "Worker Node Scaling"
	// Number of Maximum Worker Nodes for Auto Scale Configuration
	WorkerNodes uint32 `protobuf:"varint,14,opt,name=worker_nodes,json=workerNodes,proto3" json:"worker_nodes,omitempty"`
	// Gateway Type
	//
	// x-displayName: "Gateway Type"
	// Gateway Type
	GatewayType CloudGatewayType `protobuf:"varint,11,opt,name=gateway_type,json=gatewayType,proto3,enum=ves.io.schema.views.terraform_parameters.CloudGatewayType" json:"gateway_type,omitempty"`
	// Public SSH key
	//
	// x-displayName: "Public SSH key"
	// Public SSH key for accessing the site.
	SshKey string `protobuf:"bytes,13,opt,name=ssh_key,json=sshKey,proto3" json:"ssh_key,omitempty"`
}

func (m *GCPVpcSiteType) Reset()                    { *m = GCPVpcSiteType{} }
func (*GCPVpcSiteType) ProtoMessage()               {}
func (*GCPVpcSiteType) Descriptor() ([]byte, []int) { return fileDescriptorGcpTypes, []int{4} }

func (m *GCPVpcSiteType) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

func (m *GCPVpcSiteType) GetGcpVpcNetworks() []*GCPVPCNetworkChoice {
	if m != nil {
		return m.GcpVpcNetworks
	}
	return nil
}

func (m *GCPVpcSiteType) GetFleetLabel() string {
	if m != nil {
		return m.FleetLabel
	}
	return ""
}

func (m *GCPVpcSiteType) GetCertifiedHw() string {
	if m != nil {
		return m.CertifiedHw
	}
	return ""
}

func (m *GCPVpcSiteType) GetGcpRegion() string {
	if m != nil {
		return m.GcpRegion
	}
	return ""
}

func (m *GCPVpcSiteType) GetSubnets() []*GCPSubnetChoice {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *GCPVpcSiteType) GetMasterNodes() []*GCPInstanceType {
	if m != nil {
		return m.MasterNodes
	}
	return nil
}

func (m *GCPVpcSiteType) GetWorkerNodes() uint32 {
	if m != nil {
		return m.WorkerNodes
	}
	return 0
}

func (m *GCPVpcSiteType) GetGatewayType() CloudGatewayType {
	if m != nil {
		return m.GatewayType
	}
	return INGRESS_GATEWAY
}

func (m *GCPVpcSiteType) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func init() {
	proto.RegisterType((*GCPInstanceType)(nil), "ves.io.schema.views.terraform_parameters.GCPInstanceType")
	golang_proto.RegisterType((*GCPInstanceType)(nil), "ves.io.schema.views.terraform_parameters.GCPInstanceType")
	proto.RegisterType((*GCPSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.GCPSubnetParamType")
	golang_proto.RegisterType((*GCPSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.GCPSubnetParamType")
	proto.RegisterType((*GCPVPCNetworkChoice)(nil), "ves.io.schema.views.terraform_parameters.GCPVPCNetworkChoice")
	golang_proto.RegisterType((*GCPVPCNetworkChoice)(nil), "ves.io.schema.views.terraform_parameters.GCPVPCNetworkChoice")
	proto.RegisterType((*GCPSubnetChoice)(nil), "ves.io.schema.views.terraform_parameters.GCPSubnetChoice")
	golang_proto.RegisterType((*GCPSubnetChoice)(nil), "ves.io.schema.views.terraform_parameters.GCPSubnetChoice")
	proto.RegisterType((*GCPVpcSiteType)(nil), "ves.io.schema.views.terraform_parameters.GCPVpcSiteType")
	golang_proto.RegisterType((*GCPVpcSiteType)(nil), "ves.io.schema.views.terraform_parameters.GCPVpcSiteType")
}
func (this *GCPInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPInstanceType)
	if !ok {
		that2, ok := that.(GCPInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VoltNodeId != that1.VoltNodeId {
		return false
	}
	if this.VoltRegionId != that1.VoltRegionId {
		return false
	}
	if !this.PublicSubnetId.Equal(that1.PublicSubnetId) {
		return false
	}
	if !this.PrivateSubnetId.Equal(that1.PrivateSubnetId) {
		return false
	}
	if this.InstanceType != that1.InstanceType {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	if this.ImageId != that1.ImageId {
		return false
	}
	if this.NodeCount != that1.NodeCount {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	return true
}
func (this *GCPSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetParamType)
	if !ok {
		that2, ok := that.(GCPSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	if this.NetworkName != that1.NetworkName {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoice)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetworkParam.Equal(that1.NetworkParam) {
		return false
	}
	if !this.ExistingNetwork.Equal(that1.ExistingNetwork) {
		return false
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	return true
}
func (this *GCPSubnetChoice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetChoice)
	if !ok {
		that2, ok := that.(GCPSubnetChoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	if !this.ExistingSubnet.Equal(that1.ExistingSubnet) {
		return false
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	return true
}
func (this *GCPVpcSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVpcSiteType)
	if !ok {
		that2, ok := that.(GCPVpcSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	if len(this.GcpVpcNetworks) != len(that1.GcpVpcNetworks) {
		return false
	}
	for i := range this.GcpVpcNetworks {
		if !this.GcpVpcNetworks[i].Equal(that1.GcpVpcNetworks[i]) {
			return false
		}
	}
	if this.FleetLabel != that1.FleetLabel {
		return false
	}
	if this.CertifiedHw != that1.CertifiedHw {
		return false
	}
	if this.GcpRegion != that1.GcpRegion {
		return false
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if len(this.MasterNodes) != len(that1.MasterNodes) {
		return false
	}
	for i := range this.MasterNodes {
		if !this.MasterNodes[i].Equal(that1.MasterNodes[i]) {
			return false
		}
	}
	if this.WorkerNodes != that1.WorkerNodes {
		return false
	}
	if this.GatewayType != that1.GatewayType {
		return false
	}
	if this.SshKey != that1.SshKey {
		return false
	}
	return true
}
func (this *GCPInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&terraform_parameters.GCPInstanceType{")
	s = append(s, "VoltNodeId: "+fmt.Sprintf("%#v", this.VoltNodeId)+",\n")
	s = append(s, "VoltRegionId: "+fmt.Sprintf("%#v", this.VoltRegionId)+",\n")
	if this.PublicSubnetId != nil {
		s = append(s, "PublicSubnetId: "+fmt.Sprintf("%#v", this.PublicSubnetId)+",\n")
	}
	if this.PrivateSubnetId != nil {
		s = append(s, "PrivateSubnetId: "+fmt.Sprintf("%#v", this.PrivateSubnetId)+",\n")
	}
	s = append(s, "InstanceType: "+fmt.Sprintf("%#v", this.InstanceType)+",\n")
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "ImageId: "+fmt.Sprintf("%#v", this.ImageId)+",\n")
	s = append(s, "NodeCount: "+fmt.Sprintf("%#v", this.NodeCount)+",\n")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.GCPSubnetParamType{")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	s = append(s, "NetworkName: "+fmt.Sprintf("%#v", this.NetworkName)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.GCPVPCNetworkChoice{")
	if this.NetworkParam != nil {
		s = append(s, "NetworkParam: "+fmt.Sprintf("%#v", this.NetworkParam)+",\n")
	}
	if this.ExistingNetwork != nil {
		s = append(s, "ExistingNetwork: "+fmt.Sprintf("%#v", this.ExistingNetwork)+",\n")
	}
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.GCPSubnetChoice{")
	if this.SubnetParam != nil {
		s = append(s, "SubnetParam: "+fmt.Sprintf("%#v", this.SubnetParam)+",\n")
	}
	if this.ExistingSubnet != nil {
		s = append(s, "ExistingSubnet: "+fmt.Sprintf("%#v", this.ExistingSubnet)+",\n")
	}
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVpcSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&terraform_parameters.GCPVpcSiteType{")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	if this.GcpVpcNetworks != nil {
		s = append(s, "GcpVpcNetworks: "+fmt.Sprintf("%#v", this.GcpVpcNetworks)+",\n")
	}
	s = append(s, "FleetLabel: "+fmt.Sprintf("%#v", this.FleetLabel)+",\n")
	s = append(s, "CertifiedHw: "+fmt.Sprintf("%#v", this.CertifiedHw)+",\n")
	s = append(s, "GcpRegion: "+fmt.Sprintf("%#v", this.GcpRegion)+",\n")
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.MasterNodes != nil {
		s = append(s, "MasterNodes: "+fmt.Sprintf("%#v", this.MasterNodes)+",\n")
	}
	s = append(s, "WorkerNodes: "+fmt.Sprintf("%#v", this.WorkerNodes)+",\n")
	s = append(s, "GatewayType: "+fmt.Sprintf("%#v", this.GatewayType)+",\n")
	s = append(s, "SshKey: "+fmt.Sprintf("%#v", this.SshKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringGcpTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GCPInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPInstanceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VoltNodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.VoltNodeId)))
		i += copy(dAtA[i:], m.VoltNodeId)
	}
	if len(m.VoltRegionId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.VoltRegionId)))
		i += copy(dAtA[i:], m.VoltRegionId)
	}
	if m.PublicSubnetId != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.PublicSubnetId.Size()))
		n1, err := m.PublicSubnetId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PrivateSubnetId != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.PrivateSubnetId.Size()))
		n2, err := m.PrivateSubnetId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.InstanceType) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.InstanceType)))
		i += copy(dAtA[i:], m.InstanceType)
	}
	if len(m.DiskSize) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.DiskSize)))
		i += copy(dAtA[i:], m.DiskSize)
	}
	if len(m.ImageId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.ImageId)))
		i += copy(dAtA[i:], m.ImageId)
	}
	if m.NodeCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.NodeCount))
	}
	if len(m.Zone) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	return i, nil
}

func (m *GCPSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subnet != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.Subnet.Size()))
		n3, err := m.Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.NetworkName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.NetworkName)))
		i += copy(dAtA[i:], m.NetworkName)
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	return i, nil
}

func (m *GCPVPCNetworkChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkChoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkParam != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.NetworkParam.Size()))
		n4, err := m.NetworkParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ExistingNetwork != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.ExistingNetwork.Size()))
		n5, err := m.ExistingNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.InterfaceType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.InterfaceType))
	}
	return i, nil
}

func (m *GCPSubnetChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetChoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubnetParam != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.SubnetParam.Size()))
		n6, err := m.SubnetParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ExistingSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.ExistingSubnet.Size()))
		n7, err := m.ExistingSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.InterfaceType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.InterfaceType))
	}
	return i, nil
}

func (m *GCPVpcSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVpcSiteType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SiteName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.SiteName)))
		i += copy(dAtA[i:], m.SiteName)
	}
	if len(m.GcpVpcNetworks) > 0 {
		for _, msg := range m.GcpVpcNetworks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGcpTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FleetLabel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.FleetLabel)))
		i += copy(dAtA[i:], m.FleetLabel)
	}
	if len(m.CertifiedHw) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.CertifiedHw)))
		i += copy(dAtA[i:], m.CertifiedHw)
	}
	if len(m.GcpRegion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.GcpRegion)))
		i += copy(dAtA[i:], m.GcpRegion)
	}
	if len(m.Subnets) > 0 {
		for _, msg := range m.Subnets {
			dAtA[i] = 0x42
			i++
			i = encodeVarintGcpTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MasterNodes) > 0 {
		for _, msg := range m.MasterNodes {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintGcpTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GatewayType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.GatewayType))
	}
	if len(m.SshKey) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.SshKey)))
		i += copy(dAtA[i:], m.SshKey)
	}
	if m.WorkerNodes != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.WorkerNodes))
	}
	return i, nil
}

func encodeVarintGcpTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedGCPInstanceType(r randyGcpTypes, easy bool) *GCPInstanceType {
	this := &GCPInstanceType{}
	this.VoltNodeId = string(randStringGcpTypes(r))
	this.VoltRegionId = string(randStringGcpTypes(r))
	if r.Intn(10) != 0 {
		this.PublicSubnetId = NewPopulatedGCPSubnetChoice(r, easy)
	}
	if r.Intn(10) != 0 {
		this.PrivateSubnetId = NewPopulatedGCPSubnetChoice(r, easy)
	}
	this.InstanceType = string(randStringGcpTypes(r))
	this.DiskSize = string(randStringGcpTypes(r))
	this.ImageId = string(randStringGcpTypes(r))
	this.NodeCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.NodeCount *= -1
	}
	this.Zone = string(randStringGcpTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPSubnetParamType(r randyGcpTypes, easy bool) *GCPSubnetParamType {
	this := &GCPSubnetParamType{}
	if r.Intn(10) != 0 {
		this.Subnet = ves_io_schema_views1.NewPopulatedGCPSubnetParamsType(r, easy)
	}
	this.NetworkName = string(randStringGcpTypes(r))
	this.Region = string(randStringGcpTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPVPCNetworkChoice(r randyGcpTypes, easy bool) *GCPVPCNetworkChoice {
	this := &GCPVPCNetworkChoice{}
	if r.Intn(10) != 0 {
		this.NetworkParam = ves_io_schema_views1.NewPopulatedGCPVPCNetworkParamsType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ExistingNetwork = ves_io_schema_views1.NewPopulatedGCPVPCNetworkType(r, easy)
	}
	this.InterfaceType = InterfaceType([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPSubnetChoice(r randyGcpTypes, easy bool) *GCPSubnetChoice {
	this := &GCPSubnetChoice{}
	if r.Intn(10) != 0 {
		this.SubnetParam = NewPopulatedGCPSubnetParamType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ExistingSubnet = ves_io_schema_views1.NewPopulatedGCPSubnetType(r, easy)
	}
	this.InterfaceType = InterfaceType([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPVpcSiteType(r randyGcpTypes, easy bool) *GCPVpcSiteType {
	this := &GCPVpcSiteType{}
	this.SiteName = string(randStringGcpTypes(r))
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.GcpVpcNetworks = make([]*GCPVPCNetworkChoice, v1)
		for i := 0; i < v1; i++ {
			this.GcpVpcNetworks[i] = NewPopulatedGCPVPCNetworkChoice(r, easy)
		}
	}
	this.FleetLabel = string(randStringGcpTypes(r))
	this.CertifiedHw = string(randStringGcpTypes(r))
	this.GcpRegion = string(randStringGcpTypes(r))
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.Subnets = make([]*GCPSubnetChoice, v2)
		for i := 0; i < v2; i++ {
			this.Subnets[i] = NewPopulatedGCPSubnetChoice(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.MasterNodes = make([]*GCPInstanceType, v3)
		for i := 0; i < v3; i++ {
			this.MasterNodes[i] = NewPopulatedGCPInstanceType(r, easy)
		}
	}
	this.GatewayType = CloudGatewayType([]int32{0, 1}[r.Intn(2)])
	this.SshKey = string(randStringGcpTypes(r))
	this.WorkerNodes = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyGcpTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneGcpTypes(r randyGcpTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringGcpTypes(r randyGcpTypes) string {
	v4 := r.Intn(100)
	tmps := make([]rune, v4)
	for i := 0; i < v4; i++ {
		tmps[i] = randUTF8RuneGcpTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedGcpTypes(r randyGcpTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldGcpTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldGcpTypes(dAtA []byte, r randyGcpTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateGcpTypes(dAtA, uint64(key))
		v5 := r.Int63()
		if r.Intn(2) == 0 {
			v5 *= -1
		}
		dAtA = encodeVarintPopulateGcpTypes(dAtA, uint64(v5))
	case 1:
		dAtA = encodeVarintPopulateGcpTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateGcpTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateGcpTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateGcpTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateGcpTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *GCPInstanceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.VoltNodeId)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.VoltRegionId)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.PublicSubnetId != nil {
		l = m.PublicSubnetId.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.PrivateSubnetId != nil {
		l = m.PrivateSubnetId.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.InstanceType)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.DiskSize)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.NodeCount != 0 {
		n += 1 + sovGcpTypes(uint64(m.NodeCount))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}

func (m *GCPSubnetParamType) Size() (n int) {
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.NetworkName)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCNetworkChoice) Size() (n int) {
	var l int
	_ = l
	if m.NetworkParam != nil {
		l = m.NetworkParam.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.ExistingNetwork != nil {
		l = m.ExistingNetwork.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.InterfaceType != 0 {
		n += 1 + sovGcpTypes(uint64(m.InterfaceType))
	}
	return n
}

func (m *GCPSubnetChoice) Size() (n int) {
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.ExistingSubnet != nil {
		l = m.ExistingSubnet.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.InterfaceType != 0 {
		n += 1 + sovGcpTypes(uint64(m.InterfaceType))
	}
	return n
}

func (m *GCPVpcSiteType) Size() (n int) {
	var l int
	_ = l
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if len(m.GcpVpcNetworks) > 0 {
		for _, e := range m.GcpVpcNetworks {
			l = e.Size()
			n += 1 + l + sovGcpTypes(uint64(l))
		}
	}
	l = len(m.FleetLabel)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.CertifiedHw)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.GcpRegion)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovGcpTypes(uint64(l))
		}
	}
	if len(m.MasterNodes) > 0 {
		for _, e := range m.MasterNodes {
			l = e.Size()
			n += 1 + l + sovGcpTypes(uint64(l))
		}
	}
	if m.GatewayType != 0 {
		n += 1 + sovGcpTypes(uint64(m.GatewayType))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.WorkerNodes != 0 {
		n += 1 + sovGcpTypes(uint64(m.WorkerNodes))
	}
	return n
}

func sovGcpTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGcpTypes(x uint64) (n int) {
	return sovGcpTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GCPInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPInstanceType{`,
		`VoltNodeId:` + fmt.Sprintf("%v", this.VoltNodeId) + `,`,
		`VoltRegionId:` + fmt.Sprintf("%v", this.VoltRegionId) + `,`,
		`PublicSubnetId:` + strings.Replace(fmt.Sprintf("%v", this.PublicSubnetId), "GCPSubnetChoice", "GCPSubnetChoice", 1) + `,`,
		`PrivateSubnetId:` + strings.Replace(fmt.Sprintf("%v", this.PrivateSubnetId), "GCPSubnetChoice", "GCPSubnetChoice", 1) + `,`,
		`InstanceType:` + fmt.Sprintf("%v", this.InstanceType) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`ImageId:` + fmt.Sprintf("%v", this.ImageId) + `,`,
		`NodeCount:` + fmt.Sprintf("%v", this.NodeCount) + `,`,
		`Zone:` + fmt.Sprintf("%v", this.Zone) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetParamType{`,
		`Subnet:` + strings.Replace(fmt.Sprintf("%v", this.Subnet), "GCPSubnetParamsType", "ves_io_schema_views1.GCPSubnetParamsType", 1) + `,`,
		`NetworkName:` + fmt.Sprintf("%v", this.NetworkName) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoice{`,
		`NetworkParam:` + strings.Replace(fmt.Sprintf("%v", this.NetworkParam), "GCPVPCNetworkParamsType", "ves_io_schema_views1.GCPVPCNetworkParamsType", 1) + `,`,
		`ExistingNetwork:` + strings.Replace(fmt.Sprintf("%v", this.ExistingNetwork), "GCPVPCNetworkType", "ves_io_schema_views1.GCPVPCNetworkType", 1) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetChoice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetChoice{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "GCPSubnetParamType", "GCPSubnetParamType", 1) + `,`,
		`ExistingSubnet:` + strings.Replace(fmt.Sprintf("%v", this.ExistingSubnet), "GCPSubnetType", "ves_io_schema_views1.GCPSubnetType", 1) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVpcSiteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVpcSiteType{`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`GcpVpcNetworks:` + strings.Replace(fmt.Sprintf("%v", this.GcpVpcNetworks), "GCPVPCNetworkChoice", "GCPVPCNetworkChoice", 1) + `,`,
		`FleetLabel:` + fmt.Sprintf("%v", this.FleetLabel) + `,`,
		`CertifiedHw:` + fmt.Sprintf("%v", this.CertifiedHw) + `,`,
		`GcpRegion:` + fmt.Sprintf("%v", this.GcpRegion) + `,`,
		`Subnets:` + strings.Replace(fmt.Sprintf("%v", this.Subnets), "GCPSubnetChoice", "GCPSubnetChoice", 1) + `,`,
		`MasterNodes:` + strings.Replace(fmt.Sprintf("%v", this.MasterNodes), "GCPInstanceType", "GCPInstanceType", 1) + `,`,
		`GatewayType:` + fmt.Sprintf("%v", this.GatewayType) + `,`,
		`SshKey:` + fmt.Sprintf("%v", this.SshKey) + `,`,
		`WorkerNodes:` + fmt.Sprintf("%v", this.WorkerNodes) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGcpTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GCPInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltNodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltRegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltRegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicSubnetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicSubnetId == nil {
				m.PublicSubnetId = &GCPSubnetChoice{}
			}
			if err := m.PublicSubnetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateSubnetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivateSubnetId == nil {
				m.PrivateSubnetId = &GCPSubnetChoice{}
			}
			if err := m.PrivateSubnetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &ves_io_schema_views1.GCPSubnetParamsType{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkParam == nil {
				m.NetworkParam = &ves_io_schema_views1.GCPVPCNetworkParamsType{}
			}
			if err := m.NetworkParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingNetwork == nil {
				m.ExistingNetwork = &ves_io_schema_views1.GCPVPCNetworkType{}
			}
			if err := m.ExistingNetwork.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= (InterfaceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetParam == nil {
				m.SubnetParam = &GCPSubnetParamType{}
			}
			if err := m.SubnetParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingSubnet == nil {
				m.ExistingSubnet = &ves_io_schema_views1.GCPSubnetType{}
			}
			if err := m.ExistingSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= (InterfaceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVpcSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVpcSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVpcSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpVpcNetworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpVpcNetworks = append(m.GcpVpcNetworks, &GCPVPCNetworkChoice{})
			if err := m.GcpVpcNetworks[len(m.GcpVpcNetworks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FleetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertifiedHw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &GCPSubnetChoice{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodes = append(m.MasterNodes, &GCPInstanceType{})
			if err := m.MasterNodes[len(m.MasterNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayType", wireType)
			}
			m.GatewayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayType |= (CloudGatewayType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodes", wireType)
			}
			m.WorkerNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerNodes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGcpTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGcpTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGcpTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGcpTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGcpTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGcpTypes   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("ves.io/schema/views/terraform_parameters/gcp_types.proto", fileDescriptorGcpTypes)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/terraform_parameters/gcp_types.proto", fileDescriptorGcpTypes)
}

var fileDescriptorGcpTypes = []byte{
	// 936 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0xd3, 0xb4, 0x4d, 0xc6, 0x49, 0x1a, 0x06, 0x09, 0xbc, 0x59, 0x30, 0x21, 0xac, 0x50,
	0x0e, 0xd4, 0x91, 0x02, 0x12, 0x3f, 0x04, 0x12, 0x22, 0x87, 0x92, 0x2e, 0xaa, 0xb2, 0x2e, 0xda,
	0x03, 0x82, 0xb5, 0x1c, 0xfb, 0xc5, 0x19, 0x35, 0xf1, 0x58, 0x9e, 0x49, 0xb2, 0xe9, 0x89, 0x3f,
	0x01, 0x6e, 0x48, 0x1c, 0xb8, 0xf2, 0x3f, 0x70, 0xe1, 0xc8, 0x71, 0x25, 0x2e, 0x7b, 0xa4, 0xd9,
	0x0b, 0xc7, 0x3d, 0x72, 0x44, 0xf3, 0xc6, 0x49, 0xdd, 0x55, 0x61, 0xcb, 0x56, 0xdc, 0x3c, 0x9f,
	0xe7, 0xfb, 0xe6, 0xbd, 0xef, 0xbd, 0x79, 0x43, 0x3e, 0x98, 0x83, 0x70, 0x18, 0xef, 0x88, 0x60,
	0x0c, 0x53, 0xbf, 0x33, 0x67, 0xb0, 0x10, 0x1d, 0x09, 0x69, 0xea, 0x8f, 0x78, 0x3a, 0xf5, 0x12,
	0x3f, 0xf5, 0xa7, 0x20, 0x21, 0x15, 0x9d, 0x28, 0x48, 0x3c, 0xb9, 0x4c, 0x40, 0x38, 0x49, 0xca,
	0x25, 0xa7, 0x6d, 0xcd, 0x74, 0x34, 0xd3, 0x41, 0xa6, 0x73, 0x15, 0xb3, 0x71, 0x10, 0x31, 0x39,
	0x9e, 0x0d, 0x9d, 0x80, 0x4f, 0x3b, 0x11, 0x8f, 0x78, 0x07, 0x05, 0x86, 0xb3, 0x11, 0xae, 0x70,
	0x81, 0x5f, 0x5a, 0xb8, 0x71, 0xfb, 0x72, 0x48, 0x3c, 0x91, 0x8c, 0xc7, 0xd9, 0xa9, 0x8d, 0x5b,
	0x97, 0x7f, 0xe6, 0x02, 0x6a, 0xbc, 0xf6, 0x4c, 0x2a, 0xfe, 0x84, 0x85, 0xbe, 0x84, 0xec, 0xef,
	0x9d, 0xab, 0x12, 0x15, 0x4c, 0x42, 0x3e, 0xa9, 0xc6, 0x7b, 0xd7, 0xb6, 0x23, 0xc7, 0x6a, 0xfd,
	0xb2, 0x4d, 0xf6, 0x0f, 0x7b, 0x83, 0x7e, 0x2c, 0xa4, 0x1f, 0x07, 0xf0, 0xe5, 0x32, 0x01, 0xda,
	0x24, 0x95, 0x39, 0x9f, 0x48, 0x2f, 0xe6, 0x21, 0x78, 0x2c, 0xb4, 0x8c, 0xa6, 0xd1, 0x2e, 0xbb,
	0x44, 0x61, 0xc7, 0x3c, 0x84, 0x7e, 0x48, 0xef, 0x90, 0x1a, 0xee, 0x48, 0x21, 0x62, 0x3c, 0x56,
	0x7b, 0xb6, 0x71, 0x0f, 0xf2, 0x5c, 0x04, 0xfb, 0x21, 0x0d, 0x48, 0x3d, 0x99, 0x0d, 0x27, 0x2c,
	0xf0, 0xc4, 0x6c, 0x18, 0x83, 0x54, 0xfb, 0x8a, 0x4d, 0xa3, 0x6d, 0x76, 0x3f, 0x74, 0xae, 0x5b,
	0x01, 0xe7, 0xb0, 0x37, 0x38, 0x41, 0x76, 0x6f, 0xcc, 0x59, 0x00, 0x6e, 0x4d, 0x4b, 0x6a, 0xac,
	0x1f, 0x52, 0x20, 0x2f, 0x25, 0x29, 0x9b, 0xfb, 0x12, 0x72, 0xa7, 0xec, 0xdc, 0xf4, 0x94, 0xfd,
	0x4c, 0x73, 0x73, 0xcc, 0x5b, 0xa4, 0xca, 0x32, 0x8f, 0xd0, 0x75, 0x6b, 0x57, 0x27, 0xcc, 0xf2,
	0xc6, 0xdd, 0x26, 0xe5, 0x90, 0x89, 0x53, 0x4f, 0xb0, 0x33, 0xb0, 0xf6, 0x70, 0x43, 0x49, 0x01,
	0x27, 0xec, 0x0c, 0xe8, 0x2d, 0x52, 0x62, 0x53, 0x3f, 0x42, 0x47, 0x4b, 0xf8, 0x6f, 0x0f, 0xd7,
	0xfd, 0x90, 0xbe, 0x4e, 0x08, 0x7a, 0x1d, 0xf0, 0x59, 0x2c, 0xad, 0x72, 0xd3, 0x68, 0xef, 0xb8,
	0x65, 0x85, 0xf4, 0x14, 0x40, 0x29, 0x29, 0x9e, 0xf1, 0x18, 0x2c, 0x82, 0x2c, 0xfc, 0x3e, 0x2a,
	0x96, 0x0a, 0xf5, 0xed, 0xd6, 0xf7, 0x06, 0xa1, 0x9b, 0xd0, 0x07, 0x2a, 0x1d, 0x8c, 0xe3, 0x53,
	0xb2, 0xab, 0xbd, 0xc0, 0xd2, 0x99, 0xdd, 0xf6, 0x95, 0x46, 0x5c, 0x26, 0x0a, 0xc5, 0x74, 0x33,
	0x1e, 0x7d, 0x93, 0x54, 0x62, 0x90, 0x0b, 0x9e, 0x9e, 0x7a, 0xb1, 0x3f, 0x05, 0xab, 0x80, 0x47,
	0x9b, 0x19, 0x76, 0xec, 0x4f, 0x81, 0xbe, 0x42, 0x76, 0x75, 0xf9, 0xb3, 0xda, 0x67, 0xab, 0xd6,
	0x8f, 0x05, 0xf2, 0xf2, 0x61, 0x6f, 0x70, 0x7f, 0xd0, 0x3b, 0xd6, 0xbb, 0xb5, 0xa5, 0xf4, 0x1e,
	0xa9, 0xae, 0x25, 0xd1, 0xf8, 0x2c, 0xb6, 0x77, 0xfe, 0x29, 0xb6, 0x0b, 0x81, 0x5c, 0x7c, 0xeb,
	0xa8, 0x10, 0xa2, 0xf7, 0x48, 0x1d, 0x1e, 0x32, 0x21, 0x59, 0x1c, 0x79, 0xd9, 0x0f, 0x8c, 0xd4,
	0xec, 0xbe, 0xfd, 0x7c, 0x55, 0xd4, 0xdb, 0x5f, 0xf3, 0x33, 0x90, 0x3e, 0x20, 0x35, 0x16, 0x4b,
	0x48, 0x47, 0xfe, 0xba, 0xd0, 0x2a, 0xbb, 0x5a, 0xf7, 0xfd, 0xeb, 0xf7, 0x52, 0x7f, 0xcd, 0xc7,
	0x13, 0xaa, 0x2c, 0xbf, 0x6c, 0xfd, 0x54, 0xc0, 0xfb, 0x96, 0x6f, 0x36, 0xea, 0x91, 0x4a, 0xd6,
	0xba, 0x79, 0x63, 0x3e, 0x7e, 0x81, 0xee, 0xdd, 0xb4, 0x80, 0x6b, 0x8a, 0x0b, 0x80, 0xde, 0x25,
	0x9b, 0x3c, 0xb3, 0x4b, 0x92, 0xd9, 0xd4, 0xfa, 0xf7, 0xc6, 0x40, 0xa5, 0xda, 0x9a, 0xaa, 0xb1,
	0xff, 0xdd, 0xa1, 0xdf, 0x8b, 0xa4, 0xa6, 0x0a, 0x95, 0x04, 0x27, 0x4c, 0x6e, 0xee, 0x15, 0x8e,
	0x3b, 0x6c, 0x45, 0x3d, 0x8d, 0x4a, 0x0a, 0xc0, 0x3e, 0x8c, 0x48, 0x5d, 0xcd, 0xf7, 0x79, 0x12,
	0xac, 0x7b, 0x40, 0x58, 0x85, 0xe6, 0x76, 0xdb, 0xec, 0x7e, 0xf2, 0x9f, 0x1c, 0x7c, 0xb6, 0x61,
	0xdd, 0x5a, 0x14, 0x24, 0xf7, 0x93, 0x20, 0x03, 0x05, 0x7d, 0x83, 0x98, 0xa3, 0x09, 0x80, 0xf4,
	0x26, 0xfe, 0x10, 0x26, 0x59, 0xd7, 0x13, 0x84, 0xbe, 0x50, 0x88, 0xba, 0x34, 0x01, 0xa4, 0x92,
	0x8d, 0x18, 0x84, 0xde, 0x78, 0x81, 0xb3, 0xae, 0xec, 0x9a, 0x1b, 0xec, 0xf3, 0x85, 0xba, 0xe9,
	0x2a, 0xd8, 0xec, 0xe2, 0xec, 0xe0, 0x86, 0x72, 0x14, 0x24, 0x7a, 0x66, 0xd2, 0x13, 0xb2, 0xa7,
	0xeb, 0x23, 0xac, 0x12, 0xa6, 0x70, 0x83, 0x11, 0xb6, 0x56, 0xa2, 0x5f, 0x93, 0xca, 0xd4, 0x17,
	0x12, 0x52, 0x1c, 0xe8, 0xc2, 0x2a, 0xbf, 0x80, 0x72, 0xfe, 0x7d, 0x70, 0x4d, 0x2d, 0xa7, 0xde,
	0x02, 0x41, 0xbf, 0x21, 0x95, 0xc8, 0x97, 0xb0, 0xf0, 0x97, 0xba, 0x19, 0x4c, 0x6c, 0x86, 0x8f,
	0xae, 0xaf, 0xde, 0x9b, 0xf0, 0x59, 0x78, 0xa8, 0x25, 0xb4, 0x7c, 0x74, 0xb1, 0xa0, 0xaf, 0x92,
	0x3d, 0x21, 0xc6, 0xde, 0x29, 0x2c, 0xad, 0xaa, 0x1e, 0x33, 0x42, 0x8c, 0xef, 0xc2, 0x52, 0x99,
	0xad, 0xca, 0xb2, 0xc9, 0xaa, 0xd6, 0x34, 0xda, 0x55, 0xd7, 0xd4, 0x18, 0x86, 0x76, 0x54, 0x2c,
	0x91, 0xba, 0x79, 0x54, 0x2c, 0x55, 0xea, 0xd5, 0xcf, 0x7e, 0x30, 0x1e, 0x9d, 0xdb, 0x5b, 0x8f,
	0xcf, 0xed, 0xad, 0xa7, 0xe7, 0xb6, 0xf1, 0xd7, 0xb9, 0x6d, 0x7c, 0xbb, 0xb2, 0x8d, 0x9f, 0x57,
	0xb6, 0xf1, 0xdb, 0xca, 0x36, 0x1e, 0xad, 0x6c, 0xe3, 0xf1, 0xca, 0x36, 0xfe, 0x58, 0xd9, 0xc6,
	0x9f, 0x2b, 0x7b, 0xeb, 0xe9, 0xca, 0x36, 0xbe, 0x7b, 0x62, 0x6f, 0xfd, 0xfa, 0xc4, 0x36, 0xbe,
	0x7a, 0x10, 0xf1, 0xe4, 0x34, 0x72, 0xd4, 0xd3, 0xa6, 0xe2, 0x77, 0x66, 0xb9, 0x67, 0xf5, 0x20,
	0x49, 0xf9, 0x9c, 0x85, 0x90, 0x1e, 0xac, 0x7f, 0x77, 0x92, 0x61, 0xc4, 0x3b, 0xf0, 0x50, 0x66,
	0xef, 0xf0, 0x73, 0x9f, 0xe3, 0xe1, 0x2e, 0xbe, 0xc4, 0xef, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff,
	0xb9, 0xac, 0x8c, 0x07, 0xd0, 0x08, 0x00, 0x00,
}

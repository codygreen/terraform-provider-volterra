// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/site_types.proto

/*
	Package views is a generated protocol buffer package.

	It is generated from these files:
		ves.io/schema/views/site_types.proto
		ves.io/schema/views/storage_types.proto
		ves.io/schema/views/types.proto

	It has these top-level messages:
		AWSVPCParamsType
		AWSVPCchoiceType
		CloudSubnetParamType
		CloudSubnetType
		AWSVPCOneInterfaceNodeType
		AWSVPCTwoInterfaceNodeType
		AzureVnetParamsType
		AzureVnetType
		AzureVnetChoiceType
		AzureSubnetType
		AzureSubnetChoiceType
		AzureVnetOneInterfaceNodeType
		AzureVnetTwoInterfaceNodeType
		GCPVPCNetworkParamsType
		GCPVPCNetworkAutogenerateParamsType
		GCPVPCNetworkType
		GCPSubnetType
		GCPSubnetParamsType
		GCPVPCNetworkChoiceType
		GCPVPCSubnetChoiceType
		SiteStaticRoutesType
		SiteStaticRoutesListType
		GlobalNetworkConnectionType
		GlobalNetworkConnectionListType
		AllowedVIPPorts
		CustomPorts
		StorageClassListType
		StorageClassType
		StorageClassOpenebsEnterpriseType
		ObjectRefType
		SiteLocator
		WhereVirtualNetwork
		WhereSite
		WhereVirtualSite
		WhereVK8SService
		WhereType
		WhereTypeSiteVsite
		AdvertisePublic
		AdvertiseCustom
		AdvertiseSiteVsite
		CustomCiphers
		TlsConfig
		OriginPoolWithWeight
		PrefixStringListType
		GlobalConnectorType
		VolterraSoftwareType
		OperatingSystemType
*/
package views

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// AWS VPC Parameters
//
// x-displayName: "AWS VPC Parameters"
// Parameters to create new AWS VPC
type AWSVPCParamsType struct {
	// AWS VPC Name
	//
	// x-displayName: "AWS VPC Name"
	// x-required
	// x-example "MyVpc"
	// Name for your AWS VPC
	//
	// Types that are valid to be assigned to NameChoice:
	//	*AWSVPCParamsType_NameTag
	//	*AWSVPCParamsType_Autogenerate
	NameChoice isAWSVPCParamsType_NameChoice `protobuf_oneof:"name_choice"`
	// Primary IPv4 CIDR block
	//
	// x-displayName: "Primary IPv4 CIDR block"
	// x-required
	// x-example: "10.1.0.0/16"
	// IPv4 CIDR block for this VPC. It has to be private address space.
	// The Primary IPv4 block cannot be modified. All subnets prefixes in this VPC must be part of this CIDR block.
	PrimaryIpv4 string `protobuf:"bytes,3,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
	// Allocate IPv6 CIDR block
	//
	// x-displayName: "Allocate IPv6 CIDR block from AWS"
	// Allocate IPv6 CIDR block from AWS
	AllocateIpv6 bool `protobuf:"varint,6,opt,name=allocate_ipv6,json=allocateIpv6,proto3" json:"allocate_ipv6,omitempty"`
}

func (m *AWSVPCParamsType) Reset()                    { *m = AWSVPCParamsType{} }
func (*AWSVPCParamsType) ProtoMessage()               {}
func (*AWSVPCParamsType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{0} }

type isAWSVPCParamsType_NameChoice interface {
	isAWSVPCParamsType_NameChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCParamsType_NameTag struct {
	NameTag string `protobuf:"bytes,2,opt,name=name_tag,json=nameTag,proto3,oneof"`
}
type AWSVPCParamsType_Autogenerate struct {
	Autogenerate *ves_io_schema4.Empty `protobuf:"bytes,8,opt,name=autogenerate,oneof"`
}

func (*AWSVPCParamsType_NameTag) isAWSVPCParamsType_NameChoice()      {}
func (*AWSVPCParamsType_Autogenerate) isAWSVPCParamsType_NameChoice() {}

func (m *AWSVPCParamsType) GetNameChoice() isAWSVPCParamsType_NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

func (m *AWSVPCParamsType) GetNameTag() string {
	if x, ok := m.GetNameChoice().(*AWSVPCParamsType_NameTag); ok {
		return x.NameTag
	}
	return ""
}

func (m *AWSVPCParamsType) GetAutogenerate() *ves_io_schema4.Empty {
	if x, ok := m.GetNameChoice().(*AWSVPCParamsType_Autogenerate); ok {
		return x.Autogenerate
	}
	return nil
}

func (m *AWSVPCParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

func (m *AWSVPCParamsType) GetAllocateIpv6() bool {
	if m != nil {
		return m.AllocateIpv6
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AWSVPCParamsType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AWSVPCParamsType_OneofMarshaler, _AWSVPCParamsType_OneofUnmarshaler, _AWSVPCParamsType_OneofSizer, []interface{}{
		(*AWSVPCParamsType_NameTag)(nil),
		(*AWSVPCParamsType_Autogenerate)(nil),
	}
}

func _AWSVPCParamsType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AWSVPCParamsType)
	// name_choice
	switch x := m.NameChoice.(type) {
	case *AWSVPCParamsType_NameTag:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.NameTag)
	case *AWSVPCParamsType_Autogenerate:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Autogenerate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AWSVPCParamsType.NameChoice has unexpected type %T", x)
	}
	return nil
}

func _AWSVPCParamsType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AWSVPCParamsType)
	switch tag {
	case 2: // name_choice.name_tag
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.NameChoice = &AWSVPCParamsType_NameTag{x}
		return true, err
	case 8: // name_choice.autogenerate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NameChoice = &AWSVPCParamsType_Autogenerate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AWSVPCParamsType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AWSVPCParamsType)
	// name_choice
	switch x := m.NameChoice.(type) {
	case *AWSVPCParamsType_NameTag:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.NameTag)))
		n += len(x.NameTag)
	case *AWSVPCParamsType_Autogenerate:
		s := proto.Size(x.Autogenerate)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AWS VPC choice
//
// x-displayName: "AWS VPC choice"
// This defines choice about AWS VPC for a view
type AWSVPCchoiceType struct {
	// Choice of existing or new VPC
	//
	// x-displayName: "Select existing VPC or create new VPC"
	// x-required
	// This is choice of existing VPC or new VPC
	//
	// Types that are valid to be assigned to Choice:
	//	*AWSVPCchoiceType_NewVpc
	//	*AWSVPCchoiceType_VpcId
	Choice isAWSVPCchoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AWSVPCchoiceType) Reset()                    { *m = AWSVPCchoiceType{} }
func (*AWSVPCchoiceType) ProtoMessage()               {}
func (*AWSVPCchoiceType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{1} }

type isAWSVPCchoiceType_Choice interface {
	isAWSVPCchoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCchoiceType_NewVpc struct {
	NewVpc *AWSVPCParamsType `protobuf:"bytes,1,opt,name=new_vpc,json=newVpc,oneof"`
}
type AWSVPCchoiceType_VpcId struct {
	VpcId string `protobuf:"bytes,2,opt,name=vpc_id,json=vpcId,proto3,oneof"`
}

func (*AWSVPCchoiceType_NewVpc) isAWSVPCchoiceType_Choice() {}
func (*AWSVPCchoiceType_VpcId) isAWSVPCchoiceType_Choice()  {}

func (m *AWSVPCchoiceType) GetChoice() isAWSVPCchoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AWSVPCchoiceType) GetNewVpc() *AWSVPCParamsType {
	if x, ok := m.GetChoice().(*AWSVPCchoiceType_NewVpc); ok {
		return x.NewVpc
	}
	return nil
}

func (m *AWSVPCchoiceType) GetVpcId() string {
	if x, ok := m.GetChoice().(*AWSVPCchoiceType_VpcId); ok {
		return x.VpcId
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AWSVPCchoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AWSVPCchoiceType_OneofMarshaler, _AWSVPCchoiceType_OneofUnmarshaler, _AWSVPCchoiceType_OneofSizer, []interface{}{
		(*AWSVPCchoiceType_NewVpc)(nil),
		(*AWSVPCchoiceType_VpcId)(nil),
	}
}

func _AWSVPCchoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AWSVPCchoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AWSVPCchoiceType_NewVpc:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewVpc); err != nil {
			return err
		}
	case *AWSVPCchoiceType_VpcId:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.VpcId)
	case nil:
	default:
		return fmt.Errorf("AWSVPCchoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _AWSVPCchoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AWSVPCchoiceType)
	switch tag {
	case 1: // choice.new_vpc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AWSVPCParamsType)
		err := b.DecodeMessage(msg)
		m.Choice = &AWSVPCchoiceType_NewVpc{msg}
		return true, err
	case 2: // choice.vpc_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Choice = &AWSVPCchoiceType_VpcId{x}
		return true, err
	default:
		return false, nil
	}
}

func _AWSVPCchoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AWSVPCchoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AWSVPCchoiceType_NewVpc:
		s := proto.Size(x.NewVpc)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AWSVPCchoiceType_VpcId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.VpcId)))
		n += len(x.VpcId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Cloud Subnet Param
//
// x-displayName: "New Cloud Subnet Parameters"
// Parameters for creating a new cloud subnet
type CloudSubnetParamType struct {
	// IPv4 Subnet
	//
	// x-displayName: "IPv4 Subnet"
	// x-required
	// x-example: "10.1.2.0/24"
	// IPv4 subnet prefix for this subnet
	Ipv4 string `protobuf:"bytes,1,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	// IPv6 Subnet
	//
	// x-displayName: "IPv6 Subnet"
	// x-example: "1234:568:abcd:9100::/64"
	// IPv6 subnet prefix for this subnet
	Ipv6 string `protobuf:"bytes,2,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
}

func (m *CloudSubnetParamType) Reset()                    { *m = CloudSubnetParamType{} }
func (*CloudSubnetParamType) ProtoMessage()               {}
func (*CloudSubnetParamType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{2} }

func (m *CloudSubnetParamType) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

func (m *CloudSubnetParamType) GetIpv6() string {
	if m != nil {
		return m.Ipv6
	}
	return ""
}

// Cloud Subnet
//
// x-displayName: "AWS Subnet"
// Parameters for AWS subnet
type CloudSubnetType struct {
	// Choice of subnet
	//
	// x-displayName: "Select Existing Subnet or Create New"
	// x-required
	// Subnet for the Single interface of the site
	//
	// Types that are valid to be assigned to Choice:
	//	*CloudSubnetType_SubnetParam
	//	*CloudSubnetType_ExistingSubnetId
	Choice isCloudSubnetType_Choice `protobuf_oneof:"choice"`
}

func (m *CloudSubnetType) Reset()                    { *m = CloudSubnetType{} }
func (*CloudSubnetType) ProtoMessage()               {}
func (*CloudSubnetType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{3} }

type isCloudSubnetType_Choice interface {
	isCloudSubnetType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudSubnetType_SubnetParam struct {
	SubnetParam *CloudSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam,oneof"`
}
type CloudSubnetType_ExistingSubnetId struct {
	ExistingSubnetId string `protobuf:"bytes,2,opt,name=existing_subnet_id,json=existingSubnetId,proto3,oneof"`
}

func (*CloudSubnetType_SubnetParam) isCloudSubnetType_Choice()      {}
func (*CloudSubnetType_ExistingSubnetId) isCloudSubnetType_Choice() {}

func (m *CloudSubnetType) GetChoice() isCloudSubnetType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *CloudSubnetType) GetSubnetParam() *CloudSubnetParamType {
	if x, ok := m.GetChoice().(*CloudSubnetType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *CloudSubnetType) GetExistingSubnetId() string {
	if x, ok := m.GetChoice().(*CloudSubnetType_ExistingSubnetId); ok {
		return x.ExistingSubnetId
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CloudSubnetType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CloudSubnetType_OneofMarshaler, _CloudSubnetType_OneofUnmarshaler, _CloudSubnetType_OneofSizer, []interface{}{
		(*CloudSubnetType_SubnetParam)(nil),
		(*CloudSubnetType_ExistingSubnetId)(nil),
	}
}

func _CloudSubnetType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CloudSubnetType)
	// choice
	switch x := m.Choice.(type) {
	case *CloudSubnetType_SubnetParam:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubnetParam); err != nil {
			return err
		}
	case *CloudSubnetType_ExistingSubnetId:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ExistingSubnetId)
	case nil:
	default:
		return fmt.Errorf("CloudSubnetType.Choice has unexpected type %T", x)
	}
	return nil
}

func _CloudSubnetType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CloudSubnetType)
	switch tag {
	case 1: // choice.subnet_param
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudSubnetParamType)
		err := b.DecodeMessage(msg)
		m.Choice = &CloudSubnetType_SubnetParam{msg}
		return true, err
	case 2: // choice.existing_subnet_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Choice = &CloudSubnetType_ExistingSubnetId{x}
		return true, err
	default:
		return false, nil
	}
}

func _CloudSubnetType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CloudSubnetType)
	// choice
	switch x := m.Choice.(type) {
	case *CloudSubnetType_SubnetParam:
		s := proto.Size(x.SubnetParam)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CloudSubnetType_ExistingSubnetId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ExistingSubnetId)))
		n += len(x.ExistingSubnetId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Single Interface Node
//
// x-displayName: "Single Interface Node"
// Parameters for creating Single interface Node in one AZ
type AWSVPCOneInterfaceNodeType struct {
	// AWS AZ
	//
	// x-displayName: "AWS AZ Name"
	// x-required
	// x-example: "us-west-2a"
	// AWS availability zone, must be consistent with the selected AWS region.
	AwsAzName string `protobuf:"bytes,1,opt,name=aws_az_name,json=awsAzName,proto3" json:"aws_az_name,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for local Interface"
	// Subnets for the site local interface of the node
	LocalSubnet *CloudSubnetType `protobuf:"bytes,2,opt,name=local_subnet,json=localSubnet" json:"local_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,4,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AWSVPCOneInterfaceNodeType) Reset()      { *m = AWSVPCOneInterfaceNodeType{} }
func (*AWSVPCOneInterfaceNodeType) ProtoMessage() {}
func (*AWSVPCOneInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{4}
}

func (m *AWSVPCOneInterfaceNodeType) GetAwsAzName() string {
	if m != nil {
		return m.AwsAzName
	}
	return ""
}

func (m *AWSVPCOneInterfaceNodeType) GetLocalSubnet() *CloudSubnetType {
	if m != nil {
		return m.LocalSubnet
	}
	return nil
}

func (m *AWSVPCOneInterfaceNodeType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// Two Interface Node
//
// x-displayName: "Two Interface Node"
// Parameters for creating two interface Node in one AZ
type AWSVPCTwoInterfaceNodeType struct {
	// AWS AZ
	//
	// x-displayName: "AWS AZ Name"
	// x-required
	// x-example: "us-west-2a"
	// AWS availability zone, must be consistent with the selected AWS region.
	AwsAzName string `protobuf:"bytes,1,opt,name=aws_az_name,json=awsAzName,proto3" json:"aws_az_name,omitempty"`
	// Inside Subnet Choices
	//
	// x-displayName: "Subnet for Inside Interface"
	// x-required
	// Subnet for the inside interface of the node
	//
	// Types that are valid to be assigned to Choice:
	//	*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet
	//	*AWSVPCTwoInterfaceNodeType_InsideSubnet
	Choice isAWSVPCTwoInterfaceNodeType_Choice `protobuf_oneof:"choice"`
	// Outside Subnet
	//
	// x-displayName: "Subnet for Outside Interface"
	// x-required
	// Subnet for the outside interface of the node
	OutsideSubnet *CloudSubnetType `protobuf:"bytes,3,opt,name=outside_subnet,json=outsideSubnet" json:"outside_subnet,omitempty"`
	// Workload Subnet
	//
	// x-displayName: "Workload Subnet"
	// Subnet in which workloads are launched
	WorkloadSubnet *CloudSubnetType `protobuf:"bytes,7,opt,name=workload_subnet,json=workloadSubnet" json:"workload_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,8,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AWSVPCTwoInterfaceNodeType) Reset()      { *m = AWSVPCTwoInterfaceNodeType{} }
func (*AWSVPCTwoInterfaceNodeType) ProtoMessage() {}
func (*AWSVPCTwoInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{5}
}

type isAWSVPCTwoInterfaceNodeType_Choice interface {
	isAWSVPCTwoInterfaceNodeType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet struct {
	ReservedInsideSubnet *ves_io_schema4.Empty `protobuf:"bytes,6,opt,name=reserved_inside_subnet,json=reservedInsideSubnet,oneof"`
}
type AWSVPCTwoInterfaceNodeType_InsideSubnet struct {
	InsideSubnet *CloudSubnetType `protobuf:"bytes,2,opt,name=inside_subnet,json=insideSubnet,oneof"`
}

func (*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) isAWSVPCTwoInterfaceNodeType_Choice() {}
func (*AWSVPCTwoInterfaceNodeType_InsideSubnet) isAWSVPCTwoInterfaceNodeType_Choice()         {}

func (m *AWSVPCTwoInterfaceNodeType) GetChoice() isAWSVPCTwoInterfaceNodeType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetAwsAzName() string {
	if m != nil {
		return m.AwsAzName
	}
	return ""
}

func (m *AWSVPCTwoInterfaceNodeType) GetReservedInsideSubnet() *ves_io_schema4.Empty {
	if x, ok := m.GetChoice().(*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet); ok {
		return x.ReservedInsideSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetInsideSubnet() *CloudSubnetType {
	if x, ok := m.GetChoice().(*AWSVPCTwoInterfaceNodeType_InsideSubnet); ok {
		return x.InsideSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetOutsideSubnet() *CloudSubnetType {
	if m != nil {
		return m.OutsideSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetWorkloadSubnet() *CloudSubnetType {
	if m != nil {
		return m.WorkloadSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AWSVPCTwoInterfaceNodeType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AWSVPCTwoInterfaceNodeType_OneofMarshaler, _AWSVPCTwoInterfaceNodeType_OneofUnmarshaler, _AWSVPCTwoInterfaceNodeType_OneofSizer, []interface{}{
		(*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet)(nil),
		(*AWSVPCTwoInterfaceNodeType_InsideSubnet)(nil),
	}
}

func _AWSVPCTwoInterfaceNodeType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AWSVPCTwoInterfaceNodeType)
	// choice
	switch x := m.Choice.(type) {
	case *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReservedInsideSubnet); err != nil {
			return err
		}
	case *AWSVPCTwoInterfaceNodeType_InsideSubnet:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InsideSubnet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AWSVPCTwoInterfaceNodeType.Choice has unexpected type %T", x)
	}
	return nil
}

func _AWSVPCTwoInterfaceNodeType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AWSVPCTwoInterfaceNodeType)
	switch tag {
	case 6: // choice.reserved_inside_subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Choice = &AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet{msg}
		return true, err
	case 2: // choice.inside_subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudSubnetType)
		err := b.DecodeMessage(msg)
		m.Choice = &AWSVPCTwoInterfaceNodeType_InsideSubnet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AWSVPCTwoInterfaceNodeType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AWSVPCTwoInterfaceNodeType)
	// choice
	switch x := m.Choice.(type) {
	case *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet:
		s := proto.Size(x.ReservedInsideSubnet)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AWSVPCTwoInterfaceNodeType_InsideSubnet:
		s := proto.Size(x.InsideSubnet)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Azure Vnet Parameters
//
// x-displayName: "Azure Vnet Parameters"
// Parameters to create a new Azure Vnet
type AzureVnetParamsType struct {
	// Azure Vnet Name
	//
	// x-displayName: "Azure Vnet Name"
	// x-required
	// x-example: "MyVnet"
	// Name for your Azure Vnet
	//
	// Types that are valid to be assigned to NameChoice:
	//	*AzureVnetParamsType_Name
	//	*AzureVnetParamsType_Autogenerate
	NameChoice isAzureVnetParamsType_NameChoice `protobuf_oneof:"name_choice"`
	// IPv4 CIDR block
	//
	// x-displayName: "IPv4 CIDR block"
	// x-required
	// x-example: "10.1.0.0/16"
	// IPv4 CIDR block for this Vnet. It has to be private address space.
	PrimaryIpv4 string `protobuf:"bytes,2,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
}

func (m *AzureVnetParamsType) Reset()                    { *m = AzureVnetParamsType{} }
func (*AzureVnetParamsType) ProtoMessage()               {}
func (*AzureVnetParamsType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{6} }

type isAzureVnetParamsType_NameChoice interface {
	isAzureVnetParamsType_NameChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureVnetParamsType_Name struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3,oneof"`
}
type AzureVnetParamsType_Autogenerate struct {
	Autogenerate *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=autogenerate,oneof"`
}

func (*AzureVnetParamsType_Name) isAzureVnetParamsType_NameChoice()         {}
func (*AzureVnetParamsType_Autogenerate) isAzureVnetParamsType_NameChoice() {}

func (m *AzureVnetParamsType) GetNameChoice() isAzureVnetParamsType_NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

func (m *AzureVnetParamsType) GetName() string {
	if x, ok := m.GetNameChoice().(*AzureVnetParamsType_Name); ok {
		return x.Name
	}
	return ""
}

func (m *AzureVnetParamsType) GetAutogenerate() *ves_io_schema4.Empty {
	if x, ok := m.GetNameChoice().(*AzureVnetParamsType_Autogenerate); ok {
		return x.Autogenerate
	}
	return nil
}

func (m *AzureVnetParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AzureVnetParamsType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AzureVnetParamsType_OneofMarshaler, _AzureVnetParamsType_OneofUnmarshaler, _AzureVnetParamsType_OneofSizer, []interface{}{
		(*AzureVnetParamsType_Name)(nil),
		(*AzureVnetParamsType_Autogenerate)(nil),
	}
}

func _AzureVnetParamsType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AzureVnetParamsType)
	// name_choice
	switch x := m.NameChoice.(type) {
	case *AzureVnetParamsType_Name:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Name)
	case *AzureVnetParamsType_Autogenerate:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Autogenerate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AzureVnetParamsType.NameChoice has unexpected type %T", x)
	}
	return nil
}

func _AzureVnetParamsType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AzureVnetParamsType)
	switch tag {
	case 1: // name_choice.name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.NameChoice = &AzureVnetParamsType_Name{x}
		return true, err
	case 4: // name_choice.autogenerate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NameChoice = &AzureVnetParamsType_Autogenerate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AzureVnetParamsType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AzureVnetParamsType)
	// name_choice
	switch x := m.NameChoice.(type) {
	case *AzureVnetParamsType_Name:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case *AzureVnetParamsType_Autogenerate:
		s := proto.Size(x.Autogenerate)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Azure Existing Vnet Type
//
// x-displayName: "Azure Existing Vnet Type"
// Resource group and name of existing Azure Vnet
type AzureVnetType struct {
	// Existing Vnet Resource Group
	//
	// x-displayName: "Existing Vnet Resource Group"
	// x-required
	// x-example:"MyResourceGroup"
	// Resource group of existing Vnet
	ResourceGroup string `protobuf:"bytes,1,opt,name=resource_group,json=resourceGroup,proto3" json:"resource_group,omitempty"`
	// Existing Vnet Name
	//
	// x-displayName: "Existing Vnet Name"
	// x-required
	// x-example:"MyVnet"
	// Name of existing Vnet
	VnetName string `protobuf:"bytes,2,opt,name=vnet_name,json=vnetName,proto3" json:"vnet_name,omitempty"`
}

func (m *AzureVnetType) Reset()                    { *m = AzureVnetType{} }
func (*AzureVnetType) ProtoMessage()               {}
func (*AzureVnetType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{7} }

func (m *AzureVnetType) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *AzureVnetType) GetVnetName() string {
	if m != nil {
		return m.VnetName
	}
	return ""
}

// Azure Vnet choice
//
// x-displayName: "Azure Vnet choice"
// This defines choice about Azure Vnet for a view
type AzureVnetChoiceType struct {
	// Choice of existing or new Vnet
	//
	// x-displayName: "Select existing Vnet or create new Vnet"
	// x-required
	// This is choice of existing Vnet or new Vnet
	//
	// Types that are valid to be assigned to Choice:
	//	*AzureVnetChoiceType_NewVnet
	//	*AzureVnetChoiceType_ExistingVnet
	Choice isAzureVnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AzureVnetChoiceType) Reset()                    { *m = AzureVnetChoiceType{} }
func (*AzureVnetChoiceType) ProtoMessage()               {}
func (*AzureVnetChoiceType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{8} }

type isAzureVnetChoiceType_Choice interface {
	isAzureVnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureVnetChoiceType_NewVnet struct {
	NewVnet *AzureVnetParamsType `protobuf:"bytes,2,opt,name=new_vnet,json=newVnet,oneof"`
}
type AzureVnetChoiceType_ExistingVnet struct {
	ExistingVnet *AzureVnetType `protobuf:"bytes,3,opt,name=existing_vnet,json=existingVnet,oneof"`
}

func (*AzureVnetChoiceType_NewVnet) isAzureVnetChoiceType_Choice()      {}
func (*AzureVnetChoiceType_ExistingVnet) isAzureVnetChoiceType_Choice() {}

func (m *AzureVnetChoiceType) GetChoice() isAzureVnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AzureVnetChoiceType) GetNewVnet() *AzureVnetParamsType {
	if x, ok := m.GetChoice().(*AzureVnetChoiceType_NewVnet); ok {
		return x.NewVnet
	}
	return nil
}

func (m *AzureVnetChoiceType) GetExistingVnet() *AzureVnetType {
	if x, ok := m.GetChoice().(*AzureVnetChoiceType_ExistingVnet); ok {
		return x.ExistingVnet
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AzureVnetChoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AzureVnetChoiceType_OneofMarshaler, _AzureVnetChoiceType_OneofUnmarshaler, _AzureVnetChoiceType_OneofSizer, []interface{}{
		(*AzureVnetChoiceType_NewVnet)(nil),
		(*AzureVnetChoiceType_ExistingVnet)(nil),
	}
}

func _AzureVnetChoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AzureVnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AzureVnetChoiceType_NewVnet:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewVnet); err != nil {
			return err
		}
	case *AzureVnetChoiceType_ExistingVnet:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExistingVnet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AzureVnetChoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _AzureVnetChoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AzureVnetChoiceType)
	switch tag {
	case 2: // choice.new_vnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AzureVnetParamsType)
		err := b.DecodeMessage(msg)
		m.Choice = &AzureVnetChoiceType_NewVnet{msg}
		return true, err
	case 3: // choice.existing_vnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AzureVnetType)
		err := b.DecodeMessage(msg)
		m.Choice = &AzureVnetChoiceType_ExistingVnet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AzureVnetChoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AzureVnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AzureVnetChoiceType_NewVnet:
		s := proto.Size(x.NewVnet)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AzureVnetChoiceType_ExistingVnet:
		s := proto.Size(x.ExistingVnet)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetType struct {
	// Existing Subnet Name
	//
	// x-displayName: "Subnet Name"
	// x-example: "MySubnet"
	// x-required
	// Name of existing subnet.
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
	// Existing Subnet Resource Group
	//
	// x-displayName: "Subnet Resource Group"
	// x-example: "MySubnet"
	// Resource group for this subnet.
	//
	// Types that are valid to be assigned to ResourceGroupChoice:
	//	*AzureSubnetType_SubnetResourceGrp
	//	*AzureSubnetType_VnetResourceGroup
	ResourceGroupChoice isAzureSubnetType_ResourceGroupChoice `protobuf_oneof:"resource_group_choice"`
}

func (m *AzureSubnetType) Reset()                    { *m = AzureSubnetType{} }
func (*AzureSubnetType) ProtoMessage()               {}
func (*AzureSubnetType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{9} }

type isAzureSubnetType_ResourceGroupChoice interface {
	isAzureSubnetType_ResourceGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureSubnetType_SubnetResourceGrp struct {
	SubnetResourceGrp string `protobuf:"bytes,2,opt,name=subnet_resource_grp,json=subnetResourceGrp,proto3,oneof"`
}
type AzureSubnetType_VnetResourceGroup struct {
	VnetResourceGroup *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=vnet_resource_group,json=vnetResourceGroup,oneof"`
}

func (*AzureSubnetType_SubnetResourceGrp) isAzureSubnetType_ResourceGroupChoice() {}
func (*AzureSubnetType_VnetResourceGroup) isAzureSubnetType_ResourceGroupChoice() {}

func (m *AzureSubnetType) GetResourceGroupChoice() isAzureSubnetType_ResourceGroupChoice {
	if m != nil {
		return m.ResourceGroupChoice
	}
	return nil
}

func (m *AzureSubnetType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

func (m *AzureSubnetType) GetSubnetResourceGrp() string {
	if x, ok := m.GetResourceGroupChoice().(*AzureSubnetType_SubnetResourceGrp); ok {
		return x.SubnetResourceGrp
	}
	return ""
}

func (m *AzureSubnetType) GetVnetResourceGroup() *ves_io_schema4.Empty {
	if x, ok := m.GetResourceGroupChoice().(*AzureSubnetType_VnetResourceGroup); ok {
		return x.VnetResourceGroup
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AzureSubnetType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AzureSubnetType_OneofMarshaler, _AzureSubnetType_OneofUnmarshaler, _AzureSubnetType_OneofSizer, []interface{}{
		(*AzureSubnetType_SubnetResourceGrp)(nil),
		(*AzureSubnetType_VnetResourceGroup)(nil),
	}
}

func _AzureSubnetType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AzureSubnetType)
	// resource_group_choice
	switch x := m.ResourceGroupChoice.(type) {
	case *AzureSubnetType_SubnetResourceGrp:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.SubnetResourceGrp)
	case *AzureSubnetType_VnetResourceGroup:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VnetResourceGroup); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AzureSubnetType.ResourceGroupChoice has unexpected type %T", x)
	}
	return nil
}

func _AzureSubnetType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AzureSubnetType)
	switch tag {
	case 2: // resource_group_choice.subnet_resource_grp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ResourceGroupChoice = &AzureSubnetType_SubnetResourceGrp{x}
		return true, err
	case 4: // resource_group_choice.vnet_resource_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ResourceGroupChoice = &AzureSubnetType_VnetResourceGroup{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AzureSubnetType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AzureSubnetType)
	// resource_group_choice
	switch x := m.ResourceGroupChoice.(type) {
	case *AzureSubnetType_SubnetResourceGrp:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SubnetResourceGrp)))
		n += len(x.SubnetResourceGrp)
	case *AzureSubnetType_VnetResourceGroup:
		s := proto.Size(x.VnetResourceGroup)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetChoiceType struct {
	// Choice of subnet
	//
	// x-displayName: "Select Existing Subnet or Create New"
	// x-required
	// Subnet for the Single interface of the site
	//
	// Types that are valid to be assigned to Choice:
	//	*AzureSubnetChoiceType_SubnetParam
	//	*AzureSubnetChoiceType_Subnet
	Choice isAzureSubnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AzureSubnetChoiceType) Reset()                    { *m = AzureSubnetChoiceType{} }
func (*AzureSubnetChoiceType) ProtoMessage()               {}
func (*AzureSubnetChoiceType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{10} }

type isAzureSubnetChoiceType_Choice interface {
	isAzureSubnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureSubnetChoiceType_SubnetParam struct {
	SubnetParam *CloudSubnetParamType `protobuf:"bytes,2,opt,name=subnet_param,json=subnetParam,oneof"`
}
type AzureSubnetChoiceType_Subnet struct {
	Subnet *AzureSubnetType `protobuf:"bytes,3,opt,name=subnet,oneof"`
}

func (*AzureSubnetChoiceType_SubnetParam) isAzureSubnetChoiceType_Choice() {}
func (*AzureSubnetChoiceType_Subnet) isAzureSubnetChoiceType_Choice()      {}

func (m *AzureSubnetChoiceType) GetChoice() isAzureSubnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AzureSubnetChoiceType) GetSubnetParam() *CloudSubnetParamType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *AzureSubnetChoiceType) GetSubnet() *AzureSubnetType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceType_Subnet); ok {
		return x.Subnet
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AzureSubnetChoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AzureSubnetChoiceType_OneofMarshaler, _AzureSubnetChoiceType_OneofUnmarshaler, _AzureSubnetChoiceType_OneofSizer, []interface{}{
		(*AzureSubnetChoiceType_SubnetParam)(nil),
		(*AzureSubnetChoiceType_Subnet)(nil),
	}
}

func _AzureSubnetChoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AzureSubnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AzureSubnetChoiceType_SubnetParam:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubnetParam); err != nil {
			return err
		}
	case *AzureSubnetChoiceType_Subnet:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subnet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AzureSubnetChoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _AzureSubnetChoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AzureSubnetChoiceType)
	switch tag {
	case 2: // choice.subnet_param
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudSubnetParamType)
		err := b.DecodeMessage(msg)
		m.Choice = &AzureSubnetChoiceType_SubnetParam{msg}
		return true, err
	case 3: // choice.subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AzureSubnetType)
		err := b.DecodeMessage(msg)
		m.Choice = &AzureSubnetChoiceType_Subnet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AzureSubnetChoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AzureSubnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AzureSubnetChoiceType_SubnetParam:
		s := proto.Size(x.SubnetParam)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AzureSubnetChoiceType_Subnet:
		s := proto.Size(x.Subnet)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Single Interface Node
//
// x-displayName: "Single Interface Node"
// Parameters for creating Single interface Node in one AZ
type AzureVnetOneInterfaceNodeType struct {
	// Azure AZ
	//
	// x-displayName: "Azure AZ name"
	// x-required
	// x-example: "1"
	// Azure availability zone.
	AzureAz string `protobuf:"bytes,1,opt,name=azure_az,json=azureAz,proto3" json:"azure_az,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for local Interface"
	// Subnets for the site local interface of the node
	LocalSubnet *AzureSubnetChoiceType `protobuf:"bytes,2,opt,name=local_subnet,json=localSubnet" json:"local_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,4,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AzureVnetOneInterfaceNodeType) Reset()      { *m = AzureVnetOneInterfaceNodeType{} }
func (*AzureVnetOneInterfaceNodeType) ProtoMessage() {}
func (*AzureVnetOneInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{11}
}

func (m *AzureVnetOneInterfaceNodeType) GetAzureAz() string {
	if m != nil {
		return m.AzureAz
	}
	return ""
}

func (m *AzureVnetOneInterfaceNodeType) GetLocalSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.LocalSubnet
	}
	return nil
}

func (m *AzureVnetOneInterfaceNodeType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// Two Interface Node
//
// x-displayName: "Two Interface Node"
// Parameters for creating two interface Node in one AZ
type AzureVnetTwoInterfaceNodeType struct {
	// Azure AZ
	//
	// x-displayName: "Azure AZ Name"
	// x-required
	// x-example: "1"
	// Azure availability zone.
	AzureAz string `protobuf:"bytes,1,opt,name=azure_az,json=azureAz,proto3" json:"azure_az,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Inside Interface"
	// Subnets for the inside interface of the node
	InsideSubnet *AzureSubnetChoiceType `protobuf:"bytes,2,opt,name=inside_subnet,json=insideSubnet" json:"inside_subnet,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Outside Interface"
	// Subnets for the outside interface of the node
	OutsideSubnet *AzureSubnetChoiceType `protobuf:"bytes,3,opt,name=outside_subnet,json=outsideSubnet" json:"outside_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,5,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AzureVnetTwoInterfaceNodeType) Reset()      { *m = AzureVnetTwoInterfaceNodeType{} }
func (*AzureVnetTwoInterfaceNodeType) ProtoMessage() {}
func (*AzureVnetTwoInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{12}
}

func (m *AzureVnetTwoInterfaceNodeType) GetAzureAz() string {
	if m != nil {
		return m.AzureAz
	}
	return ""
}

func (m *AzureVnetTwoInterfaceNodeType) GetInsideSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.InsideSubnet
	}
	return nil
}

func (m *AzureVnetTwoInterfaceNodeType) GetOutsideSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.OutsideSubnet
	}
	return nil
}

func (m *AzureVnetTwoInterfaceNodeType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// GCP VPC Network Parameters
//
// x-displayName: "GCP VPC Network Manual Parameters"
// Parameters to create a new GCP VPC Network
type GCPVPCNetworkParamsType struct {
	// GCP VPC Network Name
	//
	// x-displayName: "GCP VPC Network Name"
	// x-required
	// x-example: "network1"
	// Name for your GCP VPC Network
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GCPVPCNetworkParamsType) Reset()      { *m = GCPVPCNetworkParamsType{} }
func (*GCPVPCNetworkParamsType) ProtoMessage() {}
func (*GCPVPCNetworkParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{13}
}

func (m *GCPVPCNetworkParamsType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GCP VPC Network Parameters Autogenerate
//
// x-displayName: "GCP VPC Network Autogenerated Parameters"
// Create a new GCP VPC Network with autogenerated name
type GCPVPCNetworkAutogenerateParamsType struct {
	// Autogenerate GCP VPC Network Name
	//
	// x-displayName: "Autogenerate GCP VPC Network Name"
	// Name for your GCP VPC Network will be autogenerated
	Autogenerate bool `protobuf:"varint,1,opt,name=autogenerate,proto3" json:"autogenerate,omitempty"`
}

func (m *GCPVPCNetworkAutogenerateParamsType) Reset()      { *m = GCPVPCNetworkAutogenerateParamsType{} }
func (*GCPVPCNetworkAutogenerateParamsType) ProtoMessage() {}
func (*GCPVPCNetworkAutogenerateParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{14}
}

func (m *GCPVPCNetworkAutogenerateParamsType) GetAutogenerate() bool {
	if m != nil {
		return m.Autogenerate
	}
	return false
}

// GCP existing VPC network Type
//
// x-displayName: "GCP existing VPC network Type"
// Name of existing VPC network
type GCPVPCNetworkType struct {
	// GCP VPC Network Name
	//
	// x-displayName: "GCP VPC Network Name"
	// x-required
	// x-example: "network1"
	// Name for your GCP VPC Network
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GCPVPCNetworkType) Reset()                    { *m = GCPVPCNetworkType{} }
func (*GCPVPCNetworkType) ProtoMessage()               {}
func (*GCPVPCNetworkType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{15} }

func (m *GCPVPCNetworkType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GCP existing subnet Type
//
// x-displayName: "GCP existing subnet Type"
// Name of existing gcp subnet
type GCPSubnetType struct {
	// GCP VPC Subnet Name
	//
	// x-displayName: "VPC Subnet Name"
	// x-required
	// x-example: "subnet1-in-network1"
	// Name of your subnet in VPC network
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
}

func (m *GCPSubnetType) Reset()                    { *m = GCPSubnetType{} }
func (*GCPSubnetType) ProtoMessage()               {}
func (*GCPSubnetType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{16} }

func (m *GCPSubnetType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

// GCP subnet parameters Type
//
// x-displayName: "GCP subnet parameters Type"
// Parameters for gcp subnet
type GCPSubnetParamsType struct {
	// GCP VPC Subnet Name
	//
	// x-displayName: "VPC Subnet Name"
	// x-example: "subnet1-in-network1"
	// Name of new VPC Subnet, will be autogenerated if empty
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
	// IPv4 CIDR block
	//
	// x-displayName: "IPv4 Subnet Prefix"
	// x-required
	// x-example: "10.1.0.0/16"
	// IPv4 prefix for this Subnet. It has to be private address space.
	PrimaryIpv4 string `protobuf:"bytes,2,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
}

func (m *GCPSubnetParamsType) Reset()                    { *m = GCPSubnetParamsType{} }
func (*GCPSubnetParamsType) ProtoMessage()               {}
func (*GCPSubnetParamsType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{17} }

func (m *GCPSubnetParamsType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

func (m *GCPSubnetParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

// GCP VPC network choice
//
// x-displayName: "GCP VPC network choice"
// This defines choice about GCP VPC network for a view
type GCPVPCNetworkChoiceType struct {
	// Choice of existing or new VPC network
	//
	// x-displayName: "Select existing VPC network or create new VPC network"
	// x-required
	// Create a new VPC Network or select an existing one.
	//
	// Types that are valid to be assigned to Choice:
	//	*GCPVPCNetworkChoiceType_NewNetworkAutogenerate
	//	*GCPVPCNetworkChoiceType_NewNetwork
	//	*GCPVPCNetworkChoiceType_ExistingNetwork
	Choice isGCPVPCNetworkChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *GCPVPCNetworkChoiceType) Reset()      { *m = GCPVPCNetworkChoiceType{} }
func (*GCPVPCNetworkChoiceType) ProtoMessage() {}
func (*GCPVPCNetworkChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{18}
}

type isGCPVPCNetworkChoiceType_Choice interface {
	isGCPVPCNetworkChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPVPCNetworkChoiceType_NewNetworkAutogenerate struct {
	NewNetworkAutogenerate *GCPVPCNetworkAutogenerateParamsType `protobuf:"bytes,4,opt,name=new_network_autogenerate,json=newNetworkAutogenerate,oneof"`
}
type GCPVPCNetworkChoiceType_NewNetwork struct {
	NewNetwork *GCPVPCNetworkParamsType `protobuf:"bytes,2,opt,name=new_network,json=newNetwork,oneof"`
}
type GCPVPCNetworkChoiceType_ExistingNetwork struct {
	ExistingNetwork *GCPVPCNetworkType `protobuf:"bytes,3,opt,name=existing_network,json=existingNetwork,oneof"`
}

func (*GCPVPCNetworkChoiceType_NewNetworkAutogenerate) isGCPVPCNetworkChoiceType_Choice() {}
func (*GCPVPCNetworkChoiceType_NewNetwork) isGCPVPCNetworkChoiceType_Choice()             {}
func (*GCPVPCNetworkChoiceType_ExistingNetwork) isGCPVPCNetworkChoiceType_Choice()        {}

func (m *GCPVPCNetworkChoiceType) GetChoice() isGCPVPCNetworkChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *GCPVPCNetworkChoiceType) GetNewNetworkAutogenerate() *GCPVPCNetworkAutogenerateParamsType {
	if x, ok := m.GetChoice().(*GCPVPCNetworkChoiceType_NewNetworkAutogenerate); ok {
		return x.NewNetworkAutogenerate
	}
	return nil
}

func (m *GCPVPCNetworkChoiceType) GetNewNetwork() *GCPVPCNetworkParamsType {
	if x, ok := m.GetChoice().(*GCPVPCNetworkChoiceType_NewNetwork); ok {
		return x.NewNetwork
	}
	return nil
}

func (m *GCPVPCNetworkChoiceType) GetExistingNetwork() *GCPVPCNetworkType {
	if x, ok := m.GetChoice().(*GCPVPCNetworkChoiceType_ExistingNetwork); ok {
		return x.ExistingNetwork
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GCPVPCNetworkChoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GCPVPCNetworkChoiceType_OneofMarshaler, _GCPVPCNetworkChoiceType_OneofUnmarshaler, _GCPVPCNetworkChoiceType_OneofSizer, []interface{}{
		(*GCPVPCNetworkChoiceType_NewNetworkAutogenerate)(nil),
		(*GCPVPCNetworkChoiceType_NewNetwork)(nil),
		(*GCPVPCNetworkChoiceType_ExistingNetwork)(nil),
	}
}

func _GCPVPCNetworkChoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GCPVPCNetworkChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *GCPVPCNetworkChoiceType_NewNetworkAutogenerate:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewNetworkAutogenerate); err != nil {
			return err
		}
	case *GCPVPCNetworkChoiceType_NewNetwork:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewNetwork); err != nil {
			return err
		}
	case *GCPVPCNetworkChoiceType_ExistingNetwork:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExistingNetwork); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GCPVPCNetworkChoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _GCPVPCNetworkChoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GCPVPCNetworkChoiceType)
	switch tag {
	case 4: // choice.new_network_autogenerate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GCPVPCNetworkAutogenerateParamsType)
		err := b.DecodeMessage(msg)
		m.Choice = &GCPVPCNetworkChoiceType_NewNetworkAutogenerate{msg}
		return true, err
	case 2: // choice.new_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GCPVPCNetworkParamsType)
		err := b.DecodeMessage(msg)
		m.Choice = &GCPVPCNetworkChoiceType_NewNetwork{msg}
		return true, err
	case 3: // choice.existing_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GCPVPCNetworkType)
		err := b.DecodeMessage(msg)
		m.Choice = &GCPVPCNetworkChoiceType_ExistingNetwork{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GCPVPCNetworkChoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GCPVPCNetworkChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *GCPVPCNetworkChoiceType_NewNetworkAutogenerate:
		s := proto.Size(x.NewNetworkAutogenerate)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GCPVPCNetworkChoiceType_NewNetwork:
		s := proto.Size(x.NewNetwork)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GCPVPCNetworkChoiceType_ExistingNetwork:
		s := proto.Size(x.ExistingNetwork)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GCP VPC network choice
//
// x-displayName: "GCP VPC network choice"
// This defines choice about GCP VPC network for a view
type GCPVPCSubnetChoiceType struct {
	// Choice of existing or new subnet
	//
	// x-displayName: "Select existing subnet or create new subnet"
	// x-required
	// Create a new VPC Subnet or select an existing one.
	//
	// Types that are valid to be assigned to Choice:
	//	*GCPVPCSubnetChoiceType_NewSubnet
	//	*GCPVPCSubnetChoiceType_ExistingSubnet
	Choice isGCPVPCSubnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *GCPVPCSubnetChoiceType) Reset()      { *m = GCPVPCSubnetChoiceType{} }
func (*GCPVPCSubnetChoiceType) ProtoMessage() {}
func (*GCPVPCSubnetChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{19}
}

type isGCPVPCSubnetChoiceType_Choice interface {
	isGCPVPCSubnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPVPCSubnetChoiceType_NewSubnet struct {
	NewSubnet *GCPSubnetParamsType `protobuf:"bytes,2,opt,name=new_subnet,json=newSubnet,oneof"`
}
type GCPVPCSubnetChoiceType_ExistingSubnet struct {
	ExistingSubnet *GCPSubnetType `protobuf:"bytes,3,opt,name=existing_subnet,json=existingSubnet,oneof"`
}

func (*GCPVPCSubnetChoiceType_NewSubnet) isGCPVPCSubnetChoiceType_Choice()      {}
func (*GCPVPCSubnetChoiceType_ExistingSubnet) isGCPVPCSubnetChoiceType_Choice() {}

func (m *GCPVPCSubnetChoiceType) GetChoice() isGCPVPCSubnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *GCPVPCSubnetChoiceType) GetNewSubnet() *GCPSubnetParamsType {
	if x, ok := m.GetChoice().(*GCPVPCSubnetChoiceType_NewSubnet); ok {
		return x.NewSubnet
	}
	return nil
}

func (m *GCPVPCSubnetChoiceType) GetExistingSubnet() *GCPSubnetType {
	if x, ok := m.GetChoice().(*GCPVPCSubnetChoiceType_ExistingSubnet); ok {
		return x.ExistingSubnet
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GCPVPCSubnetChoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GCPVPCSubnetChoiceType_OneofMarshaler, _GCPVPCSubnetChoiceType_OneofUnmarshaler, _GCPVPCSubnetChoiceType_OneofSizer, []interface{}{
		(*GCPVPCSubnetChoiceType_NewSubnet)(nil),
		(*GCPVPCSubnetChoiceType_ExistingSubnet)(nil),
	}
}

func _GCPVPCSubnetChoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GCPVPCSubnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *GCPVPCSubnetChoiceType_NewSubnet:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewSubnet); err != nil {
			return err
		}
	case *GCPVPCSubnetChoiceType_ExistingSubnet:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExistingSubnet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GCPVPCSubnetChoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _GCPVPCSubnetChoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GCPVPCSubnetChoiceType)
	switch tag {
	case 2: // choice.new_subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GCPSubnetParamsType)
		err := b.DecodeMessage(msg)
		m.Choice = &GCPVPCSubnetChoiceType_NewSubnet{msg}
		return true, err
	case 3: // choice.existing_subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GCPSubnetType)
		err := b.DecodeMessage(msg)
		m.Choice = &GCPVPCSubnetChoiceType_ExistingSubnet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GCPVPCSubnetChoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GCPVPCSubnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *GCPVPCSubnetChoiceType_NewSubnet:
		s := proto.Size(x.NewSubnet)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GCPVPCSubnetChoiceType_ExistingSubnet:
		s := proto.Size(x.ExistingSubnet)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Site Static Route Config Modes
//
// x-displayName: "Site Static Route Config Modes"
// Different ways to configure static routes
type SiteStaticRoutesType struct {
	// Static Route Config Mode
	//
	// x-displayName: "Static Route Config Mode"
	// x-required
	// Select method for configuring the route
	//
	// Types that are valid to be assigned to ConfigModeChoice:
	//	*SiteStaticRoutesType_SimpleStaticRoute
	//	*SiteStaticRoutesType_CustomStaticRoute
	ConfigModeChoice isSiteStaticRoutesType_ConfigModeChoice `protobuf_oneof:"config_mode_choice"`
}

func (m *SiteStaticRoutesType) Reset()                    { *m = SiteStaticRoutesType{} }
func (*SiteStaticRoutesType) ProtoMessage()               {}
func (*SiteStaticRoutesType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{20} }

type isSiteStaticRoutesType_ConfigModeChoice interface {
	isSiteStaticRoutesType_ConfigModeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteStaticRoutesType_SimpleStaticRoute struct {
	SimpleStaticRoute string `protobuf:"bytes,2,opt,name=simple_static_route,json=simpleStaticRoute,proto3,oneof"`
}
type SiteStaticRoutesType_CustomStaticRoute struct {
	CustomStaticRoute *ves_io_schema4.StaticRouteType `protobuf:"bytes,3,opt,name=custom_static_route,json=customStaticRoute,oneof"`
}

func (*SiteStaticRoutesType_SimpleStaticRoute) isSiteStaticRoutesType_ConfigModeChoice() {}
func (*SiteStaticRoutesType_CustomStaticRoute) isSiteStaticRoutesType_ConfigModeChoice() {}

func (m *SiteStaticRoutesType) GetConfigModeChoice() isSiteStaticRoutesType_ConfigModeChoice {
	if m != nil {
		return m.ConfigModeChoice
	}
	return nil
}

func (m *SiteStaticRoutesType) GetSimpleStaticRoute() string {
	if x, ok := m.GetConfigModeChoice().(*SiteStaticRoutesType_SimpleStaticRoute); ok {
		return x.SimpleStaticRoute
	}
	return ""
}

func (m *SiteStaticRoutesType) GetCustomStaticRoute() *ves_io_schema4.StaticRouteType {
	if x, ok := m.GetConfigModeChoice().(*SiteStaticRoutesType_CustomStaticRoute); ok {
		return x.CustomStaticRoute
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SiteStaticRoutesType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SiteStaticRoutesType_OneofMarshaler, _SiteStaticRoutesType_OneofUnmarshaler, _SiteStaticRoutesType_OneofSizer, []interface{}{
		(*SiteStaticRoutesType_SimpleStaticRoute)(nil),
		(*SiteStaticRoutesType_CustomStaticRoute)(nil),
	}
}

func _SiteStaticRoutesType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SiteStaticRoutesType)
	// config_mode_choice
	switch x := m.ConfigModeChoice.(type) {
	case *SiteStaticRoutesType_SimpleStaticRoute:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.SimpleStaticRoute)
	case *SiteStaticRoutesType_CustomStaticRoute:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomStaticRoute); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SiteStaticRoutesType.ConfigModeChoice has unexpected type %T", x)
	}
	return nil
}

func _SiteStaticRoutesType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SiteStaticRoutesType)
	switch tag {
	case 2: // config_mode_choice.simple_static_route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ConfigModeChoice = &SiteStaticRoutesType_SimpleStaticRoute{x}
		return true, err
	case 3: // config_mode_choice.custom_static_route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.StaticRouteType)
		err := b.DecodeMessage(msg)
		m.ConfigModeChoice = &SiteStaticRoutesType_CustomStaticRoute{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SiteStaticRoutesType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SiteStaticRoutesType)
	// config_mode_choice
	switch x := m.ConfigModeChoice.(type) {
	case *SiteStaticRoutesType_SimpleStaticRoute:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SimpleStaticRoute)))
		n += len(x.SimpleStaticRoute)
	case *SiteStaticRoutesType_CustomStaticRoute:
		s := proto.Size(x.CustomStaticRoute)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Static Route List Type
//
// x-displayName: "Static Route List Type"
// List of static routes
type SiteStaticRoutesListType struct {
	// List of Static Routes
	//
	// x-displayName: "List of Static Routes"
	// x-required
	// List of Static routes
	StaticRouteList []*SiteStaticRoutesType `protobuf:"bytes,1,rep,name=static_route_list,json=staticRouteList" json:"static_route_list,omitempty"`
}

func (m *SiteStaticRoutesListType) Reset()      { *m = SiteStaticRoutesListType{} }
func (*SiteStaticRoutesListType) ProtoMessage() {}
func (*SiteStaticRoutesListType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{21}
}

func (m *SiteStaticRoutesListType) GetStaticRouteList() []*SiteStaticRoutesType {
	if m != nil {
		return m.StaticRouteList
	}
	return nil
}

// Global Network Connection
//
// x-displayName: "Global Network Connection"
// Global network connection
type GlobalNetworkConnectionType struct {
	// Connector Choice
	//
	// x-displayName: "Select Network Connection Type"
	// x-required
	// Select the networks and method in which they are connected.
	//
	// Types that are valid to be assigned to ConnectionChoice:
	//	*GlobalNetworkConnectionType_SliToGlobalDr
	//	*GlobalNetworkConnectionType_SloToGlobalDr
	ConnectionChoice isGlobalNetworkConnectionType_ConnectionChoice `protobuf_oneof:"connection_choice"`
	// Select Forward Proxy
	//
	// x-displayName: "Select Forward Proxy"
	// Select to enable forward proxy
	//
	// Types that are valid to be assigned to ForwardProxyChoice:
	//	*GlobalNetworkConnectionType_DisableForwardProxy
	//	*GlobalNetworkConnectionType_EnableForwardProxy
	ForwardProxyChoice isGlobalNetworkConnectionType_ForwardProxyChoice `protobuf_oneof:"forward_proxy_choice"`
}

func (m *GlobalNetworkConnectionType) Reset()      { *m = GlobalNetworkConnectionType{} }
func (*GlobalNetworkConnectionType) ProtoMessage() {}
func (*GlobalNetworkConnectionType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{22}
}

type isGlobalNetworkConnectionType_ConnectionChoice interface {
	isGlobalNetworkConnectionType_ConnectionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalNetworkConnectionType_ForwardProxyChoice interface {
	isGlobalNetworkConnectionType_ForwardProxyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalNetworkConnectionType_SliToGlobalDr struct {
	SliToGlobalDr *GlobalConnectorType `protobuf:"bytes,2,opt,name=sli_to_global_dr,json=sliToGlobalDr,oneof"`
}
type GlobalNetworkConnectionType_SloToGlobalDr struct {
	SloToGlobalDr *GlobalConnectorType `protobuf:"bytes,3,opt,name=slo_to_global_dr,json=sloToGlobalDr,oneof"`
}
type GlobalNetworkConnectionType_DisableForwardProxy struct {
	DisableForwardProxy *ves_io_schema4.Empty `protobuf:"bytes,5,opt,name=disable_forward_proxy,json=disableForwardProxy,oneof"`
}
type GlobalNetworkConnectionType_EnableForwardProxy struct {
	EnableForwardProxy *ves_io_schema4.ForwardProxyConfigType `protobuf:"bytes,6,opt,name=enable_forward_proxy,json=enableForwardProxy,oneof"`
}

func (*GlobalNetworkConnectionType_SliToGlobalDr) isGlobalNetworkConnectionType_ConnectionChoice() {}
func (*GlobalNetworkConnectionType_SloToGlobalDr) isGlobalNetworkConnectionType_ConnectionChoice() {}
func (*GlobalNetworkConnectionType_DisableForwardProxy) isGlobalNetworkConnectionType_ForwardProxyChoice() {
}
func (*GlobalNetworkConnectionType_EnableForwardProxy) isGlobalNetworkConnectionType_ForwardProxyChoice() {
}

func (m *GlobalNetworkConnectionType) GetConnectionChoice() isGlobalNetworkConnectionType_ConnectionChoice {
	if m != nil {
		return m.ConnectionChoice
	}
	return nil
}
func (m *GlobalNetworkConnectionType) GetForwardProxyChoice() isGlobalNetworkConnectionType_ForwardProxyChoice {
	if m != nil {
		return m.ForwardProxyChoice
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetSliToGlobalDr() *GlobalConnectorType {
	if x, ok := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SliToGlobalDr); ok {
		return x.SliToGlobalDr
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetSloToGlobalDr() *GlobalConnectorType {
	if x, ok := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SloToGlobalDr); ok {
		return x.SloToGlobalDr
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetDisableForwardProxy() *ves_io_schema4.Empty {
	if x, ok := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_DisableForwardProxy); ok {
		return x.DisableForwardProxy
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetEnableForwardProxy() *ves_io_schema4.ForwardProxyConfigType {
	if x, ok := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_EnableForwardProxy); ok {
		return x.EnableForwardProxy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalNetworkConnectionType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalNetworkConnectionType_OneofMarshaler, _GlobalNetworkConnectionType_OneofUnmarshaler, _GlobalNetworkConnectionType_OneofSizer, []interface{}{
		(*GlobalNetworkConnectionType_SliToGlobalDr)(nil),
		(*GlobalNetworkConnectionType_SloToGlobalDr)(nil),
		(*GlobalNetworkConnectionType_DisableForwardProxy)(nil),
		(*GlobalNetworkConnectionType_EnableForwardProxy)(nil),
	}
}

func _GlobalNetworkConnectionType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalNetworkConnectionType)
	// connection_choice
	switch x := m.ConnectionChoice.(type) {
	case *GlobalNetworkConnectionType_SliToGlobalDr:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SliToGlobalDr); err != nil {
			return err
		}
	case *GlobalNetworkConnectionType_SloToGlobalDr:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SloToGlobalDr); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalNetworkConnectionType.ConnectionChoice has unexpected type %T", x)
	}
	// forward_proxy_choice
	switch x := m.ForwardProxyChoice.(type) {
	case *GlobalNetworkConnectionType_DisableForwardProxy:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DisableForwardProxy); err != nil {
			return err
		}
	case *GlobalNetworkConnectionType_EnableForwardProxy:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableForwardProxy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalNetworkConnectionType.ForwardProxyChoice has unexpected type %T", x)
	}
	return nil
}

func _GlobalNetworkConnectionType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalNetworkConnectionType)
	switch tag {
	case 2: // connection_choice.sli_to_global_dr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GlobalConnectorType)
		err := b.DecodeMessage(msg)
		m.ConnectionChoice = &GlobalNetworkConnectionType_SliToGlobalDr{msg}
		return true, err
	case 3: // connection_choice.slo_to_global_dr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GlobalConnectorType)
		err := b.DecodeMessage(msg)
		m.ConnectionChoice = &GlobalNetworkConnectionType_SloToGlobalDr{msg}
		return true, err
	case 5: // forward_proxy_choice.disable_forward_proxy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ForwardProxyChoice = &GlobalNetworkConnectionType_DisableForwardProxy{msg}
		return true, err
	case 6: // forward_proxy_choice.enable_forward_proxy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.ForwardProxyConfigType)
		err := b.DecodeMessage(msg)
		m.ForwardProxyChoice = &GlobalNetworkConnectionType_EnableForwardProxy{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalNetworkConnectionType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalNetworkConnectionType)
	// connection_choice
	switch x := m.ConnectionChoice.(type) {
	case *GlobalNetworkConnectionType_SliToGlobalDr:
		s := proto.Size(x.SliToGlobalDr)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalNetworkConnectionType_SloToGlobalDr:
		s := proto.Size(x.SloToGlobalDr)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// forward_proxy_choice
	switch x := m.ForwardProxyChoice.(type) {
	case *GlobalNetworkConnectionType_DisableForwardProxy:
		s := proto.Size(x.DisableForwardProxy)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalNetworkConnectionType_EnableForwardProxy:
		s := proto.Size(x.EnableForwardProxy)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Global Network Connection List
//
// x-displayName: "Global Network Connection List"
// List of global network connections
type GlobalNetworkConnectionListType struct {
	// Global Network Connections
	//
	// x-displayName: "Global Network Connections"
	// x-required
	// Global network connections
	GlobalNetworkConnections []*GlobalNetworkConnectionType `protobuf:"bytes,1,rep,name=global_network_connections,json=globalNetworkConnections" json:"global_network_connections,omitempty"`
}

func (m *GlobalNetworkConnectionListType) Reset()      { *m = GlobalNetworkConnectionListType{} }
func (*GlobalNetworkConnectionListType) ProtoMessage() {}
func (*GlobalNetworkConnectionListType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{23}
}

func (m *GlobalNetworkConnectionListType) GetGlobalNetworkConnections() []*GlobalNetworkConnectionType {
	if m != nil {
		return m.GlobalNetworkConnections
	}
	return nil
}

// Allowed VIP Ports
//
// x-displayName: "Allowed VIP Ports"
// This defines the TCP port(s) which will be opened on the cloud loadbalancer.
// Such that the client can use the cloud VIP IP and port combination
// to reach TCP/HTTP lb configured on the Volterra Site
type AllowedVIPPorts struct {
	// VIP Port Choice
	//
	// x-displayName: "Select Which Ports will be Allowed"
	// This defines various port which can be used to connect to the http/tcp loadbalancer using the VIP
	//
	// Types that are valid to be assigned to PortChoice:
	//	*AllowedVIPPorts_UseHttpPort
	//	*AllowedVIPPorts_UseHttpsPort
	//	*AllowedVIPPorts_UseHttpHttpsPort
	//	*AllowedVIPPorts_CustomPorts
	PortChoice isAllowedVIPPorts_PortChoice `protobuf_oneof:"port_choice"`
}

func (m *AllowedVIPPorts) Reset()                    { *m = AllowedVIPPorts{} }
func (*AllowedVIPPorts) ProtoMessage()               {}
func (*AllowedVIPPorts) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{24} }

type isAllowedVIPPorts_PortChoice interface {
	isAllowedVIPPorts_PortChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AllowedVIPPorts_UseHttpPort struct {
	UseHttpPort *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=use_http_port,json=useHttpPort,oneof"`
}
type AllowedVIPPorts_UseHttpsPort struct {
	UseHttpsPort *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=use_https_port,json=useHttpsPort,oneof"`
}
type AllowedVIPPorts_UseHttpHttpsPort struct {
	UseHttpHttpsPort *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=use_http_https_port,json=useHttpHttpsPort,oneof"`
}
type AllowedVIPPorts_CustomPorts struct {
	CustomPorts *CustomPorts `protobuf:"bytes,5,opt,name=custom_ports,json=customPorts,oneof"`
}

func (*AllowedVIPPorts_UseHttpPort) isAllowedVIPPorts_PortChoice()      {}
func (*AllowedVIPPorts_UseHttpsPort) isAllowedVIPPorts_PortChoice()     {}
func (*AllowedVIPPorts_UseHttpHttpsPort) isAllowedVIPPorts_PortChoice() {}
func (*AllowedVIPPorts_CustomPorts) isAllowedVIPPorts_PortChoice()      {}

func (m *AllowedVIPPorts) GetPortChoice() isAllowedVIPPorts_PortChoice {
	if m != nil {
		return m.PortChoice
	}
	return nil
}

func (m *AllowedVIPPorts) GetUseHttpPort() *ves_io_schema4.Empty {
	if x, ok := m.GetPortChoice().(*AllowedVIPPorts_UseHttpPort); ok {
		return x.UseHttpPort
	}
	return nil
}

func (m *AllowedVIPPorts) GetUseHttpsPort() *ves_io_schema4.Empty {
	if x, ok := m.GetPortChoice().(*AllowedVIPPorts_UseHttpsPort); ok {
		return x.UseHttpsPort
	}
	return nil
}

func (m *AllowedVIPPorts) GetUseHttpHttpsPort() *ves_io_schema4.Empty {
	if x, ok := m.GetPortChoice().(*AllowedVIPPorts_UseHttpHttpsPort); ok {
		return x.UseHttpHttpsPort
	}
	return nil
}

func (m *AllowedVIPPorts) GetCustomPorts() *CustomPorts {
	if x, ok := m.GetPortChoice().(*AllowedVIPPorts_CustomPorts); ok {
		return x.CustomPorts
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AllowedVIPPorts) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AllowedVIPPorts_OneofMarshaler, _AllowedVIPPorts_OneofUnmarshaler, _AllowedVIPPorts_OneofSizer, []interface{}{
		(*AllowedVIPPorts_UseHttpPort)(nil),
		(*AllowedVIPPorts_UseHttpsPort)(nil),
		(*AllowedVIPPorts_UseHttpHttpsPort)(nil),
		(*AllowedVIPPorts_CustomPorts)(nil),
	}
}

func _AllowedVIPPorts_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AllowedVIPPorts)
	// port_choice
	switch x := m.PortChoice.(type) {
	case *AllowedVIPPorts_UseHttpPort:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UseHttpPort); err != nil {
			return err
		}
	case *AllowedVIPPorts_UseHttpsPort:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UseHttpsPort); err != nil {
			return err
		}
	case *AllowedVIPPorts_UseHttpHttpsPort:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UseHttpHttpsPort); err != nil {
			return err
		}
	case *AllowedVIPPorts_CustomPorts:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomPorts); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AllowedVIPPorts.PortChoice has unexpected type %T", x)
	}
	return nil
}

func _AllowedVIPPorts_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AllowedVIPPorts)
	switch tag {
	case 2: // port_choice.use_http_port
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PortChoice = &AllowedVIPPorts_UseHttpPort{msg}
		return true, err
	case 3: // port_choice.use_https_port
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PortChoice = &AllowedVIPPorts_UseHttpsPort{msg}
		return true, err
	case 4: // port_choice.use_http_https_port
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PortChoice = &AllowedVIPPorts_UseHttpHttpsPort{msg}
		return true, err
	case 5: // port_choice.custom_ports
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CustomPorts)
		err := b.DecodeMessage(msg)
		m.PortChoice = &AllowedVIPPorts_CustomPorts{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AllowedVIPPorts_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AllowedVIPPorts)
	// port_choice
	switch x := m.PortChoice.(type) {
	case *AllowedVIPPorts_UseHttpPort:
		s := proto.Size(x.UseHttpPort)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AllowedVIPPorts_UseHttpsPort:
		s := proto.Size(x.UseHttpsPort)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AllowedVIPPorts_UseHttpHttpsPort:
		s := proto.Size(x.UseHttpHttpsPort)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AllowedVIPPorts_CustomPorts:
		s := proto.Size(x.CustomPorts)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Custom Ports
//
// x-displayName: "Custom Ports"
// List of Custom port
type CustomPorts struct {
	// Port Ranges
	//
	// x-displayName: "Port Ranges"
	// x-required
	// x-example: "80, 8080-8085"
	// Port Ranges
	PortRanges string `protobuf:"bytes,2,opt,name=port_ranges,json=portRanges,proto3" json:"port_ranges,omitempty"`
}

func (m *CustomPorts) Reset()                    { *m = CustomPorts{} }
func (*CustomPorts) ProtoMessage()               {}
func (*CustomPorts) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{25} }

func (m *CustomPorts) GetPortRanges() string {
	if m != nil {
		return m.PortRanges
	}
	return ""
}

func init() {
	proto.RegisterType((*AWSVPCParamsType)(nil), "ves.io.schema.views.AWSVPCParamsType")
	golang_proto.RegisterType((*AWSVPCParamsType)(nil), "ves.io.schema.views.AWSVPCParamsType")
	proto.RegisterType((*AWSVPCchoiceType)(nil), "ves.io.schema.views.AWSVPCchoiceType")
	golang_proto.RegisterType((*AWSVPCchoiceType)(nil), "ves.io.schema.views.AWSVPCchoiceType")
	proto.RegisterType((*CloudSubnetParamType)(nil), "ves.io.schema.views.CloudSubnetParamType")
	golang_proto.RegisterType((*CloudSubnetParamType)(nil), "ves.io.schema.views.CloudSubnetParamType")
	proto.RegisterType((*CloudSubnetType)(nil), "ves.io.schema.views.CloudSubnetType")
	golang_proto.RegisterType((*CloudSubnetType)(nil), "ves.io.schema.views.CloudSubnetType")
	proto.RegisterType((*AWSVPCOneInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCOneInterfaceNodeType")
	golang_proto.RegisterType((*AWSVPCOneInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCOneInterfaceNodeType")
	proto.RegisterType((*AWSVPCTwoInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCTwoInterfaceNodeType")
	golang_proto.RegisterType((*AWSVPCTwoInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCTwoInterfaceNodeType")
	proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.AzureVnetParamsType")
	golang_proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.AzureVnetParamsType")
	proto.RegisterType((*AzureVnetType)(nil), "ves.io.schema.views.AzureVnetType")
	golang_proto.RegisterType((*AzureVnetType)(nil), "ves.io.schema.views.AzureVnetType")
	proto.RegisterType((*AzureVnetChoiceType)(nil), "ves.io.schema.views.AzureVnetChoiceType")
	golang_proto.RegisterType((*AzureVnetChoiceType)(nil), "ves.io.schema.views.AzureVnetChoiceType")
	proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.AzureSubnetType")
	golang_proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.AzureSubnetType")
	proto.RegisterType((*AzureSubnetChoiceType)(nil), "ves.io.schema.views.AzureSubnetChoiceType")
	golang_proto.RegisterType((*AzureSubnetChoiceType)(nil), "ves.io.schema.views.AzureSubnetChoiceType")
	proto.RegisterType((*AzureVnetOneInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetOneInterfaceNodeType")
	golang_proto.RegisterType((*AzureVnetOneInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetOneInterfaceNodeType")
	proto.RegisterType((*AzureVnetTwoInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetTwoInterfaceNodeType")
	golang_proto.RegisterType((*AzureVnetTwoInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetTwoInterfaceNodeType")
	proto.RegisterType((*GCPVPCNetworkParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkParamsType")
	golang_proto.RegisterType((*GCPVPCNetworkParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkParamsType")
	proto.RegisterType((*GCPVPCNetworkAutogenerateParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkAutogenerateParamsType")
	golang_proto.RegisterType((*GCPVPCNetworkAutogenerateParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkAutogenerateParamsType")
	proto.RegisterType((*GCPVPCNetworkType)(nil), "ves.io.schema.views.GCPVPCNetworkType")
	golang_proto.RegisterType((*GCPVPCNetworkType)(nil), "ves.io.schema.views.GCPVPCNetworkType")
	proto.RegisterType((*GCPSubnetType)(nil), "ves.io.schema.views.GCPSubnetType")
	golang_proto.RegisterType((*GCPSubnetType)(nil), "ves.io.schema.views.GCPSubnetType")
	proto.RegisterType((*GCPSubnetParamsType)(nil), "ves.io.schema.views.GCPSubnetParamsType")
	golang_proto.RegisterType((*GCPSubnetParamsType)(nil), "ves.io.schema.views.GCPSubnetParamsType")
	proto.RegisterType((*GCPVPCNetworkChoiceType)(nil), "ves.io.schema.views.GCPVPCNetworkChoiceType")
	golang_proto.RegisterType((*GCPVPCNetworkChoiceType)(nil), "ves.io.schema.views.GCPVPCNetworkChoiceType")
	proto.RegisterType((*GCPVPCSubnetChoiceType)(nil), "ves.io.schema.views.GCPVPCSubnetChoiceType")
	golang_proto.RegisterType((*GCPVPCSubnetChoiceType)(nil), "ves.io.schema.views.GCPVPCSubnetChoiceType")
	proto.RegisterType((*SiteStaticRoutesType)(nil), "ves.io.schema.views.SiteStaticRoutesType")
	golang_proto.RegisterType((*SiteStaticRoutesType)(nil), "ves.io.schema.views.SiteStaticRoutesType")
	proto.RegisterType((*SiteStaticRoutesListType)(nil), "ves.io.schema.views.SiteStaticRoutesListType")
	golang_proto.RegisterType((*SiteStaticRoutesListType)(nil), "ves.io.schema.views.SiteStaticRoutesListType")
	proto.RegisterType((*GlobalNetworkConnectionType)(nil), "ves.io.schema.views.GlobalNetworkConnectionType")
	golang_proto.RegisterType((*GlobalNetworkConnectionType)(nil), "ves.io.schema.views.GlobalNetworkConnectionType")
	proto.RegisterType((*GlobalNetworkConnectionListType)(nil), "ves.io.schema.views.GlobalNetworkConnectionListType")
	golang_proto.RegisterType((*GlobalNetworkConnectionListType)(nil), "ves.io.schema.views.GlobalNetworkConnectionListType")
	proto.RegisterType((*AllowedVIPPorts)(nil), "ves.io.schema.views.AllowedVIPPorts")
	golang_proto.RegisterType((*AllowedVIPPorts)(nil), "ves.io.schema.views.AllowedVIPPorts")
	proto.RegisterType((*CustomPorts)(nil), "ves.io.schema.views.CustomPorts")
	golang_proto.RegisterType((*CustomPorts)(nil), "ves.io.schema.views.CustomPorts")
}
func (this *AWSVPCParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCParamsType)
	if !ok {
		that2, ok := that.(AWSVPCParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NameChoice == nil {
		if this.NameChoice != nil {
			return false
		}
	} else if this.NameChoice == nil {
		return false
	} else if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	if this.AllocateIpv6 != that1.AllocateIpv6 {
		return false
	}
	return true
}
func (this *AWSVPCParamsType_NameTag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCParamsType_NameTag)
	if !ok {
		that2, ok := that.(AWSVPCParamsType_NameTag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NameTag != that1.NameTag {
		return false
	}
	return true
}
func (this *AWSVPCParamsType_Autogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCParamsType_Autogenerate)
	if !ok {
		that2, ok := that.(AWSVPCParamsType_Autogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Autogenerate.Equal(that1.Autogenerate) {
		return false
	}
	return true
}
func (this *AWSVPCchoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCchoiceType)
	if !ok {
		that2, ok := that.(AWSVPCchoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AWSVPCchoiceType_NewVpc) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCchoiceType_NewVpc)
	if !ok {
		that2, ok := that.(AWSVPCchoiceType_NewVpc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVpc.Equal(that1.NewVpc) {
		return false
	}
	return true
}
func (this *AWSVPCchoiceType_VpcId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCchoiceType_VpcId)
	if !ok {
		that2, ok := that.(AWSVPCchoiceType_VpcId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	return true
}
func (this *CloudSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetParamType)
	if !ok {
		that2, ok := that.(CloudSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ipv4 != that1.Ipv4 {
		return false
	}
	if this.Ipv6 != that1.Ipv6 {
		return false
	}
	return true
}
func (this *CloudSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType)
	if !ok {
		that2, ok := that.(CloudSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *CloudSubnetType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType_SubnetParam)
	if !ok {
		that2, ok := that.(CloudSubnetType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *CloudSubnetType_ExistingSubnetId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType_ExistingSubnetId)
	if !ok {
		that2, ok := that.(CloudSubnetType_ExistingSubnetId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExistingSubnetId != that1.ExistingSubnetId {
		return false
	}
	return true
}
func (this *AWSVPCOneInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCOneInterfaceNodeType)
	if !ok {
		that2, ok := that.(AWSVPCOneInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AwsAzName != that1.AwsAzName {
		return false
	}
	if !this.LocalSubnet.Equal(that1.LocalSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AWSVPCTwoInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCTwoInterfaceNodeType)
	if !ok {
		that2, ok := that.(AWSVPCTwoInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AwsAzName != that1.AwsAzName {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	if !this.OutsideSubnet.Equal(that1.OutsideSubnet) {
		return false
	}
	if !this.WorkloadSubnet.Equal(that1.WorkloadSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet)
	if !ok {
		that2, ok := that.(AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ReservedInsideSubnet.Equal(that1.ReservedInsideSubnet) {
		return false
	}
	return true
}
func (this *AWSVPCTwoInterfaceNodeType_InsideSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCTwoInterfaceNodeType_InsideSubnet)
	if !ok {
		that2, ok := that.(AWSVPCTwoInterfaceNodeType_InsideSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideSubnet.Equal(that1.InsideSubnet) {
		return false
	}
	return true
}
func (this *AzureVnetParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetParamsType)
	if !ok {
		that2, ok := that.(AzureVnetParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NameChoice == nil {
		if this.NameChoice != nil {
			return false
		}
	} else if this.NameChoice == nil {
		return false
	} else if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	return true
}
func (this *AzureVnetParamsType_Name) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetParamsType_Name)
	if !ok {
		that2, ok := that.(AzureVnetParamsType_Name)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *AzureVnetParamsType_Autogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetParamsType_Autogenerate)
	if !ok {
		that2, ok := that.(AzureVnetParamsType_Autogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Autogenerate.Equal(that1.Autogenerate) {
		return false
	}
	return true
}
func (this *AzureVnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetType)
	if !ok {
		that2, ok := that.(AzureVnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceGroup != that1.ResourceGroup {
		return false
	}
	if this.VnetName != that1.VnetName {
		return false
	}
	return true
}
func (this *AzureVnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetChoiceType)
	if !ok {
		that2, ok := that.(AzureVnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AzureVnetChoiceType_NewVnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetChoiceType_NewVnet)
	if !ok {
		that2, ok := that.(AzureVnetChoiceType_NewVnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVnet.Equal(that1.NewVnet) {
		return false
	}
	return true
}
func (this *AzureVnetChoiceType_ExistingVnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetChoiceType_ExistingVnet)
	if !ok {
		that2, ok := that.(AzureVnetChoiceType_ExistingVnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingVnet.Equal(that1.ExistingVnet) {
		return false
	}
	return true
}
func (this *AzureSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType)
	if !ok {
		that2, ok := that.(AzureSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	if that1.ResourceGroupChoice == nil {
		if this.ResourceGroupChoice != nil {
			return false
		}
	} else if this.ResourceGroupChoice == nil {
		return false
	} else if !this.ResourceGroupChoice.Equal(that1.ResourceGroupChoice) {
		return false
	}
	return true
}
func (this *AzureSubnetType_SubnetResourceGrp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType_SubnetResourceGrp)
	if !ok {
		that2, ok := that.(AzureSubnetType_SubnetResourceGrp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetResourceGrp != that1.SubnetResourceGrp {
		return false
	}
	return true
}
func (this *AzureSubnetType_VnetResourceGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType_VnetResourceGroup)
	if !ok {
		that2, ok := that.(AzureSubnetType_VnetResourceGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VnetResourceGroup.Equal(that1.VnetResourceGroup) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType_SubnetParam)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType_Subnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType_Subnet)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType_Subnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	return true
}
func (this *AzureVnetOneInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetOneInterfaceNodeType)
	if !ok {
		that2, ok := that.(AzureVnetOneInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzureAz != that1.AzureAz {
		return false
	}
	if !this.LocalSubnet.Equal(that1.LocalSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AzureVnetTwoInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetTwoInterfaceNodeType)
	if !ok {
		that2, ok := that.(AzureVnetTwoInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzureAz != that1.AzureAz {
		return false
	}
	if !this.InsideSubnet.Equal(that1.InsideSubnet) {
		return false
	}
	if !this.OutsideSubnet.Equal(that1.OutsideSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *GCPVPCNetworkParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkParamsType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GCPVPCNetworkAutogenerateParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkAutogenerateParamsType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkAutogenerateParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Autogenerate != that1.Autogenerate {
		return false
	}
	return true
}
func (this *GCPVPCNetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GCPSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetType)
	if !ok {
		that2, ok := that.(GCPSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	return true
}
func (this *GCPSubnetParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetParamsType)
	if !ok {
		that2, ok := that.(GCPSubnetParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType_NewNetworkAutogenerate)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType_NewNetworkAutogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewNetworkAutogenerate.Equal(that1.NewNetworkAutogenerate) {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType_NewNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType_NewNetwork)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType_NewNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewNetwork.Equal(that1.NewNetwork) {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType_ExistingNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType_ExistingNetwork)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType_ExistingNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingNetwork.Equal(that1.ExistingNetwork) {
		return false
	}
	return true
}
func (this *GCPVPCSubnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCSubnetChoiceType)
	if !ok {
		that2, ok := that.(GCPVPCSubnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *GCPVPCSubnetChoiceType_NewSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCSubnetChoiceType_NewSubnet)
	if !ok {
		that2, ok := that.(GCPVPCSubnetChoiceType_NewSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewSubnet.Equal(that1.NewSubnet) {
		return false
	}
	return true
}
func (this *GCPVPCSubnetChoiceType_ExistingSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCSubnetChoiceType_ExistingSubnet)
	if !ok {
		that2, ok := that.(GCPVPCSubnetChoiceType_ExistingSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingSubnet.Equal(that1.ExistingSubnet) {
		return false
	}
	return true
}
func (this *SiteStaticRoutesType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesType)
	if !ok {
		that2, ok := that.(SiteStaticRoutesType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigModeChoice == nil {
		if this.ConfigModeChoice != nil {
			return false
		}
	} else if this.ConfigModeChoice == nil {
		return false
	} else if !this.ConfigModeChoice.Equal(that1.ConfigModeChoice) {
		return false
	}
	return true
}
func (this *SiteStaticRoutesType_SimpleStaticRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesType_SimpleStaticRoute)
	if !ok {
		that2, ok := that.(SiteStaticRoutesType_SimpleStaticRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SimpleStaticRoute != that1.SimpleStaticRoute {
		return false
	}
	return true
}
func (this *SiteStaticRoutesType_CustomStaticRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesType_CustomStaticRoute)
	if !ok {
		that2, ok := that.(SiteStaticRoutesType_CustomStaticRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomStaticRoute.Equal(that1.CustomStaticRoute) {
		return false
	}
	return true
}
func (this *SiteStaticRoutesListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesListType)
	if !ok {
		that2, ok := that.(SiteStaticRoutesListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StaticRouteList) != len(that1.StaticRouteList) {
		return false
	}
	for i := range this.StaticRouteList {
		if !this.StaticRouteList[i].Equal(that1.StaticRouteList[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalNetworkConnectionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConnectionChoice == nil {
		if this.ConnectionChoice != nil {
			return false
		}
	} else if this.ConnectionChoice == nil {
		return false
	} else if !this.ConnectionChoice.Equal(that1.ConnectionChoice) {
		return false
	}
	if that1.ForwardProxyChoice == nil {
		if this.ForwardProxyChoice != nil {
			return false
		}
	} else if this.ForwardProxyChoice == nil {
		return false
	} else if !this.ForwardProxyChoice.Equal(that1.ForwardProxyChoice) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_SliToGlobalDr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_SliToGlobalDr)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_SliToGlobalDr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SliToGlobalDr.Equal(that1.SliToGlobalDr) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_SloToGlobalDr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_SloToGlobalDr)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_SloToGlobalDr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SloToGlobalDr.Equal(that1.SloToGlobalDr) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_DisableForwardProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_DisableForwardProxy)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_DisableForwardProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableForwardProxy.Equal(that1.DisableForwardProxy) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_EnableForwardProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_EnableForwardProxy)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_EnableForwardProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableForwardProxy.Equal(that1.EnableForwardProxy) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionListType)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.GlobalNetworkConnections) != len(that1.GlobalNetworkConnections) {
		return false
	}
	for i := range this.GlobalNetworkConnections {
		if !this.GlobalNetworkConnections[i].Equal(that1.GlobalNetworkConnections[i]) {
			return false
		}
	}
	return true
}
func (this *AllowedVIPPorts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts)
	if !ok {
		that2, ok := that.(AllowedVIPPorts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PortChoice == nil {
		if this.PortChoice != nil {
			return false
		}
	} else if this.PortChoice == nil {
		return false
	} else if !this.PortChoice.Equal(that1.PortChoice) {
		return false
	}
	return true
}
func (this *AllowedVIPPorts_UseHttpPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts_UseHttpPort)
	if !ok {
		that2, ok := that.(AllowedVIPPorts_UseHttpPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseHttpPort.Equal(that1.UseHttpPort) {
		return false
	}
	return true
}
func (this *AllowedVIPPorts_UseHttpsPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts_UseHttpsPort)
	if !ok {
		that2, ok := that.(AllowedVIPPorts_UseHttpsPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseHttpsPort.Equal(that1.UseHttpsPort) {
		return false
	}
	return true
}
func (this *AllowedVIPPorts_UseHttpHttpsPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts_UseHttpHttpsPort)
	if !ok {
		that2, ok := that.(AllowedVIPPorts_UseHttpHttpsPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseHttpHttpsPort.Equal(that1.UseHttpHttpsPort) {
		return false
	}
	return true
}
func (this *AllowedVIPPorts_CustomPorts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts_CustomPorts)
	if !ok {
		that2, ok := that.(AllowedVIPPorts_CustomPorts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomPorts.Equal(that1.CustomPorts) {
		return false
	}
	return true
}
func (this *CustomPorts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CustomPorts)
	if !ok {
		that2, ok := that.(CustomPorts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PortRanges != that1.PortRanges {
		return false
	}
	return true
}
func (this *AWSVPCParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.AWSVPCParamsType{")
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "AllocateIpv6: "+fmt.Sprintf("%#v", this.AllocateIpv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCParamsType_NameTag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCParamsType_NameTag{` +
		`NameTag:` + fmt.Sprintf("%#v", this.NameTag) + `}`}, ", ")
	return s
}
func (this *AWSVPCParamsType_Autogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCParamsType_Autogenerate{` +
		`Autogenerate:` + fmt.Sprintf("%#v", this.Autogenerate) + `}`}, ", ")
	return s
}
func (this *AWSVPCchoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AWSVPCchoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCchoiceType_NewVpc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCchoiceType_NewVpc{` +
		`NewVpc:` + fmt.Sprintf("%#v", this.NewVpc) + `}`}, ", ")
	return s
}
func (this *AWSVPCchoiceType_VpcId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCchoiceType_VpcId{` +
		`VpcId:` + fmt.Sprintf("%#v", this.VpcId) + `}`}, ", ")
	return s
}
func (this *CloudSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.CloudSubnetParamType{")
	s = append(s, "Ipv4: "+fmt.Sprintf("%#v", this.Ipv4)+",\n")
	s = append(s, "Ipv6: "+fmt.Sprintf("%#v", this.Ipv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.CloudSubnetType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudSubnetType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.CloudSubnetType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *CloudSubnetType_ExistingSubnetId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.CloudSubnetType_ExistingSubnetId{` +
		`ExistingSubnetId:` + fmt.Sprintf("%#v", this.ExistingSubnetId) + `}`}, ", ")
	return s
}
func (this *AWSVPCOneInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AWSVPCOneInterfaceNodeType{")
	s = append(s, "AwsAzName: "+fmt.Sprintf("%#v", this.AwsAzName)+",\n")
	if this.LocalSubnet != nil {
		s = append(s, "LocalSubnet: "+fmt.Sprintf("%#v", this.LocalSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCTwoInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&views.AWSVPCTwoInterfaceNodeType{")
	s = append(s, "AwsAzName: "+fmt.Sprintf("%#v", this.AwsAzName)+",\n")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	if this.OutsideSubnet != nil {
		s = append(s, "OutsideSubnet: "+fmt.Sprintf("%#v", this.OutsideSubnet)+",\n")
	}
	if this.WorkloadSubnet != nil {
		s = append(s, "WorkloadSubnet: "+fmt.Sprintf("%#v", this.WorkloadSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet{` +
		`ReservedInsideSubnet:` + fmt.Sprintf("%#v", this.ReservedInsideSubnet) + `}`}, ", ")
	return s
}
func (this *AWSVPCTwoInterfaceNodeType_InsideSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCTwoInterfaceNodeType_InsideSubnet{` +
		`InsideSubnet:` + fmt.Sprintf("%#v", this.InsideSubnet) + `}`}, ", ")
	return s
}
func (this *AzureVnetParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AzureVnetParamsType{")
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetParamsType_Name) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetParamsType_Name{` +
		`Name:` + fmt.Sprintf("%#v", this.Name) + `}`}, ", ")
	return s
}
func (this *AzureVnetParamsType_Autogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetParamsType_Autogenerate{` +
		`Autogenerate:` + fmt.Sprintf("%#v", this.Autogenerate) + `}`}, ", ")
	return s
}
func (this *AzureVnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureVnetType{")
	s = append(s, "ResourceGroup: "+fmt.Sprintf("%#v", this.ResourceGroup)+",\n")
	s = append(s, "VnetName: "+fmt.Sprintf("%#v", this.VnetName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureVnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetChoiceType_NewVnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetChoiceType_NewVnet{` +
		`NewVnet:` + fmt.Sprintf("%#v", this.NewVnet) + `}`}, ", ")
	return s
}
func (this *AzureVnetChoiceType_ExistingVnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetChoiceType_ExistingVnet{` +
		`ExistingVnet:` + fmt.Sprintf("%#v", this.ExistingVnet) + `}`}, ", ")
	return s
}
func (this *AzureSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AzureSubnetType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	if this.ResourceGroupChoice != nil {
		s = append(s, "ResourceGroupChoice: "+fmt.Sprintf("%#v", this.ResourceGroupChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetType_SubnetResourceGrp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetType_SubnetResourceGrp{` +
		`SubnetResourceGrp:` + fmt.Sprintf("%#v", this.SubnetResourceGrp) + `}`}, ", ")
	return s
}
func (this *AzureSubnetType_VnetResourceGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetType_VnetResourceGroup{` +
		`VnetResourceGroup:` + fmt.Sprintf("%#v", this.VnetResourceGroup) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureSubnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetChoiceType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetChoiceType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceType_Subnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetChoiceType_Subnet{` +
		`Subnet:` + fmt.Sprintf("%#v", this.Subnet) + `}`}, ", ")
	return s
}
func (this *AzureVnetOneInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AzureVnetOneInterfaceNodeType{")
	s = append(s, "AzureAz: "+fmt.Sprintf("%#v", this.AzureAz)+",\n")
	if this.LocalSubnet != nil {
		s = append(s, "LocalSubnet: "+fmt.Sprintf("%#v", this.LocalSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetTwoInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.AzureVnetTwoInterfaceNodeType{")
	s = append(s, "AzureAz: "+fmt.Sprintf("%#v", this.AzureAz)+",\n")
	if this.InsideSubnet != nil {
		s = append(s, "InsideSubnet: "+fmt.Sprintf("%#v", this.InsideSubnet)+",\n")
	}
	if this.OutsideSubnet != nil {
		s = append(s, "OutsideSubnet: "+fmt.Sprintf("%#v", this.OutsideSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPVPCNetworkParamsType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkAutogenerateParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPVPCNetworkAutogenerateParamsType{")
	s = append(s, "Autogenerate: "+fmt.Sprintf("%#v", this.Autogenerate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPVPCNetworkType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPSubnetType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.GCPSubnetParamsType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.GCPVPCNetworkChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCNetworkChoiceType_NewNetworkAutogenerate{` +
		`NewNetworkAutogenerate:` + fmt.Sprintf("%#v", this.NewNetworkAutogenerate) + `}`}, ", ")
	return s
}
func (this *GCPVPCNetworkChoiceType_NewNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCNetworkChoiceType_NewNetwork{` +
		`NewNetwork:` + fmt.Sprintf("%#v", this.NewNetwork) + `}`}, ", ")
	return s
}
func (this *GCPVPCNetworkChoiceType_ExistingNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCNetworkChoiceType_ExistingNetwork{` +
		`ExistingNetwork:` + fmt.Sprintf("%#v", this.ExistingNetwork) + `}`}, ", ")
	return s
}
func (this *GCPVPCSubnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.GCPVPCSubnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCSubnetChoiceType_NewSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCSubnetChoiceType_NewSubnet{` +
		`NewSubnet:` + fmt.Sprintf("%#v", this.NewSubnet) + `}`}, ", ")
	return s
}
func (this *GCPVPCSubnetChoiceType_ExistingSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCSubnetChoiceType_ExistingSubnet{` +
		`ExistingSubnet:` + fmt.Sprintf("%#v", this.ExistingSubnet) + `}`}, ", ")
	return s
}
func (this *SiteStaticRoutesType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.SiteStaticRoutesType{")
	if this.ConfigModeChoice != nil {
		s = append(s, "ConfigModeChoice: "+fmt.Sprintf("%#v", this.ConfigModeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteStaticRoutesType_SimpleStaticRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.SiteStaticRoutesType_SimpleStaticRoute{` +
		`SimpleStaticRoute:` + fmt.Sprintf("%#v", this.SimpleStaticRoute) + `}`}, ", ")
	return s
}
func (this *SiteStaticRoutesType_CustomStaticRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.SiteStaticRoutesType_CustomStaticRoute{` +
		`CustomStaticRoute:` + fmt.Sprintf("%#v", this.CustomStaticRoute) + `}`}, ", ")
	return s
}
func (this *SiteStaticRoutesListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.SiteStaticRoutesListType{")
	if this.StaticRouteList != nil {
		s = append(s, "StaticRouteList: "+fmt.Sprintf("%#v", this.StaticRouteList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalNetworkConnectionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.GlobalNetworkConnectionType{")
	if this.ConnectionChoice != nil {
		s = append(s, "ConnectionChoice: "+fmt.Sprintf("%#v", this.ConnectionChoice)+",\n")
	}
	if this.ForwardProxyChoice != nil {
		s = append(s, "ForwardProxyChoice: "+fmt.Sprintf("%#v", this.ForwardProxyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalNetworkConnectionType_SliToGlobalDr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_SliToGlobalDr{` +
		`SliToGlobalDr:` + fmt.Sprintf("%#v", this.SliToGlobalDr) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionType_SloToGlobalDr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_SloToGlobalDr{` +
		`SloToGlobalDr:` + fmt.Sprintf("%#v", this.SloToGlobalDr) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionType_DisableForwardProxy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_DisableForwardProxy{` +
		`DisableForwardProxy:` + fmt.Sprintf("%#v", this.DisableForwardProxy) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionType_EnableForwardProxy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_EnableForwardProxy{` +
		`EnableForwardProxy:` + fmt.Sprintf("%#v", this.EnableForwardProxy) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GlobalNetworkConnectionListType{")
	if this.GlobalNetworkConnections != nil {
		s = append(s, "GlobalNetworkConnections: "+fmt.Sprintf("%#v", this.GlobalNetworkConnections)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllowedVIPPorts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.AllowedVIPPorts{")
	if this.PortChoice != nil {
		s = append(s, "PortChoice: "+fmt.Sprintf("%#v", this.PortChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllowedVIPPorts_UseHttpPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AllowedVIPPorts_UseHttpPort{` +
		`UseHttpPort:` + fmt.Sprintf("%#v", this.UseHttpPort) + `}`}, ", ")
	return s
}
func (this *AllowedVIPPorts_UseHttpsPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AllowedVIPPorts_UseHttpsPort{` +
		`UseHttpsPort:` + fmt.Sprintf("%#v", this.UseHttpsPort) + `}`}, ", ")
	return s
}
func (this *AllowedVIPPorts_UseHttpHttpsPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AllowedVIPPorts_UseHttpHttpsPort{` +
		`UseHttpHttpsPort:` + fmt.Sprintf("%#v", this.UseHttpHttpsPort) + `}`}, ", ")
	return s
}
func (this *AllowedVIPPorts_CustomPorts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AllowedVIPPorts_CustomPorts{` +
		`CustomPorts:` + fmt.Sprintf("%#v", this.CustomPorts) + `}`}, ", ")
	return s
}
func (this *CustomPorts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.CustomPorts{")
	s = append(s, "PortRanges: "+fmt.Sprintf("%#v", this.PortRanges)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSiteTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSVPCParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NameChoice != nil {
		nn1, err := m.NameChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if len(m.PrimaryIpv4) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i += copy(dAtA[i:], m.PrimaryIpv4)
	}
	if m.AllocateIpv6 {
		dAtA[i] = 0x30
		i++
		if m.AllocateIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AWSVPCParamsType_NameTag) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.NameTag)))
	i += copy(dAtA[i:], m.NameTag)
	return i, nil
}
func (m *AWSVPCParamsType_Autogenerate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Autogenerate != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.Autogenerate.Size()))
		n2, err := m.Autogenerate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *AWSVPCchoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCchoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn3, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *AWSVPCchoiceType_NewVpc) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewVpc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NewVpc.Size()))
		n4, err := m.NewVpc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *AWSVPCchoiceType_VpcId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.VpcId)))
	i += copy(dAtA[i:], m.VpcId)
	return i, nil
}
func (m *CloudSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ipv4) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Ipv4)))
		i += copy(dAtA[i:], m.Ipv4)
	}
	if len(m.Ipv6) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Ipv6)))
		i += copy(dAtA[i:], m.Ipv6)
	}
	return i, nil
}

func (m *CloudSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudSubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn5, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *CloudSubnetType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SubnetParam != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.SubnetParam.Size()))
		n6, err := m.SubnetParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *CloudSubnetType_ExistingSubnetId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.ExistingSubnetId)))
	i += copy(dAtA[i:], m.ExistingSubnetId)
	return i, nil
}
func (m *AWSVPCOneInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCOneInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AwsAzName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AwsAzName)))
		i += copy(dAtA[i:], m.AwsAzName)
	}
	if m.LocalSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.LocalSubnet.Size()))
		n7, err := m.LocalSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.DiskSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DiskSize))
	}
	return i, nil
}

func (m *AWSVPCTwoInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCTwoInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AwsAzName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AwsAzName)))
		i += copy(dAtA[i:], m.AwsAzName)
	}
	if m.Choice != nil {
		nn8, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	if m.OutsideSubnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.OutsideSubnet.Size()))
		n9, err := m.OutsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.WorkloadSubnet != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.WorkloadSubnet.Size()))
		n10, err := m.WorkloadSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.DiskSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DiskSize))
	}
	return i, nil
}

func (m *AWSVPCTwoInterfaceNodeType_InsideSubnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InsideSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.InsideSubnet.Size()))
		n11, err := m.InsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ReservedInsideSubnet != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.ReservedInsideSubnet.Size()))
		n12, err := m.ReservedInsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *AzureVnetParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NameChoice != nil {
		nn13, err := m.NameChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn13
	}
	if len(m.PrimaryIpv4) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i += copy(dAtA[i:], m.PrimaryIpv4)
	}
	return i, nil
}

func (m *AzureVnetParamsType_Name) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}
func (m *AzureVnetParamsType_Autogenerate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Autogenerate != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.Autogenerate.Size()))
		n14, err := m.Autogenerate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *AzureVnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceGroup) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.ResourceGroup)))
		i += copy(dAtA[i:], m.ResourceGroup)
	}
	if len(m.VnetName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.VnetName)))
		i += copy(dAtA[i:], m.VnetName)
	}
	return i, nil
}

func (m *AzureVnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn15, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	return i, nil
}

func (m *AzureVnetChoiceType_NewVnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewVnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NewVnet.Size()))
		n16, err := m.NewVnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *AzureVnetChoiceType_ExistingVnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExistingVnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.ExistingVnet.Size()))
		n17, err := m.ExistingVnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *AzureSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetName)))
		i += copy(dAtA[i:], m.SubnetName)
	}
	if m.ResourceGroupChoice != nil {
		nn18, err := m.ResourceGroupChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn18
	}
	return i, nil
}

func (m *AzureSubnetType_SubnetResourceGrp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetResourceGrp)))
	i += copy(dAtA[i:], m.SubnetResourceGrp)
	return i, nil
}
func (m *AzureSubnetType_VnetResourceGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VnetResourceGroup != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.VnetResourceGroup.Size()))
		n19, err := m.VnetResourceGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *AzureSubnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn20, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	return i, nil
}

func (m *AzureSubnetChoiceType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SubnetParam != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.SubnetParam.Size()))
		n21, err := m.SubnetParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *AzureSubnetChoiceType_Subnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Subnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.Subnet.Size()))
		n22, err := m.Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *AzureVnetOneInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetOneInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AzureAz) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AzureAz)))
		i += copy(dAtA[i:], m.AzureAz)
	}
	if m.LocalSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.LocalSubnet.Size()))
		n23, err := m.LocalSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.DiskSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DiskSize))
	}
	return i, nil
}

func (m *AzureVnetTwoInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetTwoInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AzureAz) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AzureAz)))
		i += copy(dAtA[i:], m.AzureAz)
	}
	if m.InsideSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.InsideSubnet.Size()))
		n24, err := m.InsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.OutsideSubnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.OutsideSubnet.Size()))
		n25, err := m.OutsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.DiskSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DiskSize))
	}
	return i, nil
}

func (m *GCPVPCNetworkParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GCPVPCNetworkAutogenerateParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkAutogenerateParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Autogenerate {
		dAtA[i] = 0x8
		i++
		if m.Autogenerate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GCPVPCNetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GCPSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetName)))
		i += copy(dAtA[i:], m.SubnetName)
	}
	return i, nil
}

func (m *GCPSubnetParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetName)))
		i += copy(dAtA[i:], m.SubnetName)
	}
	if len(m.PrimaryIpv4) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i += copy(dAtA[i:], m.PrimaryIpv4)
	}
	return i, nil
}

func (m *GCPVPCNetworkChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkChoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn26, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	return i, nil
}

func (m *GCPVPCNetworkChoiceType_NewNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewNetwork != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NewNetwork.Size()))
		n27, err := m.NewNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *GCPVPCNetworkChoiceType_ExistingNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExistingNetwork != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.ExistingNetwork.Size()))
		n28, err := m.ExistingNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewNetworkAutogenerate != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NewNetworkAutogenerate.Size()))
		n29, err := m.NewNetworkAutogenerate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *GCPVPCSubnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCSubnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn30, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn30
	}
	return i, nil
}

func (m *GCPVPCSubnetChoiceType_NewSubnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NewSubnet.Size()))
		n31, err := m.NewSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *GCPVPCSubnetChoiceType_ExistingSubnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExistingSubnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.ExistingSubnet.Size()))
		n32, err := m.ExistingSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *SiteStaticRoutesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStaticRoutesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigModeChoice != nil {
		nn33, err := m.ConfigModeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn33
	}
	return i, nil
}

func (m *SiteStaticRoutesType_SimpleStaticRoute) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SimpleStaticRoute)))
	i += copy(dAtA[i:], m.SimpleStaticRoute)
	return i, nil
}
func (m *SiteStaticRoutesType_CustomStaticRoute) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CustomStaticRoute != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.CustomStaticRoute.Size()))
		n34, err := m.CustomStaticRoute.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *SiteStaticRoutesListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStaticRoutesListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StaticRouteList) > 0 {
		for _, msg := range m.StaticRouteList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSiteTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GlobalNetworkConnectionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalNetworkConnectionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConnectionChoice != nil {
		nn35, err := m.ConnectionChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn35
	}
	if m.ForwardProxyChoice != nil {
		nn36, err := m.ForwardProxyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn36
	}
	return i, nil
}

func (m *GlobalNetworkConnectionType_SliToGlobalDr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SliToGlobalDr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.SliToGlobalDr.Size()))
		n37, err := m.SliToGlobalDr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *GlobalNetworkConnectionType_SloToGlobalDr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SloToGlobalDr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.SloToGlobalDr.Size()))
		n38, err := m.SloToGlobalDr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *GlobalNetworkConnectionType_DisableForwardProxy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DisableForwardProxy != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DisableForwardProxy.Size()))
		n39, err := m.DisableForwardProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *GlobalNetworkConnectionType_EnableForwardProxy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableForwardProxy != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.EnableForwardProxy.Size()))
		n40, err := m.EnableForwardProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *GlobalNetworkConnectionListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalNetworkConnectionListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GlobalNetworkConnections) > 0 {
		for _, msg := range m.GlobalNetworkConnections {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSiteTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AllowedVIPPorts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowedVIPPorts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortChoice != nil {
		nn41, err := m.PortChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn41
	}
	return i, nil
}

func (m *AllowedVIPPorts_UseHttpPort) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UseHttpPort != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.UseHttpPort.Size()))
		n42, err := m.UseHttpPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}
func (m *AllowedVIPPorts_UseHttpsPort) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UseHttpsPort != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.UseHttpsPort.Size()))
		n43, err := m.UseHttpsPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}
func (m *AllowedVIPPorts_UseHttpHttpsPort) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UseHttpHttpsPort != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.UseHttpHttpsPort.Size()))
		n44, err := m.UseHttpHttpsPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}
func (m *AllowedVIPPorts_CustomPorts) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CustomPorts != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.CustomPorts.Size()))
		n45, err := m.CustomPorts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *CustomPorts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomPorts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PortRanges) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PortRanges)))
		i += copy(dAtA[i:], m.PortRanges)
	}
	return i, nil
}

func encodeVarintSiteTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AWSVPCParamsType) Size() (n int) {
	var l int
	_ = l
	if m.NameChoice != nil {
		n += m.NameChoice.Size()
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.AllocateIpv6 {
		n += 2
	}
	return n
}

func (m *AWSVPCParamsType_NameTag) Size() (n int) {
	var l int
	_ = l
	l = len(m.NameTag)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AWSVPCParamsType_Autogenerate) Size() (n int) {
	var l int
	_ = l
	if m.Autogenerate != nil {
		l = m.Autogenerate.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCchoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AWSVPCchoiceType_NewVpc) Size() (n int) {
	var l int
	_ = l
	if m.NewVpc != nil {
		l = m.NewVpc.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCchoiceType_VpcId) Size() (n int) {
	var l int
	_ = l
	l = len(m.VpcId)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *CloudSubnetParamType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.Ipv6)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *CloudSubnetType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *CloudSubnetType_SubnetParam) Size() (n int) {
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *CloudSubnetType_ExistingSubnetId) Size() (n int) {
	var l int
	_ = l
	l = len(m.ExistingSubnetId)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AWSVPCOneInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AwsAzName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.LocalSubnet != nil {
		l = m.LocalSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovSiteTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *AWSVPCTwoInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AwsAzName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	if m.OutsideSubnet != nil {
		l = m.OutsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.WorkloadSubnet != nil {
		l = m.WorkloadSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovSiteTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *AWSVPCTwoInterfaceNodeType_InsideSubnet) Size() (n int) {
	var l int
	_ = l
	if m.InsideSubnet != nil {
		l = m.InsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) Size() (n int) {
	var l int
	_ = l
	if m.ReservedInsideSubnet != nil {
		l = m.ReservedInsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetParamsType) Size() (n int) {
	var l int
	_ = l
	if m.NameChoice != nil {
		n += m.NameChoice.Size()
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetParamsType_Name) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AzureVnetParamsType_Autogenerate) Size() (n int) {
	var l int
	_ = l
	if m.Autogenerate != nil {
		l = m.Autogenerate.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.VnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetChoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AzureVnetChoiceType_NewVnet) Size() (n int) {
	var l int
	_ = l
	if m.NewVnet != nil {
		l = m.NewVnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetChoiceType_ExistingVnet) Size() (n int) {
	var l int
	_ = l
	if m.ExistingVnet != nil {
		l = m.ExistingVnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetType) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.ResourceGroupChoice != nil {
		n += m.ResourceGroupChoice.Size()
	}
	return n
}

func (m *AzureSubnetType_SubnetResourceGrp) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetResourceGrp)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AzureSubnetType_VnetResourceGroup) Size() (n int) {
	var l int
	_ = l
	if m.VnetResourceGroup != nil {
		l = m.VnetResourceGroup.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AzureSubnetChoiceType_SubnetParam) Size() (n int) {
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceType_Subnet) Size() (n int) {
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetOneInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AzureAz)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.LocalSubnet != nil {
		l = m.LocalSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovSiteTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *AzureVnetTwoInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AzureAz)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.InsideSubnet != nil {
		l = m.InsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.OutsideSubnet != nil {
		l = m.OutsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovSiteTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *GCPVPCNetworkParamsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCNetworkAutogenerateParamsType) Size() (n int) {
	var l int
	_ = l
	if m.Autogenerate {
		n += 2
	}
	return n
}

func (m *GCPVPCNetworkType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPSubnetType) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPSubnetParamsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCNetworkChoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *GCPVPCNetworkChoiceType_NewNetwork) Size() (n int) {
	var l int
	_ = l
	if m.NewNetwork != nil {
		l = m.NewNetwork.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCNetworkChoiceType_ExistingNetwork) Size() (n int) {
	var l int
	_ = l
	if m.ExistingNetwork != nil {
		l = m.ExistingNetwork.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) Size() (n int) {
	var l int
	_ = l
	if m.NewNetworkAutogenerate != nil {
		l = m.NewNetworkAutogenerate.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCSubnetChoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *GCPVPCSubnetChoiceType_NewSubnet) Size() (n int) {
	var l int
	_ = l
	if m.NewSubnet != nil {
		l = m.NewSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCSubnetChoiceType_ExistingSubnet) Size() (n int) {
	var l int
	_ = l
	if m.ExistingSubnet != nil {
		l = m.ExistingSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *SiteStaticRoutesType) Size() (n int) {
	var l int
	_ = l
	if m.ConfigModeChoice != nil {
		n += m.ConfigModeChoice.Size()
	}
	return n
}

func (m *SiteStaticRoutesType_SimpleStaticRoute) Size() (n int) {
	var l int
	_ = l
	l = len(m.SimpleStaticRoute)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *SiteStaticRoutesType_CustomStaticRoute) Size() (n int) {
	var l int
	_ = l
	if m.CustomStaticRoute != nil {
		l = m.CustomStaticRoute.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *SiteStaticRoutesListType) Size() (n int) {
	var l int
	_ = l
	if len(m.StaticRouteList) > 0 {
		for _, e := range m.StaticRouteList {
			l = e.Size()
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalNetworkConnectionType) Size() (n int) {
	var l int
	_ = l
	if m.ConnectionChoice != nil {
		n += m.ConnectionChoice.Size()
	}
	if m.ForwardProxyChoice != nil {
		n += m.ForwardProxyChoice.Size()
	}
	return n
}

func (m *GlobalNetworkConnectionType_SliToGlobalDr) Size() (n int) {
	var l int
	_ = l
	if m.SliToGlobalDr != nil {
		l = m.SliToGlobalDr.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionType_SloToGlobalDr) Size() (n int) {
	var l int
	_ = l
	if m.SloToGlobalDr != nil {
		l = m.SloToGlobalDr.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionType_DisableForwardProxy) Size() (n int) {
	var l int
	_ = l
	if m.DisableForwardProxy != nil {
		l = m.DisableForwardProxy.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionType_EnableForwardProxy) Size() (n int) {
	var l int
	_ = l
	if m.EnableForwardProxy != nil {
		l = m.EnableForwardProxy.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionListType) Size() (n int) {
	var l int
	_ = l
	if len(m.GlobalNetworkConnections) > 0 {
		for _, e := range m.GlobalNetworkConnections {
			l = e.Size()
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	return n
}

func (m *AllowedVIPPorts) Size() (n int) {
	var l int
	_ = l
	if m.PortChoice != nil {
		n += m.PortChoice.Size()
	}
	return n
}

func (m *AllowedVIPPorts_UseHttpPort) Size() (n int) {
	var l int
	_ = l
	if m.UseHttpPort != nil {
		l = m.UseHttpPort.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AllowedVIPPorts_UseHttpsPort) Size() (n int) {
	var l int
	_ = l
	if m.UseHttpsPort != nil {
		l = m.UseHttpsPort.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AllowedVIPPorts_UseHttpHttpsPort) Size() (n int) {
	var l int
	_ = l
	if m.UseHttpHttpsPort != nil {
		l = m.UseHttpHttpsPort.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AllowedVIPPorts_CustomPorts) Size() (n int) {
	var l int
	_ = l
	if m.CustomPorts != nil {
		l = m.CustomPorts.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *CustomPorts) Size() (n int) {
	var l int
	_ = l
	l = len(m.PortRanges)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func sovSiteTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSiteTypes(x uint64) (n int) {
	return sovSiteTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSVPCParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCParamsType{`,
		`NameChoice:` + fmt.Sprintf("%v", this.NameChoice) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`AllocateIpv6:` + fmt.Sprintf("%v", this.AllocateIpv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCParamsType_NameTag) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCParamsType_NameTag{`,
		`NameTag:` + fmt.Sprintf("%v", this.NameTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCParamsType_Autogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCParamsType_Autogenerate{`,
		`Autogenerate:` + strings.Replace(fmt.Sprintf("%v", this.Autogenerate), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCchoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCchoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCchoiceType_NewVpc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCchoiceType_NewVpc{`,
		`NewVpc:` + strings.Replace(fmt.Sprintf("%v", this.NewVpc), "AWSVPCParamsType", "AWSVPCParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCchoiceType_VpcId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCchoiceType_VpcId{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetParamType{`,
		`Ipv4:` + fmt.Sprintf("%v", this.Ipv4) + `,`,
		`Ipv6:` + fmt.Sprintf("%v", this.Ipv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "CloudSubnetParamType", "CloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType_ExistingSubnetId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType_ExistingSubnetId{`,
		`ExistingSubnetId:` + fmt.Sprintf("%v", this.ExistingSubnetId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCOneInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCOneInterfaceNodeType{`,
		`AwsAzName:` + fmt.Sprintf("%v", this.AwsAzName) + `,`,
		`LocalSubnet:` + strings.Replace(fmt.Sprintf("%v", this.LocalSubnet), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCTwoInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCTwoInterfaceNodeType{`,
		`AwsAzName:` + fmt.Sprintf("%v", this.AwsAzName) + `,`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`OutsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.OutsideSubnet), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`WorkloadSubnet:` + strings.Replace(fmt.Sprintf("%v", this.WorkloadSubnet), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCTwoInterfaceNodeType_InsideSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCTwoInterfaceNodeType_InsideSubnet{`,
		`InsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.InsideSubnet), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet{`,
		`ReservedInsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.ReservedInsideSubnet), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetParamsType{`,
		`NameChoice:` + fmt.Sprintf("%v", this.NameChoice) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetParamsType_Name) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetParamsType_Name{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetParamsType_Autogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetParamsType_Autogenerate{`,
		`Autogenerate:` + strings.Replace(fmt.Sprintf("%v", this.Autogenerate), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetType{`,
		`ResourceGroup:` + fmt.Sprintf("%v", this.ResourceGroup) + `,`,
		`VnetName:` + fmt.Sprintf("%v", this.VnetName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetChoiceType_NewVnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetChoiceType_NewVnet{`,
		`NewVnet:` + strings.Replace(fmt.Sprintf("%v", this.NewVnet), "AzureVnetParamsType", "AzureVnetParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetChoiceType_ExistingVnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetChoiceType_ExistingVnet{`,
		`ExistingVnet:` + strings.Replace(fmt.Sprintf("%v", this.ExistingVnet), "AzureVnetType", "AzureVnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`ResourceGroupChoice:` + fmt.Sprintf("%v", this.ResourceGroupChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType_SubnetResourceGrp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType_SubnetResourceGrp{`,
		`SubnetResourceGrp:` + fmt.Sprintf("%v", this.SubnetResourceGrp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType_VnetResourceGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType_VnetResourceGroup{`,
		`VnetResourceGroup:` + strings.Replace(fmt.Sprintf("%v", this.VnetResourceGroup), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "CloudSubnetParamType", "CloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType_Subnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType_Subnet{`,
		`Subnet:` + strings.Replace(fmt.Sprintf("%v", this.Subnet), "AzureSubnetType", "AzureSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetOneInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetOneInterfaceNodeType{`,
		`AzureAz:` + fmt.Sprintf("%v", this.AzureAz) + `,`,
		`LocalSubnet:` + strings.Replace(fmt.Sprintf("%v", this.LocalSubnet), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetTwoInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetTwoInterfaceNodeType{`,
		`AzureAz:` + fmt.Sprintf("%v", this.AzureAz) + `,`,
		`InsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.InsideSubnet), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`OutsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.OutsideSubnet), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkParamsType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkAutogenerateParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkAutogenerateParamsType{`,
		`Autogenerate:` + fmt.Sprintf("%v", this.Autogenerate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetParamsType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType_NewNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType_NewNetwork{`,
		`NewNetwork:` + strings.Replace(fmt.Sprintf("%v", this.NewNetwork), "GCPVPCNetworkParamsType", "GCPVPCNetworkParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType_ExistingNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType_ExistingNetwork{`,
		`ExistingNetwork:` + strings.Replace(fmt.Sprintf("%v", this.ExistingNetwork), "GCPVPCNetworkType", "GCPVPCNetworkType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType_NewNetworkAutogenerate{`,
		`NewNetworkAutogenerate:` + strings.Replace(fmt.Sprintf("%v", this.NewNetworkAutogenerate), "GCPVPCNetworkAutogenerateParamsType", "GCPVPCNetworkAutogenerateParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCSubnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCSubnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCSubnetChoiceType_NewSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCSubnetChoiceType_NewSubnet{`,
		`NewSubnet:` + strings.Replace(fmt.Sprintf("%v", this.NewSubnet), "GCPSubnetParamsType", "GCPSubnetParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCSubnetChoiceType_ExistingSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCSubnetChoiceType_ExistingSubnet{`,
		`ExistingSubnet:` + strings.Replace(fmt.Sprintf("%v", this.ExistingSubnet), "GCPSubnetType", "GCPSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesType{`,
		`ConfigModeChoice:` + fmt.Sprintf("%v", this.ConfigModeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesType_SimpleStaticRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesType_SimpleStaticRoute{`,
		`SimpleStaticRoute:` + fmt.Sprintf("%v", this.SimpleStaticRoute) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesType_CustomStaticRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesType_CustomStaticRoute{`,
		`CustomStaticRoute:` + strings.Replace(fmt.Sprintf("%v", this.CustomStaticRoute), "StaticRouteType", "ves_io_schema4.StaticRouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesListType{`,
		`StaticRouteList:` + strings.Replace(fmt.Sprintf("%v", this.StaticRouteList), "SiteStaticRoutesType", "SiteStaticRoutesType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType{`,
		`ConnectionChoice:` + fmt.Sprintf("%v", this.ConnectionChoice) + `,`,
		`ForwardProxyChoice:` + fmt.Sprintf("%v", this.ForwardProxyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_SliToGlobalDr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_SliToGlobalDr{`,
		`SliToGlobalDr:` + strings.Replace(fmt.Sprintf("%v", this.SliToGlobalDr), "GlobalConnectorType", "GlobalConnectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_SloToGlobalDr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_SloToGlobalDr{`,
		`SloToGlobalDr:` + strings.Replace(fmt.Sprintf("%v", this.SloToGlobalDr), "GlobalConnectorType", "GlobalConnectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_DisableForwardProxy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_DisableForwardProxy{`,
		`DisableForwardProxy:` + strings.Replace(fmt.Sprintf("%v", this.DisableForwardProxy), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_EnableForwardProxy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_EnableForwardProxy{`,
		`EnableForwardProxy:` + strings.Replace(fmt.Sprintf("%v", this.EnableForwardProxy), "ForwardProxyConfigType", "ves_io_schema4.ForwardProxyConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionListType{`,
		`GlobalNetworkConnections:` + strings.Replace(fmt.Sprintf("%v", this.GlobalNetworkConnections), "GlobalNetworkConnectionType", "GlobalNetworkConnectionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts{`,
		`PortChoice:` + fmt.Sprintf("%v", this.PortChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts_UseHttpPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts_UseHttpPort{`,
		`UseHttpPort:` + strings.Replace(fmt.Sprintf("%v", this.UseHttpPort), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts_UseHttpsPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts_UseHttpsPort{`,
		`UseHttpsPort:` + strings.Replace(fmt.Sprintf("%v", this.UseHttpsPort), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts_UseHttpHttpsPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts_UseHttpHttpsPort{`,
		`UseHttpHttpsPort:` + strings.Replace(fmt.Sprintf("%v", this.UseHttpHttpsPort), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts_CustomPorts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts_CustomPorts{`,
		`CustomPorts:` + strings.Replace(fmt.Sprintf("%v", this.CustomPorts), "CustomPorts", "CustomPorts", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomPorts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomPorts{`,
		`PortRanges:` + fmt.Sprintf("%v", this.PortRanges) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSiteTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSVPCParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameChoice = &AWSVPCParamsType_NameTag{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocateIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllocateIpv6 = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NameChoice = &AWSVPCParamsType_Autogenerate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCchoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCchoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCchoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSVPCParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AWSVPCchoiceType_NewVpc{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &AWSVPCchoiceType_VpcId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CloudSubnetType_SubnetParam{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &CloudSubnetType_ExistingSubnetId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCOneInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCOneInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCOneInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalSubnet == nil {
				m.LocalSubnet = &CloudSubnetType{}
			}
			if err := m.LocalSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCTwoInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCTwoInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCTwoInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AWSVPCTwoInterfaceNodeType_InsideSubnet{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutsideSubnet == nil {
				m.OutsideSubnet = &CloudSubnetType{}
			}
			if err := m.OutsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedInsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadSubnet == nil {
				m.WorkloadSubnet = &CloudSubnetType{}
			}
			if err := m.WorkloadSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameChoice = &AzureVnetParamsType_Name{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NameChoice = &AzureVnetParamsType_Autogenerate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVnetParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureVnetChoiceType_NewVnet{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingVnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureVnetChoiceType_ExistingVnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetResourceGrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroupChoice = &AzureSubnetType_SubnetResourceGrp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetResourceGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceGroupChoice = &AzureSubnetType_VnetResourceGroup{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceType_SubnetParam{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceType_Subnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetOneInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetOneInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetOneInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureAz", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureAz = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalSubnet == nil {
				m.LocalSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.LocalSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetTwoInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetTwoInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetTwoInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureAz", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureAz = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideSubnet == nil {
				m.InsideSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.InsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutsideSubnet == nil {
				m.OutsideSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.OutsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkAutogenerateParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkAutogenerateParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkAutogenerateParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Autogenerate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPVPCNetworkParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCNetworkChoiceType_NewNetwork{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPVPCNetworkType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCNetworkChoiceType_ExistingNetwork{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNetworkAutogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPVPCNetworkAutogenerateParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCNetworkChoiceType_NewNetworkAutogenerate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCSubnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCSubnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCSubnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPSubnetParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCSubnetChoiceType_NewSubnet{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCSubnetChoiceType_ExistingSubnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStaticRoutesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStaticRoutesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStaticRoutesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleStaticRoute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigModeChoice = &SiteStaticRoutesType_SimpleStaticRoute{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomStaticRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.StaticRouteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigModeChoice = &SiteStaticRoutesType_CustomStaticRoute{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStaticRoutesListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStaticRoutesListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStaticRoutesListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRouteList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRouteList = append(m.StaticRouteList, &SiteStaticRoutesType{})
			if err := m.StaticRouteList[len(m.StaticRouteList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalNetworkConnectionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalNetworkConnectionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalNetworkConnectionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliToGlobalDr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GlobalConnectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalNetworkConnectionType_SliToGlobalDr{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SloToGlobalDr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GlobalConnectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalNetworkConnectionType_SloToGlobalDr{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableForwardProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ForwardProxyChoice = &GlobalNetworkConnectionType_DisableForwardProxy{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableForwardProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.ForwardProxyConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ForwardProxyChoice = &GlobalNetworkConnectionType_EnableForwardProxy{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalNetworkConnectionListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalNetworkConnectionListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalNetworkConnectionListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalNetworkConnections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalNetworkConnections = append(m.GlobalNetworkConnections, &GlobalNetworkConnectionType{})
			if err := m.GlobalNetworkConnections[len(m.GlobalNetworkConnections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowedVIPPorts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowedVIPPorts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowedVIPPorts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHttpPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AllowedVIPPorts_UseHttpPort{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHttpsPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AllowedVIPPorts_UseHttpsPort{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHttpHttpsPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AllowedVIPPorts_UseHttpHttpsPort{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CustomPorts{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AllowedVIPPorts_CustomPorts{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomPorts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomPorts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomPorts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSiteTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSiteTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSiteTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSiteTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSiteTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSiteTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/views/site_types.proto", fileDescriptorSiteTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/site_types.proto", fileDescriptorSiteTypes)
}

var fileDescriptorSiteTypes = []byte{
	// 2430 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcb, 0x6f, 0x1b, 0xc7,
	0x19, 0xe7, 0x90, 0x14, 0x45, 0x0d, 0x45, 0x89, 0x5a, 0xc9, 0x09, 0xa3, 0x24, 0xb4, 0x4a, 0x3f,
	0x22, 0x1b, 0x24, 0x65, 0x52, 0xb2, 0xa2, 0xba, 0x80, 0x6b, 0x51, 0x76, 0x2c, 0xb9, 0xb5, 0xad,
	0xac, 0x1c, 0x05, 0x48, 0x91, 0x2c, 0x96, 0xcb, 0x11, 0xbd, 0x30, 0xb9, 0xb3, 0xd8, 0x59, 0x92,
	0xb6, 0x5a, 0xa3, 0x46, 0x0f, 0x6d, 0x50, 0x14, 0xa8, 0xd1, 0x53, 0xff, 0x84, 0xa2, 0x68, 0x2f,
	0x3d, 0x96, 0x39, 0x08, 0x39, 0x14, 0x3e, 0x0a, 0xe8, 0xc5, 0x40, 0x2f, 0xb1, 0x82, 0x02, 0xce,
	0xa1, 0xb0, 0xe1, 0x53, 0x6e, 0x2d, 0xe6, 0xb1, 0xe4, 0xec, 0x8a, 0xd4, 0x23, 0xed, 0xa1, 0x07,
	0x9f, 0x34, 0x8f, 0xdf, 0xfc, 0xe6, 0x9b, 0xef, 0xfb, 0xf6, 0x7b, 0x88, 0xf0, 0x74, 0x0b, 0x91,
	0x82, 0x89, 0xe7, 0x88, 0x71, 0x17, 0x35, 0xf4, 0xb9, 0x96, 0x89, 0xda, 0x64, 0x8e, 0x98, 0x2e,
	0xd2, 0xdc, 0x07, 0x36, 0x22, 0x05, 0xdb, 0xc1, 0x2e, 0x56, 0x26, 0x39, 0xaa, 0xc0, 0x51, 0x05,
	0x86, 0x9a, 0xce, 0xd7, 0x4c, 0xf7, 0x6e, 0xb3, 0x52, 0x30, 0x70, 0x63, 0xae, 0x86, 0x6b, 0x78,
	0x8e, 0x61, 0x2b, 0xcd, 0x2d, 0x36, 0x63, 0x13, 0x36, 0xe2, 0x1c, 0xd3, 0x6f, 0xfa, 0x6f, 0xb2,
	0x90, 0x2b, 0x36, 0xde, 0xf6, 0x6f, 0x60, 0xdb, 0x35, 0xb1, 0x25, 0x6e, 0x9e, 0x7e, 0xcb, 0xbf,
	0x29, 0x09, 0x35, 0xfd, 0x4e, 0x40, 0x74, 0xbd, 0x6e, 0x56, 0x75, 0x17, 0x89, 0xdd, 0x99, 0xfd,
	0x0f, 0xd3, 0xfc, 0xd4, 0x27, 0xfb, 0x3d, 0x5d, 0xba, 0x20, 0xfb, 0x97, 0x30, 0x4c, 0x2d, 0x7f,
	0xbc, 0xb1, 0xb9, 0xbe, 0xb2, 0xae, 0x3b, 0x7a, 0x83, 0xdc, 0x79, 0x60, 0x23, 0xe5, 0x3c, 0x8c,
	0x5b, 0x7a, 0x03, 0x69, 0xae, 0x5e, 0x4b, 0x87, 0x67, 0xc0, 0xec, 0x48, 0x39, 0xf9, 0x6d, 0x07,
	0x84, 0xfe, 0xfa, 0xcd, 0x4e, 0x24, 0xea, 0x84, 0xd3, 0x57, 0x56, 0x43, 0xea, 0x30, 0x05, 0xdc,
	0xd1, 0x6b, 0xca, 0x35, 0x38, 0x6a, 0x3b, 0x66, 0x43, 0x77, 0x1e, 0x68, 0xa6, 0xdd, 0x5a, 0x48,
	0x47, 0x18, 0x3e, 0xeb, 0xe1, 0x87, 0x9c, 0xc8, 0xb7, 0x00, 0x88, 0xd1, 0xef, 0xc3, 0xef, 0x88,
	0xd1, 0xe3, 0x70, 0x4a, 0x4d, 0x88, 0x73, 0x6b, 0x76, 0x6b, 0x41, 0xc9, 0xc3, 0xa4, 0x5e, 0xaf,
	0x63, 0x43, 0x77, 0x11, 0xe5, 0x59, 0x4c, 0xc7, 0x66, 0xc0, 0x6c, 0xbc, 0x1c, 0x7f, 0xde, 0x01,
	0x80, 0x72, 0xa9, 0xa3, 0xde, 0xf6, 0x9a, 0xdd, 0x5a, 0x54, 0x2e, 0xc1, 0x51, 0xbd, 0xe9, 0xe2,
	0x1a, 0xb2, 0x90, 0xa3, 0xbb, 0x28, 0x1d, 0x9f, 0x01, 0xb3, 0x89, 0xd2, 0x54, 0xc1, 0x6f, 0xc3,
	0x6b, 0x0d, 0xdb, 0x7d, 0xb0, 0x4a, 0xcf, 0x4a, 0xd8, 0x4b, 0xf1, 0x57, 0x97, 0x87, 0xde, 0xcf,
	0xcd, 0xe7, 0x16, 0xcb, 0x19, 0x98, 0x60, 0xef, 0x34, 0xee, 0x62, 0xd3, 0x40, 0xca, 0xf8, 0x4e,
	0x07, 0xc4, 0x77, 0x3b, 0x60, 0x78, 0xaf, 0x03, 0x22, 0x4b, 0xb9, 0xd2, 0x8d, 0x68, 0x1c, 0xa4,
	0xc2, 0x37, 0xa2, 0xf1, 0x68, 0x6a, 0xe8, 0x46, 0x34, 0x3e, 0x94, 0x8a, 0xdd, 0x88, 0xc6, 0x87,
	0x53, 0xf1, 0xec, 0x13, 0xe0, 0x29, 0x8d, 0x9f, 0x64, 0x4a, 0xbb, 0x02, 0x87, 0x2d, 0xd4, 0xd6,
	0x5a, 0xb6, 0x91, 0x06, 0x4c, 0x9a, 0x33, 0x85, 0x3e, 0x1e, 0x55, 0x08, 0x2a, 0x7b, 0x35, 0xa4,
	0xc6, 0x2c, 0xd4, 0xde, 0xb4, 0x0d, 0xe5, 0x43, 0x18, 0x6b, 0xd9, 0x86, 0x66, 0x56, 0x85, 0xd2,
	0x97, 0x7c, 0x4a, 0xa7, 0x83, 0xb3, 0xce, 0xe9, 0x52, 0xf6, 0xb3, 0xd9, 0x96, 0x6d, 0xe4, 0xcf,
	0xcd, 0xfe, 0x44, 0xcf, 0x6f, 0x5f, 0xc8, 0x7f, 0xff, 0xd3, 0x9f, 0x2e, 0x3d, 0xfc, 0x59, 0x77,
	0x5c, 0x7c, 0xff, 0xe1, 0xb9, 0xd3, 0xab, 0x21, 0x75, 0xa8, 0x65, 0x1b, 0x6b, 0xd5, 0xf2, 0x5b,
	0x30, 0x26, 0x3d, 0x0e, 0xec, 0x76, 0x40, 0x84, 0x3e, 0xae, 0xc8, 0x1e, 0x17, 0x49, 0x45, 0xb3,
	0x2e, 0x9c, 0x5a, 0xa9, 0xe3, 0x66, 0x75, 0xa3, 0x59, 0xb1, 0x90, 0xcb, 0xc4, 0x62, 0xaf, 0xc9,
	0xc1, 0x28, 0x33, 0x27, 0x60, 0x92, 0xa4, 0x07, 0x99, 0x53, 0x65, 0x28, 0xe5, 0x2c, 0x43, 0x2f,
	0x0a, 0xb9, 0x15, 0xcf, 0x68, 0x02, 0xf7, 0x28, 0x0c, 0x18, 0x6e, 0xf1, 0x52, 0xec, 0xd5, 0x65,
	0x7a, 0x77, 0xf6, 0x05, 0x80, 0xe3, 0xd2, 0xb5, 0xec, 0xc6, 0x5b, 0x70, 0x94, 0xb0, 0x99, 0x66,
	0x53, 0x29, 0x84, 0x12, 0xcf, 0xf5, 0x55, 0x62, 0x3f, 0x91, 0x57, 0x43, 0x6a, 0x82, 0xf4, 0x96,
	0x94, 0x7b, 0x50, 0x41, 0xf7, 0x4d, 0xe2, 0x9a, 0x56, 0x4d, 0x13, 0xc4, 0x5d, 0xcd, 0xfe, 0x60,
	0x9f, 0x66, 0xcf, 0x39, 0xef, 0x95, 0xce, 0x7c, 0x36, 0xcb, 0x81, 0x87, 0x29, 0x37, 0xe5, 0x11,
	0x73, 0x11, 0x8e, 0xa2, 0xe7, 0x2f, 0xe3, 0x70, 0x9a, 0x9b, 0xfe, 0xb6, 0x85, 0xd6, 0x2c, 0x17,
	0x39, 0x5b, 0xba, 0x81, 0x6e, 0xe1, 0x2a, 0x77, 0x9e, 0xc7, 0xc3, 0x30, 0xa1, 0xb7, 0x89, 0xa6,
	0x6f, 0x6b, 0xd4, 0x23, 0x85, 0xda, 0x5f, 0xc4, 0x3c, 0x39, 0xff, 0x19, 0x73, 0xf6, 0x62, 0xea,
	0xb8, 0x6e, 0xe7, 0x2d, 0xec, 0xb8, 0x77, 0x91, 0x4e, 0xdc, 0x7c, 0x51, 0x0f, 0x2e, 0x18, 0xc1,
	0x85, 0x2a, 0x5b, 0x20, 0xb8, 0xe9, 0x3f, 0x22, 0x2d, 0x54, 0x82, 0x0b, 0x86, 0x9a, 0x44, 0xcd,
	0xbc, 0x81, 0x2c, 0xd7, 0xd1, 0xeb, 0xf4, 0x80, 0x6f, 0x5a, 0xf1, 0x4f, 0x0d, 0x15, 0xa2, 0x66,
	0xbe, 0x8d, 0x38, 0x75, 0x6f, 0x5c, 0x91, 0xc6, 0x12, 0x66, 0x5e, 0xc2, 0xcc, 0x4b, 0x98, 0x79,
	0x43, 0x85, 0x44, 0xcf, 0x7b, 0x22, 0xf6, 0xc6, 0x15, 0x69, 0x6c, 0xa8, 0xb0, 0x49, 0x7a, 0x98,
	0xee, 0xb8, 0x22, 0x8d, 0x65, 0x4c, 0x55, 0x1a, 0x23, 0x69, 0xbc, 0xd5, 0x1b, 0x97, 0x24, 0x9e,
	0x92, 0xc4, 0x53, 0xe2, 0x3c, 0x4c, 0x36, 0x81, 0xe1, 0xe3, 0x8a, 0x34, 0x96, 0x31, 0x55, 0x35,
	0x69, 0xe8, 0x3e, 0xa5, 0xc9, 0xd3, 0x8a, 0x7f, 0x5a, 0x55, 0x13, 0xfa, 0x16, 0x57, 0x39, 0x85,
	0x4a, 0x93, 0x8a, 0x3c, 0x31, 0x54, 0xa8, 0xdb, 0xbd, 0xf7, 0x76, 0xc7, 0x15, 0x69, 0x6c, 0xa8,
	0x09, 0xcf, 0x7a, 0x9c, 0xca, 0x96, 0xa9, 0xec, 0x1e, 0x95, 0xdf, 0x2f, 0x4a, 0x41, 0xcf, 0x29,
	0x55, 0x82, 0x0b, 0xfb, 0x8e, 0x04, 0x5d, 0xa9, 0x14, 0x74, 0xa5, 0x52, 0xd0, 0x95, 0x4a, 0x86,
	0x9a, 0x40, 0x4d, 0x49, 0xba, 0xde, 0xa4, 0x22, 0x4f, 0x38, 0x8c, 0x5d, 0xe5, 0xc1, 0xc4, 0xa4,
	0x22, 0x4f, 0x24, 0x3f, 0x2a, 0x49, 0x7e, 0x54, 0x92, 0xfc, 0x88, 0xde, 0xd8, 0x40, 0xd2, 0x8d,
	0xbd, 0x49, 0x45, 0x9e, 0x48, 0xa6, 0x2b, 0x4a, 0xe6, 0x2d, 0x1a, 0xea, 0x88, 0xde, 0x26, 0xcb,
	0xdb, 0xb7, 0xf4, 0x06, 0x52, 0x6e, 0xc2, 0x51, 0x9a, 0x70, 0xea, 0x22, 0x78, 0xb0, 0xc8, 0x91,
	0x28, 0x9d, 0x3e, 0x2c, 0x1e, 0xd1, 0xcf, 0xb9, 0x1c, 0x7d, 0xd9, 0x01, 0x40, 0x4d, 0xb0, 0xf3,
	0x7c, 0x59, 0x29, 0xc1, 0x91, 0xaa, 0x49, 0xee, 0x69, 0xc4, 0xdc, 0x46, 0xe9, 0xe8, 0x0c, 0x98,
	0x4d, 0x96, 0x4f, 0x3c, 0x7d, 0x08, 0x68, 0xa8, 0xfc, 0xfc, 0x0b, 0x30, 0xc1, 0x42, 0xe5, 0xf9,
	0x48, 0xfa, 0x51, 0x4a, 0x8d, 0x53, 0xdc, 0x86, 0xb9, 0xcd, 0x33, 0x55, 0x31, 0x37, 0xdf, 0x0d,
	0x22, 0x2f, 0xa0, 0x17, 0x44, 0xee, 0xb4, 0xf1, 0xeb, 0x20, 0xf2, 0x3a, 0x88, 0xbc, 0x0e, 0x22,
	0xff, 0xe7, 0x41, 0xe4, 0x23, 0x98, 0x34, 0x2d, 0x62, 0x56, 0xd1, 0x77, 0x89, 0x22, 0x71, 0x5a,
	0x4a, 0xd0, 0x48, 0x42, 0x4b, 0x58, 0x4e, 0x23, 0x82, 0xc9, 0x87, 0x70, 0x0c, 0x37, 0x5d, 0x99,
	0x37, 0x72, 0xec, 0xe8, 0x94, 0x14, 0x0c, 0x82, 0x52, 0x85, 0x6f, 0x38, 0x88, 0x20, 0xa7, 0x85,
	0xaa, 0x9a, 0x5f, 0xe4, 0xd8, 0xe0, 0xda, 0xba, 0x1c, 0xdd, 0xe1, 0xe2, 0x4d, 0x79, 0x67, 0xd7,
	0x64, 0x31, 0x37, 0xe0, 0x78, 0x1b, 0x3b, 0xf7, 0xea, 0x58, 0xaf, 0x7a, 0x64, 0xc3, 0xc7, 0x96,
	0x73, 0xcc, 0xa3, 0xe8, 0x17, 0x48, 0xe3, 0x47, 0x0b, 0xa4, 0xa3, 0xaf, 0x2e, 0x8f, 0x14, 0x73,
	0x17, 0x73, 0xb4, 0xec, 0x5f, 0x2a, 0xbf, 0xdb, 0x2d, 0xd6, 0x26, 0x77, 0x3a, 0x20, 0xf6, 0x84,
	0x17, 0x6c, 0x43, 0xb4, 0x60, 0x5b, 0x64, 0xb1, 0x96, 0x57, 0xfa, 0xd1, 0xd4, 0x50, 0xf6, 0x5f,
	0x00, 0x4e, 0x2e, 0x6f, 0x37, 0x1d, 0xb4, 0xe9, 0xd5, 0x95, 0xbc, 0x43, 0x3a, 0x03, 0xa3, 0x52,
	0x88, 0x1d, 0xf7, 0x22, 0x6c, 0xcc, 0x89, 0xa6, 0x00, 0xeb, 0x8f, 0xd8, 0xf6, 0xbe, 0xe6, 0x28,
	0x7c, 0xc4, 0xe6, 0x28, 0xee, 0x6f, 0x8e, 0x82, 0xdd, 0x4e, 0xf4, 0x18, 0xdd, 0x0e, 0x2d, 0xb9,
	0xe7, 0x73, 0xa5, 0x7e, 0xbd, 0x4e, 0xd4, 0x2b, 0x53, 0x17, 0x72, 0x45, 0x91, 0x61, 0x9a, 0x30,
	0xd9, 0x7d, 0x2e, 0x7b, 0xe8, 0x22, 0x1c, 0x73, 0x10, 0xc1, 0x4d, 0xc7, 0x40, 0x5a, 0xcd, 0xc1,
	0x4d, 0x7b, 0xc0, 0x93, 0xd5, 0xa4, 0x07, 0xbb, 0x4e, 0x51, 0x4a, 0x0e, 0x8e, 0xb4, 0x68, 0xc9,
	0xcd, 0xb4, 0x14, 0xee, 0x7f, 0x24, 0x4e, 0x11, 0xf4, 0x33, 0xa1, 0x0d, 0x55, 0x4f, 0xcd, 0x2b,
	0xbd, 0x9e, 0xea, 0x1a, 0x8c, 0xb3, 0x9e, 0xaa, 0xf7, 0xe5, 0xcc, 0xf6, 0x6f, 0xaa, 0xf6, 0x9b,
	0x88, 0xf5, 0xa8, 0xa8, 0x4d, 0x17, 0x95, 0x35, 0x98, 0xec, 0xb6, 0x02, 0xad, 0xde, 0xd7, 0x92,
	0x3d, 0x98, 0x4b, 0xb0, 0x8c, 0x7a, 0x47, 0xe9, 0x5a, 0xa0, 0xd0, 0x0f, 0xef, 0x76, 0x00, 0xa0,
	0x1a, 0x2c, 0xe5, 0xe6, 0x79, 0xb7, 0x98, 0xfd, 0x45, 0x18, 0x8e, 0x33, 0x0a, 0xa9, 0xb5, 0x29,
	0x40, 0xd1, 0x99, 0xc8, 0x79, 0xd9, 0xdf, 0x52, 0xab, 0x90, 0x23, 0x58, 0xd4, 0xf8, 0x21, 0x9c,
	0x14, 0x78, 0x49, 0xf7, 0xf6, 0xa0, 0x56, 0x7c, 0x82, 0x63, 0xd5, 0xae, 0xfe, 0x6d, 0xe5, 0x03,
	0x38, 0xd9, 0x0a, 0x1c, 0xa7, 0xa6, 0x3b, 0xd8, 0x6f, 0x26, 0x5a, 0x3e, 0x16, 0xdc, 0xb4, 0x85,
	0xf3, 0x14, 0xcb, 0xb3, 0xf0, 0x84, 0x9f, 0x6a, 0x80, 0x1b, 0x79, 0x85, 0xca, 0x57, 0x00, 0x9e,
	0x90, 0x94, 0x20, 0x59, 0xf4, 0x93, 0x40, 0x97, 0x17, 0x3e, 0x66, 0x97, 0x57, 0x86, 0xec, 0x23,
	0xf9, 0x35, 0x08, 0xa7, 0x40, 0xb0, 0xe3, 0xbb, 0x01, 0x63, 0x47, 0x88, 0x86, 0x01, 0xe3, 0x04,
	0x08, 0x05, 0xc3, 0xe1, 0x76, 0xfe, 0x06, 0xc0, 0x77, 0xbb, 0xae, 0xd2, 0xb7, 0xa7, 0x9b, 0x83,
	0x71, 0x9d, 0x02, 0x34, 0x7d, 0x5b, 0x98, 0x7c, 0xca, 0x33, 0x5d, 0xc2, 0x19, 0x51, 0x41, 0x51,
	0x05, 0x25, 0x15, 0xcc, 0xab, 0xc3, 0x0c, 0xb5, 0xbc, 0xad, 0x6c, 0xf4, 0xad, 0x38, 0xcf, 0x1f,
	0xf6, 0x8a, 0x9e, 0x76, 0xff, 0x8b, 0xba, 0xf3, 0xdf, 0x27, 0xf7, 0xd5, 0x9d, 0x3d, 0x73, 0xfe,
	0x2d, 0x2c, 0xbd, 0xb5, 0x6f, 0xe9, 0x79, 0xec, 0xb7, 0x0e, 0x48, 0x8c, 0xc7, 0x7f, 0xac, 0x3f,
	0x31, 0x7e, 0x3c, 0x20, 0x31, 0x1e, 0x9f, 0x37, 0x90, 0x1e, 0x7d, 0x6a, 0x1c, 0x3a, 0x9a, 0x1a,
	0xe1, 0xab, 0xcb, 0xc3, 0xc5, 0x5c, 0x29, 0x77, 0x91, 0x39, 0x0d, 0x4d, 0x27, 0x57, 0xe1, 0x9b,
	0xd7, 0x57, 0xd6, 0x37, 0xd7, 0x57, 0x6e, 0x21, 0x97, 0xa6, 0x35, 0x29, 0xa3, 0x9c, 0x3a, 0x30,
	0xa3, 0xf0, 0x7c, 0x72, 0x29, 0xfa, 0xea, 0x32, 0x28, 0x66, 0x3f, 0x82, 0xa7, 0x7c, 0x2c, 0xcb,
	0x52, 0xbc, 0x97, 0x18, 0x67, 0x03, 0x59, 0x03, 0xb0, 0xff, 0xa8, 0x45, 0x9f, 0x33, 0xad, 0xf9,
	0x72, 0x04, 0xa7, 0x5d, 0x82, 0x13, 0x3e, 0xda, 0x23, 0x8b, 0x95, 0x5d, 0x86, 0xc9, 0xeb, 0x2b,
	0xeb, 0x52, 0xc0, 0xbb, 0xd0, 0x2f, 0xe0, 0xed, 0x3b, 0x2c, 0x85, 0xbc, 0xec, 0x6f, 0x00, 0x9c,
	0xec, 0x72, 0x48, 0x8f, 0x38, 0x6e, 0xe8, 0xfc, 0xdf, 0x64, 0xdc, 0xec, 0xd3, 0x70, 0xc0, 0x52,
	0x52, 0x08, 0xbb, 0x0d, 0x13, 0x34, 0x29, 0x59, 0x7c, 0x43, 0x38, 0x6e, 0xae, 0xaf, 0x83, 0x0d,
	0x30, 0xf6, 0x6a, 0x48, 0x85, 0x16, 0x6a, 0x8b, 0x75, 0x65, 0x03, 0x76, 0xff, 0xa1, 0xd4, 0x65,
	0xe5, 0x6e, 0x7b, 0xf6, 0x70, 0x56, 0xc1, 0x37, 0xee, 0x31, 0x78, 0xa4, 0x2e, 0x4c, 0x4b, 0x52,
	0x6a, 0x7d, 0xea, 0x87, 0xa5, 0xc3, 0xc9, 0xfb, 0x7b, 0xd6, 0x6a, 0x48, 0x7d, 0xa3, 0x27, 0xbe,
	0x8c, 0x29, 0xbf, 0xdd, 0x0d, 0x9b, 0x13, 0x22, 0x33, 0xd0, 0xb0, 0x39, 0xb4, 0x90, 0xeb, 0x05,
	0xce, 0xbf, 0x03, 0xf8, 0x06, 0xbf, 0x64, 0x5f, 0x72, 0x58, 0x83, 0x54, 0x2d, 0xfe, 0x88, 0x30,
	0x3b, 0x48, 0xca, 0xa0, 0xab, 0xac, 0x86, 0xd4, 0x11, 0x0b, 0xb5, 0xc5, 0xf7, 0x7a, 0x13, 0x8e,
	0x07, 0xfe, 0xfb, 0x77, 0x60, 0xd2, 0xf7, 0xb9, 0xef, 0x6a, 0x48, 0x1d, 0xf3, 0xff, 0x87, 0xef,
	0xf0, 0x74, 0xf0, 0xe7, 0x30, 0x9c, 0xda, 0x30, 0x5d, 0xb4, 0xe1, 0xea, 0xae, 0x69, 0xa8, 0xb8,
	0xe9, 0x22, 0xee, 0xc0, 0xbf, 0x05, 0x70, 0x92, 0x98, 0x0d, 0xbb, 0x8e, 0x34, 0xc2, 0xf6, 0x34,
	0x87, 0x6e, 0x0a, 0xc7, 0xfc, 0xf4, 0x8f, 0x5f, 0x80, 0xdb, 0xd3, 0x37, 0x79, 0xec, 0x64, 0x29,
	0x9b, 0x98, 0x2e, 0x2a, 0x10, 0x1b, 0x19, 0x05, 0xd3, 0xaa, 0x39, 0x88, 0x10, 0x0d, 0xf1, 0x3f,
	0xb5, 0x76, 0xc1, 0x8b, 0x98, 0x12, 0x0f, 0x29, 0xc8, 0x33, 0xad, 0x6e, 0x12, 0xb7, 0xe7, 0xe7,
	0xac, 0x38, 0x60, 0x77, 0x4b, 0x62, 0x29, 0x9b, 0x70, 0xd2, 0x68, 0x12, 0x17, 0x37, 0xfc, 0x02,
	0x71, 0xf5, 0x64, 0x02, 0xea, 0x91, 0x0e, 0xf2, 0xe0, 0xb8, 0xcb, 0x0b, 0xfe, 0x09, 0x4e, 0x21,
	0x6d, 0x97, 0xcf, 0x40, 0xc5, 0xc0, 0xd6, 0x96, 0x59, 0xd3, 0x1a, 0xb8, 0xea, 0x2b, 0x34, 0xfb,
	0xe8, 0xeb, 0x57, 0x00, 0xa6, 0x83, 0xfa, 0xfa, 0xb1, 0x49, 0x78, 0xf8, 0xb8, 0x07, 0x27, 0xf6,
	0xbd, 0x2a, 0x0d, 0x66, 0x22, 0x03, 0x2b, 0x85, 0x7e, 0x9a, 0x2f, 0x4f, 0x31, 0x45, 0xfc, 0x0e,
	0x84, 0x53, 0x57, 0xbc, 0x51, 0x1c, 0xa8, 0xe3, 0xa4, 0x87, 0xa3, 0x17, 0x66, 0x7f, 0x19, 0x85,
	0x6f, 0x5f, 0xaf, 0xe3, 0x8a, 0x5e, 0xf7, 0x3e, 0x75, 0x6c, 0x59, 0xc8, 0x70, 0x4d, 0x6c, 0x31,
	0x61, 0x36, 0x60, 0x8a, 0xd4, 0x4d, 0xcd, 0xc5, 0x5a, 0x8d, 0xa1, 0xb4, 0xaa, 0x73, 0xb0, 0x6b,
	0x32, 0x94, 0x20, 0xc1, 0x8e, 0x70, 0xa8, 0x24, 0xa9, 0x9b, 0x77, 0x30, 0xdf, 0xbb, 0xea, 0x70,
	0x52, 0xec, 0x27, 0x8d, 0x7c, 0x17, 0x52, 0x2c, 0x91, 0xae, 0xc3, 0x13, 0x55, 0x93, 0xe8, 0x95,
	0x3a, 0xd2, 0xb6, 0xb0, 0xd3, 0xd6, 0x9d, 0xaa, 0x66, 0x3b, 0xf8, 0xfe, 0x03, 0x96, 0xaf, 0x06,
	0x76, 0x70, 0x34, 0x1f, 0xac, 0x02, 0x75, 0x52, 0x1c, 0xfd, 0x80, 0x9f, 0x5c, 0xa7, 0x07, 0x15,
	0x0d, 0x4e, 0x21, 0xab, 0x0f, 0x61, 0xac, 0xef, 0x0f, 0x1c, 0xf2, 0xd1, 0x15, 0xe6, 0x09, 0xdc,
	0x65, 0xc4, 0x0d, 0x0a, 0xa7, 0x92, 0x51, 0x97, 0xde, 0xfb, 0xb2, 0x03, 0x4e, 0xc1, 0xef, 0xc1,
	0x69, 0xfe, 0x88, 0x19, 0x61, 0x82, 0x99, 0x9e, 0x0d, 0x88, 0x12, 0x29, 0xe6, 0x16, 0xca, 0xa7,
	0xe1, 0x84, 0xd1, 0x5d, 0x1b, 0xe4, 0x5b, 0xe5, 0x39, 0x38, 0xe5, 0x13, 0xd4, 0x03, 0xbe, 0xb9,
	0xd3, 0x01, 0x43, 0xa2, 0xcf, 0x8b, 0x52, 0xf0, 0xc5, 0xdc, 0x22, 0xcd, 0xf2, 0xf2, 0x2f, 0x3c,
	0xd9, 0x3f, 0x01, 0x78, 0x72, 0x80, 0x23, 0x74, 0x3d, 0xf3, 0x73, 0x00, 0xa7, 0x85, 0xc5, 0xbc,
	0xc8, 0xda, 0x13, 0x8b, 0x08, 0x1f, 0xbd, 0x70, 0x80, 0x09, 0xfb, 0xfa, 0x58, 0x39, 0x4d, 0x1f,
	0xd1, 0x75, 0xd7, 0xb8, 0xe4, 0xae, 0xe9, 0x5a, 0xff, 0x63, 0x24, 0xfb, 0x0f, 0xda, 0x68, 0xd4,
	0xeb, 0xb8, 0x8d, 0xaa, 0x9b, 0x6b, 0xeb, 0xeb, 0xd8, 0x71, 0x89, 0x72, 0x05, 0x26, 0x9b, 0x04,
	0x69, 0x77, 0x5d, 0xd7, 0xd6, 0x6c, 0xec, 0x78, 0x31, 0x74, 0x80, 0xe5, 0x69, 0x52, 0xa4, 0x35,
	0x74, 0x93, 0xa0, 0x55, 0xd7, 0xb5, 0x29, 0x85, 0x52, 0x86, 0x63, 0x1e, 0x03, 0xe1, 0x14, 0x91,
	0x23, 0x50, 0x8c, 0x0a, 0x0a, 0xc2, 0x38, 0x7e, 0x04, 0x27, 0xbb, 0x52, 0x48, 0x44, 0xd1, 0x23,
	0x10, 0xa5, 0x04, 0x91, 0x4c, 0x36, 0x2a, 0xa2, 0x15, 0x25, 0x21, 0xc2, 0x97, 0x67, 0xfa, 0x37,
	0x0c, 0x0c, 0xc8, 0x54, 0xc1, 0xab, 0x38, 0xfa, 0x3a, 0x43, 0x5a, 0xcc, 0xc2, 0x04, 0x65, 0xd1,
	0xa4, 0xf6, 0xdf, 0xcb, 0x51, 0xc3, 0xa5, 0xdc, 0x7c, 0x6e, 0x21, 0x77, 0x51, 0xc4, 0xa7, 0xab,
	0x30, 0x21, 0xb1, 0x29, 0x73, 0xe2, 0xa0, 0xa3, 0x5b, 0x35, 0x44, 0x44, 0xf0, 0x1e, 0x93, 0xaa,
	0x8a, 0x27, 0x61, 0xa0, 0x42, 0x0a, 0x51, 0x19, 0x82, 0xb3, 0x94, 0x7f, 0xbe, 0xfb, 0x2c, 0x13,
	0x7a, 0xfa, 0x2c, 0x13, 0x7a, 0xf9, 0x2c, 0x03, 0x1e, 0xed, 0x65, 0xc0, 0x1f, 0xf6, 0x32, 0xe0,
	0xc9, 0x5e, 0x06, 0xec, 0xee, 0x65, 0xc0, 0xd3, 0xbd, 0x0c, 0xf8, 0x6a, 0x2f, 0x03, 0x9e, 0xef,
	0x65, 0x42, 0x2f, 0xf7, 0x32, 0xe0, 0xf1, 0xd7, 0x99, 0xd0, 0xce, 0xd7, 0x19, 0xf0, 0xc9, 0x5a,
	0x0d, 0xdb, 0xf7, 0x6a, 0x85, 0x16, 0xae, 0xbb, 0xc8, 0x71, 0xf4, 0x42, 0x93, 0xcc, 0xb1, 0xc1,
	0x16, 0x76, 0x1a, 0x79, 0xdb, 0xc1, 0x2d, 0xb3, 0x8a, 0x9c, 0xbc, 0xb7, 0x3d, 0x67, 0x57, 0x6a,
	0x78, 0x0e, 0xdd, 0x77, 0xc5, 0x6f, 0xbc, 0xf2, 0x4f, 0xbd, 0x95, 0x18, 0xfb, 0x95, 0x77, 0xfe,
	0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x06, 0x06, 0x4c, 0xa1, 0x03, 0x1f, 0x00, 0x00,
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/site_types.proto

/*
	Package views is a generated protocol buffer package.

	It is generated from these files:
		ves.io/schema/views/site_types.proto
		ves.io/schema/views/types.proto

	It has these top-level messages:
		AWSVPCParamsType
		AWSVPCchoiceType
		CloudSubnetParamType
		CloudSubnetType
		AWSVPCOneInterfaceNodeType
		AWSVPCTwoInterfaceNodeType
		AzureVnetParamsType
		AzureVnetType
		AzureVnetChoiceType
		AzureSubnetType
		AzureSubnetChoiceType
		AzureVnetOneInterfaceNodeType
		AzureVnetTwoInterfaceNodeType
		GCPVPCNetworkParamsType
		GCPVPCNetworkType
		GCPSubnetType
		GCPSubnetParamsType
		GCPVPCNetworkChoiceType
		GCPVPCSubnetChoiceType
		GCPVPCOneInterfaceNodeType
		GCPVPCTwoInterfaceNodeType
		SiteStaticRoutesType
		SiteStaticRoutesListType
		GlobalNetworkConnectionType
		GlobalNetworkConnectionListType
		ObjectRefType
		SiteLocator
		WhereSite
		WhereVirtualSite
		WhereVK8SService
		WhereType
		WhereTypeSiteVsite
		AdvertisePublic
		AdvertiseCustom
		AdvertiseSiteVsite
		CustomCiphers
		TlsConfig
		OriginPoolWithWeight
		PrefixStringListType
		GlobalConnectorType
*/
package views

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// AWS VPC Parameters
//
// x-displayName: "AWS VPC Parameters"
// Parameters to create new AWS VPC
type AWSVPCParamsType struct {
	// AWS VPC Name Tag
	//
	// x-displayName: "AWS VPC Name Tag"
	// x-required
	// x-example "MyVpc"
	// Optional Name tag for your VPC
	NameTag string `protobuf:"bytes,2,opt,name=name_tag,json=nameTag,proto3" json:"name_tag,omitempty"`
	// Primary IPv4 CIDR block
	//
	// x-displayName: "Primary IPv4 CIDR block"
	// x-required
	// x-example: "10.1.0.0/16"
	// IPv4 CIDR block for this VPC. It has to be private address space.
	// The Primary IPv4 block cannot be modified. All subnets prefixes in this VPC must be part of this CIDR block.
	PrimaryIpv4 string `protobuf:"bytes,3,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
	// Allocate IPv6 CIDR block
	//
	// x-displayName: "Allocate IPv6 CIDR block from AWS"
	// Allocate IPv6 CIDR block from AWS
	AllocateIpv6 bool `protobuf:"varint,6,opt,name=allocate_ipv6,json=allocateIpv6,proto3" json:"allocate_ipv6,omitempty"`
}

func (m *AWSVPCParamsType) Reset()                    { *m = AWSVPCParamsType{} }
func (*AWSVPCParamsType) ProtoMessage()               {}
func (*AWSVPCParamsType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{0} }

func (m *AWSVPCParamsType) GetNameTag() string {
	if m != nil {
		return m.NameTag
	}
	return ""
}

func (m *AWSVPCParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

func (m *AWSVPCParamsType) GetAllocateIpv6() bool {
	if m != nil {
		return m.AllocateIpv6
	}
	return false
}

// AWS VPC choice
//
// x-displayName: "AWS VPC choice"
// This defines choice about AWS VPC for a view
type AWSVPCchoiceType struct {
	// Choice of existing or new VPC
	//
	// x-displayName: "Select existing VPC or create new VPC"
	// x-required
	// This is choice of existing VPC or new VPC
	//
	// Types that are valid to be assigned to Choice:
	//	*AWSVPCchoiceType_NewVpc
	//	*AWSVPCchoiceType_VpcId
	Choice isAWSVPCchoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AWSVPCchoiceType) Reset()                    { *m = AWSVPCchoiceType{} }
func (*AWSVPCchoiceType) ProtoMessage()               {}
func (*AWSVPCchoiceType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{1} }

type isAWSVPCchoiceType_Choice interface {
	isAWSVPCchoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCchoiceType_NewVpc struct {
	NewVpc *AWSVPCParamsType `protobuf:"bytes,1,opt,name=new_vpc,json=newVpc,oneof"`
}
type AWSVPCchoiceType_VpcId struct {
	VpcId string `protobuf:"bytes,2,opt,name=vpc_id,json=vpcId,proto3,oneof"`
}

func (*AWSVPCchoiceType_NewVpc) isAWSVPCchoiceType_Choice() {}
func (*AWSVPCchoiceType_VpcId) isAWSVPCchoiceType_Choice()  {}

func (m *AWSVPCchoiceType) GetChoice() isAWSVPCchoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AWSVPCchoiceType) GetNewVpc() *AWSVPCParamsType {
	if x, ok := m.GetChoice().(*AWSVPCchoiceType_NewVpc); ok {
		return x.NewVpc
	}
	return nil
}

func (m *AWSVPCchoiceType) GetVpcId() string {
	if x, ok := m.GetChoice().(*AWSVPCchoiceType_VpcId); ok {
		return x.VpcId
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AWSVPCchoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AWSVPCchoiceType_OneofMarshaler, _AWSVPCchoiceType_OneofUnmarshaler, _AWSVPCchoiceType_OneofSizer, []interface{}{
		(*AWSVPCchoiceType_NewVpc)(nil),
		(*AWSVPCchoiceType_VpcId)(nil),
	}
}

func _AWSVPCchoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AWSVPCchoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AWSVPCchoiceType_NewVpc:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewVpc); err != nil {
			return err
		}
	case *AWSVPCchoiceType_VpcId:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.VpcId)
	case nil:
	default:
		return fmt.Errorf("AWSVPCchoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _AWSVPCchoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AWSVPCchoiceType)
	switch tag {
	case 1: // choice.new_vpc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AWSVPCParamsType)
		err := b.DecodeMessage(msg)
		m.Choice = &AWSVPCchoiceType_NewVpc{msg}
		return true, err
	case 2: // choice.vpc_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Choice = &AWSVPCchoiceType_VpcId{x}
		return true, err
	default:
		return false, nil
	}
}

func _AWSVPCchoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AWSVPCchoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AWSVPCchoiceType_NewVpc:
		s := proto.Size(x.NewVpc)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AWSVPCchoiceType_VpcId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.VpcId)))
		n += len(x.VpcId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Cloud Subnet Param
//
// x-displayName: "New Cloud Subnet Parameters"
// Parameters for creating a new cloud subnet
type CloudSubnetParamType struct {
	// IPv4 Subnet
	//
	// x-displayName: "IPv4 Subnet"
	// x-required
	// x-example: "10.1.2.0/24"
	// IPv4 subnet prefix for this subnet
	Ipv4 string `protobuf:"bytes,1,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	// IPv6 Subnet
	//
	// x-displayName: "IPv6 Subnet"
	// x-example: "1234:568:abcd:9100::/64"
	// IPv6 subnet prefix for this subnet
	Ipv6 string `protobuf:"bytes,2,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
}

func (m *CloudSubnetParamType) Reset()                    { *m = CloudSubnetParamType{} }
func (*CloudSubnetParamType) ProtoMessage()               {}
func (*CloudSubnetParamType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{2} }

func (m *CloudSubnetParamType) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

func (m *CloudSubnetParamType) GetIpv6() string {
	if m != nil {
		return m.Ipv6
	}
	return ""
}

// Cloud Subnet
//
// x-displayName: "AWS Subnet"
// Parameters for AWS subnet
type CloudSubnetType struct {
	// Choice of subnet
	//
	// x-displayName: "Select Existing Subnet or Create New"
	// x-required
	// Subnet for the Single interface of the site
	//
	// Types that are valid to be assigned to Choice:
	//	*CloudSubnetType_SubnetParam
	//	*CloudSubnetType_ExistingSubnetId
	Choice isCloudSubnetType_Choice `protobuf_oneof:"choice"`
}

func (m *CloudSubnetType) Reset()                    { *m = CloudSubnetType{} }
func (*CloudSubnetType) ProtoMessage()               {}
func (*CloudSubnetType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{3} }

type isCloudSubnetType_Choice interface {
	isCloudSubnetType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudSubnetType_SubnetParam struct {
	SubnetParam *CloudSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam,oneof"`
}
type CloudSubnetType_ExistingSubnetId struct {
	ExistingSubnetId string `protobuf:"bytes,2,opt,name=existing_subnet_id,json=existingSubnetId,proto3,oneof"`
}

func (*CloudSubnetType_SubnetParam) isCloudSubnetType_Choice()      {}
func (*CloudSubnetType_ExistingSubnetId) isCloudSubnetType_Choice() {}

func (m *CloudSubnetType) GetChoice() isCloudSubnetType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *CloudSubnetType) GetSubnetParam() *CloudSubnetParamType {
	if x, ok := m.GetChoice().(*CloudSubnetType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *CloudSubnetType) GetExistingSubnetId() string {
	if x, ok := m.GetChoice().(*CloudSubnetType_ExistingSubnetId); ok {
		return x.ExistingSubnetId
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CloudSubnetType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CloudSubnetType_OneofMarshaler, _CloudSubnetType_OneofUnmarshaler, _CloudSubnetType_OneofSizer, []interface{}{
		(*CloudSubnetType_SubnetParam)(nil),
		(*CloudSubnetType_ExistingSubnetId)(nil),
	}
}

func _CloudSubnetType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CloudSubnetType)
	// choice
	switch x := m.Choice.(type) {
	case *CloudSubnetType_SubnetParam:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubnetParam); err != nil {
			return err
		}
	case *CloudSubnetType_ExistingSubnetId:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ExistingSubnetId)
	case nil:
	default:
		return fmt.Errorf("CloudSubnetType.Choice has unexpected type %T", x)
	}
	return nil
}

func _CloudSubnetType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CloudSubnetType)
	switch tag {
	case 1: // choice.subnet_param
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudSubnetParamType)
		err := b.DecodeMessage(msg)
		m.Choice = &CloudSubnetType_SubnetParam{msg}
		return true, err
	case 2: // choice.existing_subnet_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Choice = &CloudSubnetType_ExistingSubnetId{x}
		return true, err
	default:
		return false, nil
	}
}

func _CloudSubnetType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CloudSubnetType)
	// choice
	switch x := m.Choice.(type) {
	case *CloudSubnetType_SubnetParam:
		s := proto.Size(x.SubnetParam)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CloudSubnetType_ExistingSubnetId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ExistingSubnetId)))
		n += len(x.ExistingSubnetId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Single Interface Node
//
// x-displayName: "Single Interface Node"
// Parameters for creating Single interface Node in one AZ
type AWSVPCOneInterfaceNodeType struct {
	// AWS AZ
	//
	// x-required
	// x-displayName: "AWS AZ name"
	// x-required
	// x-example: "us-west-2a"
	// Name for AWS availability Zone, should match with region selected.
	AwsAzName string `protobuf:"bytes,1,opt,name=aws_az_name,json=awsAzName,proto3" json:"aws_az_name,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for local Interface"
	// Subnets for the site local interface of the node
	LocalSubnet *CloudSubnetType `protobuf:"bytes,2,opt,name=local_subnet,json=localSubnet" json:"local_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,4,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AWSVPCOneInterfaceNodeType) Reset()      { *m = AWSVPCOneInterfaceNodeType{} }
func (*AWSVPCOneInterfaceNodeType) ProtoMessage() {}
func (*AWSVPCOneInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{4}
}

func (m *AWSVPCOneInterfaceNodeType) GetAwsAzName() string {
	if m != nil {
		return m.AwsAzName
	}
	return ""
}

func (m *AWSVPCOneInterfaceNodeType) GetLocalSubnet() *CloudSubnetType {
	if m != nil {
		return m.LocalSubnet
	}
	return nil
}

func (m *AWSVPCOneInterfaceNodeType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// Two Interface Node
//
// x-displayName: "Two Interface Node"
// Parameters for creating two interface Node in one AZ
type AWSVPCTwoInterfaceNodeType struct {
	// AWS AZ
	//
	// x-required
	// x-displayName: "AWS AZ name"
	// x-required
	// x-example: "us-west-2a"
	// Name for AWS availability Zone, should match with AWS region selected.
	AwsAzName string `protobuf:"bytes,1,opt,name=aws_az_name,json=awsAzName,proto3" json:"aws_az_name,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Inside Interface"
	// Subnets for the inside interface of the node
	InsideSubnet *CloudSubnetType `protobuf:"bytes,2,opt,name=inside_subnet,json=insideSubnet" json:"inside_subnet,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Outside Interface"
	// Subnets for the outside interface of the node
	OutsideSubnet *CloudSubnetType `protobuf:"bytes,3,opt,name=outside_subnet,json=outsideSubnet" json:"outside_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize string `protobuf:"bytes,4,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AWSVPCTwoInterfaceNodeType) Reset()      { *m = AWSVPCTwoInterfaceNodeType{} }
func (*AWSVPCTwoInterfaceNodeType) ProtoMessage() {}
func (*AWSVPCTwoInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{5}
}

func (m *AWSVPCTwoInterfaceNodeType) GetAwsAzName() string {
	if m != nil {
		return m.AwsAzName
	}
	return ""
}

func (m *AWSVPCTwoInterfaceNodeType) GetInsideSubnet() *CloudSubnetType {
	if m != nil {
		return m.InsideSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetOutsideSubnet() *CloudSubnetType {
	if m != nil {
		return m.OutsideSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetDiskSize() string {
	if m != nil {
		return m.DiskSize
	}
	return ""
}

// Azure Vnet Parameters
//
// x-displayName: "Azure Vnet Parameters"
// Parameters to create a new Azure Vnet
type AzureVnetParamsType struct {
	// Azure Vnet Name
	//
	// x-displayName: "Azure Vnet Name"
	// x-required
	// x-example: "MyVnet"
	// Name for your Azure Vnet
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// IPv4 CIDR block
	//
	// x-displayName: "IPv4 CIDR block"
	// x-required
	// x-example: "10.1.0.0/16"
	// IPv4 CIDR block for this Vnet. It has to be private address space.
	PrimaryIpv4 string `protobuf:"bytes,2,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
}

func (m *AzureVnetParamsType) Reset()                    { *m = AzureVnetParamsType{} }
func (*AzureVnetParamsType) ProtoMessage()               {}
func (*AzureVnetParamsType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{6} }

func (m *AzureVnetParamsType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AzureVnetParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

// Azure Existing Vnet Type
//
// x-displayName: "Azure Existing Vnet Type"
// Resource group and name of existing Azure Vnet
type AzureVnetType struct {
	// Existing Vnet Resource Group
	//
	// x-displayName: "Existing Vnet Resource Group"
	// x-required
	// x-example:"MyResourceGroup"
	// Resource group of existing Vnet
	ResourceGroup string `protobuf:"bytes,1,opt,name=resource_group,json=resourceGroup,proto3" json:"resource_group,omitempty"`
	// Existing Vnet Name
	//
	// x-displayName: "Existing Vnet Name"
	// x-required
	// x-example:"MyVnet"
	// Name of existing Vnet
	VnetName string `protobuf:"bytes,2,opt,name=vnet_name,json=vnetName,proto3" json:"vnet_name,omitempty"`
}

func (m *AzureVnetType) Reset()                    { *m = AzureVnetType{} }
func (*AzureVnetType) ProtoMessage()               {}
func (*AzureVnetType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{7} }

func (m *AzureVnetType) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *AzureVnetType) GetVnetName() string {
	if m != nil {
		return m.VnetName
	}
	return ""
}

// Azure Vnet choice
//
// x-displayName: "Azure Vnet choice"
// This defines choice about Azure Vnet for a view
type AzureVnetChoiceType struct {
	// Choice of existing or new Vnet
	//
	// x-displayName: "Select existing Vnet or create new Vnet"
	// x-required
	// This is choice of existing Vnet or new Vnet
	//
	// Types that are valid to be assigned to Choice:
	//	*AzureVnetChoiceType_NewVnet
	//	*AzureVnetChoiceType_ExistingVnet
	Choice isAzureVnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AzureVnetChoiceType) Reset()                    { *m = AzureVnetChoiceType{} }
func (*AzureVnetChoiceType) ProtoMessage()               {}
func (*AzureVnetChoiceType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{8} }

type isAzureVnetChoiceType_Choice interface {
	isAzureVnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureVnetChoiceType_NewVnet struct {
	NewVnet *AzureVnetParamsType `protobuf:"bytes,2,opt,name=new_vnet,json=newVnet,oneof"`
}
type AzureVnetChoiceType_ExistingVnet struct {
	ExistingVnet *AzureVnetType `protobuf:"bytes,3,opt,name=existing_vnet,json=existingVnet,oneof"`
}

func (*AzureVnetChoiceType_NewVnet) isAzureVnetChoiceType_Choice()      {}
func (*AzureVnetChoiceType_ExistingVnet) isAzureVnetChoiceType_Choice() {}

func (m *AzureVnetChoiceType) GetChoice() isAzureVnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AzureVnetChoiceType) GetNewVnet() *AzureVnetParamsType {
	if x, ok := m.GetChoice().(*AzureVnetChoiceType_NewVnet); ok {
		return x.NewVnet
	}
	return nil
}

func (m *AzureVnetChoiceType) GetExistingVnet() *AzureVnetType {
	if x, ok := m.GetChoice().(*AzureVnetChoiceType_ExistingVnet); ok {
		return x.ExistingVnet
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AzureVnetChoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AzureVnetChoiceType_OneofMarshaler, _AzureVnetChoiceType_OneofUnmarshaler, _AzureVnetChoiceType_OneofSizer, []interface{}{
		(*AzureVnetChoiceType_NewVnet)(nil),
		(*AzureVnetChoiceType_ExistingVnet)(nil),
	}
}

func _AzureVnetChoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AzureVnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AzureVnetChoiceType_NewVnet:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewVnet); err != nil {
			return err
		}
	case *AzureVnetChoiceType_ExistingVnet:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExistingVnet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AzureVnetChoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _AzureVnetChoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AzureVnetChoiceType)
	switch tag {
	case 2: // choice.new_vnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AzureVnetParamsType)
		err := b.DecodeMessage(msg)
		m.Choice = &AzureVnetChoiceType_NewVnet{msg}
		return true, err
	case 3: // choice.existing_vnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AzureVnetType)
		err := b.DecodeMessage(msg)
		m.Choice = &AzureVnetChoiceType_ExistingVnet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AzureVnetChoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AzureVnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AzureVnetChoiceType_NewVnet:
		s := proto.Size(x.NewVnet)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AzureVnetChoiceType_ExistingVnet:
		s := proto.Size(x.ExistingVnet)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetType struct {
	// Existing Subnet Name
	//
	// x-displayName: "Existing Subnet Name"
	// x-example:"MySubnet"
	// x-required
	// Name of existing subnet.
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
	// Existing Subnet Resource Group
	//
	// x-displayName: "Existing Subnet Resource Group"
	// x-example:"MySubnet"
	// Resource group for this subnet. Resource group is taken from Vnet, if left blank.
	SubnetResourceGrp string `protobuf:"bytes,2,opt,name=subnet_resource_grp,json=subnetResourceGrp,proto3" json:"subnet_resource_grp,omitempty"`
}

func (m *AzureSubnetType) Reset()                    { *m = AzureSubnetType{} }
func (*AzureSubnetType) ProtoMessage()               {}
func (*AzureSubnetType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{9} }

func (m *AzureSubnetType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

func (m *AzureSubnetType) GetSubnetResourceGrp() string {
	if m != nil {
		return m.SubnetResourceGrp
	}
	return ""
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetChoiceType struct {
	// Choice of subnet
	//
	// x-displayName: "Select Existing Subnet or Create New"
	// x-required
	// Subnet for the Single interface of the site
	//
	// Types that are valid to be assigned to Choice:
	//	*AzureSubnetChoiceType_SubnetParam
	//	*AzureSubnetChoiceType_Subnet
	Choice isAzureSubnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AzureSubnetChoiceType) Reset()                    { *m = AzureSubnetChoiceType{} }
func (*AzureSubnetChoiceType) ProtoMessage()               {}
func (*AzureSubnetChoiceType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{10} }

type isAzureSubnetChoiceType_Choice interface {
	isAzureSubnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureSubnetChoiceType_SubnetParam struct {
	SubnetParam *CloudSubnetParamType `protobuf:"bytes,2,opt,name=subnet_param,json=subnetParam,oneof"`
}
type AzureSubnetChoiceType_Subnet struct {
	Subnet *AzureSubnetType `protobuf:"bytes,3,opt,name=subnet,oneof"`
}

func (*AzureSubnetChoiceType_SubnetParam) isAzureSubnetChoiceType_Choice() {}
func (*AzureSubnetChoiceType_Subnet) isAzureSubnetChoiceType_Choice()      {}

func (m *AzureSubnetChoiceType) GetChoice() isAzureSubnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AzureSubnetChoiceType) GetSubnetParam() *CloudSubnetParamType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *AzureSubnetChoiceType) GetSubnet() *AzureSubnetType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceType_Subnet); ok {
		return x.Subnet
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AzureSubnetChoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AzureSubnetChoiceType_OneofMarshaler, _AzureSubnetChoiceType_OneofUnmarshaler, _AzureSubnetChoiceType_OneofSizer, []interface{}{
		(*AzureSubnetChoiceType_SubnetParam)(nil),
		(*AzureSubnetChoiceType_Subnet)(nil),
	}
}

func _AzureSubnetChoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AzureSubnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AzureSubnetChoiceType_SubnetParam:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubnetParam); err != nil {
			return err
		}
	case *AzureSubnetChoiceType_Subnet:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subnet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AzureSubnetChoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _AzureSubnetChoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AzureSubnetChoiceType)
	switch tag {
	case 2: // choice.subnet_param
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudSubnetParamType)
		err := b.DecodeMessage(msg)
		m.Choice = &AzureSubnetChoiceType_SubnetParam{msg}
		return true, err
	case 3: // choice.subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AzureSubnetType)
		err := b.DecodeMessage(msg)
		m.Choice = &AzureSubnetChoiceType_Subnet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AzureSubnetChoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AzureSubnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *AzureSubnetChoiceType_SubnetParam:
		s := proto.Size(x.SubnetParam)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AzureSubnetChoiceType_Subnet:
		s := proto.Size(x.Subnet)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Single Interface Node
//
// x-displayName: "Single Interface Node"
// Parameters for creating Single interface Node in one AZ
type AzureVnetOneInterfaceNodeType struct {
	// Azure AZ
	//
	// x-displayName: "Azure AZ name"
	// x-required
	// x-example: "1"
	// Name for AWS availability Zone.
	AzureAz string `protobuf:"bytes,1,opt,name=azure_az,json=azureAz,proto3" json:"azure_az,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for local Interface"
	// Subnets for the site local interface of the node
	LocalSubnet *AzureSubnetChoiceType `protobuf:"bytes,2,opt,name=local_subnet,json=localSubnet" json:"local_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize string `protobuf:"bytes,3,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AzureVnetOneInterfaceNodeType) Reset()      { *m = AzureVnetOneInterfaceNodeType{} }
func (*AzureVnetOneInterfaceNodeType) ProtoMessage() {}
func (*AzureVnetOneInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{11}
}

func (m *AzureVnetOneInterfaceNodeType) GetAzureAz() string {
	if m != nil {
		return m.AzureAz
	}
	return ""
}

func (m *AzureVnetOneInterfaceNodeType) GetLocalSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.LocalSubnet
	}
	return nil
}

func (m *AzureVnetOneInterfaceNodeType) GetDiskSize() string {
	if m != nil {
		return m.DiskSize
	}
	return ""
}

// Two Interface Node
//
// x-displayName: "Two Interface Node"
// Parameters for creating two interface Node in one AZ
type AzureVnetTwoInterfaceNodeType struct {
	// Azure AZ
	//
	// x-displayName: "Azure AZ name"
	// x-required
	// x-example: "1"
	// Name for AWS availability Zone.
	AzureAz string `protobuf:"bytes,1,opt,name=azure_az,json=azureAz,proto3" json:"azure_az,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Inside Interface"
	// Subnets for the inside interface of the node
	InsideSubnet *AzureSubnetChoiceType `protobuf:"bytes,2,opt,name=inside_subnet,json=insideSubnet" json:"inside_subnet,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Outside Interface"
	// Subnets for the outside interface of the node
	OutsideSubnet *AzureSubnetChoiceType `protobuf:"bytes,3,opt,name=outside_subnet,json=outsideSubnet" json:"outside_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize string `protobuf:"bytes,4,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AzureVnetTwoInterfaceNodeType) Reset()      { *m = AzureVnetTwoInterfaceNodeType{} }
func (*AzureVnetTwoInterfaceNodeType) ProtoMessage() {}
func (*AzureVnetTwoInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{12}
}

func (m *AzureVnetTwoInterfaceNodeType) GetAzureAz() string {
	if m != nil {
		return m.AzureAz
	}
	return ""
}

func (m *AzureVnetTwoInterfaceNodeType) GetInsideSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.InsideSubnet
	}
	return nil
}

func (m *AzureVnetTwoInterfaceNodeType) GetOutsideSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.OutsideSubnet
	}
	return nil
}

func (m *AzureVnetTwoInterfaceNodeType) GetDiskSize() string {
	if m != nil {
		return m.DiskSize
	}
	return ""
}

// GCP VPC Network Parameters
//
// x-displayName: "GCP VPC Network Parameters"
// Parameters to create a new GCP VPC Network
type GCPVPCNetworkParamsType struct {
	// GCP VPC Network Name
	//
	// x-displayName: "GCP VPC Network Name"
	// x-required
	// x-example: "network1"
	// Name for your GCP VPC Network
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GCPVPCNetworkParamsType) Reset()      { *m = GCPVPCNetworkParamsType{} }
func (*GCPVPCNetworkParamsType) ProtoMessage() {}
func (*GCPVPCNetworkParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{13}
}

func (m *GCPVPCNetworkParamsType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GCP existing VPC network Type
//
// x-displayName: "GCP existing VPC network Type"
// Name of existing VPC network
type GCPVPCNetworkType struct {
	// GCP VPC Network Name
	//
	// x-displayName: "GCP VPC Network Name"
	// x-required
	// x-example: "network1"
	// Name for your GCP VPC Network
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GCPVPCNetworkType) Reset()                    { *m = GCPVPCNetworkType{} }
func (*GCPVPCNetworkType) ProtoMessage()               {}
func (*GCPVPCNetworkType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{14} }

func (m *GCPVPCNetworkType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GCP existing subnet Type
//
// x-displayName: "GCP existing subnet Type"
// Name of existing gcp subnet
type GCPSubnetType struct {
	// GCP VPC Subnet Name
	//
	// x-displayName: "VPC Subnet Name"
	// x-required
	// x-example: "subnet1-in-network1"
	// Name of your subnet in VPC network
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
}

func (m *GCPSubnetType) Reset()                    { *m = GCPSubnetType{} }
func (*GCPSubnetType) ProtoMessage()               {}
func (*GCPSubnetType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{15} }

func (m *GCPSubnetType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

// GCP subnet parameters Type
//
// x-displayName: "GCP subnet parameters Type"
// Parameters for gcp subnet
type GCPSubnetParamsType struct {
	// GCP VPC Subnet Name
	//
	// x-displayName: "VPC Subnet Name"
	// x-required
	// x-example: "subnet1-in-network1"
	// Name of new VPC Subnet
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
	// IPv4 CIDR block
	//
	// x-displayName: "IPv4 Subnet Prefix"
	// x-required
	// x-example: "10.1.0.0/16"
	// IPv4 prefix for this Subnet. It has to be private address space.
	PrimaryIpv4 string `protobuf:"bytes,2,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
}

func (m *GCPSubnetParamsType) Reset()                    { *m = GCPSubnetParamsType{} }
func (*GCPSubnetParamsType) ProtoMessage()               {}
func (*GCPSubnetParamsType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{16} }

func (m *GCPSubnetParamsType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

func (m *GCPSubnetParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

// GCP VPC network choice
//
// x-displayName: "GCP VPC network choice"
// This defines choice about GCP VPC network for a view
type GCPVPCNetworkChoiceType struct {
	// Choice of existing or new VPC network
	//
	// x-displayName: "Select existing VPC network or create new VPC network"
	// x-required
	// This is choice of existing VPC network or new VPC network
	//
	// Types that are valid to be assigned to Choice:
	//	*GCPVPCNetworkChoiceType_NewNetwork
	//	*GCPVPCNetworkChoiceType_ExistingNetwork
	Choice isGCPVPCNetworkChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *GCPVPCNetworkChoiceType) Reset()      { *m = GCPVPCNetworkChoiceType{} }
func (*GCPVPCNetworkChoiceType) ProtoMessage() {}
func (*GCPVPCNetworkChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{17}
}

type isGCPVPCNetworkChoiceType_Choice interface {
	isGCPVPCNetworkChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPVPCNetworkChoiceType_NewNetwork struct {
	NewNetwork *GCPVPCNetworkParamsType `protobuf:"bytes,2,opt,name=new_network,json=newNetwork,oneof"`
}
type GCPVPCNetworkChoiceType_ExistingNetwork struct {
	ExistingNetwork *GCPVPCNetworkType `protobuf:"bytes,3,opt,name=existing_network,json=existingNetwork,oneof"`
}

func (*GCPVPCNetworkChoiceType_NewNetwork) isGCPVPCNetworkChoiceType_Choice()      {}
func (*GCPVPCNetworkChoiceType_ExistingNetwork) isGCPVPCNetworkChoiceType_Choice() {}

func (m *GCPVPCNetworkChoiceType) GetChoice() isGCPVPCNetworkChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *GCPVPCNetworkChoiceType) GetNewNetwork() *GCPVPCNetworkParamsType {
	if x, ok := m.GetChoice().(*GCPVPCNetworkChoiceType_NewNetwork); ok {
		return x.NewNetwork
	}
	return nil
}

func (m *GCPVPCNetworkChoiceType) GetExistingNetwork() *GCPVPCNetworkType {
	if x, ok := m.GetChoice().(*GCPVPCNetworkChoiceType_ExistingNetwork); ok {
		return x.ExistingNetwork
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GCPVPCNetworkChoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GCPVPCNetworkChoiceType_OneofMarshaler, _GCPVPCNetworkChoiceType_OneofUnmarshaler, _GCPVPCNetworkChoiceType_OneofSizer, []interface{}{
		(*GCPVPCNetworkChoiceType_NewNetwork)(nil),
		(*GCPVPCNetworkChoiceType_ExistingNetwork)(nil),
	}
}

func _GCPVPCNetworkChoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GCPVPCNetworkChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *GCPVPCNetworkChoiceType_NewNetwork:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewNetwork); err != nil {
			return err
		}
	case *GCPVPCNetworkChoiceType_ExistingNetwork:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExistingNetwork); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GCPVPCNetworkChoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _GCPVPCNetworkChoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GCPVPCNetworkChoiceType)
	switch tag {
	case 2: // choice.new_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GCPVPCNetworkParamsType)
		err := b.DecodeMessage(msg)
		m.Choice = &GCPVPCNetworkChoiceType_NewNetwork{msg}
		return true, err
	case 3: // choice.existing_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GCPVPCNetworkType)
		err := b.DecodeMessage(msg)
		m.Choice = &GCPVPCNetworkChoiceType_ExistingNetwork{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GCPVPCNetworkChoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GCPVPCNetworkChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *GCPVPCNetworkChoiceType_NewNetwork:
		s := proto.Size(x.NewNetwork)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GCPVPCNetworkChoiceType_ExistingNetwork:
		s := proto.Size(x.ExistingNetwork)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GCP VPC network choice
//
// x-displayName: "GCP VPC network choice"
// This defines choice about GCP VPC network for a view
type GCPVPCSubnetChoiceType struct {
	// Choice of existing or new subnet
	//
	// x-displayName: "Select existing subnet or create new subnet"
	// x-required
	// This is choice of existing subnet or new subnet
	//
	// Types that are valid to be assigned to Choice:
	//	*GCPVPCSubnetChoiceType_NewSubnet
	//	*GCPVPCSubnetChoiceType_ExistingSubnet
	Choice isGCPVPCSubnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *GCPVPCSubnetChoiceType) Reset()      { *m = GCPVPCSubnetChoiceType{} }
func (*GCPVPCSubnetChoiceType) ProtoMessage() {}
func (*GCPVPCSubnetChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{18}
}

type isGCPVPCSubnetChoiceType_Choice interface {
	isGCPVPCSubnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPVPCSubnetChoiceType_NewSubnet struct {
	NewSubnet *GCPSubnetParamsType `protobuf:"bytes,2,opt,name=new_subnet,json=newSubnet,oneof"`
}
type GCPVPCSubnetChoiceType_ExistingSubnet struct {
	ExistingSubnet *GCPSubnetType `protobuf:"bytes,3,opt,name=existing_subnet,json=existingSubnet,oneof"`
}

func (*GCPVPCSubnetChoiceType_NewSubnet) isGCPVPCSubnetChoiceType_Choice()      {}
func (*GCPVPCSubnetChoiceType_ExistingSubnet) isGCPVPCSubnetChoiceType_Choice() {}

func (m *GCPVPCSubnetChoiceType) GetChoice() isGCPVPCSubnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *GCPVPCSubnetChoiceType) GetNewSubnet() *GCPSubnetParamsType {
	if x, ok := m.GetChoice().(*GCPVPCSubnetChoiceType_NewSubnet); ok {
		return x.NewSubnet
	}
	return nil
}

func (m *GCPVPCSubnetChoiceType) GetExistingSubnet() *GCPSubnetType {
	if x, ok := m.GetChoice().(*GCPVPCSubnetChoiceType_ExistingSubnet); ok {
		return x.ExistingSubnet
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GCPVPCSubnetChoiceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GCPVPCSubnetChoiceType_OneofMarshaler, _GCPVPCSubnetChoiceType_OneofUnmarshaler, _GCPVPCSubnetChoiceType_OneofSizer, []interface{}{
		(*GCPVPCSubnetChoiceType_NewSubnet)(nil),
		(*GCPVPCSubnetChoiceType_ExistingSubnet)(nil),
	}
}

func _GCPVPCSubnetChoiceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GCPVPCSubnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *GCPVPCSubnetChoiceType_NewSubnet:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewSubnet); err != nil {
			return err
		}
	case *GCPVPCSubnetChoiceType_ExistingSubnet:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExistingSubnet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GCPVPCSubnetChoiceType.Choice has unexpected type %T", x)
	}
	return nil
}

func _GCPVPCSubnetChoiceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GCPVPCSubnetChoiceType)
	switch tag {
	case 2: // choice.new_subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GCPSubnetParamsType)
		err := b.DecodeMessage(msg)
		m.Choice = &GCPVPCSubnetChoiceType_NewSubnet{msg}
		return true, err
	case 3: // choice.existing_subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GCPSubnetType)
		err := b.DecodeMessage(msg)
		m.Choice = &GCPVPCSubnetChoiceType_ExistingSubnet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GCPVPCSubnetChoiceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GCPVPCSubnetChoiceType)
	// choice
	switch x := m.Choice.(type) {
	case *GCPVPCSubnetChoiceType_NewSubnet:
		s := proto.Size(x.NewSubnet)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GCPVPCSubnetChoiceType_ExistingSubnet:
		s := proto.Size(x.ExistingSubnet)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Single Interface Node
//
// x-displayName: "Single Interface Node"
// Parameters for creating Single interface Node
type GCPVPCOneInterfaceNodeType struct {
	// GCP zone
	//
	// x-required
	// x-displayName: "GCP zone name"
	// x-required
	// x-example: "us-west1-a"
	// Name for GCP zone, should match with region selected.
	GcpZoneName string `protobuf:"bytes,1,opt,name=gcp_zone_name,json=gcpZoneName,proto3" json:"gcp_zone_name,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for local Interface"
	// Subnets for the local interface of the node, should be in local network
	LocalSubnet *GCPVPCSubnetChoiceType `protobuf:"bytes,2,opt,name=local_subnet,json=localSubnet" json:"local_subnet,omitempty"`
}

func (m *GCPVPCOneInterfaceNodeType) Reset()      { *m = GCPVPCOneInterfaceNodeType{} }
func (*GCPVPCOneInterfaceNodeType) ProtoMessage() {}
func (*GCPVPCOneInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{19}
}

func (m *GCPVPCOneInterfaceNodeType) GetGcpZoneName() string {
	if m != nil {
		return m.GcpZoneName
	}
	return ""
}

func (m *GCPVPCOneInterfaceNodeType) GetLocalSubnet() *GCPVPCSubnetChoiceType {
	if m != nil {
		return m.LocalSubnet
	}
	return nil
}

// Two Interface Node
//
// x-displayName: "Two Interface Node"
// Parameters for creating two interface Node in different vpc networks
type GCPVPCTwoInterfaceNodeType struct {
	// GCP AZ
	//
	// x-required
	// x-displayName: "GCP AZ name"
	// x-required
	// x-example: "us-west-2a"
	// Name for GCP zone, should match with region selected.
	GcpZoneName string `protobuf:"bytes,1,opt,name=gcp_zone_name,json=gcpZoneName,proto3" json:"gcp_zone_name,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Inside Interface"
	// Subnets for the inside interface of the node, should be in inside network
	InsideSubnet *GCPVPCSubnetChoiceType `protobuf:"bytes,2,opt,name=inside_subnet,json=insideSubnet" json:"inside_subnet,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Outside Interface"
	// Subnets for the outside interface of the node, should be in outside network
	OutsideSubnet *GCPVPCSubnetChoiceType `protobuf:"bytes,3,opt,name=outside_subnet,json=outsideSubnet" json:"outside_subnet,omitempty"`
}

func (m *GCPVPCTwoInterfaceNodeType) Reset()      { *m = GCPVPCTwoInterfaceNodeType{} }
func (*GCPVPCTwoInterfaceNodeType) ProtoMessage() {}
func (*GCPVPCTwoInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{20}
}

func (m *GCPVPCTwoInterfaceNodeType) GetGcpZoneName() string {
	if m != nil {
		return m.GcpZoneName
	}
	return ""
}

func (m *GCPVPCTwoInterfaceNodeType) GetInsideSubnet() *GCPVPCSubnetChoiceType {
	if m != nil {
		return m.InsideSubnet
	}
	return nil
}

func (m *GCPVPCTwoInterfaceNodeType) GetOutsideSubnet() *GCPVPCSubnetChoiceType {
	if m != nil {
		return m.OutsideSubnet
	}
	return nil
}

// Site Static Route Config Modes
//
// x-displayName: "Site Static Route Config Modes"
// Different ways to configure static routes
type SiteStaticRoutesType struct {
	// Static Route Config Mode
	//
	// x-displayName: "Static Route Config Mode"
	// x-required
	// Select method for configuring the route
	//
	// Types that are valid to be assigned to ConfigModeChoice:
	//	*SiteStaticRoutesType_SimpleStaticRoute
	//	*SiteStaticRoutesType_CustomStaticRoute
	ConfigModeChoice isSiteStaticRoutesType_ConfigModeChoice `protobuf_oneof:"config_mode_choice"`
}

func (m *SiteStaticRoutesType) Reset()                    { *m = SiteStaticRoutesType{} }
func (*SiteStaticRoutesType) ProtoMessage()               {}
func (*SiteStaticRoutesType) Descriptor() ([]byte, []int) { return fileDescriptorSiteTypes, []int{21} }

type isSiteStaticRoutesType_ConfigModeChoice interface {
	isSiteStaticRoutesType_ConfigModeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteStaticRoutesType_SimpleStaticRoute struct {
	SimpleStaticRoute string `protobuf:"bytes,2,opt,name=simple_static_route,json=simpleStaticRoute,proto3,oneof"`
}
type SiteStaticRoutesType_CustomStaticRoute struct {
	CustomStaticRoute *ves_io_schema4.StaticRouteType `protobuf:"bytes,3,opt,name=custom_static_route,json=customStaticRoute,oneof"`
}

func (*SiteStaticRoutesType_SimpleStaticRoute) isSiteStaticRoutesType_ConfigModeChoice() {}
func (*SiteStaticRoutesType_CustomStaticRoute) isSiteStaticRoutesType_ConfigModeChoice() {}

func (m *SiteStaticRoutesType) GetConfigModeChoice() isSiteStaticRoutesType_ConfigModeChoice {
	if m != nil {
		return m.ConfigModeChoice
	}
	return nil
}

func (m *SiteStaticRoutesType) GetSimpleStaticRoute() string {
	if x, ok := m.GetConfigModeChoice().(*SiteStaticRoutesType_SimpleStaticRoute); ok {
		return x.SimpleStaticRoute
	}
	return ""
}

func (m *SiteStaticRoutesType) GetCustomStaticRoute() *ves_io_schema4.StaticRouteType {
	if x, ok := m.GetConfigModeChoice().(*SiteStaticRoutesType_CustomStaticRoute); ok {
		return x.CustomStaticRoute
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SiteStaticRoutesType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SiteStaticRoutesType_OneofMarshaler, _SiteStaticRoutesType_OneofUnmarshaler, _SiteStaticRoutesType_OneofSizer, []interface{}{
		(*SiteStaticRoutesType_SimpleStaticRoute)(nil),
		(*SiteStaticRoutesType_CustomStaticRoute)(nil),
	}
}

func _SiteStaticRoutesType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SiteStaticRoutesType)
	// config_mode_choice
	switch x := m.ConfigModeChoice.(type) {
	case *SiteStaticRoutesType_SimpleStaticRoute:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.SimpleStaticRoute)
	case *SiteStaticRoutesType_CustomStaticRoute:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomStaticRoute); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SiteStaticRoutesType.ConfigModeChoice has unexpected type %T", x)
	}
	return nil
}

func _SiteStaticRoutesType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SiteStaticRoutesType)
	switch tag {
	case 2: // config_mode_choice.simple_static_route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ConfigModeChoice = &SiteStaticRoutesType_SimpleStaticRoute{x}
		return true, err
	case 3: // config_mode_choice.custom_static_route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.StaticRouteType)
		err := b.DecodeMessage(msg)
		m.ConfigModeChoice = &SiteStaticRoutesType_CustomStaticRoute{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SiteStaticRoutesType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SiteStaticRoutesType)
	// config_mode_choice
	switch x := m.ConfigModeChoice.(type) {
	case *SiteStaticRoutesType_SimpleStaticRoute:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SimpleStaticRoute)))
		n += len(x.SimpleStaticRoute)
	case *SiteStaticRoutesType_CustomStaticRoute:
		s := proto.Size(x.CustomStaticRoute)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Static Route List Type
//
// x-displayName: "Static Route List Type"
// List of static routes
type SiteStaticRoutesListType struct {
	// List of Static Routes
	//
	// x-displayName: "List of Static Routes
	// x-required
	// List of Static routes
	StaticRouteList []*SiteStaticRoutesType `protobuf:"bytes,1,rep,name=static_route_list,json=staticRouteList" json:"static_route_list,omitempty"`
}

func (m *SiteStaticRoutesListType) Reset()      { *m = SiteStaticRoutesListType{} }
func (*SiteStaticRoutesListType) ProtoMessage() {}
func (*SiteStaticRoutesListType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{22}
}

func (m *SiteStaticRoutesListType) GetStaticRouteList() []*SiteStaticRoutesType {
	if m != nil {
		return m.StaticRouteList
	}
	return nil
}

// Global Network Connection
//
// x-displayName: "Global Network Connection"
// Global network connection
type GlobalNetworkConnectionType struct {
	// Connector Choice
	//
	// x-displayName: "Select Network Connection Type"
	// x-required
	// Select the networks and method in which they are connected.
	//
	// Types that are valid to be assigned to ConnectionChoice:
	//	*GlobalNetworkConnectionType_SliToGlobalDr
	//	*GlobalNetworkConnectionType_SloToGlobalDr
	ConnectionChoice isGlobalNetworkConnectionType_ConnectionChoice `protobuf_oneof:"connection_choice"`
	// Select Forward Proxy
	//
	// x-displayName: "Select Forward Proxy"
	// Select to enable forward proxy
	//
	// Types that are valid to be assigned to ForwardProxyChoice:
	//	*GlobalNetworkConnectionType_DisableForwardProxy
	//	*GlobalNetworkConnectionType_EnableForwardProxy
	ForwardProxyChoice isGlobalNetworkConnectionType_ForwardProxyChoice `protobuf_oneof:"forward_proxy_choice"`
}

func (m *GlobalNetworkConnectionType) Reset()      { *m = GlobalNetworkConnectionType{} }
func (*GlobalNetworkConnectionType) ProtoMessage() {}
func (*GlobalNetworkConnectionType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{23}
}

type isGlobalNetworkConnectionType_ConnectionChoice interface {
	isGlobalNetworkConnectionType_ConnectionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalNetworkConnectionType_ForwardProxyChoice interface {
	isGlobalNetworkConnectionType_ForwardProxyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalNetworkConnectionType_SliToGlobalDr struct {
	SliToGlobalDr *GlobalConnectorType `protobuf:"bytes,2,opt,name=sli_to_global_dr,json=sliToGlobalDr,oneof"`
}
type GlobalNetworkConnectionType_SloToGlobalDr struct {
	SloToGlobalDr *GlobalConnectorType `protobuf:"bytes,3,opt,name=slo_to_global_dr,json=sloToGlobalDr,oneof"`
}
type GlobalNetworkConnectionType_DisableForwardProxy struct {
	DisableForwardProxy *ves_io_schema4.Empty `protobuf:"bytes,5,opt,name=disable_forward_proxy,json=disableForwardProxy,oneof"`
}
type GlobalNetworkConnectionType_EnableForwardProxy struct {
	EnableForwardProxy *ves_io_schema4.ForwardProxyConfigType `protobuf:"bytes,6,opt,name=enable_forward_proxy,json=enableForwardProxy,oneof"`
}

func (*GlobalNetworkConnectionType_SliToGlobalDr) isGlobalNetworkConnectionType_ConnectionChoice() {}
func (*GlobalNetworkConnectionType_SloToGlobalDr) isGlobalNetworkConnectionType_ConnectionChoice() {}
func (*GlobalNetworkConnectionType_DisableForwardProxy) isGlobalNetworkConnectionType_ForwardProxyChoice() {
}
func (*GlobalNetworkConnectionType_EnableForwardProxy) isGlobalNetworkConnectionType_ForwardProxyChoice() {
}

func (m *GlobalNetworkConnectionType) GetConnectionChoice() isGlobalNetworkConnectionType_ConnectionChoice {
	if m != nil {
		return m.ConnectionChoice
	}
	return nil
}
func (m *GlobalNetworkConnectionType) GetForwardProxyChoice() isGlobalNetworkConnectionType_ForwardProxyChoice {
	if m != nil {
		return m.ForwardProxyChoice
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetSliToGlobalDr() *GlobalConnectorType {
	if x, ok := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SliToGlobalDr); ok {
		return x.SliToGlobalDr
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetSloToGlobalDr() *GlobalConnectorType {
	if x, ok := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SloToGlobalDr); ok {
		return x.SloToGlobalDr
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetDisableForwardProxy() *ves_io_schema4.Empty {
	if x, ok := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_DisableForwardProxy); ok {
		return x.DisableForwardProxy
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetEnableForwardProxy() *ves_io_schema4.ForwardProxyConfigType {
	if x, ok := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_EnableForwardProxy); ok {
		return x.EnableForwardProxy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalNetworkConnectionType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalNetworkConnectionType_OneofMarshaler, _GlobalNetworkConnectionType_OneofUnmarshaler, _GlobalNetworkConnectionType_OneofSizer, []interface{}{
		(*GlobalNetworkConnectionType_SliToGlobalDr)(nil),
		(*GlobalNetworkConnectionType_SloToGlobalDr)(nil),
		(*GlobalNetworkConnectionType_DisableForwardProxy)(nil),
		(*GlobalNetworkConnectionType_EnableForwardProxy)(nil),
	}
}

func _GlobalNetworkConnectionType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalNetworkConnectionType)
	// connection_choice
	switch x := m.ConnectionChoice.(type) {
	case *GlobalNetworkConnectionType_SliToGlobalDr:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SliToGlobalDr); err != nil {
			return err
		}
	case *GlobalNetworkConnectionType_SloToGlobalDr:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SloToGlobalDr); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalNetworkConnectionType.ConnectionChoice has unexpected type %T", x)
	}
	// forward_proxy_choice
	switch x := m.ForwardProxyChoice.(type) {
	case *GlobalNetworkConnectionType_DisableForwardProxy:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DisableForwardProxy); err != nil {
			return err
		}
	case *GlobalNetworkConnectionType_EnableForwardProxy:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableForwardProxy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalNetworkConnectionType.ForwardProxyChoice has unexpected type %T", x)
	}
	return nil
}

func _GlobalNetworkConnectionType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalNetworkConnectionType)
	switch tag {
	case 2: // connection_choice.sli_to_global_dr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GlobalConnectorType)
		err := b.DecodeMessage(msg)
		m.ConnectionChoice = &GlobalNetworkConnectionType_SliToGlobalDr{msg}
		return true, err
	case 3: // connection_choice.slo_to_global_dr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GlobalConnectorType)
		err := b.DecodeMessage(msg)
		m.ConnectionChoice = &GlobalNetworkConnectionType_SloToGlobalDr{msg}
		return true, err
	case 5: // forward_proxy_choice.disable_forward_proxy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ForwardProxyChoice = &GlobalNetworkConnectionType_DisableForwardProxy{msg}
		return true, err
	case 6: // forward_proxy_choice.enable_forward_proxy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.ForwardProxyConfigType)
		err := b.DecodeMessage(msg)
		m.ForwardProxyChoice = &GlobalNetworkConnectionType_EnableForwardProxy{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalNetworkConnectionType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalNetworkConnectionType)
	// connection_choice
	switch x := m.ConnectionChoice.(type) {
	case *GlobalNetworkConnectionType_SliToGlobalDr:
		s := proto.Size(x.SliToGlobalDr)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalNetworkConnectionType_SloToGlobalDr:
		s := proto.Size(x.SloToGlobalDr)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// forward_proxy_choice
	switch x := m.ForwardProxyChoice.(type) {
	case *GlobalNetworkConnectionType_DisableForwardProxy:
		s := proto.Size(x.DisableForwardProxy)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalNetworkConnectionType_EnableForwardProxy:
		s := proto.Size(x.EnableForwardProxy)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Global Network Connection List
//
// x-displayName: "Global Network Connection List"
// List of global network connections
type GlobalNetworkConnectionListType struct {
	// Global Network Connections
	//
	// x-displayName: "Global Network Connections"
	// x-required
	// Global network connections
	GlobalNetworkConnections []*GlobalNetworkConnectionType `protobuf:"bytes,1,rep,name=global_network_connections,json=globalNetworkConnections" json:"global_network_connections,omitempty"`
}

func (m *GlobalNetworkConnectionListType) Reset()      { *m = GlobalNetworkConnectionListType{} }
func (*GlobalNetworkConnectionListType) ProtoMessage() {}
func (*GlobalNetworkConnectionListType) Descriptor() ([]byte, []int) {
	return fileDescriptorSiteTypes, []int{24}
}

func (m *GlobalNetworkConnectionListType) GetGlobalNetworkConnections() []*GlobalNetworkConnectionType {
	if m != nil {
		return m.GlobalNetworkConnections
	}
	return nil
}

func init() {
	proto.RegisterType((*AWSVPCParamsType)(nil), "ves.io.schema.views.AWSVPCParamsType")
	golang_proto.RegisterType((*AWSVPCParamsType)(nil), "ves.io.schema.views.AWSVPCParamsType")
	proto.RegisterType((*AWSVPCchoiceType)(nil), "ves.io.schema.views.AWSVPCchoiceType")
	golang_proto.RegisterType((*AWSVPCchoiceType)(nil), "ves.io.schema.views.AWSVPCchoiceType")
	proto.RegisterType((*CloudSubnetParamType)(nil), "ves.io.schema.views.CloudSubnetParamType")
	golang_proto.RegisterType((*CloudSubnetParamType)(nil), "ves.io.schema.views.CloudSubnetParamType")
	proto.RegisterType((*CloudSubnetType)(nil), "ves.io.schema.views.CloudSubnetType")
	golang_proto.RegisterType((*CloudSubnetType)(nil), "ves.io.schema.views.CloudSubnetType")
	proto.RegisterType((*AWSVPCOneInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCOneInterfaceNodeType")
	golang_proto.RegisterType((*AWSVPCOneInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCOneInterfaceNodeType")
	proto.RegisterType((*AWSVPCTwoInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCTwoInterfaceNodeType")
	golang_proto.RegisterType((*AWSVPCTwoInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCTwoInterfaceNodeType")
	proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.AzureVnetParamsType")
	golang_proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.AzureVnetParamsType")
	proto.RegisterType((*AzureVnetType)(nil), "ves.io.schema.views.AzureVnetType")
	golang_proto.RegisterType((*AzureVnetType)(nil), "ves.io.schema.views.AzureVnetType")
	proto.RegisterType((*AzureVnetChoiceType)(nil), "ves.io.schema.views.AzureVnetChoiceType")
	golang_proto.RegisterType((*AzureVnetChoiceType)(nil), "ves.io.schema.views.AzureVnetChoiceType")
	proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.AzureSubnetType")
	golang_proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.AzureSubnetType")
	proto.RegisterType((*AzureSubnetChoiceType)(nil), "ves.io.schema.views.AzureSubnetChoiceType")
	golang_proto.RegisterType((*AzureSubnetChoiceType)(nil), "ves.io.schema.views.AzureSubnetChoiceType")
	proto.RegisterType((*AzureVnetOneInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetOneInterfaceNodeType")
	golang_proto.RegisterType((*AzureVnetOneInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetOneInterfaceNodeType")
	proto.RegisterType((*AzureVnetTwoInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetTwoInterfaceNodeType")
	golang_proto.RegisterType((*AzureVnetTwoInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetTwoInterfaceNodeType")
	proto.RegisterType((*GCPVPCNetworkParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkParamsType")
	golang_proto.RegisterType((*GCPVPCNetworkParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkParamsType")
	proto.RegisterType((*GCPVPCNetworkType)(nil), "ves.io.schema.views.GCPVPCNetworkType")
	golang_proto.RegisterType((*GCPVPCNetworkType)(nil), "ves.io.schema.views.GCPVPCNetworkType")
	proto.RegisterType((*GCPSubnetType)(nil), "ves.io.schema.views.GCPSubnetType")
	golang_proto.RegisterType((*GCPSubnetType)(nil), "ves.io.schema.views.GCPSubnetType")
	proto.RegisterType((*GCPSubnetParamsType)(nil), "ves.io.schema.views.GCPSubnetParamsType")
	golang_proto.RegisterType((*GCPSubnetParamsType)(nil), "ves.io.schema.views.GCPSubnetParamsType")
	proto.RegisterType((*GCPVPCNetworkChoiceType)(nil), "ves.io.schema.views.GCPVPCNetworkChoiceType")
	golang_proto.RegisterType((*GCPVPCNetworkChoiceType)(nil), "ves.io.schema.views.GCPVPCNetworkChoiceType")
	proto.RegisterType((*GCPVPCSubnetChoiceType)(nil), "ves.io.schema.views.GCPVPCSubnetChoiceType")
	golang_proto.RegisterType((*GCPVPCSubnetChoiceType)(nil), "ves.io.schema.views.GCPVPCSubnetChoiceType")
	proto.RegisterType((*GCPVPCOneInterfaceNodeType)(nil), "ves.io.schema.views.GCPVPCOneInterfaceNodeType")
	golang_proto.RegisterType((*GCPVPCOneInterfaceNodeType)(nil), "ves.io.schema.views.GCPVPCOneInterfaceNodeType")
	proto.RegisterType((*GCPVPCTwoInterfaceNodeType)(nil), "ves.io.schema.views.GCPVPCTwoInterfaceNodeType")
	golang_proto.RegisterType((*GCPVPCTwoInterfaceNodeType)(nil), "ves.io.schema.views.GCPVPCTwoInterfaceNodeType")
	proto.RegisterType((*SiteStaticRoutesType)(nil), "ves.io.schema.views.SiteStaticRoutesType")
	golang_proto.RegisterType((*SiteStaticRoutesType)(nil), "ves.io.schema.views.SiteStaticRoutesType")
	proto.RegisterType((*SiteStaticRoutesListType)(nil), "ves.io.schema.views.SiteStaticRoutesListType")
	golang_proto.RegisterType((*SiteStaticRoutesListType)(nil), "ves.io.schema.views.SiteStaticRoutesListType")
	proto.RegisterType((*GlobalNetworkConnectionType)(nil), "ves.io.schema.views.GlobalNetworkConnectionType")
	golang_proto.RegisterType((*GlobalNetworkConnectionType)(nil), "ves.io.schema.views.GlobalNetworkConnectionType")
	proto.RegisterType((*GlobalNetworkConnectionListType)(nil), "ves.io.schema.views.GlobalNetworkConnectionListType")
	golang_proto.RegisterType((*GlobalNetworkConnectionListType)(nil), "ves.io.schema.views.GlobalNetworkConnectionListType")
}
func (this *AWSVPCParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCParamsType)
	if !ok {
		that2, ok := that.(AWSVPCParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NameTag != that1.NameTag {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	if this.AllocateIpv6 != that1.AllocateIpv6 {
		return false
	}
	return true
}
func (this *AWSVPCchoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCchoiceType)
	if !ok {
		that2, ok := that.(AWSVPCchoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AWSVPCchoiceType_NewVpc) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCchoiceType_NewVpc)
	if !ok {
		that2, ok := that.(AWSVPCchoiceType_NewVpc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVpc.Equal(that1.NewVpc) {
		return false
	}
	return true
}
func (this *AWSVPCchoiceType_VpcId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCchoiceType_VpcId)
	if !ok {
		that2, ok := that.(AWSVPCchoiceType_VpcId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	return true
}
func (this *CloudSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetParamType)
	if !ok {
		that2, ok := that.(CloudSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ipv4 != that1.Ipv4 {
		return false
	}
	if this.Ipv6 != that1.Ipv6 {
		return false
	}
	return true
}
func (this *CloudSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType)
	if !ok {
		that2, ok := that.(CloudSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *CloudSubnetType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType_SubnetParam)
	if !ok {
		that2, ok := that.(CloudSubnetType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *CloudSubnetType_ExistingSubnetId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType_ExistingSubnetId)
	if !ok {
		that2, ok := that.(CloudSubnetType_ExistingSubnetId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExistingSubnetId != that1.ExistingSubnetId {
		return false
	}
	return true
}
func (this *AWSVPCOneInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCOneInterfaceNodeType)
	if !ok {
		that2, ok := that.(AWSVPCOneInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AwsAzName != that1.AwsAzName {
		return false
	}
	if !this.LocalSubnet.Equal(that1.LocalSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AWSVPCTwoInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCTwoInterfaceNodeType)
	if !ok {
		that2, ok := that.(AWSVPCTwoInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AwsAzName != that1.AwsAzName {
		return false
	}
	if !this.InsideSubnet.Equal(that1.InsideSubnet) {
		return false
	}
	if !this.OutsideSubnet.Equal(that1.OutsideSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AzureVnetParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetParamsType)
	if !ok {
		that2, ok := that.(AzureVnetParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	return true
}
func (this *AzureVnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetType)
	if !ok {
		that2, ok := that.(AzureVnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceGroup != that1.ResourceGroup {
		return false
	}
	if this.VnetName != that1.VnetName {
		return false
	}
	return true
}
func (this *AzureVnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetChoiceType)
	if !ok {
		that2, ok := that.(AzureVnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AzureVnetChoiceType_NewVnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetChoiceType_NewVnet)
	if !ok {
		that2, ok := that.(AzureVnetChoiceType_NewVnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVnet.Equal(that1.NewVnet) {
		return false
	}
	return true
}
func (this *AzureVnetChoiceType_ExistingVnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetChoiceType_ExistingVnet)
	if !ok {
		that2, ok := that.(AzureVnetChoiceType_ExistingVnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingVnet.Equal(that1.ExistingVnet) {
		return false
	}
	return true
}
func (this *AzureSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType)
	if !ok {
		that2, ok := that.(AzureSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	if this.SubnetResourceGrp != that1.SubnetResourceGrp {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType_SubnetParam)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType_Subnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType_Subnet)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType_Subnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	return true
}
func (this *AzureVnetOneInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetOneInterfaceNodeType)
	if !ok {
		that2, ok := that.(AzureVnetOneInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzureAz != that1.AzureAz {
		return false
	}
	if !this.LocalSubnet.Equal(that1.LocalSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AzureVnetTwoInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetTwoInterfaceNodeType)
	if !ok {
		that2, ok := that.(AzureVnetTwoInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzureAz != that1.AzureAz {
		return false
	}
	if !this.InsideSubnet.Equal(that1.InsideSubnet) {
		return false
	}
	if !this.OutsideSubnet.Equal(that1.OutsideSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *GCPVPCNetworkParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkParamsType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GCPVPCNetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GCPSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetType)
	if !ok {
		that2, ok := that.(GCPSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	return true
}
func (this *GCPSubnetParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetParamsType)
	if !ok {
		that2, ok := that.(GCPSubnetParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType_NewNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType_NewNetwork)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType_NewNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewNetwork.Equal(that1.NewNetwork) {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType_ExistingNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType_ExistingNetwork)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType_ExistingNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingNetwork.Equal(that1.ExistingNetwork) {
		return false
	}
	return true
}
func (this *GCPVPCSubnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCSubnetChoiceType)
	if !ok {
		that2, ok := that.(GCPVPCSubnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *GCPVPCSubnetChoiceType_NewSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCSubnetChoiceType_NewSubnet)
	if !ok {
		that2, ok := that.(GCPVPCSubnetChoiceType_NewSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewSubnet.Equal(that1.NewSubnet) {
		return false
	}
	return true
}
func (this *GCPVPCSubnetChoiceType_ExistingSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCSubnetChoiceType_ExistingSubnet)
	if !ok {
		that2, ok := that.(GCPVPCSubnetChoiceType_ExistingSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingSubnet.Equal(that1.ExistingSubnet) {
		return false
	}
	return true
}
func (this *GCPVPCOneInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCOneInterfaceNodeType)
	if !ok {
		that2, ok := that.(GCPVPCOneInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GcpZoneName != that1.GcpZoneName {
		return false
	}
	if !this.LocalSubnet.Equal(that1.LocalSubnet) {
		return false
	}
	return true
}
func (this *GCPVPCTwoInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCTwoInterfaceNodeType)
	if !ok {
		that2, ok := that.(GCPVPCTwoInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GcpZoneName != that1.GcpZoneName {
		return false
	}
	if !this.InsideSubnet.Equal(that1.InsideSubnet) {
		return false
	}
	if !this.OutsideSubnet.Equal(that1.OutsideSubnet) {
		return false
	}
	return true
}
func (this *SiteStaticRoutesType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesType)
	if !ok {
		that2, ok := that.(SiteStaticRoutesType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigModeChoice == nil {
		if this.ConfigModeChoice != nil {
			return false
		}
	} else if this.ConfigModeChoice == nil {
		return false
	} else if !this.ConfigModeChoice.Equal(that1.ConfigModeChoice) {
		return false
	}
	return true
}
func (this *SiteStaticRoutesType_SimpleStaticRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesType_SimpleStaticRoute)
	if !ok {
		that2, ok := that.(SiteStaticRoutesType_SimpleStaticRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SimpleStaticRoute != that1.SimpleStaticRoute {
		return false
	}
	return true
}
func (this *SiteStaticRoutesType_CustomStaticRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesType_CustomStaticRoute)
	if !ok {
		that2, ok := that.(SiteStaticRoutesType_CustomStaticRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomStaticRoute.Equal(that1.CustomStaticRoute) {
		return false
	}
	return true
}
func (this *SiteStaticRoutesListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesListType)
	if !ok {
		that2, ok := that.(SiteStaticRoutesListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StaticRouteList) != len(that1.StaticRouteList) {
		return false
	}
	for i := range this.StaticRouteList {
		if !this.StaticRouteList[i].Equal(that1.StaticRouteList[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalNetworkConnectionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConnectionChoice == nil {
		if this.ConnectionChoice != nil {
			return false
		}
	} else if this.ConnectionChoice == nil {
		return false
	} else if !this.ConnectionChoice.Equal(that1.ConnectionChoice) {
		return false
	}
	if that1.ForwardProxyChoice == nil {
		if this.ForwardProxyChoice != nil {
			return false
		}
	} else if this.ForwardProxyChoice == nil {
		return false
	} else if !this.ForwardProxyChoice.Equal(that1.ForwardProxyChoice) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_SliToGlobalDr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_SliToGlobalDr)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_SliToGlobalDr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SliToGlobalDr.Equal(that1.SliToGlobalDr) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_SloToGlobalDr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_SloToGlobalDr)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_SloToGlobalDr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SloToGlobalDr.Equal(that1.SloToGlobalDr) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_DisableForwardProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_DisableForwardProxy)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_DisableForwardProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableForwardProxy.Equal(that1.DisableForwardProxy) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_EnableForwardProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_EnableForwardProxy)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_EnableForwardProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableForwardProxy.Equal(that1.EnableForwardProxy) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionListType)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.GlobalNetworkConnections) != len(that1.GlobalNetworkConnections) {
		return false
	}
	for i := range this.GlobalNetworkConnections {
		if !this.GlobalNetworkConnections[i].Equal(that1.GlobalNetworkConnections[i]) {
			return false
		}
	}
	return true
}
func (this *AWSVPCParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AWSVPCParamsType{")
	s = append(s, "NameTag: "+fmt.Sprintf("%#v", this.NameTag)+",\n")
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "AllocateIpv6: "+fmt.Sprintf("%#v", this.AllocateIpv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCchoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AWSVPCchoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCchoiceType_NewVpc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCchoiceType_NewVpc{` +
		`NewVpc:` + fmt.Sprintf("%#v", this.NewVpc) + `}`}, ", ")
	return s
}
func (this *AWSVPCchoiceType_VpcId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCchoiceType_VpcId{` +
		`VpcId:` + fmt.Sprintf("%#v", this.VpcId) + `}`}, ", ")
	return s
}
func (this *CloudSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.CloudSubnetParamType{")
	s = append(s, "Ipv4: "+fmt.Sprintf("%#v", this.Ipv4)+",\n")
	s = append(s, "Ipv6: "+fmt.Sprintf("%#v", this.Ipv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.CloudSubnetType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudSubnetType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.CloudSubnetType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *CloudSubnetType_ExistingSubnetId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.CloudSubnetType_ExistingSubnetId{` +
		`ExistingSubnetId:` + fmt.Sprintf("%#v", this.ExistingSubnetId) + `}`}, ", ")
	return s
}
func (this *AWSVPCOneInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AWSVPCOneInterfaceNodeType{")
	s = append(s, "AwsAzName: "+fmt.Sprintf("%#v", this.AwsAzName)+",\n")
	if this.LocalSubnet != nil {
		s = append(s, "LocalSubnet: "+fmt.Sprintf("%#v", this.LocalSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCTwoInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.AWSVPCTwoInterfaceNodeType{")
	s = append(s, "AwsAzName: "+fmt.Sprintf("%#v", this.AwsAzName)+",\n")
	if this.InsideSubnet != nil {
		s = append(s, "InsideSubnet: "+fmt.Sprintf("%#v", this.InsideSubnet)+",\n")
	}
	if this.OutsideSubnet != nil {
		s = append(s, "OutsideSubnet: "+fmt.Sprintf("%#v", this.OutsideSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureVnetParamsType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureVnetType{")
	s = append(s, "ResourceGroup: "+fmt.Sprintf("%#v", this.ResourceGroup)+",\n")
	s = append(s, "VnetName: "+fmt.Sprintf("%#v", this.VnetName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureVnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetChoiceType_NewVnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetChoiceType_NewVnet{` +
		`NewVnet:` + fmt.Sprintf("%#v", this.NewVnet) + `}`}, ", ")
	return s
}
func (this *AzureVnetChoiceType_ExistingVnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetChoiceType_ExistingVnet{` +
		`ExistingVnet:` + fmt.Sprintf("%#v", this.ExistingVnet) + `}`}, ", ")
	return s
}
func (this *AzureSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureSubnetType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	s = append(s, "SubnetResourceGrp: "+fmt.Sprintf("%#v", this.SubnetResourceGrp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureSubnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetChoiceType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetChoiceType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceType_Subnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetChoiceType_Subnet{` +
		`Subnet:` + fmt.Sprintf("%#v", this.Subnet) + `}`}, ", ")
	return s
}
func (this *AzureVnetOneInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AzureVnetOneInterfaceNodeType{")
	s = append(s, "AzureAz: "+fmt.Sprintf("%#v", this.AzureAz)+",\n")
	if this.LocalSubnet != nil {
		s = append(s, "LocalSubnet: "+fmt.Sprintf("%#v", this.LocalSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetTwoInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.AzureVnetTwoInterfaceNodeType{")
	s = append(s, "AzureAz: "+fmt.Sprintf("%#v", this.AzureAz)+",\n")
	if this.InsideSubnet != nil {
		s = append(s, "InsideSubnet: "+fmt.Sprintf("%#v", this.InsideSubnet)+",\n")
	}
	if this.OutsideSubnet != nil {
		s = append(s, "OutsideSubnet: "+fmt.Sprintf("%#v", this.OutsideSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPVPCNetworkParamsType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPVPCNetworkType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPSubnetType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.GCPSubnetParamsType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.GCPVPCNetworkChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkChoiceType_NewNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCNetworkChoiceType_NewNetwork{` +
		`NewNetwork:` + fmt.Sprintf("%#v", this.NewNetwork) + `}`}, ", ")
	return s
}
func (this *GCPVPCNetworkChoiceType_ExistingNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCNetworkChoiceType_ExistingNetwork{` +
		`ExistingNetwork:` + fmt.Sprintf("%#v", this.ExistingNetwork) + `}`}, ", ")
	return s
}
func (this *GCPVPCSubnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.GCPVPCSubnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCSubnetChoiceType_NewSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCSubnetChoiceType_NewSubnet{` +
		`NewSubnet:` + fmt.Sprintf("%#v", this.NewSubnet) + `}`}, ", ")
	return s
}
func (this *GCPVPCSubnetChoiceType_ExistingSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCSubnetChoiceType_ExistingSubnet{` +
		`ExistingSubnet:` + fmt.Sprintf("%#v", this.ExistingSubnet) + `}`}, ", ")
	return s
}
func (this *GCPVPCOneInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.GCPVPCOneInterfaceNodeType{")
	s = append(s, "GcpZoneName: "+fmt.Sprintf("%#v", this.GcpZoneName)+",\n")
	if this.LocalSubnet != nil {
		s = append(s, "LocalSubnet: "+fmt.Sprintf("%#v", this.LocalSubnet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCTwoInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.GCPVPCTwoInterfaceNodeType{")
	s = append(s, "GcpZoneName: "+fmt.Sprintf("%#v", this.GcpZoneName)+",\n")
	if this.InsideSubnet != nil {
		s = append(s, "InsideSubnet: "+fmt.Sprintf("%#v", this.InsideSubnet)+",\n")
	}
	if this.OutsideSubnet != nil {
		s = append(s, "OutsideSubnet: "+fmt.Sprintf("%#v", this.OutsideSubnet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteStaticRoutesType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.SiteStaticRoutesType{")
	if this.ConfigModeChoice != nil {
		s = append(s, "ConfigModeChoice: "+fmt.Sprintf("%#v", this.ConfigModeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteStaticRoutesType_SimpleStaticRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.SiteStaticRoutesType_SimpleStaticRoute{` +
		`SimpleStaticRoute:` + fmt.Sprintf("%#v", this.SimpleStaticRoute) + `}`}, ", ")
	return s
}
func (this *SiteStaticRoutesType_CustomStaticRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.SiteStaticRoutesType_CustomStaticRoute{` +
		`CustomStaticRoute:` + fmt.Sprintf("%#v", this.CustomStaticRoute) + `}`}, ", ")
	return s
}
func (this *SiteStaticRoutesListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.SiteStaticRoutesListType{")
	if this.StaticRouteList != nil {
		s = append(s, "StaticRouteList: "+fmt.Sprintf("%#v", this.StaticRouteList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalNetworkConnectionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.GlobalNetworkConnectionType{")
	if this.ConnectionChoice != nil {
		s = append(s, "ConnectionChoice: "+fmt.Sprintf("%#v", this.ConnectionChoice)+",\n")
	}
	if this.ForwardProxyChoice != nil {
		s = append(s, "ForwardProxyChoice: "+fmt.Sprintf("%#v", this.ForwardProxyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalNetworkConnectionType_SliToGlobalDr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_SliToGlobalDr{` +
		`SliToGlobalDr:` + fmt.Sprintf("%#v", this.SliToGlobalDr) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionType_SloToGlobalDr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_SloToGlobalDr{` +
		`SloToGlobalDr:` + fmt.Sprintf("%#v", this.SloToGlobalDr) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionType_DisableForwardProxy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_DisableForwardProxy{` +
		`DisableForwardProxy:` + fmt.Sprintf("%#v", this.DisableForwardProxy) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionType_EnableForwardProxy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_EnableForwardProxy{` +
		`EnableForwardProxy:` + fmt.Sprintf("%#v", this.EnableForwardProxy) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GlobalNetworkConnectionListType{")
	if this.GlobalNetworkConnections != nil {
		s = append(s, "GlobalNetworkConnections: "+fmt.Sprintf("%#v", this.GlobalNetworkConnections)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSiteTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSVPCParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NameTag) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.NameTag)))
		i += copy(dAtA[i:], m.NameTag)
	}
	if len(m.PrimaryIpv4) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i += copy(dAtA[i:], m.PrimaryIpv4)
	}
	if m.AllocateIpv6 {
		dAtA[i] = 0x30
		i++
		if m.AllocateIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AWSVPCchoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCchoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn1, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *AWSVPCchoiceType_NewVpc) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewVpc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NewVpc.Size()))
		n2, err := m.NewVpc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *AWSVPCchoiceType_VpcId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.VpcId)))
	i += copy(dAtA[i:], m.VpcId)
	return i, nil
}
func (m *CloudSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ipv4) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Ipv4)))
		i += copy(dAtA[i:], m.Ipv4)
	}
	if len(m.Ipv6) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Ipv6)))
		i += copy(dAtA[i:], m.Ipv6)
	}
	return i, nil
}

func (m *CloudSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudSubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn3, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *CloudSubnetType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SubnetParam != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.SubnetParam.Size()))
		n4, err := m.SubnetParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *CloudSubnetType_ExistingSubnetId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.ExistingSubnetId)))
	i += copy(dAtA[i:], m.ExistingSubnetId)
	return i, nil
}
func (m *AWSVPCOneInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCOneInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AwsAzName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AwsAzName)))
		i += copy(dAtA[i:], m.AwsAzName)
	}
	if m.LocalSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.LocalSubnet.Size()))
		n5, err := m.LocalSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.DiskSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DiskSize))
	}
	return i, nil
}

func (m *AWSVPCTwoInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCTwoInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AwsAzName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AwsAzName)))
		i += copy(dAtA[i:], m.AwsAzName)
	}
	if m.InsideSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.InsideSubnet.Size()))
		n6, err := m.InsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.OutsideSubnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.OutsideSubnet.Size()))
		n7, err := m.OutsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.DiskSize) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.DiskSize)))
		i += copy(dAtA[i:], m.DiskSize)
	}
	return i, nil
}

func (m *AzureVnetParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PrimaryIpv4) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i += copy(dAtA[i:], m.PrimaryIpv4)
	}
	return i, nil
}

func (m *AzureVnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceGroup) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.ResourceGroup)))
		i += copy(dAtA[i:], m.ResourceGroup)
	}
	if len(m.VnetName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.VnetName)))
		i += copy(dAtA[i:], m.VnetName)
	}
	return i, nil
}

func (m *AzureVnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn8, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *AzureVnetChoiceType_NewVnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewVnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NewVnet.Size()))
		n9, err := m.NewVnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *AzureVnetChoiceType_ExistingVnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExistingVnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.ExistingVnet.Size()))
		n10, err := m.ExistingVnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *AzureSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetName)))
		i += copy(dAtA[i:], m.SubnetName)
	}
	if len(m.SubnetResourceGrp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetResourceGrp)))
		i += copy(dAtA[i:], m.SubnetResourceGrp)
	}
	return i, nil
}

func (m *AzureSubnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn11, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *AzureSubnetChoiceType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SubnetParam != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.SubnetParam.Size()))
		n12, err := m.SubnetParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *AzureSubnetChoiceType_Subnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Subnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.Subnet.Size()))
		n13, err := m.Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *AzureVnetOneInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetOneInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AzureAz) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AzureAz)))
		i += copy(dAtA[i:], m.AzureAz)
	}
	if m.LocalSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.LocalSubnet.Size()))
		n14, err := m.LocalSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.DiskSize) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.DiskSize)))
		i += copy(dAtA[i:], m.DiskSize)
	}
	return i, nil
}

func (m *AzureVnetTwoInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetTwoInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AzureAz) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AzureAz)))
		i += copy(dAtA[i:], m.AzureAz)
	}
	if m.InsideSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.InsideSubnet.Size()))
		n15, err := m.InsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.OutsideSubnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.OutsideSubnet.Size()))
		n16, err := m.OutsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.DiskSize) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.DiskSize)))
		i += copy(dAtA[i:], m.DiskSize)
	}
	return i, nil
}

func (m *GCPVPCNetworkParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GCPVPCNetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GCPSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetName)))
		i += copy(dAtA[i:], m.SubnetName)
	}
	return i, nil
}

func (m *GCPSubnetParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetName)))
		i += copy(dAtA[i:], m.SubnetName)
	}
	if len(m.PrimaryIpv4) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i += copy(dAtA[i:], m.PrimaryIpv4)
	}
	return i, nil
}

func (m *GCPVPCNetworkChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkChoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn17, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn17
	}
	return i, nil
}

func (m *GCPVPCNetworkChoiceType_NewNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewNetwork != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NewNetwork.Size()))
		n18, err := m.NewNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *GCPVPCNetworkChoiceType_ExistingNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExistingNetwork != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.ExistingNetwork.Size()))
		n19, err := m.ExistingNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *GCPVPCSubnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCSubnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		nn20, err := m.Choice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	return i, nil
}

func (m *GCPVPCSubnetChoiceType_NewSubnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NewSubnet.Size()))
		n21, err := m.NewSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *GCPVPCSubnetChoiceType_ExistingSubnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExistingSubnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.ExistingSubnet.Size()))
		n22, err := m.ExistingSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *GCPVPCOneInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCOneInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GcpZoneName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.GcpZoneName)))
		i += copy(dAtA[i:], m.GcpZoneName)
	}
	if m.LocalSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.LocalSubnet.Size()))
		n23, err := m.LocalSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *GCPVPCTwoInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCTwoInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GcpZoneName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.GcpZoneName)))
		i += copy(dAtA[i:], m.GcpZoneName)
	}
	if m.InsideSubnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.InsideSubnet.Size()))
		n24, err := m.InsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.OutsideSubnet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.OutsideSubnet.Size()))
		n25, err := m.OutsideSubnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *SiteStaticRoutesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStaticRoutesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigModeChoice != nil {
		nn26, err := m.ConfigModeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	return i, nil
}

func (m *SiteStaticRoutesType_SimpleStaticRoute) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SimpleStaticRoute)))
	i += copy(dAtA[i:], m.SimpleStaticRoute)
	return i, nil
}
func (m *SiteStaticRoutesType_CustomStaticRoute) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CustomStaticRoute != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.CustomStaticRoute.Size()))
		n27, err := m.CustomStaticRoute.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *SiteStaticRoutesListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStaticRoutesListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StaticRouteList) > 0 {
		for _, msg := range m.StaticRouteList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSiteTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GlobalNetworkConnectionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalNetworkConnectionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConnectionChoice != nil {
		nn28, err := m.ConnectionChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn28
	}
	if m.ForwardProxyChoice != nil {
		nn29, err := m.ForwardProxyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn29
	}
	return i, nil
}

func (m *GlobalNetworkConnectionType_SliToGlobalDr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SliToGlobalDr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.SliToGlobalDr.Size()))
		n30, err := m.SliToGlobalDr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *GlobalNetworkConnectionType_SloToGlobalDr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SloToGlobalDr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.SloToGlobalDr.Size()))
		n31, err := m.SloToGlobalDr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *GlobalNetworkConnectionType_DisableForwardProxy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DisableForwardProxy != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DisableForwardProxy.Size()))
		n32, err := m.DisableForwardProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *GlobalNetworkConnectionType_EnableForwardProxy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableForwardProxy != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.EnableForwardProxy.Size()))
		n33, err := m.EnableForwardProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *GlobalNetworkConnectionListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalNetworkConnectionListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GlobalNetworkConnections) > 0 {
		for _, msg := range m.GlobalNetworkConnections {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSiteTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintSiteTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedAWSVPCParamsType(r randySiteTypes, easy bool) *AWSVPCParamsType {
	this := &AWSVPCParamsType{}
	this.NameTag = string(randStringSiteTypes(r))
	this.PrimaryIpv4 = string(randStringSiteTypes(r))
	this.AllocateIpv6 = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAWSVPCchoiceType(r randySiteTypes, easy bool) *AWSVPCchoiceType {
	this := &AWSVPCchoiceType{}
	oneofNumber_Choice := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_Choice {
	case 1:
		this.Choice = NewPopulatedAWSVPCchoiceType_NewVpc(r, easy)
	case 2:
		this.Choice = NewPopulatedAWSVPCchoiceType_VpcId(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAWSVPCchoiceType_NewVpc(r randySiteTypes, easy bool) *AWSVPCchoiceType_NewVpc {
	this := &AWSVPCchoiceType_NewVpc{}
	this.NewVpc = NewPopulatedAWSVPCParamsType(r, easy)
	return this
}
func NewPopulatedAWSVPCchoiceType_VpcId(r randySiteTypes, easy bool) *AWSVPCchoiceType_VpcId {
	this := &AWSVPCchoiceType_VpcId{}
	this.VpcId = string(randStringSiteTypes(r))
	return this
}
func NewPopulatedCloudSubnetParamType(r randySiteTypes, easy bool) *CloudSubnetParamType {
	this := &CloudSubnetParamType{}
	this.Ipv4 = string(randStringSiteTypes(r))
	this.Ipv6 = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCloudSubnetType(r randySiteTypes, easy bool) *CloudSubnetType {
	this := &CloudSubnetType{}
	oneofNumber_Choice := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_Choice {
	case 1:
		this.Choice = NewPopulatedCloudSubnetType_SubnetParam(r, easy)
	case 2:
		this.Choice = NewPopulatedCloudSubnetType_ExistingSubnetId(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCloudSubnetType_SubnetParam(r randySiteTypes, easy bool) *CloudSubnetType_SubnetParam {
	this := &CloudSubnetType_SubnetParam{}
	this.SubnetParam = NewPopulatedCloudSubnetParamType(r, easy)
	return this
}
func NewPopulatedCloudSubnetType_ExistingSubnetId(r randySiteTypes, easy bool) *CloudSubnetType_ExistingSubnetId {
	this := &CloudSubnetType_ExistingSubnetId{}
	this.ExistingSubnetId = string(randStringSiteTypes(r))
	return this
}
func NewPopulatedAWSVPCOneInterfaceNodeType(r randySiteTypes, easy bool) *AWSVPCOneInterfaceNodeType {
	this := &AWSVPCOneInterfaceNodeType{}
	this.AwsAzName = string(randStringSiteTypes(r))
	if r.Intn(10) != 0 {
		this.LocalSubnet = NewPopulatedCloudSubnetType(r, easy)
	}
	this.DiskSize = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAWSVPCTwoInterfaceNodeType(r randySiteTypes, easy bool) *AWSVPCTwoInterfaceNodeType {
	this := &AWSVPCTwoInterfaceNodeType{}
	this.AwsAzName = string(randStringSiteTypes(r))
	if r.Intn(10) != 0 {
		this.InsideSubnet = NewPopulatedCloudSubnetType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.OutsideSubnet = NewPopulatedCloudSubnetType(r, easy)
	}
	this.DiskSize = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAzureVnetParamsType(r randySiteTypes, easy bool) *AzureVnetParamsType {
	this := &AzureVnetParamsType{}
	this.Name = string(randStringSiteTypes(r))
	this.PrimaryIpv4 = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAzureVnetType(r randySiteTypes, easy bool) *AzureVnetType {
	this := &AzureVnetType{}
	this.ResourceGroup = string(randStringSiteTypes(r))
	this.VnetName = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAzureVnetChoiceType(r randySiteTypes, easy bool) *AzureVnetChoiceType {
	this := &AzureVnetChoiceType{}
	oneofNumber_Choice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_Choice {
	case 2:
		this.Choice = NewPopulatedAzureVnetChoiceType_NewVnet(r, easy)
	case 3:
		this.Choice = NewPopulatedAzureVnetChoiceType_ExistingVnet(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAzureVnetChoiceType_NewVnet(r randySiteTypes, easy bool) *AzureVnetChoiceType_NewVnet {
	this := &AzureVnetChoiceType_NewVnet{}
	this.NewVnet = NewPopulatedAzureVnetParamsType(r, easy)
	return this
}
func NewPopulatedAzureVnetChoiceType_ExistingVnet(r randySiteTypes, easy bool) *AzureVnetChoiceType_ExistingVnet {
	this := &AzureVnetChoiceType_ExistingVnet{}
	this.ExistingVnet = NewPopulatedAzureVnetType(r, easy)
	return this
}
func NewPopulatedAzureSubnetType(r randySiteTypes, easy bool) *AzureSubnetType {
	this := &AzureSubnetType{}
	this.SubnetName = string(randStringSiteTypes(r))
	this.SubnetResourceGrp = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAzureSubnetChoiceType(r randySiteTypes, easy bool) *AzureSubnetChoiceType {
	this := &AzureSubnetChoiceType{}
	oneofNumber_Choice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_Choice {
	case 2:
		this.Choice = NewPopulatedAzureSubnetChoiceType_SubnetParam(r, easy)
	case 3:
		this.Choice = NewPopulatedAzureSubnetChoiceType_Subnet(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAzureSubnetChoiceType_SubnetParam(r randySiteTypes, easy bool) *AzureSubnetChoiceType_SubnetParam {
	this := &AzureSubnetChoiceType_SubnetParam{}
	this.SubnetParam = NewPopulatedCloudSubnetParamType(r, easy)
	return this
}
func NewPopulatedAzureSubnetChoiceType_Subnet(r randySiteTypes, easy bool) *AzureSubnetChoiceType_Subnet {
	this := &AzureSubnetChoiceType_Subnet{}
	this.Subnet = NewPopulatedAzureSubnetType(r, easy)
	return this
}
func NewPopulatedAzureVnetOneInterfaceNodeType(r randySiteTypes, easy bool) *AzureVnetOneInterfaceNodeType {
	this := &AzureVnetOneInterfaceNodeType{}
	this.AzureAz = string(randStringSiteTypes(r))
	if r.Intn(10) != 0 {
		this.LocalSubnet = NewPopulatedAzureSubnetChoiceType(r, easy)
	}
	this.DiskSize = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAzureVnetTwoInterfaceNodeType(r randySiteTypes, easy bool) *AzureVnetTwoInterfaceNodeType {
	this := &AzureVnetTwoInterfaceNodeType{}
	this.AzureAz = string(randStringSiteTypes(r))
	if r.Intn(10) != 0 {
		this.InsideSubnet = NewPopulatedAzureSubnetChoiceType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.OutsideSubnet = NewPopulatedAzureSubnetChoiceType(r, easy)
	}
	this.DiskSize = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPVPCNetworkParamsType(r randySiteTypes, easy bool) *GCPVPCNetworkParamsType {
	this := &GCPVPCNetworkParamsType{}
	this.Name = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPVPCNetworkType(r randySiteTypes, easy bool) *GCPVPCNetworkType {
	this := &GCPVPCNetworkType{}
	this.Name = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPSubnetType(r randySiteTypes, easy bool) *GCPSubnetType {
	this := &GCPSubnetType{}
	this.SubnetName = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPSubnetParamsType(r randySiteTypes, easy bool) *GCPSubnetParamsType {
	this := &GCPSubnetParamsType{}
	this.SubnetName = string(randStringSiteTypes(r))
	this.PrimaryIpv4 = string(randStringSiteTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPVPCNetworkChoiceType(r randySiteTypes, easy bool) *GCPVPCNetworkChoiceType {
	this := &GCPVPCNetworkChoiceType{}
	oneofNumber_Choice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_Choice {
	case 2:
		this.Choice = NewPopulatedGCPVPCNetworkChoiceType_NewNetwork(r, easy)
	case 3:
		this.Choice = NewPopulatedGCPVPCNetworkChoiceType_ExistingNetwork(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPVPCNetworkChoiceType_NewNetwork(r randySiteTypes, easy bool) *GCPVPCNetworkChoiceType_NewNetwork {
	this := &GCPVPCNetworkChoiceType_NewNetwork{}
	this.NewNetwork = NewPopulatedGCPVPCNetworkParamsType(r, easy)
	return this
}
func NewPopulatedGCPVPCNetworkChoiceType_ExistingNetwork(r randySiteTypes, easy bool) *GCPVPCNetworkChoiceType_ExistingNetwork {
	this := &GCPVPCNetworkChoiceType_ExistingNetwork{}
	this.ExistingNetwork = NewPopulatedGCPVPCNetworkType(r, easy)
	return this
}
func NewPopulatedGCPVPCSubnetChoiceType(r randySiteTypes, easy bool) *GCPVPCSubnetChoiceType {
	this := &GCPVPCSubnetChoiceType{}
	oneofNumber_Choice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_Choice {
	case 2:
		this.Choice = NewPopulatedGCPVPCSubnetChoiceType_NewSubnet(r, easy)
	case 3:
		this.Choice = NewPopulatedGCPVPCSubnetChoiceType_ExistingSubnet(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPVPCSubnetChoiceType_NewSubnet(r randySiteTypes, easy bool) *GCPVPCSubnetChoiceType_NewSubnet {
	this := &GCPVPCSubnetChoiceType_NewSubnet{}
	this.NewSubnet = NewPopulatedGCPSubnetParamsType(r, easy)
	return this
}
func NewPopulatedGCPVPCSubnetChoiceType_ExistingSubnet(r randySiteTypes, easy bool) *GCPVPCSubnetChoiceType_ExistingSubnet {
	this := &GCPVPCSubnetChoiceType_ExistingSubnet{}
	this.ExistingSubnet = NewPopulatedGCPSubnetType(r, easy)
	return this
}
func NewPopulatedGCPVPCOneInterfaceNodeType(r randySiteTypes, easy bool) *GCPVPCOneInterfaceNodeType {
	this := &GCPVPCOneInterfaceNodeType{}
	this.GcpZoneName = string(randStringSiteTypes(r))
	if r.Intn(10) != 0 {
		this.LocalSubnet = NewPopulatedGCPVPCSubnetChoiceType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGCPVPCTwoInterfaceNodeType(r randySiteTypes, easy bool) *GCPVPCTwoInterfaceNodeType {
	this := &GCPVPCTwoInterfaceNodeType{}
	this.GcpZoneName = string(randStringSiteTypes(r))
	if r.Intn(10) != 0 {
		this.InsideSubnet = NewPopulatedGCPVPCSubnetChoiceType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.OutsideSubnet = NewPopulatedGCPVPCSubnetChoiceType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSiteStaticRoutesType(r randySiteTypes, easy bool) *SiteStaticRoutesType {
	this := &SiteStaticRoutesType{}
	oneofNumber_ConfigModeChoice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_ConfigModeChoice {
	case 2:
		this.ConfigModeChoice = NewPopulatedSiteStaticRoutesType_SimpleStaticRoute(r, easy)
	case 3:
		this.ConfigModeChoice = NewPopulatedSiteStaticRoutesType_CustomStaticRoute(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSiteStaticRoutesType_SimpleStaticRoute(r randySiteTypes, easy bool) *SiteStaticRoutesType_SimpleStaticRoute {
	this := &SiteStaticRoutesType_SimpleStaticRoute{}
	this.SimpleStaticRoute = string(randStringSiteTypes(r))
	return this
}
func NewPopulatedSiteStaticRoutesType_CustomStaticRoute(r randySiteTypes, easy bool) *SiteStaticRoutesType_CustomStaticRoute {
	this := &SiteStaticRoutesType_CustomStaticRoute{}
	this.CustomStaticRoute = ves_io_schema4.NewPopulatedStaticRouteType(r, easy)
	return this
}
func NewPopulatedSiteStaticRoutesListType(r randySiteTypes, easy bool) *SiteStaticRoutesListType {
	this := &SiteStaticRoutesListType{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.StaticRouteList = make([]*SiteStaticRoutesType, v1)
		for i := 0; i < v1; i++ {
			this.StaticRouteList[i] = NewPopulatedSiteStaticRoutesType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalNetworkConnectionType(r randySiteTypes, easy bool) *GlobalNetworkConnectionType {
	this := &GlobalNetworkConnectionType{}
	oneofNumber_ConnectionChoice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_ConnectionChoice {
	case 2:
		this.ConnectionChoice = NewPopulatedGlobalNetworkConnectionType_SliToGlobalDr(r, easy)
	case 3:
		this.ConnectionChoice = NewPopulatedGlobalNetworkConnectionType_SloToGlobalDr(r, easy)
	}
	oneofNumber_ForwardProxyChoice := []int32{5, 6}[r.Intn(2)]
	switch oneofNumber_ForwardProxyChoice {
	case 5:
		this.ForwardProxyChoice = NewPopulatedGlobalNetworkConnectionType_DisableForwardProxy(r, easy)
	case 6:
		this.ForwardProxyChoice = NewPopulatedGlobalNetworkConnectionType_EnableForwardProxy(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalNetworkConnectionType_SliToGlobalDr(r randySiteTypes, easy bool) *GlobalNetworkConnectionType_SliToGlobalDr {
	this := &GlobalNetworkConnectionType_SliToGlobalDr{}
	this.SliToGlobalDr = NewPopulatedGlobalConnectorType(r, easy)
	return this
}
func NewPopulatedGlobalNetworkConnectionType_SloToGlobalDr(r randySiteTypes, easy bool) *GlobalNetworkConnectionType_SloToGlobalDr {
	this := &GlobalNetworkConnectionType_SloToGlobalDr{}
	this.SloToGlobalDr = NewPopulatedGlobalConnectorType(r, easy)
	return this
}
func NewPopulatedGlobalNetworkConnectionType_DisableForwardProxy(r randySiteTypes, easy bool) *GlobalNetworkConnectionType_DisableForwardProxy {
	this := &GlobalNetworkConnectionType_DisableForwardProxy{}
	this.DisableForwardProxy = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedGlobalNetworkConnectionType_EnableForwardProxy(r randySiteTypes, easy bool) *GlobalNetworkConnectionType_EnableForwardProxy {
	this := &GlobalNetworkConnectionType_EnableForwardProxy{}
	this.EnableForwardProxy = ves_io_schema4.NewPopulatedForwardProxyConfigType(r, easy)
	return this
}
func NewPopulatedGlobalNetworkConnectionListType(r randySiteTypes, easy bool) *GlobalNetworkConnectionListType {
	this := &GlobalNetworkConnectionListType{}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.GlobalNetworkConnections = make([]*GlobalNetworkConnectionType, v2)
		for i := 0; i < v2; i++ {
			this.GlobalNetworkConnections[i] = NewPopulatedGlobalNetworkConnectionType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randySiteTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneSiteTypes(r randySiteTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringSiteTypes(r randySiteTypes) string {
	v3 := r.Intn(100)
	tmps := make([]rune, v3)
	for i := 0; i < v3; i++ {
		tmps[i] = randUTF8RuneSiteTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedSiteTypes(r randySiteTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldSiteTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldSiteTypes(dAtA []byte, r randySiteTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateSiteTypes(dAtA, uint64(key))
		v4 := r.Int63()
		if r.Intn(2) == 0 {
			v4 *= -1
		}
		dAtA = encodeVarintPopulateSiteTypes(dAtA, uint64(v4))
	case 1:
		dAtA = encodeVarintPopulateSiteTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateSiteTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateSiteTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateSiteTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateSiteTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *AWSVPCParamsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.NameTag)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.AllocateIpv6 {
		n += 2
	}
	return n
}

func (m *AWSVPCchoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AWSVPCchoiceType_NewVpc) Size() (n int) {
	var l int
	_ = l
	if m.NewVpc != nil {
		l = m.NewVpc.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCchoiceType_VpcId) Size() (n int) {
	var l int
	_ = l
	l = len(m.VpcId)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *CloudSubnetParamType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.Ipv6)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *CloudSubnetType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *CloudSubnetType_SubnetParam) Size() (n int) {
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *CloudSubnetType_ExistingSubnetId) Size() (n int) {
	var l int
	_ = l
	l = len(m.ExistingSubnetId)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AWSVPCOneInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AwsAzName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.LocalSubnet != nil {
		l = m.LocalSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovSiteTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *AWSVPCTwoInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AwsAzName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.InsideSubnet != nil {
		l = m.InsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.OutsideSubnet != nil {
		l = m.OutsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.DiskSize)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetParamsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.VnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetChoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AzureVnetChoiceType_NewVnet) Size() (n int) {
	var l int
	_ = l
	if m.NewVnet != nil {
		l = m.NewVnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetChoiceType_ExistingVnet) Size() (n int) {
	var l int
	_ = l
	if m.ExistingVnet != nil {
		l = m.ExistingVnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetType) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.SubnetResourceGrp)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AzureSubnetChoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AzureSubnetChoiceType_SubnetParam) Size() (n int) {
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceType_Subnet) Size() (n int) {
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetOneInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AzureAz)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.LocalSubnet != nil {
		l = m.LocalSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.DiskSize)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetTwoInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AzureAz)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.InsideSubnet != nil {
		l = m.InsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.OutsideSubnet != nil {
		l = m.OutsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.DiskSize)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCNetworkParamsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCNetworkType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPSubnetType) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPSubnetParamsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCNetworkChoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *GCPVPCNetworkChoiceType_NewNetwork) Size() (n int) {
	var l int
	_ = l
	if m.NewNetwork != nil {
		l = m.NewNetwork.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCNetworkChoiceType_ExistingNetwork) Size() (n int) {
	var l int
	_ = l
	if m.ExistingNetwork != nil {
		l = m.ExistingNetwork.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCSubnetChoiceType) Size() (n int) {
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *GCPVPCSubnetChoiceType_NewSubnet) Size() (n int) {
	var l int
	_ = l
	if m.NewSubnet != nil {
		l = m.NewSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCSubnetChoiceType_ExistingSubnet) Size() (n int) {
	var l int
	_ = l
	if m.ExistingSubnet != nil {
		l = m.ExistingSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCOneInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.GcpZoneName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.LocalSubnet != nil {
		l = m.LocalSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCTwoInterfaceNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.GcpZoneName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.InsideSubnet != nil {
		l = m.InsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.OutsideSubnet != nil {
		l = m.OutsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *SiteStaticRoutesType) Size() (n int) {
	var l int
	_ = l
	if m.ConfigModeChoice != nil {
		n += m.ConfigModeChoice.Size()
	}
	return n
}

func (m *SiteStaticRoutesType_SimpleStaticRoute) Size() (n int) {
	var l int
	_ = l
	l = len(m.SimpleStaticRoute)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *SiteStaticRoutesType_CustomStaticRoute) Size() (n int) {
	var l int
	_ = l
	if m.CustomStaticRoute != nil {
		l = m.CustomStaticRoute.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *SiteStaticRoutesListType) Size() (n int) {
	var l int
	_ = l
	if len(m.StaticRouteList) > 0 {
		for _, e := range m.StaticRouteList {
			l = e.Size()
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalNetworkConnectionType) Size() (n int) {
	var l int
	_ = l
	if m.ConnectionChoice != nil {
		n += m.ConnectionChoice.Size()
	}
	if m.ForwardProxyChoice != nil {
		n += m.ForwardProxyChoice.Size()
	}
	return n
}

func (m *GlobalNetworkConnectionType_SliToGlobalDr) Size() (n int) {
	var l int
	_ = l
	if m.SliToGlobalDr != nil {
		l = m.SliToGlobalDr.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionType_SloToGlobalDr) Size() (n int) {
	var l int
	_ = l
	if m.SloToGlobalDr != nil {
		l = m.SloToGlobalDr.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionType_DisableForwardProxy) Size() (n int) {
	var l int
	_ = l
	if m.DisableForwardProxy != nil {
		l = m.DisableForwardProxy.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionType_EnableForwardProxy) Size() (n int) {
	var l int
	_ = l
	if m.EnableForwardProxy != nil {
		l = m.EnableForwardProxy.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionListType) Size() (n int) {
	var l int
	_ = l
	if len(m.GlobalNetworkConnections) > 0 {
		for _, e := range m.GlobalNetworkConnections {
			l = e.Size()
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	return n
}

func sovSiteTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSiteTypes(x uint64) (n int) {
	return sovSiteTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSVPCParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCParamsType{`,
		`NameTag:` + fmt.Sprintf("%v", this.NameTag) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`AllocateIpv6:` + fmt.Sprintf("%v", this.AllocateIpv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCchoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCchoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCchoiceType_NewVpc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCchoiceType_NewVpc{`,
		`NewVpc:` + strings.Replace(fmt.Sprintf("%v", this.NewVpc), "AWSVPCParamsType", "AWSVPCParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCchoiceType_VpcId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCchoiceType_VpcId{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetParamType{`,
		`Ipv4:` + fmt.Sprintf("%v", this.Ipv4) + `,`,
		`Ipv6:` + fmt.Sprintf("%v", this.Ipv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "CloudSubnetParamType", "CloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType_ExistingSubnetId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType_ExistingSubnetId{`,
		`ExistingSubnetId:` + fmt.Sprintf("%v", this.ExistingSubnetId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCOneInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCOneInterfaceNodeType{`,
		`AwsAzName:` + fmt.Sprintf("%v", this.AwsAzName) + `,`,
		`LocalSubnet:` + strings.Replace(fmt.Sprintf("%v", this.LocalSubnet), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCTwoInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCTwoInterfaceNodeType{`,
		`AwsAzName:` + fmt.Sprintf("%v", this.AwsAzName) + `,`,
		`InsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.InsideSubnet), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`OutsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.OutsideSubnet), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetParamsType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetType{`,
		`ResourceGroup:` + fmt.Sprintf("%v", this.ResourceGroup) + `,`,
		`VnetName:` + fmt.Sprintf("%v", this.VnetName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetChoiceType_NewVnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetChoiceType_NewVnet{`,
		`NewVnet:` + strings.Replace(fmt.Sprintf("%v", this.NewVnet), "AzureVnetParamsType", "AzureVnetParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetChoiceType_ExistingVnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetChoiceType_ExistingVnet{`,
		`ExistingVnet:` + strings.Replace(fmt.Sprintf("%v", this.ExistingVnet), "AzureVnetType", "AzureVnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`SubnetResourceGrp:` + fmt.Sprintf("%v", this.SubnetResourceGrp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "CloudSubnetParamType", "CloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType_Subnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType_Subnet{`,
		`Subnet:` + strings.Replace(fmt.Sprintf("%v", this.Subnet), "AzureSubnetType", "AzureSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetOneInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetOneInterfaceNodeType{`,
		`AzureAz:` + fmt.Sprintf("%v", this.AzureAz) + `,`,
		`LocalSubnet:` + strings.Replace(fmt.Sprintf("%v", this.LocalSubnet), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetTwoInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetTwoInterfaceNodeType{`,
		`AzureAz:` + fmt.Sprintf("%v", this.AzureAz) + `,`,
		`InsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.InsideSubnet), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`OutsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.OutsideSubnet), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkParamsType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetParamsType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType_NewNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType_NewNetwork{`,
		`NewNetwork:` + strings.Replace(fmt.Sprintf("%v", this.NewNetwork), "GCPVPCNetworkParamsType", "GCPVPCNetworkParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType_ExistingNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType_ExistingNetwork{`,
		`ExistingNetwork:` + strings.Replace(fmt.Sprintf("%v", this.ExistingNetwork), "GCPVPCNetworkType", "GCPVPCNetworkType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCSubnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCSubnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCSubnetChoiceType_NewSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCSubnetChoiceType_NewSubnet{`,
		`NewSubnet:` + strings.Replace(fmt.Sprintf("%v", this.NewSubnet), "GCPSubnetParamsType", "GCPSubnetParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCSubnetChoiceType_ExistingSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCSubnetChoiceType_ExistingSubnet{`,
		`ExistingSubnet:` + strings.Replace(fmt.Sprintf("%v", this.ExistingSubnet), "GCPSubnetType", "GCPSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCOneInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCOneInterfaceNodeType{`,
		`GcpZoneName:` + fmt.Sprintf("%v", this.GcpZoneName) + `,`,
		`LocalSubnet:` + strings.Replace(fmt.Sprintf("%v", this.LocalSubnet), "GCPVPCSubnetChoiceType", "GCPVPCSubnetChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCTwoInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCTwoInterfaceNodeType{`,
		`GcpZoneName:` + fmt.Sprintf("%v", this.GcpZoneName) + `,`,
		`InsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.InsideSubnet), "GCPVPCSubnetChoiceType", "GCPVPCSubnetChoiceType", 1) + `,`,
		`OutsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.OutsideSubnet), "GCPVPCSubnetChoiceType", "GCPVPCSubnetChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesType{`,
		`ConfigModeChoice:` + fmt.Sprintf("%v", this.ConfigModeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesType_SimpleStaticRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesType_SimpleStaticRoute{`,
		`SimpleStaticRoute:` + fmt.Sprintf("%v", this.SimpleStaticRoute) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesType_CustomStaticRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesType_CustomStaticRoute{`,
		`CustomStaticRoute:` + strings.Replace(fmt.Sprintf("%v", this.CustomStaticRoute), "StaticRouteType", "ves_io_schema4.StaticRouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesListType{`,
		`StaticRouteList:` + strings.Replace(fmt.Sprintf("%v", this.StaticRouteList), "SiteStaticRoutesType", "SiteStaticRoutesType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType{`,
		`ConnectionChoice:` + fmt.Sprintf("%v", this.ConnectionChoice) + `,`,
		`ForwardProxyChoice:` + fmt.Sprintf("%v", this.ForwardProxyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_SliToGlobalDr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_SliToGlobalDr{`,
		`SliToGlobalDr:` + strings.Replace(fmt.Sprintf("%v", this.SliToGlobalDr), "GlobalConnectorType", "GlobalConnectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_SloToGlobalDr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_SloToGlobalDr{`,
		`SloToGlobalDr:` + strings.Replace(fmt.Sprintf("%v", this.SloToGlobalDr), "GlobalConnectorType", "GlobalConnectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_DisableForwardProxy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_DisableForwardProxy{`,
		`DisableForwardProxy:` + strings.Replace(fmt.Sprintf("%v", this.DisableForwardProxy), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_EnableForwardProxy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_EnableForwardProxy{`,
		`EnableForwardProxy:` + strings.Replace(fmt.Sprintf("%v", this.EnableForwardProxy), "ForwardProxyConfigType", "ves_io_schema4.ForwardProxyConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionListType{`,
		`GlobalNetworkConnections:` + strings.Replace(fmt.Sprintf("%v", this.GlobalNetworkConnections), "GlobalNetworkConnectionType", "GlobalNetworkConnectionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSiteTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSVPCParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocateIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllocateIpv6 = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCchoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCchoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCchoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSVPCParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AWSVPCchoiceType_NewVpc{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &AWSVPCchoiceType_VpcId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CloudSubnetType_SubnetParam{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &CloudSubnetType_ExistingSubnetId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCOneInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCOneInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCOneInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalSubnet == nil {
				m.LocalSubnet = &CloudSubnetType{}
			}
			if err := m.LocalSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCTwoInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCTwoInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCTwoInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideSubnet == nil {
				m.InsideSubnet = &CloudSubnetType{}
			}
			if err := m.InsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutsideSubnet == nil {
				m.OutsideSubnet = &CloudSubnetType{}
			}
			if err := m.OutsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVnetParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureVnetChoiceType_NewVnet{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingVnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureVnetChoiceType_ExistingVnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetResourceGrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetResourceGrp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceType_SubnetParam{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceType_Subnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetOneInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetOneInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetOneInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureAz", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureAz = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalSubnet == nil {
				m.LocalSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.LocalSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetTwoInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetTwoInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetTwoInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureAz", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureAz = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideSubnet == nil {
				m.InsideSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.InsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutsideSubnet == nil {
				m.OutsideSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.OutsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPVPCNetworkParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCNetworkChoiceType_NewNetwork{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPVPCNetworkType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCNetworkChoiceType_ExistingNetwork{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCSubnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCSubnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCSubnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPSubnetParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCSubnetChoiceType_NewSubnet{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCSubnetChoiceType_ExistingSubnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCOneInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCOneInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCOneInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpZoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpZoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalSubnet == nil {
				m.LocalSubnet = &GCPVPCSubnetChoiceType{}
			}
			if err := m.LocalSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCTwoInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCTwoInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCTwoInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpZoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpZoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideSubnet == nil {
				m.InsideSubnet = &GCPVPCSubnetChoiceType{}
			}
			if err := m.InsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutsideSubnet == nil {
				m.OutsideSubnet = &GCPVPCSubnetChoiceType{}
			}
			if err := m.OutsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStaticRoutesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStaticRoutesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStaticRoutesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleStaticRoute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigModeChoice = &SiteStaticRoutesType_SimpleStaticRoute{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomStaticRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.StaticRouteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigModeChoice = &SiteStaticRoutesType_CustomStaticRoute{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStaticRoutesListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStaticRoutesListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStaticRoutesListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRouteList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRouteList = append(m.StaticRouteList, &SiteStaticRoutesType{})
			if err := m.StaticRouteList[len(m.StaticRouteList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalNetworkConnectionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalNetworkConnectionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalNetworkConnectionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliToGlobalDr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GlobalConnectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalNetworkConnectionType_SliToGlobalDr{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SloToGlobalDr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GlobalConnectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalNetworkConnectionType_SloToGlobalDr{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableForwardProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ForwardProxyChoice = &GlobalNetworkConnectionType_DisableForwardProxy{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableForwardProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.ForwardProxyConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ForwardProxyChoice = &GlobalNetworkConnectionType_EnableForwardProxy{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalNetworkConnectionListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalNetworkConnectionListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalNetworkConnectionListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalNetworkConnections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalNetworkConnections = append(m.GlobalNetworkConnections, &GlobalNetworkConnectionType{})
			if err := m.GlobalNetworkConnections[len(m.GlobalNetworkConnections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSiteTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSiteTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSiteTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSiteTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSiteTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSiteTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/views/site_types.proto", fileDescriptorSiteTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/site_types.proto", fileDescriptorSiteTypes)
}

var fileDescriptorSiteTypes = []byte{
	// 2243 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x4d, 0x6c, 0x1b, 0xc7,
	0xf5, 0xe7, 0x90, 0x14, 0x4d, 0x0e, 0x45, 0x8b, 0x5a, 0x29, 0x09, 0xad, 0xe4, 0xcf, 0xe8, 0xcf,
	0xd8, 0x0e, 0x9d, 0xf0, 0xc3, 0x5c, 0xaa, 0xaa, 0xeb, 0xb6, 0x86, 0x4d, 0xc5, 0xb5, 0xe4, 0x36,
	0xb6, 0xb2, 0x32, 0x5c, 0xc0, 0x45, 0xb3, 0xd8, 0x5d, 0x8e, 0xe8, 0x85, 0xc9, 0x9d, 0xc5, 0xee,
	0x92, 0xb4, 0xd5, 0x1a, 0x30, 0x7a, 0xe9, 0x17, 0x50, 0x04, 0x3d, 0x15, 0x28, 0xd0, 0x73, 0x0e,
	0x05, 0xda, 0xa2, 0x97, 0xa2, 0x42, 0x01, 0xa3, 0x27, 0xf7, 0x52, 0x08, 0xe8, 0xc5, 0xb9, 0xc5,
	0xcc, 0xc5, 0x3d, 0x35, 0x10, 0x7a, 0xf0, 0xb1, 0x98, 0xd9, 0x59, 0xee, 0xec, 0x72, 0x29, 0x59,
	0x41, 0x4e, 0x81, 0x6e, 0x6f, 0xde, 0xfc, 0xde, 0x6f, 0xde, 0xbc, 0x79, 0xfb, 0xe6, 0x8d, 0x44,
	0x78, 0x7a, 0x80, 0xec, 0x9a, 0x8e, 0xeb, 0xb6, 0x76, 0x17, 0xf5, 0x94, 0xfa, 0x40, 0x47, 0x43,
	0xbb, 0x6e, 0xeb, 0x0e, 0x92, 0x9d, 0x07, 0x26, 0xb2, 0x6b, 0xa6, 0x85, 0x1d, 0x2c, 0x2c, 0xb8,
	0xa8, 0x9a, 0x8b, 0xaa, 0x51, 0xd4, 0x52, 0xb5, 0xa3, 0x3b, 0x77, 0xfb, 0x6a, 0x4d, 0xc3, 0xbd,
	0x7a, 0x07, 0x77, 0x70, 0x9d, 0x62, 0xd5, 0xfe, 0x36, 0x1d, 0xd1, 0x01, 0x95, 0x5c, 0x8e, 0xa5,
	0xd7, 0x82, 0x2b, 0x19, 0xc8, 0x61, 0x13, 0xaf, 0x07, 0x27, 0xb0, 0xe9, 0xe8, 0xd8, 0x60, 0x2b,
	0x2f, 0x9d, 0x0a, 0x4e, 0x72, 0x4e, 0x2d, 0xbd, 0x11, 0x72, 0x5d, 0xe9, 0xea, 0x6d, 0xc5, 0x41,
	0x6c, 0x76, 0x79, 0x72, 0x63, 0x72, 0x90, 0xfa, 0xcd, 0xa8, 0xad, 0x73, 0x0b, 0x94, 0xfe, 0x09,
	0x60, 0xfe, 0xca, 0xf7, 0xb7, 0x6e, 0x6f, 0xae, 0x6d, 0x2a, 0x96, 0xd2, 0xb3, 0x6f, 0x3d, 0x30,
	0x91, 0x50, 0x86, 0x69, 0x43, 0xe9, 0x21, 0xd9, 0x51, 0x3a, 0x85, 0xf8, 0x32, 0x28, 0x67, 0x5a,
	0xb9, 0x17, 0xbb, 0x20, 0xf6, 0xd7, 0x7f, 0x3f, 0x4e, 0x24, 0xad, 0x78, 0xe1, 0xb2, 0x74, 0x82,
	0x4c, 0xdf, 0x52, 0x3a, 0xc2, 0x55, 0x38, 0x6b, 0x5a, 0x7a, 0x4f, 0xb1, 0x1e, 0xc8, 0xba, 0x39,
	0x58, 0x29, 0x24, 0x28, 0xba, 0xe4, 0xa1, 0x67, 0xac, 0xc4, 0x0b, 0x00, 0x98, 0xf4, 0x9b, 0xf8,
	0x1b, 0x4c, 0xfa, 0x28, 0x9e, 0x97, 0xb2, 0xcc, 0x6e, 0xc3, 0x1c, 0xac, 0x08, 0x55, 0x98, 0x53,
	0xba, 0x5d, 0xac, 0x29, 0x0e, 0x22, 0x3c, 0xab, 0x85, 0xd4, 0x32, 0x28, 0xa7, 0x5b, 0xe9, 0xe7,
	0xbb, 0x00, 0x10, 0x2e, 0x69, 0xd6, 0x9b, 0xde, 0x30, 0x07, 0xab, 0x17, 0xd3, 0xfb, 0x97, 0x66,
	0xc4, 0x4a, 0xb3, 0xb2, 0x7a, 0x3d, 0x99, 0x06, 0xf9, 0xf8, 0xf5, 0x64, 0x3a, 0x99, 0x9f, 0xb9,
	0x9e, 0x4c, 0xcf, 0xe4, 0x53, 0xa5, 0x27, 0xe3, 0x0d, 0x69, 0x77, 0xb1, 0xae, 0x21, 0xba, 0xa1,
	0xcb, 0xf0, 0x84, 0x81, 0x86, 0xf2, 0xc0, 0xd4, 0x0a, 0x60, 0x19, 0x94, 0xb3, 0xe2, 0x99, 0x5a,
	0xc4, 0x69, 0xd7, 0xc2, 0x81, 0x58, 0x8f, 0x49, 0x29, 0x03, 0x0d, 0x6f, 0x9b, 0x9a, 0xf0, 0x01,
	0x4c, 0x0d, 0x4c, 0x4d, 0xd6, 0xdb, 0x2c, 0x20, 0x17, 0x02, 0x01, 0x21, 0xc2, 0x59, 0xeb, 0xb4,
	0x58, 0xfa, 0xb0, 0x3c, 0x30, 0xb5, 0xea, 0xb9, 0xf2, 0x0f, 0x94, 0xea, 0xce, 0xf9, 0xea, 0x37,
	0x7e, 0xf8, 0xa3, 0x0b, 0x0f, 0x7f, 0x3c, 0x96, 0x1b, 0x5f, 0x7f, 0x78, 0xee, 0xf4, 0x7a, 0x4c,
	0x9a, 0x19, 0x98, 0xda, 0x46, 0xbb, 0x75, 0x0a, 0xa6, 0x5c, 0x17, 0x85, 0xb9, 0xc7, 0xbb, 0x00,
	0xec, 0xed, 0x82, 0xc4, 0x68, 0x17, 0x24, 0x1a, 0x15, 0xf1, 0x7a, 0x32, 0x9d, 0xc8, 0x27, 0x4b,
	0x0e, 0x5c, 0x5c, 0xeb, 0xe2, 0x7e, 0x7b, 0xab, 0xaf, 0x1a, 0xc8, 0xa1, 0x6e, 0xd1, 0xdd, 0x54,
	0x60, 0x92, 0x06, 0x1b, 0x50, 0x4f, 0x0a, 0xd3, 0x82, 0x2d, 0x51, 0x94, 0x70, 0x96, 0xa2, 0x57,
	0x99, 0xdf, 0x82, 0x17, 0x52, 0x86, 0x7b, 0x14, 0x07, 0x14, 0xb7, 0x7a, 0x31, 0xb5, 0x7f, 0x89,
	0xac, 0x5d, 0xfa, 0x0f, 0x80, 0x73, 0xdc, 0xb2, 0x74, 0xc5, 0x1b, 0x70, 0xd6, 0xa6, 0x23, 0xd9,
	0x24, 0x5e, 0xb0, 0x20, 0x9e, 0x8b, 0x0c, 0x62, 0x94, 0xcb, 0xeb, 0x31, 0x29, 0x6b, 0xfb, 0x2a,
	0xe1, 0x1e, 0x14, 0xd0, 0x7d, 0xdd, 0x76, 0x74, 0xa3, 0x23, 0x33, 0xe2, 0x71, 0x64, 0xbf, 0x39,
	0x11, 0xd9, 0x73, 0xd6, 0xdb, 0xe2, 0x99, 0x0f, 0xcb, 0x2e, 0xf0, 0xb0, 0xe0, 0xe6, 0x3d, 0x62,
	0xd7, 0x85, 0x97, 0x89, 0xf3, 0x7e, 0x12, 0x2e, 0xb9, 0x47, 0x7f, 0xd3, 0x40, 0x1b, 0x86, 0x83,
	0xac, 0x6d, 0x45, 0x43, 0x37, 0x70, 0xdb, 0x4d, 0x9e, 0x7f, 0x24, 0x60, 0x56, 0x19, 0xda, 0xb2,
	0xb2, 0x23, 0x93, 0xb4, 0x67, 0x61, 0xff, 0x38, 0xe1, 0xf9, 0xf9, 0xbb, 0x84, 0xf5, 0xdb, 0x84,
	0x34, 0xa7, 0x98, 0x55, 0x03, 0x5b, 0xce, 0x5d, 0xa4, 0xd8, 0x4e, 0xb5, 0xa1, 0x84, 0x15, 0x5a,
	0x58, 0xd1, 0xa6, 0x0a, 0x1b, 0xf7, 0x83, 0x26, 0x9c, 0x42, 0x0d, 0x2b, 0x34, 0x29, 0x87, 0xfa,
	0x55, 0x0d, 0x19, 0x8e, 0xa5, 0x74, 0x89, 0x41, 0x60, 0xa8, 0x06, 0x87, 0x9a, 0x04, 0x51, 0xbf,
	0x3a, 0x44, 0x2e, 0xb5, 0x2f, 0xab, 0x9c, 0xcc, 0x61, 0x9a, 0x1c, 0xa6, 0xc9, 0x61, 0x9a, 0x9a,
	0x04, 0x6d, 0xa5, 0xea, 0xb9, 0xe8, 0xcb, 0x2a, 0x27, 0x6b, 0x12, 0xec, 0xdb, 0x3e, 0x66, 0x2c,
	0xab, 0x9c, 0xcc, 0x63, 0xda, 0x9c, 0x8c, 0x38, 0x79, 0xdb, 0x97, 0x45, 0x8e, 0x47, 0xe4, 0x78,
	0x44, 0x97, 0x87, 0xfa, 0xc6, 0x30, 0xae, 0xac, 0x72, 0x32, 0x8f, 0x69, 0x4b, 0x19, 0x65, 0x68,
	0x5f, 0xd9, 0xb9, 0xa1, 0xf4, 0x90, 0x70, 0x0d, 0xce, 0x92, 0x3a, 0xd2, 0x65, 0x59, 0x47, 0x53,
	0x2e, 0x2b, 0x9e, 0x3e, 0x2c, 0x91, 0x49, 0x1e, 0x48, 0x59, 0x6a, 0xe9, 0x2a, 0x84, 0x3a, 0xcc,
	0xb4, 0x75, 0xfb, 0x9e, 0x6c, 0xeb, 0x3b, 0xa8, 0x90, 0x5c, 0x06, 0xe5, 0x5c, 0x4b, 0x78, 0xfa,
	0x10, 0x90, 0xaf, 0x8b, 0xe4, 0x44, 0xea, 0x9d, 0x64, 0xe1, 0xd1, 0x7f, 0x13, 0x52, 0x9a, 0x80,
	0xb6, 0xf4, 0x1d, 0x44, 0x6b, 0x56, 0xa3, 0xd2, 0x1c, 0x27, 0xdd, 0xee, 0x8c, 0x97, 0x74, 0xb7,
	0x86, 0xf8, 0x38, 0xe9, 0xbe, 0xca, 0x49, 0xb7, 0x01, 0x73, 0xba, 0x61, 0xeb, 0x6d, 0xf4, 0x45,
	0xb2, 0x6e, 0xd6, 0x35, 0x65, 0x69, 0xf7, 0x5d, 0x78, 0x12, 0xf7, 0x1d, 0x9e, 0x2b, 0x71, 0x04,
	0xae, 0x1c, 0xb3, 0x65, 0x64, 0xd5, 0x70, 0x0e, 0x67, 0x5a, 0x79, 0x2e, 0x87, 0x49, 0xfd, 0x5d,
	0xe6, 0x32, 0x18, 0xee, 0x5f, 0x3a, 0xd1, 0xa8, 0x88, 0x95, 0x95, 0x4a, 0xb3, 0xf4, 0x73, 0x00,
	0x17, 0xae, 0xec, 0xf4, 0x2d, 0x74, 0xdb, 0xab, 0xe9, 0x6e, 0xe7, 0xf0, 0x16, 0x4c, 0x72, 0xe9,
	0x3a, 0xe7, 0x65, 0x6b, 0xca, 0x4a, 0xe6, 0x41, 0xe1, 0xb2, 0x44, 0x27, 0x27, 0x9a, 0x86, 0xf8,
	0x4b, 0x36, 0x0d, 0xe9, 0x40, 0xd3, 0x30, 0xbe, 0xb0, 0xfa, 0x30, 0x37, 0x76, 0x85, 0x3a, 0xb1,
	0x0a, 0x4f, 0x5a, 0xc8, 0xc6, 0x7d, 0x4b, 0x43, 0x72, 0xc7, 0xc2, 0x7d, 0x73, 0x9a, 0x3b, 0x39,
	0x0f, 0x76, 0x8d, 0xa0, 0x84, 0x0a, 0xcc, 0x0c, 0xc8, 0x55, 0x44, 0x77, 0x10, 0x8f, 0x36, 0x49,
	0x13, 0x04, 0x39, 0x55, 0xd2, 0x68, 0xf8, 0x21, 0x58, 0xf3, 0x7b, 0x8d, 0xab, 0x30, 0x4d, 0x7b,
	0x0d, 0xff, 0xa0, 0xcb, 0xd1, 0xcd, 0xc6, 0x64, 0xf8, 0xd6, 0x63, 0x12, 0xe9, 0x53, 0x88, 0x92,
	0x24, 0xcd, 0xf8, 0x8a, 0x1c, 0xf8, 0x07, 0x5d, 0x3a, 0x98, 0x8b, 0xb1, 0xcc, 0x7a, 0xa6, 0x44,
	0x17, 0xba, 0x00, 0xe3, 0x7b, 0xbb, 0x00, 0x90, 0x0b, 0x50, 0xac, 0x34, 0xdd, 0xfe, 0xa9, 0xf4,
	0x08, 0xc0, 0x39, 0x4a, 0xc1, 0x5d, 0xf9, 0x35, 0xc8, 0x6e, 0x6c, 0xbe, 0xfe, 0x84, 0xda, 0x40,
	0xe8, 0x22, 0x68, 0x92, 0x7f, 0x1b, 0x2e, 0x30, 0x3c, 0x17, 0x7b, 0x33, 0xba, 0x7d, 0x9c, 0x77,
	0x91, 0xd2, 0x38, 0xfa, 0x66, 0xe9, 0x53, 0x00, 0x5f, 0xe1, 0x5c, 0xe0, 0xe2, 0x79, 0x27, 0xd4,
	0x7b, 0xc4, 0x8f, 0xd8, 0x7b, 0xb4, 0x20, 0x4d, 0xa0, 0x5f, 0x80, 0x78, 0x1e, 0x84, 0xfb, 0x90,
	0xeb, 0x30, 0xf5, 0x12, 0x9f, 0x51, 0x28, 0x34, 0x21, 0x42, 0xc6, 0x70, 0x78, 0x94, 0x9f, 0x02,
	0xf8, 0x7f, 0xe3, 0x83, 0x8a, 0xec, 0x34, 0xea, 0x30, 0xad, 0x10, 0x80, 0xac, 0xec, 0xb0, 0x80,
	0x2f, 0x7a, 0x81, 0xcb, 0x5a, 0x19, 0x09, 0x34, 0x24, 0x20, 0x4a, 0xa0, 0x29, 0x9d, 0xa0, 0xa8,
	0x2b, 0x3b, 0xc2, 0xfb, 0x91, 0xd7, 0xd9, 0x3b, 0x87, 0xed, 0xc2, 0x8f, 0x6e, 0xf0, 0x52, 0x0b,
	0x14, 0x84, 0xc4, 0xa1, 0x05, 0x61, 0x7c, 0xa5, 0x95, 0xfe, 0x10, 0xe7, 0xb6, 0x16, 0x79, 0x9f,
	0x1d, 0x79, 0x6b, 0x37, 0xa3, 0x8b, 0xe6, 0x51, 0xf6, 0x16, 0x2c, 0x9d, 0x1f, 0x4c, 0x29, 0x9d,
	0x47, 0x61, 0xfc, 0xf2, 0x0a, 0xe8, 0x7b, 0xf0, 0xb5, 0x6b, 0x6b, 0x9b, 0xb7, 0x37, 0xd7, 0x6e,
	0x20, 0x67, 0x88, 0xad, 0x7b, 0x47, 0xac, 0xa1, 0x17, 0x93, 0xfb, 0x97, 0x40, 0xa3, 0x74, 0x01,
	0xce, 0x07, 0x58, 0x5e, 0xda, 0xbe, 0x74, 0x05, 0xe6, 0xae, 0xad, 0x6d, 0x72, 0xdf, 0xfb, 0xf9,
	0xa8, 0xef, 0x7d, 0xc2, 0x98, 0xfb, 0xe2, 0x4b, 0xbf, 0x02, 0x70, 0x61, 0xcc, 0xc1, 0xf9, 0x7f,
	0x64, 0xa6, 0x2f, 0xe9, 0x42, 0x20, 0x35, 0x24, 0x18, 0x54, 0xae, 0x8a, 0xdc, 0x84, 0x59, 0x52,
	0x95, 0x0d, 0x77, 0x82, 0x25, 0x53, 0x25, 0xf2, 0xe8, 0xa7, 0x9c, 0xcb, 0x7a, 0x4c, 0x82, 0x06,
	0x1a, 0x32, 0xbd, 0xb0, 0x05, 0xc7, 0x2f, 0x8d, 0x31, 0xab, 0x9b, 0x50, 0x67, 0x0f, 0x67, 0x65,
	0x7c, 0x73, 0x1e, 0x03, 0x53, 0x1f, 0x5e, 0x43, 0xfe, 0x05, 0xe0, 0xab, 0x2e, 0xd3, 0x44, 0x9d,
	0xdc, 0x80, 0xc4, 0xbd, 0xe0, 0xd7, 0x52, 0x9e, 0xe6, 0x4a, 0xf8, 0xd0, 0xd6, 0x63, 0x52, 0xc6,
	0x40, 0x43, 0x96, 0xd7, 0xef, 0xc3, 0xb9, 0xd0, 0xf3, 0xec, 0xc0, 0xdb, 0x27, 0x90, 0x48, 0xeb,
	0x31, 0xe9, 0x64, 0xf0, 0x09, 0x76, 0xf8, 0xae, 0x3e, 0x81, 0x70, 0xc9, 0xdd, 0x55, 0x64, 0x59,
	0x1c, 0x65, 0x60, 0xae, 0xa3, 0x99, 0xf2, 0x0e, 0x36, 0x10, 0x9f, 0x53, 0x7f, 0xcb, 0x78, 0x19,
	0xf2, 0xe7, 0x8c, 0xf5, 0xc7, 0x8c, 0x34, 0xab, 0xd8, 0xba, 0xdb, 0x1c, 0x36, 0xaa, 0x4a, 0x60,
	0xa4, 0x06, 0x46, 0x1a, 0x37, 0x12, 0x03, 0x48, 0x31, 0x80, 0x14, 0xab, 0x9a, 0x34, 0x4f, 0x47,
	0xe3, 0x0e, 0x9a, 0x10, 0x4f, 0xa8, 0xd4, 0x49, 0xd5, 0x84, 0xa1, 0x38, 0x69, 0x28, 0x4e, 0x1a,
	0x46, 0xac, 0xd8, 0x9c, 0x34, 0x6c, 0x4e, 0x1a, 0x36, 0xab, 0x9a, 0x94, 0xa3, 0x2a, 0xda, 0xb9,
	0x13, 0x37, 0x03, 0x43, 0x35, 0x38, 0xf4, 0x56, 0x19, 0xb7, 0xf9, 0xfe, 0xbe, 0x38, 0x95, 0x3a,
	0xa9, 0x9a, 0x30, 0x14, 0x27, 0x0d, 0xc5, 0x49, 0x43, 0xb2, 0xaf, 0x57, 0x95, 0xbe, 0x4d, 0x1e,
	0x09, 0xe1, 0x65, 0xa3, 0xf5, 0xea, 0x14, 0xbd, 0x26, 0xcd, 0xa1, 0xbe, 0x85, 0x4d, 0xe4, 0xee,
	0x9d, 0x10, 0x84, 0x14, 0x6a, 0x58, 0xa1, 0x49, 0x27, 0x99, 0x82, 0xf4, 0xe6, 0x04, 0x10, 0x1c,
	0x87, 0xe7, 0xdb, 0x81, 0x31, 0xd9, 0x60, 0x70, 0xac, 0x86, 0xc6, 0x41, 0xfb, 0x66, 0x08, 0xdf,
	0x0c, 0xe1, 0x9b, 0x21, 0xfc, 0x4a, 0x08, 0xbf, 0x12, 0xc2, 0xaf, 0x84, 0xf0, 0xab, 0x21, 0xfc,
	0x6a, 0x08, 0xbf, 0x5a, 0xd5, 0xa4, 0x53, 0x74, 0xe7, 0x4a, 0x0f, 0x59, 0xba, 0x16, 0x4a, 0xde,
	0xa9, 0x53, 0xea, 0xf4, 0x29, 0x4d, 0x5a, 0xa4, 0x27, 0xe0, 0x4d, 0x79, 0x5c, 0x51, 0x5a, 0x35,
	0x52, 0xab, 0x49, 0xb9, 0xbe, 0xed, 0xbd, 0x12, 0x69, 0x72, 0xf2, 0x43, 0x35, 0x38, 0x0c, 0x81,
	0xfd, 0xe7, 0x19, 0x41, 0xfa, 0xb2, 0xc6, 0xc9, 0xfe, 0xd3, 0x8e, 0x84, 0xd3, 0x97, 0x55, 0x4e,
	0xf6, 0x9f, 0x67, 0x8d, 0xaa, 0xc2, 0xc9, 0x2a, 0x27, 0xfb, 0x18, 0x91, 0xc3, 0x88, 0x1c, 0x46,
	0xe4, 0x30, 0x4d, 0x0e, 0xd3, 0xe4, 0x30, 0x4d, 0x0e, 0xb3, 0xc2, 0x61, 0x56, 0x38, 0x0c, 0xf1,
	0x27, 0xdb, 0xd1, 0xcc, 0x3b, 0xd8, 0x40, 0xf4, 0x0e, 0xbc, 0x11, 0xd9, 0xca, 0xbd, 0x7b, 0xc0,
	0x5d, 0x72, 0x60, 0x2f, 0x37, 0x7e, 0x1d, 0xfd, 0x29, 0xeb, 0xd5, 0xd6, 0xc8, 0xbe, 0xec, 0xb8,
	0xb6, 0x1e, 0xd7, 0xd6, 0xe3, 0xda, 0x7a, 0x5c, 0x5b, 0xbf, 0xd2, 0xb5, 0x75, 0x33, 0xfa, 0x2d,
	0x79, 0xa4, 0xe2, 0x1a, 0x7c, 0x4c, 0x4a, 0x53, 0x1e, 0x93, 0x47, 0xa2, 0x0c, 0xbe, 0x26, 0xd9,
	0x73, 0x5a, 0xac, 0x34, 0x4b, 0x9f, 0x00, 0xb8, 0xb8, 0xa5, 0x3b, 0x68, 0xcb, 0x51, 0x1c, 0x5d,
	0x93, 0x70, 0xdf, 0x41, 0xee, 0xd3, 0xea, 0x5b, 0x70, 0xc1, 0xd6, 0x7b, 0x66, 0x17, 0xc9, 0x36,
	0x9d, 0x92, 0x2d, 0x32, 0xc7, 0xde, 0x4b, 0xd0, 0x7f, 0x2b, 0xad, 0xc7, 0xa4, 0x79, 0x17, 0xc8,
	0x51, 0x08, 0xb7, 0xe1, 0x82, 0xd6, 0xb7, 0x1d, 0xdc, 0x0b, 0x5a, 0xbb, 0x9e, 0x17, 0x43, 0x9e,
	0x73, 0x86, 0xf4, 0x8f, 0x1e, 0x49, 0xd2, 0xb6, 0x13, 0x5e, 0x97, 0x82, 0x9b, 0x6e, 0x9d, 0x81,
	0x82, 0x86, 0x8d, 0x6d, 0xbd, 0x23, 0xf7, 0x70, 0x1b, 0xc9, 0x07, 0xf7, 0xfa, 0x3f, 0x05, 0xb0,
	0x10, 0xde, 0xdb, 0xf7, 0x74, 0xdb, 0x7d, 0x84, 0xde, 0x83, 0xf3, 0xbc, 0x6b, 0x72, 0x57, 0xb7,
	0x9d, 0x02, 0x58, 0x4e, 0x4c, 0xfd, 0x83, 0x4f, 0x54, 0x94, 0x5a, 0x8b, 0x34, 0x10, 0xbf, 0x06,
	0xf1, 0xfc, 0x65, 0x4f, 0x4a, 0x03, 0x69, 0xce, 0xf6, 0x71, 0x64, 0xc1, 0xd2, 0x4f, 0x92, 0xf0,
	0xf5, 0x6b, 0x5d, 0xac, 0x2a, 0x5d, 0xef, 0xb9, 0x88, 0x0d, 0x03, 0x69, 0x8e, 0x8e, 0x0d, 0xea,
	0xcc, 0x16, 0xcc, 0xdb, 0x5d, 0x5d, 0x76, 0xb0, 0xdc, 0xa1, 0x28, 0xb9, 0x6d, 0x1d, 0xfc, 0xac,
	0xa2, 0x28, 0x46, 0x82, 0x2d, 0xf6, 0x18, 0xca, 0xd9, 0x5d, 0xfd, 0x16, 0x76, 0xe7, 0xde, 0xb3,
	0x5c, 0x52, 0x1c, 0x24, 0x4d, 0x7c, 0x11, 0x52, 0xcc, 0x91, 0x6e, 0xc2, 0x57, 0xda, 0xba, 0xad,
	0xa8, 0x5d, 0x24, 0x6f, 0x63, 0x6b, 0xa8, 0x58, 0x6d, 0xd9, 0xb4, 0xf0, 0xfd, 0x07, 0x85, 0x19,
	0xca, 0xbc, 0x18, 0x62, 0xbe, 0xda, 0x33, 0x9d, 0x07, 0xad, 0xe4, 0x73, 0x72, 0xa0, 0x40, 0x5a,
	0x60, 0xa6, 0xdf, 0x71, 0x2d, 0x37, 0x89, 0xa1, 0x20, 0xc3, 0x45, 0x64, 0x44, 0x10, 0xa6, 0x22,
	0xff, 0x7b, 0xca, 0x9b, 0xae, 0xd1, 0x4c, 0x70, 0x53, 0x86, 0xad, 0x20, 0xb8, 0x54, 0x3c, 0xea,
	0xe2, 0xdb, 0x7f, 0xdf, 0x05, 0x6f, 0xc1, 0xff, 0x87, 0x4b, 0xee, 0x26, 0x96, 0xd9, 0x11, 0x2c,
	0xfb, 0x67, 0x60, 0x0b, 0x89, 0x46, 0x65, 0xa5, 0x75, 0x1a, 0xce, 0x6b, 0x63, 0xdd, 0xb4, 0xdc,
	0x6a, 0xbd, 0x0b, 0x17, 0x03, 0x8e, 0x7a, 0xc0, 0x85, 0xc7, 0xbb, 0x60, 0xe6, 0x89, 0xfb, 0x5f,
	0xbf, 0x24, 0x01, 0x7f, 0x2d, 0xf8, 0x4f, 0xe3, 0xd2, 0xef, 0x01, 0x7c, 0x73, 0x4a, 0x12, 0x8c,
	0xb3, 0xf2, 0x67, 0x00, 0x2e, 0xb1, 0xd3, 0x62, 0x2f, 0x7d, 0xd9, 0x77, 0xc9, 0x66, 0xf9, 0x79,
	0xfe, 0x80, 0xe3, 0x8b, 0xcc, 0xaf, 0x56, 0x61, 0x8f, 0xfd, 0x9d, 0x88, 0xa6, 0x6a, 0x9a, 0x4b,
	0xd5, 0x42, 0x27, 0xda, 0xcc, 0x6e, 0xfd, 0x12, 0xec, 0x3d, 0x2b, 0xc6, 0x9e, 0x3e, 0x2b, 0xc6,
	0x3e, 0x7f, 0x56, 0x04, 0x2f, 0x9e, 0x15, 0xc1, 0xa3, 0x51, 0x11, 0x7c, 0x3c, 0x2a, 0x82, 0xbf,
	0x8c, 0x8a, 0xe0, 0xf1, 0xa8, 0x08, 0x9e, 0x8c, 0x8a, 0x60, 0x6f, 0x54, 0x04, 0x4f, 0x47, 0x45,
	0xf0, 0xe9, 0xa8, 0x08, 0x9e, 0x8f, 0x8a, 0xb1, 0xcf, 0x47, 0x45, 0xf0, 0xd1, 0x67, 0xc5, 0xd8,
	0xe3, 0xcf, 0x8a, 0xe0, 0xce, 0x46, 0x07, 0x9b, 0xf7, 0x3a, 0xb5, 0x01, 0xee, 0x3a, 0xc8, 0xb2,
	0x94, 0x5a, 0xdf, 0xae, 0x53, 0x61, 0x1b, 0x5b, 0xbd, 0xaa, 0x69, 0xe1, 0x81, 0xde, 0x46, 0x56,
	0xd5, 0x9b, 0xae, 0x9b, 0x6a, 0x07, 0xd7, 0xd1, 0x7d, 0x87, 0xfd, 0x82, 0x80, 0xff, 0x21, 0x81,
	0x9a, 0xa2, 0xbf, 0x21, 0x68, 0xfe, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x00, 0x2a, 0x13, 0x90, 0x61,
	0x21, 0x00, 0x00,
}

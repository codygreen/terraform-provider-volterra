//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package views

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AWSVPCOneInterfaceNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCOneInterfaceNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCOneInterfaceNodeType) DeepCopy() *AWSVPCOneInterfaceNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCOneInterfaceNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCOneInterfaceNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCOneInterfaceNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCOneInterfaceNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCOneInterfaceNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCOneInterfaceNodeType) AwsAzNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_az_name")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCOneInterfaceNodeType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCOneInterfaceNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCOneInterfaceNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCOneInterfaceNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_az_name"))
		if err := fv(ctx, m.GetAwsAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("local_subnet"))
		if err := fv(ctx, m.GetLocalSubnet(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCOneInterfaceNodeTypeValidator = func() *ValidateAWSVPCOneInterfaceNodeType {
	v := &ValidateAWSVPCOneInterfaceNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAwsAzName := v.AwsAzNameValidationRuleHandler
	rulesAwsAzName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"ap-northeast-1a\",\"ap-northeast-1c\",\"ap-northeast-1d\",\"ap-southeast-1a\",\"ap-southeast-1b\",\"ap-southeast-1c\",\"eu-central-1a\",\"eu-central-1b\",\"eu-central-1c\",\"eu-west-1a\",\"eu-west-1b\",\"eu-west-1c\",\"eu-west-3a\",\"eu-west-3b\",\"eu-west-3c\",\"sa-east-1a\",\"sa-east-1b\",\"sa-east-1c\",\"us-east-1a\",\"us-east-1b\",\"us-east-1c\",\"us-east-1d\",\"us-east-1e\",\"us-east-1f\",\"us-east-2a\",\"us-east-2b\",\"us-east-2c\",\"us-west-2a\",\"us-west-2b\",\"us-west-2c\",\"us-west-2d\"]",
	}
	vFn, err = vrhAwsAzName(rulesAwsAzName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCOneInterfaceNodeType.aws_az_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_az_name"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "64000",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCOneInterfaceNodeType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["local_subnet"] = CloudSubnetTypeValidator().Validate

	return v
}()

func AWSVPCOneInterfaceNodeTypeValidator() db.Validator {
	return DefaultAWSVPCOneInterfaceNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCParamsType) DeepCopy() *AWSVPCParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCParamsType) NameChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAWSVPCParamsType) NameChoiceNameTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NameTag, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name_tag")
	}
	return oValidatorFn_NameTag, nil
}

func (v *ValidateAWSVPCParamsType) PrimaryIpv4ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_ipv4")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allocate_ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("allocate_ipv6"))
		if err := fv(ctx, m.GetAllocateIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name_choice"]; exists {
		val := m.GetNameChoice()
		vOpts := append(opts,
			db.WithValidateField("name_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNameChoice().(type) {
	case *AWSVPCParamsType_NameTag:
		if fv, exists := v.FldValidators["name_choice.name_tag"]; exists {
			val := m.GetNameChoice().(*AWSVPCParamsType_NameTag).NameTag
			vOpts := append(opts,
				db.WithValidateField("name_choice"),
				db.WithValidateField("name_tag"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AWSVPCParamsType_Autogenerate:
		if fv, exists := v.FldValidators["name_choice.autogenerate"]; exists {
			val := m.GetNameChoice().(*AWSVPCParamsType_Autogenerate).Autogenerate
			vOpts := append(opts,
				db.WithValidateField("name_choice"),
				db.WithValidateField("autogenerate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["primary_ipv4"]; exists {

		vOpts := append(opts, db.WithValidateField("primary_ipv4"))
		if err := fv(ctx, m.GetPrimaryIpv4(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCParamsTypeValidator = func() *ValidateAWSVPCParamsType {
	v := &ValidateAWSVPCParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNameChoice := v.NameChoiceValidationRuleHandler
	rulesNameChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNameChoice(rulesNameChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCParamsType.name_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name_choice"] = vFn

	vrhNameChoiceNameTag := v.NameChoiceNameTagValidationRuleHandler
	rulesNameChoiceNameTag := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFnMap["name_choice.name_tag"], err = vrhNameChoiceNameTag(rulesNameChoiceNameTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AWSVPCParamsType.name_choice_name_tag: %s", err)
		panic(errMsg)
	}

	v.FldValidators["name_choice.name_tag"] = vFnMap["name_choice.name_tag"]

	vrhPrimaryIpv4 := v.PrimaryIpv4ValidationRuleHandler
	rulesPrimaryIpv4 := map[string]string{
		"ves.io.schema.rules.message.required":            "true",
		"ves.io.schema.rules.string.ipv4_prefix":          "true",
		"ves.io.schema.rules.string.max_ip_prefix_length": "28",
		"ves.io.schema.rules.string.min_ip_prefix_length": "16",
	}
	vFn, err = vrhPrimaryIpv4(rulesPrimaryIpv4)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCParamsType.primary_ipv4: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_ipv4"] = vFn

	return v
}()

func AWSVPCParamsTypeValidator() db.Validator {
	return DefaultAWSVPCParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCTwoInterfaceNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCTwoInterfaceNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCTwoInterfaceNodeType) DeepCopy() *AWSVPCTwoInterfaceNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCTwoInterfaceNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCTwoInterfaceNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCTwoInterfaceNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCTwoInterfaceNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCTwoInterfaceNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCTwoInterfaceNodeType) AwsAzNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_az_name")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCTwoInterfaceNodeType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCTwoInterfaceNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCTwoInterfaceNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCTwoInterfaceNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_az_name"))
		if err := fv(ctx, m.GetAwsAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_subnet"))
		if err := fv(ctx, m.GetInsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_subnet"))
		if err := fv(ctx, m.GetOutsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCTwoInterfaceNodeTypeValidator = func() *ValidateAWSVPCTwoInterfaceNodeType {
	v := &ValidateAWSVPCTwoInterfaceNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAwsAzName := v.AwsAzNameValidationRuleHandler
	rulesAwsAzName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"ap-northeast-1a\",\"ap-northeast-1c\",\"ap-northeast-1d\",\"ap-southeast-1a\",\"ap-southeast-1b\",\"ap-southeast-1c\",\"eu-central-1a\",\"eu-central-1b\",\"eu-central-1c\",\"eu-west-1a\",\"eu-west-1b\",\"eu-west-1c\",\"eu-west-3a\",\"eu-west-3b\",\"eu-west-3c\",\"sa-east-1a\",\"sa-east-1b\",\"sa-east-1c\",\"us-east-1a\",\"us-east-1b\",\"us-east-1c\",\"us-east-1d\",\"us-east-1e\",\"us-east-1f\",\"us-east-2a\",\"us-east-2b\",\"us-east-2c\",\"us-west-2a\",\"us-west-2b\",\"us-west-2c\",\"us-west-2d\"]",
	}
	vFn, err = vrhAwsAzName(rulesAwsAzName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCTwoInterfaceNodeType.aws_az_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_az_name"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.string.max_len": "32",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCTwoInterfaceNodeType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["inside_subnet"] = CloudSubnetTypeValidator().Validate

	v.FldValidators["outside_subnet"] = CloudSubnetTypeValidator().Validate

	return v
}()

func AWSVPCTwoInterfaceNodeTypeValidator() db.Validator {
	return DefaultAWSVPCTwoInterfaceNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCchoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCchoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCchoiceType) DeepCopy() *AWSVPCchoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCchoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCchoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCchoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCchoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCchoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCchoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAWSVPCchoiceType) ChoiceVpcIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VpcId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vpc_id")
	}
	return oValidatorFn_VpcId, nil
}

func (v *ValidateAWSVPCchoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCchoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCchoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AWSVPCchoiceType_NewVpc:
		if fv, exists := v.FldValidators["choice.new_vpc"]; exists {
			val := m.GetChoice().(*AWSVPCchoiceType_NewVpc).NewVpc
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_vpc"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AWSVPCchoiceType_VpcId:
		if fv, exists := v.FldValidators["choice.vpc_id"]; exists {
			val := m.GetChoice().(*AWSVPCchoiceType_VpcId).VpcId
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("vpc_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCchoiceTypeValidator = func() *ValidateAWSVPCchoiceType {
	v := &ValidateAWSVPCchoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCchoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoiceVpcId := v.ChoiceVpcIdValidationRuleHandler
	rulesChoiceVpcId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(vpc-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFnMap["choice.vpc_id"], err = vrhChoiceVpcId(rulesChoiceVpcId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AWSVPCchoiceType.choice_vpc_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.vpc_id"] = vFnMap["choice.vpc_id"]

	v.FldValidators["choice.new_vpc"] = AWSVPCParamsTypeValidator().Validate

	return v
}()

func AWSVPCchoiceTypeValidator() db.Validator {
	return DefaultAWSVPCchoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureSubnetChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureSubnetChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureSubnetChoiceType) DeepCopy() *AzureSubnetChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureSubnetChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureSubnetChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureSubnetChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureSubnetChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureSubnetChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureSubnetChoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAzureSubnetChoiceType) ChoiceSubnetParamValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return CloudSubnetParamTypeValidator().Validate, nil
}
func (v *ValidateAzureSubnetChoiceType) ChoiceSubnetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return AzureSubnetTypeValidator().Validate, nil
}

func (v *ValidateAzureSubnetChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureSubnetChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureSubnetChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AzureSubnetChoiceType_SubnetParam:
		if fv, exists := v.FldValidators["choice.subnet_param"]; exists {
			val := m.GetChoice().(*AzureSubnetChoiceType_SubnetParam).SubnetParam
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("subnet_param"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureSubnetChoiceType_Subnet:
		if fv, exists := v.FldValidators["choice.subnet"]; exists {
			val := m.GetChoice().(*AzureSubnetChoiceType_Subnet).Subnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureSubnetChoiceTypeValidator = func() *ValidateAzureSubnetChoiceType {
	v := &ValidateAzureSubnetChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureSubnetChoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoiceSubnetParam := v.ChoiceSubnetParamValidationRuleHandler
	rulesChoiceSubnetParam := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["choice.subnet_param"], err = vrhChoiceSubnetParam(rulesChoiceSubnetParam)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AzureSubnetChoiceType.choice_subnet_param: %s", err)
		panic(errMsg)
	}
	vrhChoiceSubnet := v.ChoiceSubnetValidationRuleHandler
	rulesChoiceSubnet := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["choice.subnet"], err = vrhChoiceSubnet(rulesChoiceSubnet)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AzureSubnetChoiceType.choice_subnet: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.subnet_param"] = vFnMap["choice.subnet_param"]
	v.FldValidators["choice.subnet"] = vFnMap["choice.subnet"]

	return v
}()

func AzureSubnetChoiceTypeValidator() db.Validator {
	return DefaultAzureSubnetChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureSubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureSubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureSubnetType) DeepCopy() *AzureSubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureSubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureSubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureSubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureSubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureSubnetType) ResourceGroupChoiceSubnetResourceGrpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SubnetResourceGrp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subnet_resource_grp")
	}
	return oValidatorFn_SubnetResourceGrp, nil
}

func (v *ValidateAzureSubnetType) SubnetNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subnet_name")
	}

	return validatorFn, nil
}

func (v *ValidateAzureSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureSubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureSubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetResourceGroupChoice().(type) {
	case *AzureSubnetType_SubnetResourceGrp:
		if fv, exists := v.FldValidators["resource_group_choice.subnet_resource_grp"]; exists {
			val := m.GetResourceGroupChoice().(*AzureSubnetType_SubnetResourceGrp).SubnetResourceGrp
			vOpts := append(opts,
				db.WithValidateField("resource_group_choice"),
				db.WithValidateField("subnet_resource_grp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureSubnetType_VnetResourceGroup:
		if fv, exists := v.FldValidators["resource_group_choice.vnet_resource_group"]; exists {
			val := m.GetResourceGroupChoice().(*AzureSubnetType_VnetResourceGroup).VnetResourceGroup
			vOpts := append(opts,
				db.WithValidateField("resource_group_choice"),
				db.WithValidateField("vnet_resource_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["subnet_name"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet_name"))
		if err := fv(ctx, m.GetSubnetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureSubnetTypeValidator = func() *ValidateAzureSubnetType {
	v := &ValidateAzureSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResourceGroupChoiceSubnetResourceGrp := v.ResourceGroupChoiceSubnetResourceGrpValidationRuleHandler
	rulesResourceGroupChoiceSubnetResourceGrp := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFnMap["resource_group_choice.subnet_resource_grp"], err = vrhResourceGroupChoiceSubnetResourceGrp(rulesResourceGroupChoiceSubnetResourceGrp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AzureSubnetType.resource_group_choice_subnet_resource_grp: %s", err)
		panic(errMsg)
	}

	v.FldValidators["resource_group_choice.subnet_resource_grp"] = vFnMap["resource_group_choice.subnet_resource_grp"]

	vrhSubnetName := v.SubnetNameValidationRuleHandler
	rulesSubnetName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhSubnetName(rulesSubnetName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureSubnetType.subnet_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subnet_name"] = vFn

	return v
}()

func AzureSubnetTypeValidator() db.Validator {
	return DefaultAzureSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetChoiceType) DeepCopy() *AzureVnetChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetChoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAzureVnetChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AzureVnetChoiceType_NewVnet:
		if fv, exists := v.FldValidators["choice.new_vnet"]; exists {
			val := m.GetChoice().(*AzureVnetChoiceType_NewVnet).NewVnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_vnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureVnetChoiceType_ExistingVnet:
		if fv, exists := v.FldValidators["choice.existing_vnet"]; exists {
			val := m.GetChoice().(*AzureVnetChoiceType_ExistingVnet).ExistingVnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("existing_vnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetChoiceTypeValidator = func() *ValidateAzureVnetChoiceType {
	v := &ValidateAzureVnetChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetChoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.new_vnet"] = AzureVnetParamsTypeValidator().Validate
	v.FldValidators["choice.existing_vnet"] = AzureVnetTypeValidator().Validate

	return v
}()

func AzureVnetChoiceTypeValidator() db.Validator {
	return DefaultAzureVnetChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetOneInterfaceNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetOneInterfaceNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetOneInterfaceNodeType) DeepCopy() *AzureVnetOneInterfaceNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetOneInterfaceNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetOneInterfaceNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetOneInterfaceNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetOneInterfaceNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetOneInterfaceNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetOneInterfaceNodeType) AzureAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for azure_az")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetOneInterfaceNodeType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetOneInterfaceNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetOneInterfaceNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetOneInterfaceNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["azure_az"]; exists {

		vOpts := append(opts, db.WithValidateField("azure_az"))
		if err := fv(ctx, m.GetAzureAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("local_subnet"))
		if err := fv(ctx, m.GetLocalSubnet(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetOneInterfaceNodeTypeValidator = func() *ValidateAzureVnetOneInterfaceNodeType {
	v := &ValidateAzureVnetOneInterfaceNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAzureAz := v.AzureAzValidationRuleHandler
	rulesAzureAz := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"1\",\"2\",\"3\"]",
	}
	vFn, err = vrhAzureAz(rulesAzureAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetOneInterfaceNodeType.azure_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["azure_az"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.string.max_len": "32",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetOneInterfaceNodeType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["local_subnet"] = AzureSubnetChoiceTypeValidator().Validate

	return v
}()

func AzureVnetOneInterfaceNodeTypeValidator() db.Validator {
	return DefaultAzureVnetOneInterfaceNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetParamsType) DeepCopy() *AzureVnetParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetParamsType) NameChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAzureVnetParamsType) NameChoiceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Name, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}
	return oValidatorFn_Name, nil
}

func (v *ValidateAzureVnetParamsType) PrimaryIpv4ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_ipv4")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name_choice"]; exists {
		val := m.GetNameChoice()
		vOpts := append(opts,
			db.WithValidateField("name_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNameChoice().(type) {
	case *AzureVnetParamsType_Name:
		if fv, exists := v.FldValidators["name_choice.name"]; exists {
			val := m.GetNameChoice().(*AzureVnetParamsType_Name).Name
			vOpts := append(opts,
				db.WithValidateField("name_choice"),
				db.WithValidateField("name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureVnetParamsType_Autogenerate:
		if fv, exists := v.FldValidators["name_choice.autogenerate"]; exists {
			val := m.GetNameChoice().(*AzureVnetParamsType_Autogenerate).Autogenerate
			vOpts := append(opts,
				db.WithValidateField("name_choice"),
				db.WithValidateField("autogenerate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["primary_ipv4"]; exists {

		vOpts := append(opts, db.WithValidateField("primary_ipv4"))
		if err := fv(ctx, m.GetPrimaryIpv4(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetParamsTypeValidator = func() *ValidateAzureVnetParamsType {
	v := &ValidateAzureVnetParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNameChoice := v.NameChoiceValidationRuleHandler
	rulesNameChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNameChoice(rulesNameChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetParamsType.name_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name_choice"] = vFn

	vrhNameChoiceName := v.NameChoiceNameValidationRuleHandler
	rulesNameChoiceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["name_choice.name"], err = vrhNameChoiceName(rulesNameChoiceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AzureVnetParamsType.name_choice_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["name_choice.name"] = vFnMap["name_choice.name"]

	vrhPrimaryIpv4 := v.PrimaryIpv4ValidationRuleHandler
	rulesPrimaryIpv4 := map[string]string{
		"ves.io.schema.rules.message.required":            "true",
		"ves.io.schema.rules.string.ipv4_prefix":          "true",
		"ves.io.schema.rules.string.max_ip_prefix_length": "28",
		"ves.io.schema.rules.string.min_ip_prefix_length": "8",
	}
	vFn, err = vrhPrimaryIpv4(rulesPrimaryIpv4)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetParamsType.primary_ipv4: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_ipv4"] = vFn

	return v
}()

func AzureVnetParamsTypeValidator() db.Validator {
	return DefaultAzureVnetParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetTwoInterfaceNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetTwoInterfaceNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetTwoInterfaceNodeType) DeepCopy() *AzureVnetTwoInterfaceNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetTwoInterfaceNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetTwoInterfaceNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetTwoInterfaceNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetTwoInterfaceNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetTwoInterfaceNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetTwoInterfaceNodeType) AzureAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for azure_az")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetTwoInterfaceNodeType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetTwoInterfaceNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetTwoInterfaceNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetTwoInterfaceNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["azure_az"]; exists {

		vOpts := append(opts, db.WithValidateField("azure_az"))
		if err := fv(ctx, m.GetAzureAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_subnet"))
		if err := fv(ctx, m.GetInsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_subnet"))
		if err := fv(ctx, m.GetOutsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetTwoInterfaceNodeTypeValidator = func() *ValidateAzureVnetTwoInterfaceNodeType {
	v := &ValidateAzureVnetTwoInterfaceNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAzureAz := v.AzureAzValidationRuleHandler
	rulesAzureAz := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"1\",\"2\",\"3\"]",
	}
	vFn, err = vrhAzureAz(rulesAzureAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetTwoInterfaceNodeType.azure_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["azure_az"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.string.max_len": "32",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetTwoInterfaceNodeType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["inside_subnet"] = AzureSubnetChoiceTypeValidator().Validate

	v.FldValidators["outside_subnet"] = AzureSubnetChoiceTypeValidator().Validate

	return v
}()

func AzureVnetTwoInterfaceNodeTypeValidator() db.Validator {
	return DefaultAzureVnetTwoInterfaceNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetType) DeepCopy() *AzureVnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetType) ResourceGroupValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for resource_group")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetType) VnetNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vnet_name")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["resource_group"]; exists {

		vOpts := append(opts, db.WithValidateField("resource_group"))
		if err := fv(ctx, m.GetResourceGroup(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vnet_name"]; exists {

		vOpts := append(opts, db.WithValidateField("vnet_name"))
		if err := fv(ctx, m.GetVnetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetTypeValidator = func() *ValidateAzureVnetType {
	v := &ValidateAzureVnetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResourceGroup := v.ResourceGroupValidationRuleHandler
	rulesResourceGroup := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhResourceGroup(rulesResourceGroup)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetType.resource_group: %s", err)
		panic(errMsg)
	}
	v.FldValidators["resource_group"] = vFn

	vrhVnetName := v.VnetNameValidationRuleHandler
	rulesVnetName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhVnetName(rulesVnetName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetType.vnet_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vnet_name"] = vFn

	return v
}()

func AzureVnetTypeValidator() db.Validator {
	return DefaultAzureVnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CloudSubnetParamType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloudSubnetParamType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloudSubnetParamType) DeepCopy() *CloudSubnetParamType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloudSubnetParamType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloudSubnetParamType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloudSubnetParamType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloudSubnetParamTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCloudSubnetParamType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloudSubnetParamType) Ipv4ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv4")
	}

	return validatorFn, nil
}

func (v *ValidateCloudSubnetParamType) Ipv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}

	return validatorFn, nil
}

func (v *ValidateCloudSubnetParamType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloudSubnetParamType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloudSubnetParamType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ipv4"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv4"))
		if err := fv(ctx, m.GetIpv4(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6"))
		if err := fv(ctx, m.GetIpv6(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloudSubnetParamTypeValidator = func() *ValidateCloudSubnetParamType {
	v := &ValidateCloudSubnetParamType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpv4 := v.Ipv4ValidationRuleHandler
	rulesIpv4 := map[string]string{
		"ves.io.schema.rules.message.required":            "true",
		"ves.io.schema.rules.string.ipv4_prefix":          "true",
		"ves.io.schema.rules.string.max_ip_prefix_length": "28",
	}
	vFn, err = vrhIpv4(rulesIpv4)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudSubnetParamType.ipv4: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv4"] = vFn

	vrhIpv6 := v.Ipv6ValidationRuleHandler
	rulesIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6_prefix": "true",
	}
	vFn, err = vrhIpv6(rulesIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudSubnetParamType.ipv6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6"] = vFn

	return v
}()

func CloudSubnetParamTypeValidator() db.Validator {
	return DefaultCloudSubnetParamTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CloudSubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloudSubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloudSubnetType) DeepCopy() *CloudSubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloudSubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloudSubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloudSubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloudSubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCloudSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloudSubnetType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateCloudSubnetType) ChoiceExistingSubnetIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExistingSubnetId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for existing_subnet_id")
	}
	return oValidatorFn_ExistingSubnetId, nil
}

func (v *ValidateCloudSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloudSubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloudSubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *CloudSubnetType_SubnetParam:
		if fv, exists := v.FldValidators["choice.subnet_param"]; exists {
			val := m.GetChoice().(*CloudSubnetType_SubnetParam).SubnetParam
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("subnet_param"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CloudSubnetType_ExistingSubnetId:
		if fv, exists := v.FldValidators["choice.existing_subnet_id"]; exists {
			val := m.GetChoice().(*CloudSubnetType_ExistingSubnetId).ExistingSubnetId
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("existing_subnet_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloudSubnetTypeValidator = func() *ValidateCloudSubnetType {
	v := &ValidateCloudSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudSubnetType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoiceExistingSubnetId := v.ChoiceExistingSubnetIdValidationRuleHandler
	rulesChoiceExistingSubnetId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(subnet-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFnMap["choice.existing_subnet_id"], err = vrhChoiceExistingSubnetId(rulesChoiceExistingSubnetId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CloudSubnetType.choice_existing_subnet_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.existing_subnet_id"] = vFnMap["choice.existing_subnet_id"]

	v.FldValidators["choice.subnet_param"] = CloudSubnetParamTypeValidator().Validate

	return v
}()

func CloudSubnetTypeValidator() db.Validator {
	return DefaultCloudSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPSubnetParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPSubnetParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPSubnetParamsType) DeepCopy() *GCPSubnetParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPSubnetParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPSubnetParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPSubnetParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPSubnetParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPSubnetParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPSubnetParamsType) SubnetNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subnet_name")
	}

	return validatorFn, nil
}

func (v *ValidateGCPSubnetParamsType) PrimaryIpv4ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_ipv4")
	}

	return validatorFn, nil
}

func (v *ValidateGCPSubnetParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPSubnetParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPSubnetParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["primary_ipv4"]; exists {

		vOpts := append(opts, db.WithValidateField("primary_ipv4"))
		if err := fv(ctx, m.GetPrimaryIpv4(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnet_name"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet_name"))
		if err := fv(ctx, m.GetSubnetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPSubnetParamsTypeValidator = func() *ValidateGCPSubnetParamsType {
	v := &ValidateGCPSubnetParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSubnetName := v.SubnetNameValidationRuleHandler
	rulesSubnetName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhSubnetName(rulesSubnetName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPSubnetParamsType.subnet_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subnet_name"] = vFn

	vrhPrimaryIpv4 := v.PrimaryIpv4ValidationRuleHandler
	rulesPrimaryIpv4 := map[string]string{
		"ves.io.schema.rules.message.required":            "true",
		"ves.io.schema.rules.string.ipv4_prefix":          "true",
		"ves.io.schema.rules.string.max_ip_prefix_length": "28",
		"ves.io.schema.rules.string.min_ip_prefix_length": "8",
	}
	vFn, err = vrhPrimaryIpv4(rulesPrimaryIpv4)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPSubnetParamsType.primary_ipv4: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_ipv4"] = vFn

	return v
}()

func GCPSubnetParamsTypeValidator() db.Validator {
	return DefaultGCPSubnetParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPSubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPSubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPSubnetType) DeepCopy() *GCPSubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPSubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPSubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPSubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPSubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPSubnetType) SubnetNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subnet_name")
	}

	return validatorFn, nil
}

func (v *ValidateGCPSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPSubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPSubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["subnet_name"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet_name"))
		if err := fv(ctx, m.GetSubnetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPSubnetTypeValidator = func() *ValidateGCPSubnetType {
	v := &ValidateGCPSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSubnetName := v.SubnetNameValidationRuleHandler
	rulesSubnetName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhSubnetName(rulesSubnetName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPSubnetType.subnet_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subnet_name"] = vFn

	return v
}()

func GCPSubnetTypeValidator() db.Validator {
	return DefaultGCPSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCNetworkAutogenerateParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCNetworkAutogenerateParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCNetworkAutogenerateParamsType) DeepCopy() *GCPVPCNetworkAutogenerateParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCNetworkAutogenerateParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCNetworkAutogenerateParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCNetworkAutogenerateParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCNetworkAutogenerateParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCNetworkAutogenerateParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCNetworkAutogenerateParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCNetworkAutogenerateParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCNetworkAutogenerateParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["autogenerate"]; exists {

		vOpts := append(opts, db.WithValidateField("autogenerate"))
		if err := fv(ctx, m.GetAutogenerate(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCNetworkAutogenerateParamsTypeValidator = func() *ValidateGCPVPCNetworkAutogenerateParamsType {
	v := &ValidateGCPVPCNetworkAutogenerateParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GCPVPCNetworkAutogenerateParamsTypeValidator() db.Validator {
	return DefaultGCPVPCNetworkAutogenerateParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCNetworkChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCNetworkChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCNetworkChoiceType) DeepCopy() *GCPVPCNetworkChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCNetworkChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCNetworkChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCNetworkChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCNetworkChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCNetworkChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCNetworkChoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateGCPVPCNetworkChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCNetworkChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCNetworkChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *GCPVPCNetworkChoiceType_NewNetwork:
		if fv, exists := v.FldValidators["choice.new_network"]; exists {
			val := m.GetChoice().(*GCPVPCNetworkChoiceType_NewNetwork).NewNetwork
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GCPVPCNetworkChoiceType_ExistingNetwork:
		if fv, exists := v.FldValidators["choice.existing_network"]; exists {
			val := m.GetChoice().(*GCPVPCNetworkChoiceType_ExistingNetwork).ExistingNetwork
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("existing_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GCPVPCNetworkChoiceType_NewNetworkAutogenerate:
		if fv, exists := v.FldValidators["choice.new_network_autogenerate"]; exists {
			val := m.GetChoice().(*GCPVPCNetworkChoiceType_NewNetworkAutogenerate).NewNetworkAutogenerate
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_network_autogenerate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCNetworkChoiceTypeValidator = func() *ValidateGCPVPCNetworkChoiceType {
	v := &ValidateGCPVPCNetworkChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPVPCNetworkChoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.new_network"] = GCPVPCNetworkParamsTypeValidator().Validate
	v.FldValidators["choice.existing_network"] = GCPVPCNetworkTypeValidator().Validate

	return v
}()

func GCPVPCNetworkChoiceTypeValidator() db.Validator {
	return DefaultGCPVPCNetworkChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCNetworkParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCNetworkParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCNetworkParamsType) DeepCopy() *GCPVPCNetworkParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCNetworkParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCNetworkParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCNetworkParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCNetworkParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCNetworkParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCNetworkParamsType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGCPVPCNetworkParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCNetworkParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCNetworkParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCNetworkParamsTypeValidator = func() *ValidateGCPVPCNetworkParamsType {
	v := &ValidateGCPVPCNetworkParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPVPCNetworkParamsType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func GCPVPCNetworkParamsTypeValidator() db.Validator {
	return DefaultGCPVPCNetworkParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCNetworkType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCNetworkType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCNetworkType) DeepCopy() *GCPVPCNetworkType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCNetworkType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCNetworkType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCNetworkType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCNetworkTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCNetworkType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCNetworkType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGCPVPCNetworkType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCNetworkType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCNetworkType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCNetworkTypeValidator = func() *ValidateGCPVPCNetworkType {
	v := &ValidateGCPVPCNetworkType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPVPCNetworkType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func GCPVPCNetworkTypeValidator() db.Validator {
	return DefaultGCPVPCNetworkTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCSubnetChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCSubnetChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCSubnetChoiceType) DeepCopy() *GCPVPCSubnetChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCSubnetChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCSubnetChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCSubnetChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCSubnetChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCSubnetChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCSubnetChoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateGCPVPCSubnetChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCSubnetChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCSubnetChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *GCPVPCSubnetChoiceType_NewSubnet:
		if fv, exists := v.FldValidators["choice.new_subnet"]; exists {
			val := m.GetChoice().(*GCPVPCSubnetChoiceType_NewSubnet).NewSubnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GCPVPCSubnetChoiceType_ExistingSubnet:
		if fv, exists := v.FldValidators["choice.existing_subnet"]; exists {
			val := m.GetChoice().(*GCPVPCSubnetChoiceType_ExistingSubnet).ExistingSubnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("existing_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCSubnetChoiceTypeValidator = func() *ValidateGCPVPCSubnetChoiceType {
	v := &ValidateGCPVPCSubnetChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPVPCSubnetChoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.new_subnet"] = GCPSubnetParamsTypeValidator().Validate
	v.FldValidators["choice.existing_subnet"] = GCPSubnetTypeValidator().Validate

	return v
}()

func GCPVPCSubnetChoiceTypeValidator() db.Validator {
	return DefaultGCPVPCSubnetChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalNetworkConnectionListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalNetworkConnectionListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalNetworkConnectionListType) DeepCopy() *GlobalNetworkConnectionListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalNetworkConnectionListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalNetworkConnectionListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalNetworkConnectionListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalNetworkConnectionListTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalNetworkConnectionListType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetGlobalNetworkConnectionsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *GlobalNetworkConnectionListType) GetGlobalNetworkConnectionsDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GlobalNetworkConnections == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.GlobalNetworkConnections {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("global_network_connections[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateGlobalNetworkConnectionListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalNetworkConnectionListType) GlobalNetworkConnectionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*GlobalNetworkConnectionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := GlobalNetworkConnectionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for global_network_connections")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*GlobalNetworkConnectionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*GlobalNetworkConnectionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated global_network_connections")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items global_network_connections")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalNetworkConnectionListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalNetworkConnectionListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalNetworkConnectionListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["global_network_connections"]; exists {
		vOpts := append(opts, db.WithValidateField("global_network_connections"))
		if err := fv(ctx, m.GetGlobalNetworkConnections(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalNetworkConnectionListTypeValidator = func() *ValidateGlobalNetworkConnectionListType {
	v := &ValidateGlobalNetworkConnectionListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhGlobalNetworkConnections := v.GlobalNetworkConnectionsValidationRuleHandler
	rulesGlobalNetworkConnections := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhGlobalNetworkConnections(rulesGlobalNetworkConnections)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalNetworkConnectionListType.global_network_connections: %s", err)
		panic(errMsg)
	}
	v.FldValidators["global_network_connections"] = vFn

	return v
}()

func GlobalNetworkConnectionListTypeValidator() db.Validator {
	return DefaultGlobalNetworkConnectionListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalNetworkConnectionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalNetworkConnectionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalNetworkConnectionType) DeepCopy() *GlobalNetworkConnectionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalNetworkConnectionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalNetworkConnectionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalNetworkConnectionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalNetworkConnectionTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalNetworkConnectionType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetConnectionChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *GlobalNetworkConnectionType) GetConnectionChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.ConnectionChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetConnectionChoice().(type) {
	case *GlobalNetworkConnectionType_SliToGlobalDr:
		odrInfos, err = m.GetSliToGlobalDr().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "sli_to_global_dr." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *GlobalNetworkConnectionType_SloToGlobalDr:
		odrInfos, err = m.GetSloToGlobalDr().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "slo_to_global_dr." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

type ValidateGlobalNetworkConnectionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalNetworkConnectionType) ConnectionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalNetworkConnectionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalNetworkConnectionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalNetworkConnectionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_choice"]; exists {
		val := m.GetConnectionChoice()
		vOpts := append(opts,
			db.WithValidateField("connection_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConnectionChoice().(type) {
	case *GlobalNetworkConnectionType_SliToGlobalDr:
		if fv, exists := v.FldValidators["connection_choice.sli_to_global_dr"]; exists {
			val := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SliToGlobalDr).SliToGlobalDr
			vOpts := append(opts,
				db.WithValidateField("connection_choice"),
				db.WithValidateField("sli_to_global_dr"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalNetworkConnectionType_SloToGlobalDr:
		if fv, exists := v.FldValidators["connection_choice.slo_to_global_dr"]; exists {
			val := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SloToGlobalDr).SloToGlobalDr
			vOpts := append(opts,
				db.WithValidateField("connection_choice"),
				db.WithValidateField("slo_to_global_dr"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetForwardProxyChoice().(type) {
	case *GlobalNetworkConnectionType_DisableForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.disable_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_DisableForwardProxy).DisableForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("disable_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalNetworkConnectionType_EnableForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.enable_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_EnableForwardProxy).EnableForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("enable_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalNetworkConnectionTypeValidator = func() *ValidateGlobalNetworkConnectionType {
	v := &ValidateGlobalNetworkConnectionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConnectionChoice := v.ConnectionChoiceValidationRuleHandler
	rulesConnectionChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectionChoice(rulesConnectionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalNetworkConnectionType.connection_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_choice"] = vFn

	v.FldValidators["connection_choice.sli_to_global_dr"] = GlobalConnectorTypeValidator().Validate
	v.FldValidators["connection_choice.slo_to_global_dr"] = GlobalConnectorTypeValidator().Validate

	v.FldValidators["forward_proxy_choice.enable_forward_proxy"] = ves_io_schema.ForwardProxyConfigTypeValidator().Validate

	return v
}()

func GlobalNetworkConnectionTypeValidator() db.Validator {
	return DefaultGlobalNetworkConnectionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStaticRoutesListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStaticRoutesListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStaticRoutesListType) DeepCopy() *SiteStaticRoutesListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStaticRoutesListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStaticRoutesListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStaticRoutesListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStaticRoutesListTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteStaticRoutesListType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetStaticRouteListDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *SiteStaticRoutesListType) GetStaticRouteListDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.StaticRouteList == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.StaticRouteList {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("static_route_list[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateSiteStaticRoutesListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStaticRoutesListType) StaticRouteListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*SiteStaticRoutesType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := SiteStaticRoutesTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_route_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*SiteStaticRoutesType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*SiteStaticRoutesType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_route_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_route_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSiteStaticRoutesListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStaticRoutesListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStaticRoutesListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["static_route_list"]; exists {
		vOpts := append(opts, db.WithValidateField("static_route_list"))
		if err := fv(ctx, m.GetStaticRouteList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStaticRoutesListTypeValidator = func() *ValidateSiteStaticRoutesListType {
	v := &ValidateSiteStaticRoutesListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStaticRouteList := v.StaticRouteListValidationRuleHandler
	rulesStaticRouteList := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhStaticRouteList(rulesStaticRouteList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteStaticRoutesListType.static_route_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_route_list"] = vFn

	return v
}()

func SiteStaticRoutesListTypeValidator() db.Validator {
	return DefaultSiteStaticRoutesListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStaticRoutesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStaticRoutesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStaticRoutesType) DeepCopy() *SiteStaticRoutesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStaticRoutesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStaticRoutesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStaticRoutesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStaticRoutesTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteStaticRoutesType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetConfigModeChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *SiteStaticRoutesType) GetConfigModeChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.ConfigModeChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetConfigModeChoice().(type) {
	case *SiteStaticRoutesType_CustomStaticRoute:
		odrInfos, err = m.GetCustomStaticRoute().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "custom_static_route." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

type ValidateSiteStaticRoutesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStaticRoutesType) ConfigModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for config_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSiteStaticRoutesType) ConfigModeChoiceSimpleStaticRouteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SimpleStaticRoute, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for simple_static_route")
	}
	return oValidatorFn_SimpleStaticRoute, nil
}

func (v *ValidateSiteStaticRoutesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStaticRoutesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStaticRoutesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["config_mode_choice"]; exists {
		val := m.GetConfigModeChoice()
		vOpts := append(opts,
			db.WithValidateField("config_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConfigModeChoice().(type) {
	case *SiteStaticRoutesType_SimpleStaticRoute:
		if fv, exists := v.FldValidators["config_mode_choice.simple_static_route"]; exists {
			val := m.GetConfigModeChoice().(*SiteStaticRoutesType_SimpleStaticRoute).SimpleStaticRoute
			vOpts := append(opts,
				db.WithValidateField("config_mode_choice"),
				db.WithValidateField("simple_static_route"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteStaticRoutesType_CustomStaticRoute:
		if fv, exists := v.FldValidators["config_mode_choice.custom_static_route"]; exists {
			val := m.GetConfigModeChoice().(*SiteStaticRoutesType_CustomStaticRoute).CustomStaticRoute
			vOpts := append(opts,
				db.WithValidateField("config_mode_choice"),
				db.WithValidateField("custom_static_route"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStaticRoutesTypeValidator = func() *ValidateSiteStaticRoutesType {
	v := &ValidateSiteStaticRoutesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConfigModeChoice := v.ConfigModeChoiceValidationRuleHandler
	rulesConfigModeChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConfigModeChoice(rulesConfigModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteStaticRoutesType.config_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["config_mode_choice"] = vFn

	vrhConfigModeChoiceSimpleStaticRoute := v.ConfigModeChoiceSimpleStaticRouteValidationRuleHandler
	rulesConfigModeChoiceSimpleStaticRoute := map[string]string{
		"ves.io.schema.rules.string.ipv4_prefix": "true",
	}
	vFnMap["config_mode_choice.simple_static_route"], err = vrhConfigModeChoiceSimpleStaticRoute(rulesConfigModeChoiceSimpleStaticRoute)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SiteStaticRoutesType.config_mode_choice_simple_static_route: %s", err)
		panic(errMsg)
	}

	v.FldValidators["config_mode_choice.simple_static_route"] = vFnMap["config_mode_choice.simple_static_route"]

	v.FldValidators["config_mode_choice.custom_static_route"] = ves_io_schema.StaticRouteTypeValidator().Validate

	return v
}()

func SiteStaticRoutesTypeValidator() db.Validator {
	return DefaultSiteStaticRoutesTypeValidator
}

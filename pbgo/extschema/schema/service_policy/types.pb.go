// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/service_policy/types.proto

package service_policy

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	google_protobuf1 "github.com/gogo/protobuf/types"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// simple rule
//
// x-displayName: "Simple Rule"
// A SimpleRule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from
// or derived from an L7 request API. A request API is considered to match the simple rule if all predicates in the rule evaluate to true for that request. Any
// predicates that are not specified in a rule are implicitly considered to be true. If a request API matches a simple rule, the action for the simple rule is
// enforced.
//
// A SimpleRule does not currently support any predicates that contain references to objects.
type SimpleRule struct {
	// name
	//
	// x-displayName: "Name"
	// x-required
	// Name of the rule.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// action
	//
	// x-displayName: "Action"
	// x-required
	// Action to be enforced if the input request matches the rule.
	Action ves_io_schema_policy.RuleAction `protobuf:"varint,2,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// domain matcher
	//
	// x-displayName: "Domain Matcher"
	// A list of exact values and/or regular expressions for the expected name of the domain. The actual value of domain is the host component
	// from the URL. The predicate evaluates to true if the domain value matches any of the exact values or regular expressions in the domain
	// matcher.
	DomainMatcher *ves_io_schema_policy.MatcherType `protobuf:"bytes,3,opt,name=domain_matcher,json=domainMatcher" json:"domain_matcher,omitempty"`
	// path
	//
	// x-displayName: "HTTP Path"
	// A list of exact values, prefixes and regular expressions for the expected value of the HTTP path. The actual value of the HTTP path is the unescaped path
	// value extracted from the HTTP URL Resource, excluding any query and fragment information.
	// The predicate evaluates to true if the actual path value matches any of the exact or prefix values or regular expressions in the path matcher.
	Path *ves_io_schema_policy.PathMatcherType `protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
	// headers
	//
	// x-displayName: "HTTP Headers"
	// A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType
	// instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.
	// Note that all specified header predicates must evaluate to true.
	Headers []*ves_io_schema_policy.HeaderMatcherType `protobuf:"bytes,5,rep,name=headers" json:"headers,omitempty"`
	// method
	//
	// x-displayName: "HTTP Method"
	// The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.
	// The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.
	HttpMethod *ves_io_schema_policy.HttpMethodMatcherType `protobuf:"bytes,6,opt,name=http_method,json=httpMethod" json:"http_method,omitempty"`
	// App Firewall Action
	//
	// x-displayName: "App Firewall Action"
	// x-required
	// App Firewall action to be enforced if the input request matches the rule.
	WafAction *ves_io_schema_policy.WafAction `protobuf:"bytes,7,opt,name=waf_action,json=wafAction" json:"waf_action,omitempty"`
	// expiration timestamp
	//
	// x-displayName: "Expiration Timestamp"
	// x-example: "2019-12-31:44:34.171543432Z"
	// The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in
	// the configuration but is not applied anymore.
	ExpirationTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,8,opt,name=expiration_timestamp,json=expirationTimestamp" json:"expiration_timestamp,omitempty"`
	// scheme
	//
	// x-displayName: "Scheme"
	// x-example: "HTTPS"
	// The scheme in the request.
	Scheme []string `protobuf:"bytes,12,rep,name=scheme" json:"scheme,omitempty"`
	// port matcher
	//
	// x-displayName: "Port Matcher"
	// The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.
	PortMatcher *ves_io_schema_policy.PortMatcherType `protobuf:"bytes,10,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Deny access to Facebook"
	// Description for the rule.
	Description string `protobuf:"bytes,11,opt,name=description,proto3" json:"description,omitempty"`
	// url matcher
	//
	// x-displayName: "URL Matcher"
	// A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the domain and path match any of the URL items.
	UrlMatcher *ves_io_schema_policy.URLMatcherType `protobuf:"bytes,13,opt,name=url_matcher,json=urlMatcher" json:"url_matcher,omitempty"`
	// l4 dest matcher
	//
	// x-displayName: "L4 Destination Matcher"
	// A L4 Destination matcher specifies a list of IPv4 prefixes and a TCP port range as match criteria. The match is considered successful if the destination
	// IP matches one of the prefixes and the destination port belongs to the port range.
	L4DestMatcher *ves_io_schema_policy.L4DestMatcherType `protobuf:"bytes,14,opt,name=l4_dest_matcher,json=l4DestMatcher" json:"l4_dest_matcher,omitempty"`
	// ip prefix list
	//
	// x-displayName: "IPv4 Prefix List"
	// List of IPv4 Prefixes values.
	// The predicate evaluates to true if the client IPv4 Address is covered by one or more of the IPv4 Prefixes from the list.
	IpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,15,opt,name=ip_prefix_list,json=ipPrefixList" json:"ip_prefix_list,omitempty"`
	// dst ip prefix list
	//
	// x-displayName: "Destination IPv4 Prefix List"
	// List of IPv4 Prefixes values.
	// The predicate evaluates to true if the destination address is covered by one or more of the IPv4 Prefixes from the list.
	DstIpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,16,opt,name=dst_ip_prefix_list,json=dstIpPrefixList" json:"dst_ip_prefix_list,omitempty"`
}

func (m *SimpleRule) Reset()                    { *m = SimpleRule{} }
func (*SimpleRule) ProtoMessage()               {}
func (*SimpleRule) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *SimpleRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SimpleRule) GetAction() ves_io_schema_policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return ves_io_schema_policy.DENY
}

func (m *SimpleRule) GetDomainMatcher() *ves_io_schema_policy.MatcherType {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *SimpleRule) GetPath() *ves_io_schema_policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *SimpleRule) GetHeaders() []*ves_io_schema_policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *SimpleRule) GetHttpMethod() *ves_io_schema_policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *SimpleRule) GetWafAction() *ves_io_schema_policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *SimpleRule) GetExpirationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *SimpleRule) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *SimpleRule) GetPortMatcher() *ves_io_schema_policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *SimpleRule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SimpleRule) GetUrlMatcher() *ves_io_schema_policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *SimpleRule) GetL4DestMatcher() *ves_io_schema_policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *SimpleRule) GetIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if m != nil {
		return m.IpPrefixList
	}
	return nil
}

func (m *SimpleRule) GetDstIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if m != nil {
		return m.DstIpPrefixList
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Specification"
// Shape of service_policy in the storage backend.
type GlobalSpecType struct {
	// algo
	//
	// x-displayName: "Rule Combining Algorithm"
	// x-required
	// The rule combining algorithm determines how the list of rules in the policy is evaluated.
	//
	// - FIRST_MATCH Rules are evaluated sequentially till a matching rule is identified
	// - ALLOW_OVERRIDES Rules with an ALLOW action are evaluated prior to rules with a DENY action
	// - DENY_OVERRIDES Rules with a DENY action are evaluated prior to rules with an ALLOW action
	Algo ves_io_schema_policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// server choice
	//
	// x-displayName: "Server Selection"
	// x-required
	// Select servers for which the policy the will be applied.
	//
	// Types that are valid to be assigned to ServerChoice:
	//	*GlobalSpecType_AnyServer
	//	*GlobalSpecType_ServerName
	//	*GlobalSpecType_ServerSelector
	//	*GlobalSpecType_ServerNameMatcher
	ServerChoice isGlobalSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	// port matcher
	//
	// x-displayName: "Port Matcher"
	// The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.
	PortMatcher *ves_io_schema_policy.PortMatcherType `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
	// role
	//
	// x-displayName: "Role"
	// The expected role of the client invoking the request API. The actual roles for the client are derived from the user and namespace information in the API
	// request.
	// The predicate evaluates to true if any of the client's roles match the value specified in role.
	Role *ves_io_schema_policy.RoleMatcherType `protobuf:"bytes,7,opt,name=role" json:"role,omitempty"`
	// deny_info
	//
	// x-displayName: "Deny Information"
	// Detailed information including HTTP response code and error message to be sent when the policy action is DENY.
	DenyInfo *ves_io_schema_policy.DenyInformation `protobuf:"bytes,8,opt,name=deny_info,json=denyInfo" json:"deny_info,omitempty"`
	// Default Forwarding Classes
	//
	// x-displayName: "Default Forwarding Classes"
	// Ordered list of forwarding class to use for traffic that match the enclosing rule
	// Action valid only when the policy is used PBR
	DefaultForwardingClasses []*ves_io_schema4.ObjectRefType `protobuf:"bytes,9,rep,name=default_forwarding_classes,json=defaultForwardingClasses" json:"default_forwarding_classes,omitempty"`
	// rules
	//
	// x-displayName: "Rules"
	// A list of references to service_policy_rule objects.
	// The order of evaluation of the rules depends on the rule combining algorithm.
	Rules []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=rules" json:"rules,omitempty"`
	// simple_rules
	//
	// x-displayName: "Simple Rules"
	// A list of SimpleRules.
	// The order of evaluation of the simple rules depends on the rule combining algorithm.
	//
	// This is mutually exclusive with the rules field and is for internal use only.
	SimpleRules []*SimpleRule `protobuf:"bytes,1001,rep,name=simple_rules,json=simpleRules" json:"simple_rules,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

type isGlobalSpecType_ServerChoice interface {
	isGlobalSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AnyServer struct {
	AnyServer *ves_io_schema4.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,oneof"`
}
type GlobalSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof"`
}
type GlobalSpecType_ServerSelector struct {
	ServerSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,oneof"`
}
type GlobalSpecType_ServerNameMatcher struct {
	ServerNameMatcher *ves_io_schema_policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,oneof"`
}

func (*GlobalSpecType_AnyServer) isGlobalSpecType_ServerChoice()         {}
func (*GlobalSpecType_ServerName) isGlobalSpecType_ServerChoice()        {}
func (*GlobalSpecType_ServerSelector) isGlobalSpecType_ServerChoice()    {}
func (*GlobalSpecType_ServerNameMatcher) isGlobalSpecType_ServerChoice() {}

func (m *GlobalSpecType) GetServerChoice() isGlobalSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}

func (m *GlobalSpecType) GetAlgo() ves_io_schema_policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return ves_io_schema_policy.FIRST_MATCH
}

func (m *GlobalSpecType) GetAnyServer() *ves_io_schema4.Empty {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *GlobalSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GlobalSpecType) GetServerSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *GlobalSpecType) GetServerNameMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetPortMatcher() *ves_io_schema_policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetRole() *ves_io_schema_policy.RoleMatcherType {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *GlobalSpecType) GetDenyInfo() *ves_io_schema_policy.DenyInformation {
	if m != nil {
		return m.DenyInfo
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultForwardingClasses() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.DefaultForwardingClasses
	}
	return nil
}

func (m *GlobalSpecType) GetRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *GlobalSpecType) GetSimpleRules() []*SimpleRule {
	if m != nil {
		return m.SimpleRules
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_AnyServer)(nil),
		(*GlobalSpecType_ServerName)(nil),
		(*GlobalSpecType_ServerSelector)(nil),
		(*GlobalSpecType_ServerNameMatcher)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// server_choice
	switch x := m.ServerChoice.(type) {
	case *GlobalSpecType_AnyServer:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyServer); err != nil {
			return err
		}
	case *GlobalSpecType_ServerName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ServerName)
	case *GlobalSpecType_ServerSelector:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerSelector); err != nil {
			return err
		}
	case *GlobalSpecType_ServerNameMatcher:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerNameMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.ServerChoice has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 11: // server_choice.any_server
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &GlobalSpecType_AnyServer{msg}
		return true, err
	case 2: // server_choice.server_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServerChoice = &GlobalSpecType_ServerName{x}
		return true, err
	case 3: // server_choice.server_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &GlobalSpecType_ServerSelector{msg}
		return true, err
	case 5: // server_choice.server_name_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.MatcherTypeBasic)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &GlobalSpecType_ServerNameMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// server_choice
	switch x := m.ServerChoice.(type) {
	case *GlobalSpecType_AnyServer:
		s := proto.Size(x.AnyServer)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_ServerName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ServerName)))
		n += len(x.ServerName)
	case *GlobalSpecType_ServerSelector:
		s := proto.Size(x.ServerSelector)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_ServerNameMatcher:
		s := proto.Size(x.ServerNameMatcher)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create service policy
//
// x-displayName: "Specification"
// Create service_policy creates a new object in the storage backend for metadata.namespace.
type CreateSpecType struct {
	Algo ves_io_schema_policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// Types that are valid to be assigned to ServerChoice:
	//	*CreateSpecType_AnyServer
	//	*CreateSpecType_ServerName
	//	*CreateSpecType_ServerSelector
	//	*CreateSpecType_ServerNameMatcher
	ServerChoice isCreateSpecType_ServerChoice         `protobuf_oneof:"server_choice"`
	Rules        []*ves_io_schema4.ObjectRefType       `protobuf:"bytes,4,rep,name=rules" json:"rules,omitempty"`
	PortMatcher  *ves_io_schema_policy.PortMatcherType `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isCreateSpecType_ServerChoice interface {
	isCreateSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AnyServer struct {
	AnyServer *ves_io_schema4.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,oneof"`
}
type CreateSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof"`
}
type CreateSpecType_ServerSelector struct {
	ServerSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,oneof"`
}
type CreateSpecType_ServerNameMatcher struct {
	ServerNameMatcher *ves_io_schema_policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,oneof"`
}

func (*CreateSpecType_AnyServer) isCreateSpecType_ServerChoice()         {}
func (*CreateSpecType_ServerName) isCreateSpecType_ServerChoice()        {}
func (*CreateSpecType_ServerSelector) isCreateSpecType_ServerChoice()    {}
func (*CreateSpecType_ServerNameMatcher) isCreateSpecType_ServerChoice() {}

func (m *CreateSpecType) GetServerChoice() isCreateSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}

func (m *CreateSpecType) GetAlgo() ves_io_schema_policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return ves_io_schema_policy.FIRST_MATCH
}

func (m *CreateSpecType) GetAnyServer() *ves_io_schema4.Empty {
	if x, ok := m.GetServerChoice().(*CreateSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *CreateSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *CreateSpecType) GetServerSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *CreateSpecType) GetServerNameMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *CreateSpecType) GetRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *CreateSpecType) GetPortMatcher() *ves_io_schema_policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_AnyServer)(nil),
		(*CreateSpecType_ServerName)(nil),
		(*CreateSpecType_ServerSelector)(nil),
		(*CreateSpecType_ServerNameMatcher)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// server_choice
	switch x := m.ServerChoice.(type) {
	case *CreateSpecType_AnyServer:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyServer); err != nil {
			return err
		}
	case *CreateSpecType_ServerName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ServerName)
	case *CreateSpecType_ServerSelector:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerSelector); err != nil {
			return err
		}
	case *CreateSpecType_ServerNameMatcher:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerNameMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.ServerChoice has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 11: // server_choice.any_server
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &CreateSpecType_AnyServer{msg}
		return true, err
	case 2: // server_choice.server_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServerChoice = &CreateSpecType_ServerName{x}
		return true, err
	case 3: // server_choice.server_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &CreateSpecType_ServerSelector{msg}
		return true, err
	case 5: // server_choice.server_name_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.MatcherTypeBasic)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &CreateSpecType_ServerNameMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// server_choice
	switch x := m.ServerChoice.(type) {
	case *CreateSpecType_AnyServer:
		s := proto.Size(x.AnyServer)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_ServerName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ServerName)))
		n += len(x.ServerName)
	case *CreateSpecType_ServerSelector:
		s := proto.Size(x.ServerSelector)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_ServerNameMatcher:
		s := proto.Size(x.ServerNameMatcher)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace service policy
//
// x-displayName: "Specification"
// Replace service_policy replaces an existing object in the storage backend for metadata.namespace.
type ReplaceSpecType struct {
	Algo ves_io_schema_policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// Types that are valid to be assigned to ServerChoice:
	//	*ReplaceSpecType_AnyServer
	//	*ReplaceSpecType_ServerName
	//	*ReplaceSpecType_ServerSelector
	//	*ReplaceSpecType_ServerNameMatcher
	ServerChoice isReplaceSpecType_ServerChoice        `protobuf_oneof:"server_choice"`
	Rules        []*ves_io_schema4.ObjectRefType       `protobuf:"bytes,4,rep,name=rules" json:"rules,omitempty"`
	PortMatcher  *ves_io_schema_policy.PortMatcherType `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

type isReplaceSpecType_ServerChoice interface {
	isReplaceSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AnyServer struct {
	AnyServer *ves_io_schema4.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,oneof"`
}
type ReplaceSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof"`
}
type ReplaceSpecType_ServerSelector struct {
	ServerSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,oneof"`
}
type ReplaceSpecType_ServerNameMatcher struct {
	ServerNameMatcher *ves_io_schema_policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,oneof"`
}

func (*ReplaceSpecType_AnyServer) isReplaceSpecType_ServerChoice()         {}
func (*ReplaceSpecType_ServerName) isReplaceSpecType_ServerChoice()        {}
func (*ReplaceSpecType_ServerSelector) isReplaceSpecType_ServerChoice()    {}
func (*ReplaceSpecType_ServerNameMatcher) isReplaceSpecType_ServerChoice() {}

func (m *ReplaceSpecType) GetServerChoice() isReplaceSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetAlgo() ves_io_schema_policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return ves_io_schema_policy.FIRST_MATCH
}

func (m *ReplaceSpecType) GetAnyServer() *ves_io_schema4.Empty {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *ReplaceSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *ReplaceSpecType) GetServerSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetServerNameMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *ReplaceSpecType) GetPortMatcher() *ves_io_schema_policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_AnyServer)(nil),
		(*ReplaceSpecType_ServerName)(nil),
		(*ReplaceSpecType_ServerSelector)(nil),
		(*ReplaceSpecType_ServerNameMatcher)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// server_choice
	switch x := m.ServerChoice.(type) {
	case *ReplaceSpecType_AnyServer:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyServer); err != nil {
			return err
		}
	case *ReplaceSpecType_ServerName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ServerName)
	case *ReplaceSpecType_ServerSelector:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerSelector); err != nil {
			return err
		}
	case *ReplaceSpecType_ServerNameMatcher:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerNameMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.ServerChoice has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 11: // server_choice.any_server
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &ReplaceSpecType_AnyServer{msg}
		return true, err
	case 2: // server_choice.server_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServerChoice = &ReplaceSpecType_ServerName{x}
		return true, err
	case 3: // server_choice.server_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &ReplaceSpecType_ServerSelector{msg}
		return true, err
	case 5: // server_choice.server_name_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.MatcherTypeBasic)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &ReplaceSpecType_ServerNameMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// server_choice
	switch x := m.ServerChoice.(type) {
	case *ReplaceSpecType_AnyServer:
		s := proto.Size(x.AnyServer)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_ServerName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ServerName)))
		n += len(x.ServerName)
	case *ReplaceSpecType_ServerSelector:
		s := proto.Size(x.ServerSelector)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_ServerNameMatcher:
		s := proto.Size(x.ServerNameMatcher)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get service policy
//
// x-displayName: "Specification"
// Get service_policy reads a given object from storage backend for metadata.namespace.
type GetSpecType struct {
	Algo ves_io_schema_policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// Types that are valid to be assigned to ServerChoice:
	//	*GetSpecType_AnyServer
	//	*GetSpecType_ServerName
	//	*GetSpecType_ServerSelector
	//	*GetSpecType_ServerNameMatcher
	ServerChoice isGetSpecType_ServerChoice            `protobuf_oneof:"server_choice"`
	Rules        []*ves_io_schema4.ObjectRefType       `protobuf:"bytes,4,rep,name=rules" json:"rules,omitempty"`
	PortMatcher  *ves_io_schema_policy.PortMatcherType `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
	SimpleRules  []*SimpleRule                         `protobuf:"bytes,1001,rep,name=simple_rules,json=simpleRules" json:"simple_rules,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isGetSpecType_ServerChoice interface {
	isGetSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AnyServer struct {
	AnyServer *ves_io_schema4.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,oneof"`
}
type GetSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof"`
}
type GetSpecType_ServerSelector struct {
	ServerSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,oneof"`
}
type GetSpecType_ServerNameMatcher struct {
	ServerNameMatcher *ves_io_schema_policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,oneof"`
}

func (*GetSpecType_AnyServer) isGetSpecType_ServerChoice()         {}
func (*GetSpecType_ServerName) isGetSpecType_ServerChoice()        {}
func (*GetSpecType_ServerSelector) isGetSpecType_ServerChoice()    {}
func (*GetSpecType_ServerNameMatcher) isGetSpecType_ServerChoice() {}

func (m *GetSpecType) GetServerChoice() isGetSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}

func (m *GetSpecType) GetAlgo() ves_io_schema_policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return ves_io_schema_policy.FIRST_MATCH
}

func (m *GetSpecType) GetAnyServer() *ves_io_schema4.Empty {
	if x, ok := m.GetServerChoice().(*GetSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *GetSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GetSpecType) GetServerSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *GetSpecType) GetServerNameMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *GetSpecType) GetRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *GetSpecType) GetPortMatcher() *ves_io_schema_policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GetSpecType) GetSimpleRules() []*SimpleRule {
	if m != nil {
		return m.SimpleRules
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_AnyServer)(nil),
		(*GetSpecType_ServerName)(nil),
		(*GetSpecType_ServerSelector)(nil),
		(*GetSpecType_ServerNameMatcher)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// server_choice
	switch x := m.ServerChoice.(type) {
	case *GetSpecType_AnyServer:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyServer); err != nil {
			return err
		}
	case *GetSpecType_ServerName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ServerName)
	case *GetSpecType_ServerSelector:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerSelector); err != nil {
			return err
		}
	case *GetSpecType_ServerNameMatcher:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerNameMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.ServerChoice has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 11: // server_choice.any_server
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &GetSpecType_AnyServer{msg}
		return true, err
	case 2: // server_choice.server_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServerChoice = &GetSpecType_ServerName{x}
		return true, err
	case 3: // server_choice.server_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &GetSpecType_ServerSelector{msg}
		return true, err
	case 5: // server_choice.server_name_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.MatcherTypeBasic)
		err := b.DecodeMessage(msg)
		m.ServerChoice = &GetSpecType_ServerNameMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// server_choice
	switch x := m.ServerChoice.(type) {
	case *GetSpecType_AnyServer:
		s := proto.Size(x.AnyServer)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_ServerName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ServerName)))
		n += len(x.ServerName)
	case *GetSpecType_ServerSelector:
		s := proto.Size(x.ServerSelector)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_ServerNameMatcher:
		s := proto.Size(x.ServerNameMatcher)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*SimpleRule)(nil), "ves.io.schema.service_policy.SimpleRule")
	golang_proto.RegisterType((*SimpleRule)(nil), "ves.io.schema.service_policy.SimpleRule")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy.GetSpecType")
}
func (this *SimpleRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleRule)
	if !ok {
		that2, ok := that.(SimpleRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.Role.Equal(that1.Role) {
		return false
	}
	if !this.DenyInfo.Equal(that1.DenyInfo) {
		return false
	}
	if len(this.DefaultForwardingClasses) != len(that1.DefaultForwardingClasses) {
		return false
	}
	for i := range this.DefaultForwardingClasses {
		if !this.DefaultForwardingClasses[i].Equal(that1.DefaultForwardingClasses[i]) {
			return false
		}
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if len(this.SimpleRules) != len(that1.SimpleRules) {
		return false
	}
	for i := range this.SimpleRules {
		if !this.SimpleRules[i].Equal(that1.SimpleRules[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyServer)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerName)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyServer)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerName)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyServer)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if len(this.SimpleRules) != len(that1.SimpleRules) {
		return false
	}
	for i := range this.SimpleRules {
		if !this.SimpleRules[i].Equal(that1.SimpleRules[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyServer)
	if !ok {
		that2, ok := that.(GetSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *GetSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerName)
	if !ok {
		that2, ok := that.(GetSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GetSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(GetSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *GetSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *SimpleRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&service_policy.SimpleRule{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	if this.IpPrefixList != nil {
		s = append(s, "IpPrefixList: "+fmt.Sprintf("%#v", this.IpPrefixList)+",\n")
	}
	if this.DstIpPrefixList != nil {
		s = append(s, "DstIpPrefixList: "+fmt.Sprintf("%#v", this.DstIpPrefixList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&service_policy.GlobalSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.Role != nil {
		s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	}
	if this.DenyInfo != nil {
		s = append(s, "DenyInfo: "+fmt.Sprintf("%#v", this.DenyInfo)+",\n")
	}
	if this.DefaultForwardingClasses != nil {
		s = append(s, "DefaultForwardingClasses: "+fmt.Sprintf("%#v", this.DefaultForwardingClasses)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.SimpleRules != nil {
		s = append(s, "SimpleRules: "+fmt.Sprintf("%#v", this.SimpleRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&service_policy.CreateSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&service_policy.ReplaceSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&service_policy.GetSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.SimpleRules != nil {
		s = append(s, "SimpleRules: "+fmt.Sprintf("%#v", this.SimpleRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SimpleRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Action != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	if m.DomainMatcher != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DomainMatcher.Size()))
		n1, err := m.DomainMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Path != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Path.Size()))
		n2, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HttpMethod != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod.Size()))
		n3, err := m.HttpMethod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.WafAction != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafAction.Size()))
		n4, err := m.WafAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ExpirationTimestamp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTimestamp.Size()))
		n5, err := m.ExpirationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.PortMatcher != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortMatcher.Size()))
		n6, err := m.PortMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.UrlMatcher != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UrlMatcher.Size()))
		n7, err := m.UrlMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.L4DestMatcher != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.L4DestMatcher.Size()))
		n8, err := m.L4DestMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.IpPrefixList != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixList.Size()))
		n9, err := m.IpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.DstIpPrefixList != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIpPrefixList.Size()))
		n10, err := m.DstIpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Algo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		nn11, err := m.ServerChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PortMatcher != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortMatcher.Size()))
		n12, err := m.PortMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Role != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Role.Size()))
		n13, err := m.Role.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.DenyInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DenyInfo.Size()))
		n14, err := m.DenyInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.DefaultForwardingClasses) > 0 {
		for _, msg := range m.DefaultForwardingClasses {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SimpleRules) > 0 {
		for _, msg := range m.SimpleRules {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x3e
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GlobalSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i += copy(dAtA[i:], m.ServerName)
	return i, nil
}
func (m *GlobalSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerSelector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerSelector.Size()))
		n15, err := m.ServerSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *GlobalSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerNameMatcher != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerNameMatcher.Size()))
		n16, err := m.ServerNameMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *GlobalSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyServer != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyServer.Size()))
		n17, err := m.AnyServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Algo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		nn18, err := m.ServerChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn18
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PortMatcher != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortMatcher.Size()))
		n19, err := m.PortMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *CreateSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i += copy(dAtA[i:], m.ServerName)
	return i, nil
}
func (m *CreateSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerSelector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerSelector.Size()))
		n20, err := m.ServerSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *CreateSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerNameMatcher != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerNameMatcher.Size()))
		n21, err := m.ServerNameMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *CreateSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyServer != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyServer.Size()))
		n22, err := m.AnyServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Algo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		nn23, err := m.ServerChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PortMatcher != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortMatcher.Size()))
		n24, err := m.PortMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *ReplaceSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i += copy(dAtA[i:], m.ServerName)
	return i, nil
}
func (m *ReplaceSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerSelector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerSelector.Size()))
		n25, err := m.ServerSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *ReplaceSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerNameMatcher != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerNameMatcher.Size()))
		n26, err := m.ServerNameMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *ReplaceSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyServer != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyServer.Size()))
		n27, err := m.AnyServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Algo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		nn28, err := m.ServerChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn28
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PortMatcher != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortMatcher.Size()))
		n29, err := m.PortMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.SimpleRules) > 0 {
		for _, msg := range m.SimpleRules {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x3e
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i += copy(dAtA[i:], m.ServerName)
	return i, nil
}
func (m *GetSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerSelector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerSelector.Size()))
		n30, err := m.ServerSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *GetSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerNameMatcher != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerNameMatcher.Size()))
		n31, err := m.ServerNameMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *GetSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyServer != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyServer.Size()))
		n32, err := m.AnyServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedSimpleRule(r randyTypes, easy bool) *SimpleRule {
	this := &SimpleRule{}
	this.Name = string(randStringTypes(r))
	this.Action = ves_io_schema_policy.RuleAction([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(10) != 0 {
		this.DomainMatcher = ves_io_schema_policy.NewPopulatedMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Path = ves_io_schema_policy.NewPopulatedPathMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Headers = make([]*ves_io_schema_policy.HeaderMatcherType, v1)
		for i := 0; i < v1; i++ {
			this.Headers[i] = ves_io_schema_policy.NewPopulatedHeaderMatcherType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.HttpMethod = ves_io_schema_policy.NewPopulatedHttpMethodMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.WafAction = ves_io_schema_policy.NewPopulatedWafAction(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ExpirationTimestamp = google_protobuf1.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.PortMatcher = ves_io_schema_policy.NewPopulatedPortMatcherType(r, easy)
	}
	this.Description = string(randStringTypes(r))
	v2 := r.Intn(10)
	this.Scheme = make([]string, v2)
	for i := 0; i < v2; i++ {
		this.Scheme[i] = string(randStringTypes(r))
	}
	if r.Intn(10) != 0 {
		this.UrlMatcher = ves_io_schema_policy.NewPopulatedURLMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.L4DestMatcher = ves_io_schema_policy.NewPopulatedL4DestMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.IpPrefixList = ves_io_schema_policy.NewPopulatedPrefixMatchList(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DstIpPrefixList = ves_io_schema_policy.NewPopulatedPrefixMatchList(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	this.Algo = ves_io_schema_policy.RuleCombiningAlgorithm([]int32{0, 1, 2}[r.Intn(3)])
	oneofNumber_ServerChoice := []int32{2, 3, 5, 11}[r.Intn(4)]
	switch oneofNumber_ServerChoice {
	case 2:
		this.ServerChoice = NewPopulatedGlobalSpecType_ServerName(r, easy)
	case 3:
		this.ServerChoice = NewPopulatedGlobalSpecType_ServerSelector(r, easy)
	case 5:
		this.ServerChoice = NewPopulatedGlobalSpecType_ServerNameMatcher(r, easy)
	case 11:
		this.ServerChoice = NewPopulatedGlobalSpecType_AnyServer(r, easy)
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Rules = make([]*ves_io_schema4.ObjectRefType, v3)
		for i := 0; i < v3; i++ {
			this.Rules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.PortMatcher = ves_io_schema_policy.NewPopulatedPortMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Role = ves_io_schema_policy.NewPopulatedRoleMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DenyInfo = ves_io_schema_policy.NewPopulatedDenyInformation(r, easy)
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.DefaultForwardingClasses = make([]*ves_io_schema4.ObjectRefType, v4)
		for i := 0; i < v4; i++ {
			this.DefaultForwardingClasses[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.SimpleRules = make([]*SimpleRule, v5)
		for i := 0; i < v5; i++ {
			this.SimpleRules[i] = NewPopulatedSimpleRule(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType_ServerName(r randyTypes, easy bool) *GlobalSpecType_ServerName {
	this := &GlobalSpecType_ServerName{}
	this.ServerName = string(randStringTypes(r))
	return this
}
func NewPopulatedGlobalSpecType_ServerSelector(r randyTypes, easy bool) *GlobalSpecType_ServerSelector {
	this := &GlobalSpecType_ServerSelector{}
	this.ServerSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_ServerNameMatcher(r randyTypes, easy bool) *GlobalSpecType_ServerNameMatcher {
	this := &GlobalSpecType_ServerNameMatcher{}
	this.ServerNameMatcher = ves_io_schema_policy.NewPopulatedMatcherTypeBasic(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_AnyServer(r randyTypes, easy bool) *GlobalSpecType_AnyServer {
	this := &GlobalSpecType_AnyServer{}
	this.AnyServer = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	this.Algo = ves_io_schema_policy.RuleCombiningAlgorithm([]int32{0, 1, 2}[r.Intn(3)])
	oneofNumber_ServerChoice := []int32{2, 3, 5, 11}[r.Intn(4)]
	switch oneofNumber_ServerChoice {
	case 2:
		this.ServerChoice = NewPopulatedCreateSpecType_ServerName(r, easy)
	case 3:
		this.ServerChoice = NewPopulatedCreateSpecType_ServerSelector(r, easy)
	case 5:
		this.ServerChoice = NewPopulatedCreateSpecType_ServerNameMatcher(r, easy)
	case 11:
		this.ServerChoice = NewPopulatedCreateSpecType_AnyServer(r, easy)
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.Rules = make([]*ves_io_schema4.ObjectRefType, v6)
		for i := 0; i < v6; i++ {
			this.Rules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.PortMatcher = ves_io_schema_policy.NewPopulatedPortMatcherType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType_ServerName(r randyTypes, easy bool) *CreateSpecType_ServerName {
	this := &CreateSpecType_ServerName{}
	this.ServerName = string(randStringTypes(r))
	return this
}
func NewPopulatedCreateSpecType_ServerSelector(r randyTypes, easy bool) *CreateSpecType_ServerSelector {
	this := &CreateSpecType_ServerSelector{}
	this.ServerSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_ServerNameMatcher(r randyTypes, easy bool) *CreateSpecType_ServerNameMatcher {
	this := &CreateSpecType_ServerNameMatcher{}
	this.ServerNameMatcher = ves_io_schema_policy.NewPopulatedMatcherTypeBasic(r, easy)
	return this
}
func NewPopulatedCreateSpecType_AnyServer(r randyTypes, easy bool) *CreateSpecType_AnyServer {
	this := &CreateSpecType_AnyServer{}
	this.AnyServer = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	this.Algo = ves_io_schema_policy.RuleCombiningAlgorithm([]int32{0, 1, 2}[r.Intn(3)])
	oneofNumber_ServerChoice := []int32{2, 3, 5, 11}[r.Intn(4)]
	switch oneofNumber_ServerChoice {
	case 2:
		this.ServerChoice = NewPopulatedReplaceSpecType_ServerName(r, easy)
	case 3:
		this.ServerChoice = NewPopulatedReplaceSpecType_ServerSelector(r, easy)
	case 5:
		this.ServerChoice = NewPopulatedReplaceSpecType_ServerNameMatcher(r, easy)
	case 11:
		this.ServerChoice = NewPopulatedReplaceSpecType_AnyServer(r, easy)
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Rules = make([]*ves_io_schema4.ObjectRefType, v7)
		for i := 0; i < v7; i++ {
			this.Rules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.PortMatcher = ves_io_schema_policy.NewPopulatedPortMatcherType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType_ServerName(r randyTypes, easy bool) *ReplaceSpecType_ServerName {
	this := &ReplaceSpecType_ServerName{}
	this.ServerName = string(randStringTypes(r))
	return this
}
func NewPopulatedReplaceSpecType_ServerSelector(r randyTypes, easy bool) *ReplaceSpecType_ServerSelector {
	this := &ReplaceSpecType_ServerSelector{}
	this.ServerSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_ServerNameMatcher(r randyTypes, easy bool) *ReplaceSpecType_ServerNameMatcher {
	this := &ReplaceSpecType_ServerNameMatcher{}
	this.ServerNameMatcher = ves_io_schema_policy.NewPopulatedMatcherTypeBasic(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_AnyServer(r randyTypes, easy bool) *ReplaceSpecType_AnyServer {
	this := &ReplaceSpecType_AnyServer{}
	this.AnyServer = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	this.Algo = ves_io_schema_policy.RuleCombiningAlgorithm([]int32{0, 1, 2}[r.Intn(3)])
	oneofNumber_ServerChoice := []int32{2, 3, 5, 11}[r.Intn(4)]
	switch oneofNumber_ServerChoice {
	case 2:
		this.ServerChoice = NewPopulatedGetSpecType_ServerName(r, easy)
	case 3:
		this.ServerChoice = NewPopulatedGetSpecType_ServerSelector(r, easy)
	case 5:
		this.ServerChoice = NewPopulatedGetSpecType_ServerNameMatcher(r, easy)
	case 11:
		this.ServerChoice = NewPopulatedGetSpecType_AnyServer(r, easy)
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.Rules = make([]*ves_io_schema4.ObjectRefType, v8)
		for i := 0; i < v8; i++ {
			this.Rules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.PortMatcher = ves_io_schema_policy.NewPopulatedPortMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.SimpleRules = make([]*SimpleRule, v9)
		for i := 0; i < v9; i++ {
			this.SimpleRules[i] = NewPopulatedSimpleRule(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType_ServerName(r randyTypes, easy bool) *GetSpecType_ServerName {
	this := &GetSpecType_ServerName{}
	this.ServerName = string(randStringTypes(r))
	return this
}
func NewPopulatedGetSpecType_ServerSelector(r randyTypes, easy bool) *GetSpecType_ServerSelector {
	this := &GetSpecType_ServerSelector{}
	this.ServerSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedGetSpecType_ServerNameMatcher(r randyTypes, easy bool) *GetSpecType_ServerNameMatcher {
	this := &GetSpecType_ServerNameMatcher{}
	this.ServerNameMatcher = ves_io_schema_policy.NewPopulatedMatcherTypeBasic(r, easy)
	return this
}
func NewPopulatedGetSpecType_AnyServer(r randyTypes, easy bool) *GetSpecType_AnyServer {
	this := &GetSpecType_AnyServer{}
	this.AnyServer = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v10 := r.Intn(100)
	tmps := make([]rune, v10)
	for i := 0; i < v10; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v11 := r.Int63()
		if r.Intn(2) == 0 {
			v11 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v11))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *SimpleRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DenyInfo != nil {
		l = m.DenyInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DefaultForwardingClasses) > 0 {
		for _, e := range m.DefaultForwardingClasses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SimpleRules) > 0 {
		for _, e := range m.SimpleRules {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_ServerName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ServerSelector) Size() (n int) {
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ServerNameMatcher) Size() (n int) {
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyServer) Size() (n int) {
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_ServerName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_ServerSelector) Size() (n int) {
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ServerNameMatcher) Size() (n int) {
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyServer) Size() (n int) {
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_ServerName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_ServerSelector) Size() (n int) {
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ServerNameMatcher) Size() (n int) {
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyServer) Size() (n int) {
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.SimpleRules) > 0 {
		for _, e := range m.SimpleRules {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_ServerName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_ServerSelector) Size() (n int) {
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ServerNameMatcher) Size() (n int) {
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyServer) Size() (n int) {
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SimpleRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleRule{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "ves_io_schema_policy.PathMatcherType", 1) + `,`,
		`Headers:` + strings.Replace(fmt.Sprintf("%v", this.Headers), "HeaderMatcherType", "ves_io_schema_policy.HeaderMatcherType", 1) + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "ves_io_schema_policy.HttpMethodMatcherType", 1) + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "ves_io_schema_policy.WafAction", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "ves_io_schema_policy.PortMatcherType", 1) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "ves_io_schema_policy.URLMatcherType", 1) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "ves_io_schema_policy.L4DestMatcherType", 1) + `,`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + strings.Replace(fmt.Sprintf("%v", this.Rules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "ves_io_schema_policy.PortMatcherType", 1) + `,`,
		`Role:` + strings.Replace(fmt.Sprintf("%v", this.Role), "RoleMatcherType", "ves_io_schema_policy.RoleMatcherType", 1) + `,`,
		`DenyInfo:` + strings.Replace(fmt.Sprintf("%v", this.DenyInfo), "DenyInformation", "ves_io_schema_policy.DenyInformation", 1) + `,`,
		`DefaultForwardingClasses:` + strings.Replace(fmt.Sprintf("%v", this.DefaultForwardingClasses), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`SimpleRules:` + strings.Replace(fmt.Sprintf("%v", this.SimpleRules), "SimpleRule", "SimpleRule", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + strings.Replace(fmt.Sprintf("%v", this.Rules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "ves_io_schema_policy.PortMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + strings.Replace(fmt.Sprintf("%v", this.Rules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "ves_io_schema_policy.PortMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + strings.Replace(fmt.Sprintf("%v", this.Rules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "ves_io_schema_policy.PortMatcherType", 1) + `,`,
		`SimpleRules:` + strings.Replace(fmt.Sprintf("%v", this.SimpleRules), "SimpleRule", "SimpleRule", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SimpleRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (ves_io_schema_policy.RuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &ves_io_schema_policy.MatcherType{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &ves_io_schema_policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &ves_io_schema_policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &ves_io_schema_policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &ves_io_schema_policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &ves_io_schema_policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &ves_io_schema_policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &ves_io_schema_policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpPrefixList == nil {
				m.IpPrefixList = &ves_io_schema_policy.PrefixMatchList{}
			}
			if err := m.IpPrefixList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIpPrefixList == nil {
				m.DstIpPrefixList = &ves_io_schema_policy.PrefixMatchList{}
			}
			if err := m.DstIpPrefixList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= (ves_io_schema_policy.RuleCombiningAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &GlobalSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &ves_io_schema4.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &ves_io_schema_policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &ves_io_schema_policy.RoleMatcherType{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenyInfo == nil {
				m.DenyInfo = &ves_io_schema_policy.DenyInformation{}
			}
			if err := m.DenyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultForwardingClasses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultForwardingClasses = append(m.DefaultForwardingClasses, &ves_io_schema4.ObjectRefType{})
			if err := m.DefaultForwardingClasses[len(m.DefaultForwardingClasses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_AnyServer{v}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SimpleRules = append(m.SimpleRules, &SimpleRule{})
			if err := m.SimpleRules[len(m.SimpleRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= (ves_io_schema_policy.RuleCombiningAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &CreateSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &ves_io_schema4.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &ves_io_schema_policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_AnyServer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= (ves_io_schema_policy.RuleCombiningAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &ReplaceSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &ves_io_schema4.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &ves_io_schema_policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_AnyServer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= (ves_io_schema_policy.RuleCombiningAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &GetSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &ves_io_schema4.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &ves_io_schema_policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_AnyServer{v}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SimpleRules = append(m.SimpleRules, &SimpleRule{})
			if err := m.SimpleRules[len(m.SimpleRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/service_policy/types.proto", fileDescriptorTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/service_policy/types.proto", fileDescriptorTypes)
}

var fileDescriptorTypes = []byte{
	// 1313 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xf7, 0xd8, 0x4e, 0x62, 0xcf, 0x26, 0x8e, 0x3b, 0xad, 0xbe, 0xda, 0x6f, 0xa8, 0xb6, 0xae,
	0xd5, 0x16, 0x0b, 0x9c, 0x35, 0x75, 0x53, 0x04, 0x3d, 0x54, 0xc4, 0xe9, 0x0f, 0xb7, 0x75, 0x4a,
	0x59, 0xbb, 0xa2, 0x80, 0xd0, 0x76, 0xbc, 0x3b, 0xb6, 0x17, 0x76, 0x77, 0x56, 0xbb, 0xe3, 0xa4,
	0x3e, 0x44, 0x8a, 0xf8, 0x0b, 0x50, 0x85, 0xe0, 0x5f, 0x40, 0x95, 0xb8, 0x23, 0x72, 0x89, 0x38,
	0x21, 0x4e, 0x3d, 0x46, 0x9c, 0x88, 0x7b, 0x69, 0x6f, 0x15, 0x27, 0xc4, 0x09, 0xed, 0xec, 0xfa,
	0xc7, 0x1a, 0xa7, 0xd0, 0x96, 0x5e, 0x50, 0x4e, 0x99, 0x1f, 0x9f, 0xf7, 0x99, 0xf7, 0xde, 0x7c,
	0xde, 0x1b, 0x67, 0x61, 0x61, 0x83, 0x78, 0xb2, 0x41, 0x4b, 0x9e, 0xd6, 0x21, 0x16, 0x2e, 0x79,
	0xc4, 0xdd, 0x30, 0x34, 0xa2, 0x3a, 0xd4, 0x34, 0xb4, 0x5e, 0x89, 0xf5, 0x1c, 0xe2, 0xc9, 0x8e,
	0x4b, 0x19, 0x45, 0xc7, 0x03, 0xa4, 0x1c, 0x20, 0xe5, 0x28, 0x72, 0x69, 0xb9, 0x6d, 0xb0, 0x4e,
	0xb7, 0x29, 0x6b, 0xd4, 0x2a, 0xb5, 0x69, 0x9b, 0x96, 0xb8, 0x51, 0xb3, 0xdb, 0xe2, 0x33, 0x3e,
	0xe1, 0xa3, 0x80, 0x6c, 0xe9, 0x44, 0x9b, 0xd2, 0xb6, 0x49, 0x46, 0x28, 0x66, 0x58, 0xc4, 0x63,
	0xd8, 0x72, 0x42, 0xc0, 0x6b, 0x51, 0xbf, 0xa8, 0xc3, 0x0c, 0x6a, 0x87, 0xae, 0x2c, 0xe5, 0xa2,
	0x9b, 0x7f, 0x75, 0x76, 0xe9, 0xff, 0x51, 0xc4, 0xf8, 0xd6, 0xf1, 0xe8, 0xd6, 0x06, 0x36, 0x0d,
	0x1d, 0x33, 0x32, 0x9d, 0x7a, 0xc3, 0x20, 0x9b, 0x6a, 0xe4, 0xf0, 0xfc, 0x77, 0x29, 0x08, 0xeb,
	0x86, 0xe5, 0x98, 0x44, 0xe9, 0x9a, 0x04, 0x21, 0x98, 0xb4, 0xb1, 0x45, 0x44, 0x90, 0x03, 0x85,
	0xb4, 0xc2, 0xc7, 0xe8, 0x1d, 0x38, 0x8b, 0x35, 0xdf, 0x46, 0x8c, 0xe7, 0x40, 0x21, 0x53, 0xce,
	0xc9, 0xd1, 0xdc, 0x05, 0x0e, 0xcb, 0xbe, 0xfd, 0x2a, 0xc7, 0x29, 0x21, 0x1e, 0x55, 0x61, 0x46,
	0xa7, 0x16, 0x36, 0x6c, 0xd5, 0xc2, 0x4c, 0xeb, 0x10, 0x57, 0x4c, 0xe4, 0x40, 0x41, 0x28, 0x9f,
	0x9c, 0xce, 0xb0, 0x1e, 0x80, 0x1a, 0x3d, 0x87, 0x28, 0x0b, 0x81, 0x61, 0xb8, 0x84, 0xde, 0x85,
	0x49, 0x07, 0xb3, 0x8e, 0x98, 0xe4, 0xf6, 0xa7, 0xa7, 0xdb, 0xdf, 0xc2, 0xac, 0x33, 0xce, 0xc1,
	0x4d, 0xd0, 0x3a, 0x9c, 0xeb, 0x10, 0xac, 0x13, 0xd7, 0x13, 0x67, 0x72, 0x89, 0x82, 0x50, 0x7e,
	0x7d, 0xba, 0x75, 0x95, 0x83, 0xc6, 0xec, 0x2b, 0xf0, 0x87, 0x27, 0xbb, 0x89, 0x99, 0xfb, 0x20,
	0x9e, 0xcd, 0x2a, 0x03, 0x0e, 0x54, 0x83, 0x42, 0x87, 0x31, 0x47, 0xb5, 0x08, 0xeb, 0x50, 0x5d,
	0x9c, 0xe5, 0x0e, 0xbd, 0x79, 0x00, 0x25, 0x63, 0xce, 0x3a, 0xc7, 0x8d, 0xbb, 0x05, 0x3b, 0xc3,
	0x65, 0x74, 0x11, 0xc2, 0x4d, 0xdc, 0x52, 0xc3, 0xfc, 0xce, 0x71, 0xb2, 0x13, 0xd3, 0xc9, 0x3e,
	0xc4, 0xad, 0x30, 0xbd, 0xe9, 0xcd, 0xc1, 0x10, 0xad, 0xc3, 0x63, 0xe4, 0x9e, 0x63, 0xb8, 0xd8,
	0x9f, 0xa9, 0x43, 0xd9, 0x89, 0x29, 0xce, 0xb4, 0x24, 0x07, 0xc2, 0x94, 0x07, 0xc2, 0x94, 0x1b,
	0x03, 0x84, 0x72, 0x74, 0x64, 0x37, 0x5c, 0x44, 0x55, 0x38, 0xef, 0x50, 0x97, 0x0d, 0xaf, 0x0b,
	0x3e, 0x33, 0xdd, 0xd4, 0x65, 0xe3, 0x71, 0x09, 0xce, 0x68, 0x01, 0x15, 0xa1, 0xa0, 0x13, 0x4f,
	0x73, 0x0d, 0xae, 0x36, 0x51, 0xf0, 0xf5, 0x14, 0x26, 0xd4, 0x4d, 0x88, 0xdb, 0x71, 0x65, 0x7c,
	0x1b, 0xdd, 0x85, 0xb3, 0x9c, 0x9b, 0x88, 0xf3, 0xb9, 0x44, 0x21, 0x5d, 0xa9, 0xfa, 0xc0, 0xd2,
	0x7d, 0x50, 0xcc, 0xbf, 0xe1, 0x16, 0x94, 0x33, 0x9f, 0xe4, 0x57, 0x6f, 0x7e, 0x94, 0x2f, 0xe6,
	0xf2, 0xd5, 0x46, 0xe3, 0xd6, 0xe0, 0x6f, 0xdd, 0x1f, 0x34, 0xd6, 0xf8, 0xbc, 0x51, 0xab, 0xe7,
	0x3f, 0x1d, 0xde, 0x56, 0x72, 0x30, 0x12, 0x81, 0x12, 0xf2, 0xa2, 0xcb, 0x50, 0xe8, 0xba, 0xe6,
	0x30, 0xb0, 0x05, 0x1e, 0xd8, 0xa9, 0xe9, 0x81, 0xdd, 0x56, 0x6a, 0x91, 0xfb, 0xea, 0xba, 0xe6,
	0x20, 0xac, 0x3b, 0x70, 0xd1, 0x5c, 0x51, 0x75, 0xe2, 0x8d, 0x72, 0x94, 0xe1, 0x54, 0x07, 0x88,
	0xaa, 0xb6, 0x72, 0x89, 0x78, 0xe3, 0x59, 0xaa, 0xcc, 0xed, 0x6d, 0x81, 0xc7, 0x3b, 0x00, 0x28,
	0x0b, 0xe6, 0xf8, 0x1e, 0xba, 0x01, 0x33, 0x86, 0xa3, 0x3a, 0x2e, 0x69, 0x19, 0xf7, 0x54, 0xd3,
	0xf0, 0x98, 0xb8, 0xf8, 0xcc, 0xe4, 0x73, 0x20, 0x37, 0xae, 0x19, 0x1e, 0x53, 0xe6, 0x0d, 0x27,
	0x58, 0xf2, 0x67, 0x48, 0x81, 0x48, 0xf7, 0x98, 0x3a, 0x41, 0x98, 0x7d, 0x1e, 0xc2, 0x45, 0xdd,
	0x63, 0xd7, 0xc6, 0x38, 0xaf, 0x27, 0x53, 0xe9, 0x2c, 0xcc, 0x3f, 0x9e, 0x83, 0x99, 0xab, 0x26,
	0x6d, 0x62, 0xb3, 0xee, 0x10, 0xcd, 0x8f, 0x08, 0xdd, 0x81, 0x49, 0x6c, 0xb6, 0x29, 0xef, 0x19,
	0x99, 0x72, 0xf1, 0xe0, 0xee, 0xb0, 0x46, 0xad, 0xa6, 0x61, 0x1b, 0x76, 0x7b, 0xd5, 0x6c, 0x53,
	0xd7, 0x60, 0x1d, 0xab, 0xf2, 0xbf, 0xbd, 0x2d, 0xf0, 0xcb, 0x0e, 0x10, 0xae, 0x5c, 0x53, 0xea,
	0x0d, 0x75, 0x7d, 0xb5, 0xb1, 0x56, 0xe5, 0xc9, 0xe1, 0x8c, 0x68, 0x19, 0x0a, 0x7e, 0x63, 0x26,
	0xae, 0xca, 0x9b, 0x52, 0x3c, 0x22, 0xa2, 0xc2, 0x76, 0xbc, 0x1a, 0x53, 0x60, 0x00, 0xb8, 0xe9,
	0x37, 0xaa, 0x1b, 0x70, 0x31, 0x84, 0x7b, 0xc4, 0x24, 0x1a, 0xa3, 0x83, 0x7e, 0x33, 0xd9, 0xb1,
	0x6a, 0xb8, 0x49, 0xcc, 0x7a, 0x88, 0xf1, 0x63, 0xa8, 0xc6, 0x94, 0x4c, 0x60, 0x3a, 0x58, 0x45,
	0xb7, 0xe1, 0x8c, 0xdb, 0x35, 0x89, 0x27, 0x26, 0x79, 0xd3, 0x38, 0x3e, 0x41, 0xf1, 0x7e, 0xf3,
	0x33, 0xa2, 0x31, 0x85, 0xb4, 0xf8, 0xa5, 0x9e, 0x7c, 0xb0, 0x75, 0x34, 0xfa, 0x84, 0xa8, 0xbe,
	0xb1, 0xef, 0xe9, 0xec, 0x7d, 0x90, 0xc8, 0x6e, 0xc7, 0x95, 0x80, 0x0d, 0xdd, 0x81, 0x47, 0xc7,
	0x42, 0x1a, 0x8a, 0x68, 0x86, 0xfb, 0x79, 0xe6, 0x6f, 0xfb, 0x62, 0x05, 0x7b, 0x86, 0x56, 0x8d,
	0x29, 0x47, 0x46, 0x61, 0x0f, 0x04, 0xf4, 0xc1, 0x44, 0xed, 0xce, 0x3e, 0x47, 0xed, 0x8e, 0x54,
	0x19, 0x29, 0xe2, 0x0a, 0x4c, 0xba, 0xd4, 0x24, 0x61, 0x5f, 0x3a, 0x80, 0x4a, 0xa1, 0x26, 0x99,
	0x4a, 0xc5, 0x6d, 0xd1, 0x0d, 0x98, 0xd6, 0x89, 0xdd, 0x53, 0x0d, 0xbb, 0x45, 0xc3, 0xb6, 0x74,
	0x00, 0xd1, 0x25, 0x62, 0xf7, 0xae, 0xd9, 0x2d, 0xea, 0x5a, 0xbc, 0x2b, 0x8d, 0x88, 0x52, 0x7a,
	0xb8, 0x83, 0xb6, 0x01, 0x5c, 0xd2, 0x49, 0x0b, 0x77, 0x4d, 0xa6, 0xb6, 0xa8, 0xbb, 0x89, 0x5d,
	0xdd, 0xb0, 0xdb, 0xaa, 0x66, 0x62, 0xcf, 0x23, 0x9e, 0x98, 0xfe, 0x07, 0x57, 0x75, 0xea, 0xc1,
	0x56, 0x76, 0xd2, 0x34, 0x3c, 0x68, 0xd8, 0x40, 0x12, 0x8a, 0x18, 0x9e, 0x72, 0x65, 0x88, 0x5c,
	0x0b, 0xce, 0x40, 0xe7, 0x21, 0xc4, 0x76, 0x4f, 0x0d, 0xf2, 0xcf, 0xfb, 0x9a, 0x50, 0x3e, 0x36,
	0x71, 0xe2, 0x65, 0xcb, 0x61, 0xbd, 0x6a, 0x4c, 0x49, 0x63, 0xbb, 0x57, 0xe7, 0x40, 0x74, 0x17,
	0xce, 0x7b, 0xfc, 0x99, 0x55, 0x03, 0x55, 0x3d, 0x99, 0xe3, 0xbe, 0x16, 0xe4, 0x67, 0xfd, 0x0e,
	0x91, 0x47, 0x2f, 0x73, 0x05, 0x8d, 0x39, 0x19, 0x68, 0x2a, 0xa5, 0x08, 0xde, 0x70, 0xdf, 0xbb,
	0x90, 0xff, 0x71, 0x07, 0x48, 0x30, 0x0b, 0xe1, 0x2a, 0x63, 0x58, 0xeb, 0x58, 0xc4, 0x66, 0x28,
	0x7e, 0xf6, 0x2d, 0x08, 0xe1, 0x0c, 0x07, 0x20, 0xb0, 0x52, 0x39, 0x0d, 0x17, 0x42, 0xf5, 0x69,
	0x1d, 0x6a, 0x68, 0x04, 0x1d, 0xdb, 0xdd, 0x01, 0xc2, 0xc3, 0x1d, 0x00, 0xfb, 0x3b, 0x20, 0x75,
	0xf6, 0x6c, 0xb1, 0x5c, 0x3c, 0x5f, 0x3c, 0x77, 0x3d, 0x99, 0x82, 0x59, 0x21, 0xff, 0x75, 0x12,
	0x66, 0xd6, 0x5c, 0x82, 0x19, 0x19, 0x96, 0xfa, 0x7b, 0x2f, 0x5e, 0xea, 0x61, 0x49, 0x9f, 0x9c,
	0x52, 0xd2, 0xaf, 0xb2, 0x8c, 0xcb, 0xcf, 0x51, 0xc6, 0xaf, 0xbe, 0x46, 0xab, 0x2f, 0x51, 0xa3,
	0xd1, 0xd2, 0x7c, 0x31, 0x19, 0x5e, 0x38, 0xf1, 0xf3, 0xc5, 0x89, 0xf6, 0xfd, 0xdb, 0x45, 0x21,
	0xbc, 0xf6, 0xe2, 0x4a, 0xf1, 0xed, 0x4a, 0x7e, 0x52, 0x21, 0x47, 0xbe, 0xf8, 0x03, 0x44, 0x97,
	0xf2, 0xdf, 0x24, 0xe1, 0xa2, 0x42, 0x1c, 0x13, 0x6b, 0x87, 0xca, 0x38, 0x54, 0xc6, 0xb8, 0x32,
	0xf6, 0x93, 0x50, 0xb8, 0x4a, 0xd8, 0xa1, 0x2a, 0xfe, 0x23, 0xaa, 0x40, 0xb5, 0x97, 0x7c, 0xb6,
	0xa2, 0x4f, 0xd4, 0xbf, 0xa1, 0xb1, 0xca, 0x57, 0xe0, 0xe1, 0xbe, 0x14, 0xdb, 0xdb, 0x97, 0x62,
	0x4f, 0xf7, 0x25, 0xf0, 0xfb, 0xbe, 0x04, 0xb6, 0xfb, 0x12, 0xf8, 0xb6, 0x2f, 0x81, 0xef, 0xfb,
	0x12, 0xd8, 0xed, 0x4b, 0xe0, 0xa7, 0xbe, 0x04, 0x1e, 0xf6, 0x25, 0xb0, 0xd7, 0x97, 0xc0, 0xaf,
	0x7d, 0x09, 0x3c, 0xee, 0x4b, 0xb1, 0xa7, 0x7d, 0x09, 0x7c, 0xf9, 0x48, 0x8a, 0xed, 0x3e, 0x92,
	0xc0, 0xc7, 0x4a, 0x9b, 0x3a, 0x9f, 0xb7, 0xe5, 0x0d, 0x6a, 0x32, 0xe2, 0xba, 0x58, 0xee, 0x7a,
	0x25, 0x3e, 0xf0, 0x7f, 0x7b, 0x2c, 0x3b, 0x2e, 0xdd, 0x30, 0x74, 0xe2, 0x2e, 0x0f, 0xb6, 0x4b,
	0x4e, 0xb3, 0x4d, 0x4b, 0xe4, 0x1e, 0x1b, 0x7c, 0x55, 0x98, 0xf6, 0x71, 0xa1, 0x39, 0xcb, 0xff,
	0xc7, 0x3a, 0xf7, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9c, 0x71, 0x82, 0x94, 0x83, 0x10, 0x00,
	0x00,
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/tunnel/types.proto

package tunnel

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import ves_io_schema3 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Tunnel Type
//
// x-displayName: "Tunnel Type"
// Supported tunnel types are IPSec
type TunnelType int32

const (
	// x-displayName: "IPSEC with PSK"
	// IPSEC tunnel type with PSK
	IPSEC_PSK TunnelType = 0
)

var TunnelType_name = map[int32]string{
	0: "IPSEC_PSK",
}
var TunnelType_value = map[string]int32{
	"IPSEC_PSK": 0,
}

func (TunnelType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// IPSec tunnel configuration parameters
//
// x-displayName: "IPSEC tunnel parameters"
// Configuration for IPSec encapsulation are:
// 1. PSK - pre shared key to be used by IKE
type IpsecTunnelParams struct {
	// IPSec Pre shared key
	//
	// x-displayName: "Ipsec PSK"
	// Pre shared key, valid for tunnel type IPSEC_PSK, SA are computed by IKE dynamically
	IpsecPsk *ves_io_schema4.SecretType `protobuf:"bytes,1,opt,name=ipsec_psk,json=ipsecPsk" json:"ipsec_psk,omitempty"`
}

func (m *IpsecTunnelParams) Reset()                    { *m = IpsecTunnelParams{} }
func (*IpsecTunnelParams) ProtoMessage()               {}
func (*IpsecTunnelParams) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *IpsecTunnelParams) GetIpsecPsk() *ves_io_schema4.SecretType {
	if m != nil {
		return m.IpsecPsk
	}
	return nil
}

// Tunnel Parameters
//
// x-displayName: "Tunnel Parameters"
// Tunnel configuration parameters for supported encapsulation
// 1. IPSec is supported with PSK for which PSK can be configured
type TunnelParams struct {
	// Type
	//
	// x-displayName: "Type"
	// Type of tunnel params
	//
	// Types that are valid to be assigned to Type:
	//	*TunnelParams_Ipsec
	Type isTunnelParams_Type `protobuf_oneof:"type"`
}

func (m *TunnelParams) Reset()                    { *m = TunnelParams{} }
func (*TunnelParams) ProtoMessage()               {}
func (*TunnelParams) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

type isTunnelParams_Type interface {
	isTunnelParams_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TunnelParams_Ipsec struct {
	Ipsec *IpsecTunnelParams `protobuf:"bytes,1,opt,name=ipsec,oneof"`
}

func (*TunnelParams_Ipsec) isTunnelParams_Type() {}

func (m *TunnelParams) GetType() isTunnelParams_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TunnelParams) GetIpsec() *IpsecTunnelParams {
	if x, ok := m.GetType().(*TunnelParams_Ipsec); ok {
		return x.Ipsec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TunnelParams) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TunnelParams_OneofMarshaler, _TunnelParams_OneofUnmarshaler, _TunnelParams_OneofSizer, []interface{}{
		(*TunnelParams_Ipsec)(nil),
	}
}

func _TunnelParams_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TunnelParams)
	// type
	switch x := m.Type.(type) {
	case *TunnelParams_Ipsec:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipsec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TunnelParams.Type has unexpected type %T", x)
	}
	return nil
}

func _TunnelParams_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TunnelParams)
	switch tag {
	case 1: // type.ipsec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IpsecTunnelParams)
		err := b.DecodeMessage(msg)
		m.Type = &TunnelParams_Ipsec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TunnelParams_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TunnelParams)
	// type
	switch x := m.Type.(type) {
	case *TunnelParams_Ipsec:
		s := proto.Size(x.Ipsec)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Interface Type
//
// x-displayName: "Interface Type"
// Provides the local interface to pick up source IP and network for transporting encapsulated packet
type InterfaceType struct {
	// Local Interface
	//
	// x-displayName: "Local Interface"
	// Local interface to be used for filling in source information of IP and network for transport
	LocalIntf []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1,rep,name=local_intf,json=localIntf" json:"local_intf,omitempty"`
}

func (m *InterfaceType) Reset()                    { *m = InterfaceType{} }
func (*InterfaceType) ProtoMessage()               {}
func (*InterfaceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *InterfaceType) GetLocalIntf() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.LocalIntf
	}
	return nil
}

// Local IP Address Type
//
// x-displayName: "Local IP Address Type"
// Provides the configuration to pick up source IP and network for transporting encapsulated packet
type LocalIpAddressType struct {
	// Type
	//
	// x-displayName: "Type"
	// Options to choose local IP address
	//
	// Types that are valid to be assigned to Type:
	//	*LocalIpAddressType_IpAddress
	//	*LocalIpAddressType_Auto
	Type isLocalIpAddressType_Type `protobuf_oneof:"type"`
	// Local Virtual Network
	//
	// x-displayName: "Local Virtual Network"
	// x-required
	// Local Virtual network to be used for transporting encapsulated packets
	VirtualNetworkType *ves_io_schema4.VirtualNetworkSelectorType `protobuf:"bytes,3,opt,name=virtual_network_type,json=virtualNetworkType" json:"virtual_network_type,omitempty"`
}

func (m *LocalIpAddressType) Reset()                    { *m = LocalIpAddressType{} }
func (*LocalIpAddressType) ProtoMessage()               {}
func (*LocalIpAddressType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

type isLocalIpAddressType_Type interface {
	isLocalIpAddressType_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalIpAddressType_IpAddress struct {
	IpAddress *ves_io_schema3.IpAddressType `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,oneof"`
}
type LocalIpAddressType_Auto struct {
	Auto *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=auto,oneof"`
}

func (*LocalIpAddressType_IpAddress) isLocalIpAddressType_Type() {}
func (*LocalIpAddressType_Auto) isLocalIpAddressType_Type()      {}

func (m *LocalIpAddressType) GetType() isLocalIpAddressType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LocalIpAddressType) GetIpAddress() *ves_io_schema3.IpAddressType {
	if x, ok := m.GetType().(*LocalIpAddressType_IpAddress); ok {
		return x.IpAddress
	}
	return nil
}

func (m *LocalIpAddressType) GetAuto() *ves_io_schema4.Empty {
	if x, ok := m.GetType().(*LocalIpAddressType_Auto); ok {
		return x.Auto
	}
	return nil
}

func (m *LocalIpAddressType) GetVirtualNetworkType() *ves_io_schema4.VirtualNetworkSelectorType {
	if m != nil {
		return m.VirtualNetworkType
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LocalIpAddressType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LocalIpAddressType_OneofMarshaler, _LocalIpAddressType_OneofUnmarshaler, _LocalIpAddressType_OneofSizer, []interface{}{
		(*LocalIpAddressType_IpAddress)(nil),
		(*LocalIpAddressType_Auto)(nil),
	}
}

func _LocalIpAddressType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LocalIpAddressType)
	// type
	switch x := m.Type.(type) {
	case *LocalIpAddressType_IpAddress:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpAddress); err != nil {
			return err
		}
	case *LocalIpAddressType_Auto:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Auto); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LocalIpAddressType.Type has unexpected type %T", x)
	}
	return nil
}

func _LocalIpAddressType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LocalIpAddressType)
	switch tag {
	case 1: // type.ip_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.IpAddressType)
		err := b.DecodeMessage(msg)
		m.Type = &LocalIpAddressType_IpAddress{msg}
		return true, err
	case 2: // type.auto
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Type = &LocalIpAddressType_Auto{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LocalIpAddressType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LocalIpAddressType)
	// type
	switch x := m.Type.(type) {
	case *LocalIpAddressType_IpAddress:
		s := proto.Size(x.IpAddress)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LocalIpAddressType_Auto:
		s := proto.Size(x.Auto)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Local IP Address Selector
//
// x-displayName: "Local IP Address Selector"
// Defines the options to select local ip address and virtual network for tunnel object
// Options available are -
// 1. Local Interface - Network Interface from which IP address and network will be selected
// 2. IP Address - IP address and network can be configured explicitly
type LocalIpAddressSelector struct {
	// Type
	//
	// x-displayName: "Type"
	// Choice to pick up local ip address for tunnel
	//
	// Types that are valid to be assigned to Type:
	//	*LocalIpAddressSelector_Intf
	//	*LocalIpAddressSelector_IpAddress
	Type isLocalIpAddressSelector_Type `protobuf_oneof:"type"`
}

func (m *LocalIpAddressSelector) Reset()                    { *m = LocalIpAddressSelector{} }
func (*LocalIpAddressSelector) ProtoMessage()               {}
func (*LocalIpAddressSelector) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isLocalIpAddressSelector_Type interface {
	isLocalIpAddressSelector_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalIpAddressSelector_Intf struct {
	Intf *InterfaceType `protobuf:"bytes,1,opt,name=intf,oneof"`
}
type LocalIpAddressSelector_IpAddress struct {
	IpAddress *LocalIpAddressType `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,oneof"`
}

func (*LocalIpAddressSelector_Intf) isLocalIpAddressSelector_Type()      {}
func (*LocalIpAddressSelector_IpAddress) isLocalIpAddressSelector_Type() {}

func (m *LocalIpAddressSelector) GetType() isLocalIpAddressSelector_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LocalIpAddressSelector) GetIntf() *InterfaceType {
	if x, ok := m.GetType().(*LocalIpAddressSelector_Intf); ok {
		return x.Intf
	}
	return nil
}

func (m *LocalIpAddressSelector) GetIpAddress() *LocalIpAddressType {
	if x, ok := m.GetType().(*LocalIpAddressSelector_IpAddress); ok {
		return x.IpAddress
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LocalIpAddressSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LocalIpAddressSelector_OneofMarshaler, _LocalIpAddressSelector_OneofUnmarshaler, _LocalIpAddressSelector_OneofSizer, []interface{}{
		(*LocalIpAddressSelector_Intf)(nil),
		(*LocalIpAddressSelector_IpAddress)(nil),
	}
}

func _LocalIpAddressSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LocalIpAddressSelector)
	// type
	switch x := m.Type.(type) {
	case *LocalIpAddressSelector_Intf:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Intf); err != nil {
			return err
		}
	case *LocalIpAddressSelector_IpAddress:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpAddress); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LocalIpAddressSelector.Type has unexpected type %T", x)
	}
	return nil
}

func _LocalIpAddressSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LocalIpAddressSelector)
	switch tag {
	case 1: // type.intf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InterfaceType)
		err := b.DecodeMessage(msg)
		m.Type = &LocalIpAddressSelector_Intf{msg}
		return true, err
	case 2: // type.ip_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LocalIpAddressType)
		err := b.DecodeMessage(msg)
		m.Type = &LocalIpAddressSelector_IpAddress{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LocalIpAddressSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LocalIpAddressSelector)
	// type
	switch x := m.Type.(type) {
	case *LocalIpAddressSelector_Intf:
		s := proto.Size(x.Intf)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LocalIpAddressSelector_IpAddress:
		s := proto.Size(x.IpAddress)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Remote Node Atributes
//
// x-displayName: "Remote Node Attributes"
// Remote node attributes specify parameters needed to be configured for remote node
type RemoteNodeAttributes struct {
	// IP Address
	//
	// x-displayName: "IP Address"
	// IP address of remote node
	Ip *ves_io_schema3.IpAddressType `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
}

func (m *RemoteNodeAttributes) Reset()                    { *m = RemoteNodeAttributes{} }
func (*RemoteNodeAttributes) ProtoMessage()               {}
func (*RemoteNodeAttributes) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *RemoteNodeAttributes) GetIp() *ves_io_schema3.IpAddressType {
	if m != nil {
		return m.Ip
	}
	return nil
}

// Remote Endpoint Type
//
// x-displayName: "Remote Endpoint Type"
// Provides a map of ver node name to remote node attributes
// Ver node should use these attributes to configure as remote tunnel
type RemoteEndpointType struct {
	// Remote Endpoints
	//
	// x-displayName: "Remote Endpoints"
	// Map of remote attributes to which tunnel will be established on per site node basis
	// Every node can have a different attributes and IP address to connect to
	// Key is ver node name and value is Remote node attributes
	Endpoints map[string]*RemoteNodeAttributes `protobuf:"bytes,2,rep,name=endpoints" json:"endpoints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RemoteEndpointType) Reset()                    { *m = RemoteEndpointType{} }
func (*RemoteEndpointType) ProtoMessage()               {}
func (*RemoteEndpointType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *RemoteEndpointType) GetEndpoints() map[string]*RemoteNodeAttributes {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

// Remote IP Address Selector
//
// x-displayName: "Remote IP Address Selector"
// Defines the options to select remote ip address for tunnel object
// Options available are -
// 1. IP Address - Specifies the remote IP to which tunnel has to be connected
// 2. Remote endpoint - Is a map of IP address on per ver node basis
type RemoteIpAddressSelector struct {
	// Type
	//
	// x-displayName: "Type"
	// Options to select remote ip address
	//
	// Types that are valid to be assigned to Type:
	//	*RemoteIpAddressSelector_Ip
	//	*RemoteIpAddressSelector_Endpoints
	Type isRemoteIpAddressSelector_Type `protobuf_oneof:"type"`
}

func (m *RemoteIpAddressSelector) Reset()                    { *m = RemoteIpAddressSelector{} }
func (*RemoteIpAddressSelector) ProtoMessage()               {}
func (*RemoteIpAddressSelector) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

type isRemoteIpAddressSelector_Type interface {
	isRemoteIpAddressSelector_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RemoteIpAddressSelector_Ip struct {
	Ip *ves_io_schema3.IpAddressType `protobuf:"bytes,1,opt,name=ip,oneof"`
}
type RemoteIpAddressSelector_Endpoints struct {
	Endpoints *RemoteEndpointType `protobuf:"bytes,2,opt,name=endpoints,oneof"`
}

func (*RemoteIpAddressSelector_Ip) isRemoteIpAddressSelector_Type()        {}
func (*RemoteIpAddressSelector_Endpoints) isRemoteIpAddressSelector_Type() {}

func (m *RemoteIpAddressSelector) GetType() isRemoteIpAddressSelector_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *RemoteIpAddressSelector) GetIp() *ves_io_schema3.IpAddressType {
	if x, ok := m.GetType().(*RemoteIpAddressSelector_Ip); ok {
		return x.Ip
	}
	return nil
}

func (m *RemoteIpAddressSelector) GetEndpoints() *RemoteEndpointType {
	if x, ok := m.GetType().(*RemoteIpAddressSelector_Endpoints); ok {
		return x.Endpoints
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RemoteIpAddressSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RemoteIpAddressSelector_OneofMarshaler, _RemoteIpAddressSelector_OneofUnmarshaler, _RemoteIpAddressSelector_OneofSizer, []interface{}{
		(*RemoteIpAddressSelector_Ip)(nil),
		(*RemoteIpAddressSelector_Endpoints)(nil),
	}
}

func _RemoteIpAddressSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RemoteIpAddressSelector)
	// type
	switch x := m.Type.(type) {
	case *RemoteIpAddressSelector_Ip:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ip); err != nil {
			return err
		}
	case *RemoteIpAddressSelector_Endpoints:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Endpoints); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RemoteIpAddressSelector.Type has unexpected type %T", x)
	}
	return nil
}

func _RemoteIpAddressSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RemoteIpAddressSelector)
	switch tag {
	case 1: // type.ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.IpAddressType)
		err := b.DecodeMessage(msg)
		m.Type = &RemoteIpAddressSelector_Ip{msg}
		return true, err
	case 2: // type.endpoints
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RemoteEndpointType)
		err := b.DecodeMessage(msg)
		m.Type = &RemoteIpAddressSelector_Endpoints{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RemoteIpAddressSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RemoteIpAddressSelector)
	// type
	switch x := m.Type.(type) {
	case *RemoteIpAddressSelector_Ip:
		s := proto.Size(x.Ip)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RemoteIpAddressSelector_Endpoints:
		s := proto.Size(x.Endpoints)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Tunnel specification
//
// x-displayName: "Specification"
// Desired state of Tunnel
type GlobalSpecType struct {
	// Tunnel Type
	//
	// x-displayName: "Tunnel Type"
	// x-required
	// Tunnel type supported is IPSEC with pre-shared key (IPSEC_PSK)
	TunnelType TunnelType `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	// Local IP Address selector
	//
	// x-displayName: "Local IP Address selector"
	// x-required
	// Selects local IP address configuration for tunnel
	LocalIp *LocalIpAddressSelector `protobuf:"bytes,7,opt,name=local_ip,json=localIp" json:"local_ip,omitempty"`
	// Remore IP Address Selector
	//
	// x-displayName: "Remote IP Address Selector"
	// x-required
	// Selects remote endpoint IP address configuration for tunnel
	RemoteIp *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp" json:"remote_ip,omitempty"`
	// Tunnel Parameters
	//
	// x-displayName: "Tunnel Parameters"
	// Configuration for supported tunnel types
	Params *TunnelParams `protobuf:"bytes,6,opt,name=params" json:"params,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *GlobalSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *GlobalSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *GlobalSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *GlobalSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

// Create tunnel
//
// x-displayName: "Create Tunnel"
// Create tunnel in a given namespace. If one already exist it will give a error.
type CreateSpecType struct {
	TunnelType TunnelType               `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	LocalIp    *LocalIpAddressSelector  `protobuf:"bytes,7,opt,name=local_ip,json=localIp" json:"local_ip,omitempty"`
	RemoteIp   *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp" json:"remote_ip,omitempty"`
	Params     *TunnelParams            `protobuf:"bytes,6,opt,name=params" json:"params,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *CreateSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *CreateSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *CreateSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *CreateSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

// Replace tunnel
//
// x-displayName: "Replace Tunnel"
// Replace tunnel in a given namespace.
type ReplaceSpecType struct {
	TunnelType TunnelType               `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	LocalIp    *LocalIpAddressSelector  `protobuf:"bytes,7,opt,name=local_ip,json=localIp" json:"local_ip,omitempty"`
	RemoteIp   *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp" json:"remote_ip,omitempty"`
	Params     *TunnelParams            `protobuf:"bytes,6,opt,name=params" json:"params,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *ReplaceSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *ReplaceSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *ReplaceSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *ReplaceSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

// Get tunnel
//
// x-displayName: "Get Tunnel"
// Get Tunnel in a given namespace.
type GetSpecType struct {
	TunnelType TunnelType               `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	LocalIp    *LocalIpAddressSelector  `protobuf:"bytes,7,opt,name=local_ip,json=localIp" json:"local_ip,omitempty"`
	RemoteIp   *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp" json:"remote_ip,omitempty"`
	Params     *TunnelParams            `protobuf:"bytes,6,opt,name=params" json:"params,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *GetSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *GetSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *GetSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *GetSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func init() {
	proto.RegisterType((*IpsecTunnelParams)(nil), "ves.io.schema.tunnel.IpsecTunnelParams")
	golang_proto.RegisterType((*IpsecTunnelParams)(nil), "ves.io.schema.tunnel.IpsecTunnelParams")
	proto.RegisterType((*TunnelParams)(nil), "ves.io.schema.tunnel.TunnelParams")
	golang_proto.RegisterType((*TunnelParams)(nil), "ves.io.schema.tunnel.TunnelParams")
	proto.RegisterType((*InterfaceType)(nil), "ves.io.schema.tunnel.InterfaceType")
	golang_proto.RegisterType((*InterfaceType)(nil), "ves.io.schema.tunnel.InterfaceType")
	proto.RegisterType((*LocalIpAddressType)(nil), "ves.io.schema.tunnel.LocalIpAddressType")
	golang_proto.RegisterType((*LocalIpAddressType)(nil), "ves.io.schema.tunnel.LocalIpAddressType")
	proto.RegisterType((*LocalIpAddressSelector)(nil), "ves.io.schema.tunnel.LocalIpAddressSelector")
	golang_proto.RegisterType((*LocalIpAddressSelector)(nil), "ves.io.schema.tunnel.LocalIpAddressSelector")
	proto.RegisterType((*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteNodeAttributes")
	golang_proto.RegisterType((*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteNodeAttributes")
	proto.RegisterType((*RemoteEndpointType)(nil), "ves.io.schema.tunnel.RemoteEndpointType")
	golang_proto.RegisterType((*RemoteEndpointType)(nil), "ves.io.schema.tunnel.RemoteEndpointType")
	proto.RegisterType((*RemoteIpAddressSelector)(nil), "ves.io.schema.tunnel.RemoteIpAddressSelector")
	golang_proto.RegisterType((*RemoteIpAddressSelector)(nil), "ves.io.schema.tunnel.RemoteIpAddressSelector")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.tunnel.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.tunnel.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.tunnel.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.tunnel.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.tunnel.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.tunnel.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.tunnel.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.tunnel.GetSpecType")
	proto.RegisterEnum("ves.io.schema.tunnel.TunnelType", TunnelType_name, TunnelType_value)
	golang_proto.RegisterEnum("ves.io.schema.tunnel.TunnelType", TunnelType_name, TunnelType_value)
}
func (x TunnelType) String() string {
	s, ok := TunnelType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *IpsecTunnelParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpsecTunnelParams)
	if !ok {
		that2, ok := that.(IpsecTunnelParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpsecPsk.Equal(that1.IpsecPsk) {
		return false
	}
	return true
}
func (this *TunnelParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelParams)
	if !ok {
		that2, ok := that.(TunnelParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *TunnelParams_Ipsec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelParams_Ipsec)
	if !ok {
		that2, ok := that.(TunnelParams_Ipsec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipsec.Equal(that1.Ipsec) {
		return false
	}
	return true
}
func (this *InterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceType)
	if !ok {
		that2, ok := that.(InterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LocalIntf) != len(that1.LocalIntf) {
		return false
	}
	for i := range this.LocalIntf {
		if !this.LocalIntf[i].Equal(that1.LocalIntf[i]) {
			return false
		}
	}
	return true
}
func (this *LocalIpAddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressType)
	if !ok {
		that2, ok := that.(LocalIpAddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	if !this.VirtualNetworkType.Equal(that1.VirtualNetworkType) {
		return false
	}
	return true
}
func (this *LocalIpAddressType_IpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressType_IpAddress)
	if !ok {
		that2, ok := that.(LocalIpAddressType_IpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpAddress.Equal(that1.IpAddress) {
		return false
	}
	return true
}
func (this *LocalIpAddressType_Auto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressType_Auto)
	if !ok {
		that2, ok := that.(LocalIpAddressType_Auto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Auto.Equal(that1.Auto) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector_Intf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector_Intf)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector_Intf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Intf.Equal(that1.Intf) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector_IpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector_IpAddress)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector_IpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpAddress.Equal(that1.IpAddress) {
		return false
	}
	return true
}
func (this *RemoteNodeAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteNodeAttributes)
	if !ok {
		that2, ok := that.(RemoteNodeAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ip.Equal(that1.Ip) {
		return false
	}
	return true
}
func (this *RemoteEndpointType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteEndpointType)
	if !ok {
		that2, ok := that.(RemoteEndpointType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	return true
}
func (this *RemoteIpAddressSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteIpAddressSelector)
	if !ok {
		that2, ok := that.(RemoteIpAddressSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *RemoteIpAddressSelector_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteIpAddressSelector_Ip)
	if !ok {
		that2, ok := that.(RemoteIpAddressSelector_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ip.Equal(that1.Ip) {
		return false
	}
	return true
}
func (this *RemoteIpAddressSelector_Endpoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteIpAddressSelector_Endpoints)
	if !ok {
		that2, ok := that.(RemoteIpAddressSelector_Endpoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Endpoints.Equal(that1.Endpoints) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *IpsecTunnelParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.IpsecTunnelParams{")
	if this.IpsecPsk != nil {
		s = append(s, "IpsecPsk: "+fmt.Sprintf("%#v", this.IpsecPsk)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.TunnelParams{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelParams_Ipsec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.TunnelParams_Ipsec{` +
		`Ipsec:` + fmt.Sprintf("%#v", this.Ipsec) + `}`}, ", ")
	return s
}
func (this *InterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.InterfaceType{")
	if this.LocalIntf != nil {
		s = append(s, "LocalIntf: "+fmt.Sprintf("%#v", this.LocalIntf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalIpAddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tunnel.LocalIpAddressType{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	if this.VirtualNetworkType != nil {
		s = append(s, "VirtualNetworkType: "+fmt.Sprintf("%#v", this.VirtualNetworkType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalIpAddressType_IpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressType_IpAddress{` +
		`IpAddress:` + fmt.Sprintf("%#v", this.IpAddress) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressType_Auto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressType_Auto{` +
		`Auto:` + fmt.Sprintf("%#v", this.Auto) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tunnel.LocalIpAddressSelector{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalIpAddressSelector_Intf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressSelector_Intf{` +
		`Intf:` + fmt.Sprintf("%#v", this.Intf) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressSelector_IpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressSelector_IpAddress{` +
		`IpAddress:` + fmt.Sprintf("%#v", this.IpAddress) + `}`}, ", ")
	return s
}
func (this *RemoteNodeAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.RemoteNodeAttributes{")
	if this.Ip != nil {
		s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteEndpointType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.RemoteEndpointType{")
	keysForEndpoints := make([]string, 0, len(this.Endpoints))
	for k, _ := range this.Endpoints {
		keysForEndpoints = append(keysForEndpoints, k)
	}
	sortkeys.Strings(keysForEndpoints)
	mapStringForEndpoints := "map[string]*RemoteNodeAttributes{"
	for _, k := range keysForEndpoints {
		mapStringForEndpoints += fmt.Sprintf("%#v: %#v,", k, this.Endpoints[k])
	}
	mapStringForEndpoints += "}"
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+mapStringForEndpoints+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteIpAddressSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tunnel.RemoteIpAddressSelector{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteIpAddressSelector_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.RemoteIpAddressSelector_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *RemoteIpAddressSelector_Endpoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.RemoteIpAddressSelector_Endpoints{` +
		`Endpoints:` + fmt.Sprintf("%#v", this.Endpoints) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.GlobalSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.CreateSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.ReplaceSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.GetSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *IpsecTunnelParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecTunnelParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpsecPsk != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpsecPsk.Size()))
		n1, err := m.IpsecPsk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *TunnelParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn2, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *TunnelParams_Ipsec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ipsec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ipsec.Size()))
		n3, err := m.Ipsec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *InterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LocalIntf) > 0 {
		for _, msg := range m.LocalIntf {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LocalIpAddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalIpAddressType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn4, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.VirtualNetworkType != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VirtualNetworkType.Size()))
		n5, err := m.VirtualNetworkType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *LocalIpAddressType_IpAddress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpAddress != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpAddress.Size()))
		n6, err := m.IpAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *LocalIpAddressType_Auto) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Auto != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Auto.Size()))
		n7, err := m.Auto.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *LocalIpAddressSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalIpAddressSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn8, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *LocalIpAddressSelector_Intf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Intf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Intf.Size()))
		n9, err := m.Intf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *LocalIpAddressSelector_IpAddress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpAddress != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpAddress.Size()))
		n10, err := m.IpAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *RemoteNodeAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteNodeAttributes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ip != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ip.Size()))
		n11, err := m.Ip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *RemoteEndpointType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteEndpointType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		keysForEndpoints := make([]string, 0, len(m.Endpoints))
		for k, _ := range m.Endpoints {
			keysForEndpoints = append(keysForEndpoints, string(k))
		}
		sortkeys.Strings(keysForEndpoints)
		for _, k := range keysForEndpoints {
			dAtA[i] = 0x12
			i++
			v := m.Endpoints[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	return i, nil
}

func (m *RemoteIpAddressSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteIpAddressSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn13, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn13
	}
	return i, nil
}

func (m *RemoteIpAddressSelector_Ip) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ip != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ip.Size()))
		n14, err := m.Ip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *RemoteIpAddressSelector_Endpoints) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Endpoints != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Endpoints.Size()))
		n15, err := m.Endpoints.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TunnelType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
	}
	if m.Params != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Params.Size()))
		n16, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.LocalIp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LocalIp.Size()))
		n17, err := m.LocalIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.RemoteIp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RemoteIp.Size()))
		n18, err := m.RemoteIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TunnelType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
	}
	if m.Params != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Params.Size()))
		n19, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.LocalIp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LocalIp.Size()))
		n20, err := m.LocalIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.RemoteIp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RemoteIp.Size()))
		n21, err := m.RemoteIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TunnelType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
	}
	if m.Params != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Params.Size()))
		n22, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.LocalIp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LocalIp.Size()))
		n23, err := m.LocalIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.RemoteIp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RemoteIp.Size()))
		n24, err := m.RemoteIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TunnelType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
	}
	if m.Params != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Params.Size()))
		n25, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.LocalIp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LocalIp.Size()))
		n26, err := m.LocalIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.RemoteIp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RemoteIp.Size()))
		n27, err := m.RemoteIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IpsecTunnelParams) Size() (n int) {
	var l int
	_ = l
	if m.IpsecPsk != nil {
		l = m.IpsecPsk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TunnelParams) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *TunnelParams_Ipsec) Size() (n int) {
	var l int
	_ = l
	if m.Ipsec != nil {
		l = m.Ipsec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InterfaceType) Size() (n int) {
	var l int
	_ = l
	if len(m.LocalIntf) > 0 {
		for _, e := range m.LocalIntf {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LocalIpAddressType) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	if m.VirtualNetworkType != nil {
		l = m.VirtualNetworkType.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LocalIpAddressType_IpAddress) Size() (n int) {
	var l int
	_ = l
	if m.IpAddress != nil {
		l = m.IpAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressType_Auto) Size() (n int) {
	var l int
	_ = l
	if m.Auto != nil {
		l = m.Auto.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressSelector) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *LocalIpAddressSelector_Intf) Size() (n int) {
	var l int
	_ = l
	if m.Intf != nil {
		l = m.Intf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressSelector_IpAddress) Size() (n int) {
	var l int
	_ = l
	if m.IpAddress != nil {
		l = m.IpAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RemoteNodeAttributes) Size() (n int) {
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RemoteEndpointType) Size() (n int) {
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for k, v := range m.Endpoints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RemoteIpAddressSelector) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *RemoteIpAddressSelector_Ip) Size() (n int) {
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RemoteIpAddressSelector_Endpoints) Size() (n int) {
	var l int
	_ = l
	if m.Endpoints != nil {
		l = m.Endpoints.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *IpsecTunnelParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpsecTunnelParams{`,
		`IpsecPsk:` + strings.Replace(fmt.Sprintf("%v", this.IpsecPsk), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelParams{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelParams_Ipsec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelParams_Ipsec{`,
		`Ipsec:` + strings.Replace(fmt.Sprintf("%v", this.Ipsec), "IpsecTunnelParams", "IpsecTunnelParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceType{`,
		`LocalIntf:` + strings.Replace(fmt.Sprintf("%v", this.LocalIntf), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`VirtualNetworkType:` + strings.Replace(fmt.Sprintf("%v", this.VirtualNetworkType), "VirtualNetworkSelectorType", "ves_io_schema4.VirtualNetworkSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressType_IpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressType_IpAddress{`,
		`IpAddress:` + strings.Replace(fmt.Sprintf("%v", this.IpAddress), "IpAddressType", "ves_io_schema3.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressType_Auto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressType_Auto{`,
		`Auto:` + strings.Replace(fmt.Sprintf("%v", this.Auto), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector_Intf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector_Intf{`,
		`Intf:` + strings.Replace(fmt.Sprintf("%v", this.Intf), "InterfaceType", "InterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector_IpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector_IpAddress{`,
		`IpAddress:` + strings.Replace(fmt.Sprintf("%v", this.IpAddress), "LocalIpAddressType", "LocalIpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteNodeAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteNodeAttributes{`,
		`Ip:` + strings.Replace(fmt.Sprintf("%v", this.Ip), "IpAddressType", "ves_io_schema3.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteEndpointType) String() string {
	if this == nil {
		return "nil"
	}
	keysForEndpoints := make([]string, 0, len(this.Endpoints))
	for k, _ := range this.Endpoints {
		keysForEndpoints = append(keysForEndpoints, k)
	}
	sortkeys.Strings(keysForEndpoints)
	mapStringForEndpoints := "map[string]*RemoteNodeAttributes{"
	for _, k := range keysForEndpoints {
		mapStringForEndpoints += fmt.Sprintf("%v: %v,", k, this.Endpoints[k])
	}
	mapStringForEndpoints += "}"
	s := strings.Join([]string{`&RemoteEndpointType{`,
		`Endpoints:` + mapStringForEndpoints + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteIpAddressSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteIpAddressSelector{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteIpAddressSelector_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteIpAddressSelector_Ip{`,
		`Ip:` + strings.Replace(fmt.Sprintf("%v", this.Ip), "IpAddressType", "ves_io_schema3.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteIpAddressSelector_Endpoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteIpAddressSelector_Endpoints{`,
		`Endpoints:` + strings.Replace(fmt.Sprintf("%v", this.Endpoints), "RemoteEndpointType", "RemoteEndpointType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(fmt.Sprintf("%v", this.Params), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(fmt.Sprintf("%v", this.LocalIp), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(fmt.Sprintf("%v", this.RemoteIp), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(fmt.Sprintf("%v", this.Params), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(fmt.Sprintf("%v", this.LocalIp), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(fmt.Sprintf("%v", this.RemoteIp), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(fmt.Sprintf("%v", this.Params), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(fmt.Sprintf("%v", this.LocalIp), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(fmt.Sprintf("%v", this.RemoteIp), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(fmt.Sprintf("%v", this.Params), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(fmt.Sprintf("%v", this.LocalIp), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(fmt.Sprintf("%v", this.RemoteIp), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *IpsecTunnelParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecTunnelParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecTunnelParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecPsk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpsecPsk == nil {
				m.IpsecPsk = &ves_io_schema4.SecretType{}
			}
			if err := m.IpsecPsk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipsec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IpsecTunnelParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &TunnelParams_Ipsec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIntf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalIntf = append(m.LocalIntf, &ves_io_schema4.ObjectRefType{})
			if err := m.LocalIntf[len(m.LocalIntf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalIpAddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalIpAddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalIpAddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.IpAddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressType_IpAddress{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressType_Auto{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetworkType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualNetworkType == nil {
				m.VirtualNetworkType = &ves_io_schema4.VirtualNetworkSelectorType{}
			}
			if err := m.VirtualNetworkType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalIpAddressSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalIpAddressSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalIpAddressSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressSelector_Intf{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalIpAddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressSelector_IpAddress{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteNodeAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteNodeAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteNodeAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &ves_io_schema3.IpAddressType{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteEndpointType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteEndpointType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteEndpointType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoints == nil {
				m.Endpoints = make(map[string]*RemoteNodeAttributes)
			}
			var mapkey string
			var mapvalue *RemoteNodeAttributes
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RemoteNodeAttributes{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Endpoints[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteIpAddressSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteIpAddressSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteIpAddressSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.IpAddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &RemoteIpAddressSelector_Ip{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoteEndpointType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &RemoteIpAddressSelector_Endpoints{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (TunnelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (TunnelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (TunnelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (TunnelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/tunnel/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/tunnel/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 1120 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xc1, 0x6f, 0x1b, 0xc5,
	0x17, 0xf6, 0xec, 0xae, 0xdd, 0xf5, 0x38, 0xcd, 0x6f, 0x33, 0x8a, 0x5a, 0xd7, 0xbf, 0x6a, 0xb5,
	0x2c, 0x07, 0x42, 0x94, 0xac, 0x21, 0xa0, 0x02, 0x96, 0x28, 0x4d, 0x4a, 0x94, 0xc4, 0x45, 0x21,
	0xda, 0x54, 0x1c, 0x28, 0x92, 0xb5, 0xb6, 0xc7, 0xce, 0x92, 0xf5, 0xce, 0x6a, 0x77, 0xec, 0x92,
	0x03, 0x52, 0xc4, 0xd1, 0x27, 0xc4, 0xb1, 0x7f, 0x01, 0x82, 0x2b, 0x02, 0x84, 0x7d, 0x88, 0x90,
	0x90, 0x0a, 0x12, 0x28, 0xc7, 0x1e, 0x9b, 0xed, 0x05, 0x7a, 0xea, 0x01, 0xee, 0x68, 0x66, 0xd6,
	0x09, 0x6b, 0xa7, 0x51, 0xca, 0x11, 0xf5, 0x36, 0x33, 0xef, 0xbd, 0xef, 0xbd, 0xf7, 0xbd, 0x6f,
	0x5f, 0x1c, 0x68, 0xf4, 0x70, 0x64, 0xb9, 0xa4, 0x1c, 0x35, 0x76, 0x70, 0xc7, 0x29, 0xd3, 0xae,
	0xef, 0x63, 0xaf, 0x4c, 0xf7, 0x02, 0x1c, 0x59, 0x41, 0x48, 0x28, 0x41, 0xb3, 0xc2, 0xc3, 0x12,
	0x1e, 0x96, 0xf0, 0x28, 0x2d, 0xb6, 0x5d, 0xba, 0xd3, 0xad, 0x5b, 0x0d, 0xd2, 0x29, 0xb7, 0x49,
	0x9b, 0x94, 0xb9, 0x73, 0xbd, 0xdb, 0xe2, 0x37, 0x7e, 0xe1, 0x27, 0x01, 0x52, 0xba, 0x9c, 0x4e,
	0xe3, 0x63, 0x9a, 0x18, 0xfe, 0x9f, 0x36, 0x90, 0x80, 0xba, 0xc4, 0x4f, 0x52, 0x97, 0xae, 0x8c,
	0x15, 0x77, 0x52, 0x55, 0xe9, 0x6a, 0xda, 0xd4, 0x73, 0x3c, 0xb7, 0xe9, 0x50, 0x9c, 0x58, 0xc7,
	0xba, 0xea, 0xb9, 0xf8, 0x6e, 0x2d, 0x05, 0x6d, 0xde, 0x82, 0x33, 0x1b, 0x41, 0x84, 0x1b, 0xb7,
	0x79, 0x3b, 0x5b, 0x4e, 0xe8, 0x74, 0x22, 0x74, 0x0d, 0xe6, 0x5d, 0xf6, 0x58, 0x0b, 0xa2, 0xdd,
	0x22, 0x30, 0xc0, 0x5c, 0x61, 0xe9, 0x8a, 0x95, 0x6e, 0x7f, 0x1b, 0x37, 0x42, 0x4c, 0x6f, 0xef,
	0x05, 0xd8, 0x56, 0xb9, 0xef, 0x56, 0xb4, 0x6b, 0xb6, 0xe1, 0x54, 0x0a, 0xe7, 0x1d, 0x98, 0xe5,
	0xb6, 0x04, 0xe3, 0x25, 0xeb, 0x34, 0x0a, 0xad, 0x89, 0xfc, 0xeb, 0x19, 0x5b, 0xc4, 0xad, 0x68,
	0x50, 0x61, 0xcd, 0x22, 0xf5, 0x60, 0x00, 0xc0, 0xe1, 0x00, 0x48, 0x55, 0x45, 0x95, 0x34, 0xd9,
	0xf4, 0xe0, 0xc5, 0x0d, 0x9f, 0xe2, 0xb0, 0xe5, 0x34, 0x30, 0xab, 0x01, 0xdd, 0x81, 0xd0, 0x23,
	0x0d, 0xc7, 0xab, 0xb9, 0x3e, 0x6d, 0x15, 0x81, 0x21, 0xcf, 0x15, 0x96, 0xae, 0x8e, 0xa5, 0x7b,
	0xbf, 0xfe, 0x31, 0x6e, 0x50, 0x1b, 0xb7, 0x58, 0xc4, 0x8a, 0xfe, 0xd5, 0xa7, 0x33, 0x3e, 0xa6,
	0x77, 0x49, 0xb8, 0xcb, 0x82, 0x04, 0xd6, 0x0f, 0x7f, 0x1c, 0xc8, 0xd9, 0x2f, 0x80, 0xa4, 0x01,
	0x3b, 0xcf, 0xf1, 0x36, 0x7c, 0xda, 0x32, 0xff, 0x04, 0x10, 0xbd, 0xc7, 0x6f, 0xc1, 0x72, 0xb3,
	0x19, 0xe2, 0x28, 0xe2, 0x39, 0xdf, 0x86, 0xd0, 0x0d, 0x6a, 0x8e, 0x78, 0x49, 0x5a, 0x1c, 0xcf,
	0x99, 0x8a, 0x58, 0xcf, 0xd8, 0x79, 0x77, 0xf4, 0x80, 0xe6, 0xa1, 0xe2, 0x74, 0x29, 0x29, 0x4a,
	0x3c, 0x70, 0x76, 0x2c, 0x70, 0xb5, 0x13, 0xd0, 0xbd, 0xf5, 0x8c, 0xcd, 0x7d, 0xd0, 0x1d, 0x38,
	0xdb, 0x73, 0x43, 0xda, 0x75, 0xbc, 0xda, 0xa8, 0x66, 0xc6, 0x4b, 0x51, 0xe6, 0xb1, 0x2f, 0x8f,
	0xc5, 0x7e, 0x20, 0x5c, 0x37, 0x85, 0xe7, 0x36, 0xf6, 0x70, 0x83, 0x92, 0x90, 0xcf, 0x0a, 0xf5,
	0x52, 0x36, 0xce, 0xc4, 0x38, 0xc9, 0x4a, 0x55, 0x51, 0x15, 0x2d, 0x6b, 0x7e, 0x0b, 0xe0, 0xa5,
	0x74, 0xdb, 0x23, 0x28, 0xf4, 0x16, 0x54, 0x12, 0xa2, 0x59, 0xfe, 0x17, 0x9f, 0x32, 0xd7, 0x7f,
	0x4e, 0x88, 0xb5, 0xc2, 0x42, 0xd0, 0x46, 0x8a, 0x35, 0xd1, 0xfc, 0xdc, 0xe9, 0x00, 0x93, 0x9c,
	0xa7, 0x18, 0x9c, 0x28, 0x5c, 0xae, 0x2a, 0xaa, 0xac, 0x29, 0xe6, 0x47, 0x70, 0xd6, 0xc6, 0x1d,
	0x42, 0xf1, 0x26, 0x69, 0xe2, 0x65, 0x4a, 0x43, 0xb7, 0xde, 0xa5, 0x38, 0x42, 0x0b, 0x50, 0x72,
	0x83, 0xf3, 0x0c, 0xca, 0x96, 0xdc, 0xa0, 0x72, 0xe9, 0xc7, 0x01, 0x40, 0x50, 0x83, 0x05, 0x81,
	0x65, 0x30, 0x30, 0x04, 0x5e, 0x35, 0x7f, 0x93, 0x21, 0x12, 0x4f, 0xab, 0x7e, 0x33, 0x20, 0xae,
	0xcf, 0xbf, 0x02, 0xf4, 0xab, 0x04, 0xf3, 0x38, 0x79, 0x60, 0x7d, 0x31, 0x05, 0xbe, 0x71, 0x7a,
	0x5f, 0x93, 0xd1, 0xd6, 0xe8, 0x12, 0xad, 0xfa, 0x34, 0xdc, 0x5b, 0xf9, 0x0b, 0x30, 0x25, 0x4e,
	0xdd, 0x03, 0x79, 0xf3, 0x42, 0x98, 0xd5, 0x40, 0x71, 0x5f, 0x62, 0x0f, 0xb9, 0x7b, 0x40, 0xd6,
	0xf6, 0x41, 0xfc, 0xf0, 0x27, 0xf9, 0xdd, 0xfe, 0x10, 0xdc, 0x40, 0xd7, 0x1f, 0x0f, 0x40, 0x85,
	0x15, 0x66, 0xb4, 0x48, 0x68, 0x24, 0xf0, 0xc6, 0x76, 0x80, 0x1b, 0x6e, 0xcb, 0xc5, 0x4d, 0xc3,
	0x89, 0x8c, 0xc8, 0xa5, 0xb8, 0xe2, 0x93, 0x26, 0x5e, 0xe0, 0x47, 0xc3, 0x8d, 0x0c, 0xb1, 0x01,
	0x1c, 0xcf, 0x60, 0x40, 0xd3, 0xfd, 0x21, 0x80, 0x48, 0x8d, 0x07, 0x40, 0x61, 0x40, 0xec, 0x09,
	0xf6, 0x87, 0x20, 0x87, 0x94, 0xfb, 0x03, 0x90, 0x61, 0xd7, 0x5c, 0x7f, 0x08, 0x24, 0x95, 0x67,
	0xad, 0xf4, 0x87, 0xe0, 0x5a, 0xe9, 0xf5, 0xc7, 0x03, 0xf0, 0x4a, 0xc2, 0x8a, 0x73, 0x4c, 0xaf,
	0x28, 0x61, 0x07, 0x27, 0x65, 0x18, 0xc4, 0x37, 0x1c, 0xa3, 0xed, 0xf6, 0xb0, 0x6f, 0xf8, 0x09,
	0xb0, 0xd6, 0x1f, 0x82, 0xa9, 0x12, 0x8c, 0x07, 0x20, 0x27, 0xf6, 0xc7, 0x71, 0xb6, 0x92, 0xc2,
	0x66, 0x68, 0x9f, 0x30, 0x58, 0xda, 0x81, 0xd3, 0x69, 0x52, 0x90, 0x06, 0xe5, 0x5d, 0xbc, 0xc7,
	0xe7, 0x97, 0xb7, 0xd9, 0x11, 0xdd, 0x80, 0xd9, 0x9e, 0xe3, 0x75, 0x71, 0x22, 0xa3, 0xf9, 0xb3,
	0xe8, 0x4e, 0x6b, 0xc1, 0x16, 0x81, 0x15, 0xe9, 0x4d, 0x60, 0x7e, 0x0d, 0xe0, 0x65, 0xe1, 0x33,
	0x29, 0x74, 0xeb, 0xbc, 0x92, 0x59, 0xcf, 0x30, 0xd1, 0xa0, 0xf5, 0xb4, 0x08, 0xce, 0x10, 0xf7,
	0xa4, 0x08, 0x98, 0xb8, 0x8f, 0x83, 0x9f, 0x2a, 0xee, 0x9f, 0x25, 0x38, 0xbd, 0xe6, 0x91, 0xba,
	0xe3, 0xb1, 0x31, 0x73, 0xe9, 0x6d, 0xc2, 0x82, 0x00, 0x15, 0x4b, 0x81, 0x55, 0x3b, 0xbd, 0x64,
	0x9c, 0x9e, 0x56, 0xec, 0x59, 0xfe, 0xdd, 0x17, 0xb8, 0xa4, 0x3e, 0x03, 0x72, 0x09, 0x64, 0x6c,
	0x48, 0x8f, 0x0d, 0xa8, 0x02, 0x73, 0x01, 0x5f, 0xc4, 0xc5, 0x1c, 0xef, 0xc0, 0x3c, 0x0b, 0x4a,
	0xac, 0x6c, 0x3b, 0x89, 0x40, 0x6b, 0x50, 0x4d, 0x16, 0x71, 0x50, 0xbc, 0xc0, 0xa3, 0x17, 0xce,
	0xf3, 0x71, 0x8f, 0x08, 0xb7, 0x2f, 0x88, 0xb5, 0x1b, 0xa0, 0x2a, 0xcc, 0x87, 0x9c, 0x22, 0x86,
	0xa4, 0x72, 0xa4, 0xc5, 0xb3, 0x98, 0x9c, 0x84, 0x52, 0xc3, 0xc4, 0x20, 0xfe, 0x68, 0x08, 0xfe,
	0xc4, 0x6e, 0xab, 0x2a, 0x6a, 0x56, 0xcb, 0x99, 0xdf, 0x49, 0x70, 0xfa, 0x66, 0x88, 0x1d, 0x8a,
	0x8f, 0xb9, 0x5c, 0xfe, 0x57, 0x5c, 0xfe, 0xa7, 0xe9, 0xab, 0xcc, 0xfc, 0x72, 0x7d, 0x4c, 0x72,
	0xe6, 0xf7, 0x12, 0xfc, 0x9f, 0x8d, 0x03, 0xcf, 0x69, 0x3c, 0xa7, 0xee, 0x19, 0xa9, 0xfb, 0x46,
	0x82, 0x85, 0x35, 0x4c, 0x9f, 0xd3, 0xf6, 0x4c, 0xb4, 0xcd, 0xbf, 0x00, 0xe1, 0x49, 0xf7, 0xe8,
	0x22, 0xcc, 0x6f, 0x6c, 0x6d, 0xaf, 0xde, 0xac, 0x6d, 0x6d, 0xdf, 0xd2, 0x32, 0xa6, 0xa2, 0x02,
	0x0d, 0xac, 0xec, 0x83, 0xc3, 0x23, 0x3d, 0xf3, 0xe0, 0x48, 0xcf, 0x3c, 0x39, 0xd2, 0xc1, 0x7e,
	0xac, 0x83, 0x2f, 0x63, 0x1d, 0xdc, 0x8f, 0x75, 0x70, 0x18, 0xeb, 0xe0, 0x41, 0xac, 0x83, 0x87,
	0xb1, 0x0e, 0x7e, 0x8f, 0xf5, 0xcc, 0x93, 0x58, 0x07, 0x9f, 0x3f, 0xd2, 0x33, 0x07, 0x8f, 0x74,
	0xf0, 0x61, 0xb5, 0x4d, 0x82, 0xdd, 0xb6, 0xd5, 0x23, 0x1e, 0xc5, 0x61, 0xe8, 0x58, 0xdd, 0xa8,
	0xcc, 0x0f, 0x2d, 0x12, 0x76, 0x16, 0x83, 0x90, 0xf4, 0xdc, 0x26, 0x0e, 0x17, 0x47, 0xe6, 0x72,
	0x50, 0x6f, 0x93, 0x32, 0xfe, 0x84, 0x26, 0xbf, 0xa9, 0x53, 0xff, 0x30, 0xd4, 0x73, 0xfc, 0x57,
	0xf5, 0x6b, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x65, 0xc1, 0xa1, 0xa4, 0x4f, 0x0c, 0x00, 0x00,
}

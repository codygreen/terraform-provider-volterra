// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/registration/types.proto

package registration

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/gogo/protobuf/types"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Infrastructure provider
//
// x-displayName: "Infrastructure Provider"
// Infrastructure provider enum for registration. It describes where is instance running.
type Provider int32

const (
	// x-displayName: "Unknown"
	// Provider was not detected
	UNKNOWN Provider = 0
	// x-displayName: "AWS"
	// AWS cloud instance
	AWS Provider = 1
	// x-displayName: "GCP"
	// Google cloud instance
	GOOGLE Provider = 2
	// x-displayName: "Azure"
	// Azure cloud instance
	AZURE Provider = 3
	// x-displayName: "VMware"
	// VMWare VM
	VMWARE Provider = 4
	// x-displayName: "KVM"
	// KVM VM
	KVM Provider = 5
	// x-displayName: "Other"
	// Other provider, which was not identified by system.
	OTHER Provider = 6
	// x-displayName: "Volterra"
	// Volterra HW device.
	VOLTERRA Provider = 7
)

var Provider_name = map[int32]string{
	0: "UNKNOWN",
	1: "AWS",
	2: "GOOGLE",
	3: "AZURE",
	4: "VMWARE",
	5: "KVM",
	6: "OTHER",
	7: "VOLTERRA",
}
var Provider_value = map[string]int32{
	"UNKNOWN":  0,
	"AWS":      1,
	"GOOGLE":   2,
	"AZURE":    3,
	"VMWARE":   4,
	"KVM":      5,
	"OTHER":    6,
	"VOLTERRA": 7,
}

func (Provider) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// ObjectState
//
// x-displayName: "Object State"
// Defines states for registration object
type ObjectState int32

const (
	// x-displayName: "Not Set"
	// State isn't set
	NOTSET ObjectState = 0
	// x-displayName: "New"
	// Object was created (registration request was received and object created)
	NEW ObjectState = 1
	// x-displayName: "Approved"
	// Registration was approved and waiting for configuration
	// This state can be set by user only if current state is NEW
	APPROVED ObjectState = 2
	// x-displayName: "Admitted"
	// Registration is approved and prepared for  to connect
	// It can't be set manually.
	ADMITTED ObjectState = 3
	// x-displayName: "Retired"
	// Registration isn't valid anymore and it will be deleted in near future
	// This state can be set by user anytime.
	RETIRED ObjectState = 4
	// x-displayName: "Failed"
	// Registration is failed (vpm reported or timeout)
	FAILED ObjectState = 5
	// x-displayName: "Done"
	// DEPRECATED. Registration is reported as finished (workload was deployed)
	DONE ObjectState = 6
	// x-displayName: "Pending"
	// User action is required
	PENDING ObjectState = 7
	// x-displayName: "Online"
	// Registration is online
	ONLINE ObjectState = 8
	// x-displayName: "Upgrading"
	// Operating system upgrade is in progress
	UPGRADING ObjectState = 9
	// x-displayName: "Maintenance"
	// Maintenance is in progress
	MAINTENANCE ObjectState = 10
)

var ObjectState_name = map[int32]string{
	0:  "NOTSET",
	1:  "NEW",
	2:  "APPROVED",
	3:  "ADMITTED",
	4:  "RETIRED",
	5:  "FAILED",
	6:  "DONE",
	7:  "PENDING",
	8:  "ONLINE",
	9:  "UPGRADING",
	10: "MAINTENANCE",
}
var ObjectState_value = map[string]int32{
	"NOTSET":      0,
	"NEW":         1,
	"APPROVED":    2,
	"ADMITTED":    3,
	"RETIRED":     4,
	"FAILED":      5,
	"DONE":        6,
	"PENDING":     7,
	"ONLINE":      8,
	"UPGRADING":   9,
	"MAINTENANCE": 10,
}

func (ObjectState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// Infrastructure information
//
// x-displayName: "Infra Information"
// InfraMetadata stores information about instance infrastructure
type Infra struct {
	// Provider
	//
	// x-displayName: "Provider"
	// Infrastructure provider detected by system
	Provider Provider `protobuf:"varint,1,opt,name=provider,proto3,enum=ves.io.schema.registration.Provider" json:"provider,omitempty"`
	// Instance ID
	//
	// x-displayName: "Instance ID"
	// Instance id (assigned by infrastructure provider)
	InstanceId string `protobuf:"bytes,2,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	// Zone
	//
	// x-displayName: "Region"
	// Instance zone (or region), depends on provider
	Zone string `protobuf:"bytes,3,opt,name=zone,proto3" json:"zone,omitempty"`
	// availability_zone
	//
	// x-displayName: "Availability Zone"
	// An Availability Zone is a high-availability offering that protects your applications and data from datacenter failures.
	AvailabilityZone string `protobuf:"bytes,11,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// Instance hostname
	//
	// x-displayName: "Hostname"
	// x-required
	// Must be unique in entire cluster and same as OS settings.
	// '.' (dots) are not allowed in hostname
	Hostname string `protobuf:"bytes,4,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Instance domain
	//
	// x-displayName: "Instance Domain"
	// Machine domain. It's used for Kubernetes cloud provider when domain must be
	// different than Volterra
	Domain string `protobuf:"bytes,7,opt,name=domain,proto3" json:"domain,omitempty"`
	// Machine ID
	//
	// x-displayName: "Machine ID"
	// Machine id - generated by operating system
	MachineId string `protobuf:"bytes,5,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
	// Interfaces
	//
	// x-displayName: "Interfaces"
	// x-required
	// Machine interfaces present during registration time
	Interfaces map[string]*Interface `protobuf:"bytes,6,rep,name=interfaces" json:"interfaces,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Hardware information
	//
	// x-displayName: "Hardware Information"
	// HW information about node in the site
	HwInfo *ves_io_schema_site.OsInfo `protobuf:"bytes,8,opt,name=hw_info,json=hwInfo" json:"hw_info,omitempty"`
	// Certified hardware name
	//
	// x-displayName: "Certified Hardware"
	// certified HW name used to map with Volterra certified_hardware definition
	CertifiedHw string `protobuf:"bytes,9,opt,name=certified_hw,json=certifiedHw,proto3" json:"certified_hw,omitempty"`
	// Internet Proxy Configuration
	//
	// x-displayName: "Local HTTP/HTTPS proxy configuration"
	// It will be used as the proxy URL for HTTP requests and HTTPS requests to Volterra public domains.
	InternetProxy *InternetProxy `protobuf:"bytes,10,opt,name=internet_proxy,json=internetProxy" json:"internet_proxy,omitempty"`
	// Timestamp
	//
	// x-displayName: "Current (machine) time"
	// It's used to verify machine have acceptable time difference from server
	Timestamp *google_protobuf1.Timestamp `protobuf:"bytes,12,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *Infra) Reset()                    { *m = Infra{} }
func (*Infra) ProtoMessage()               {}
func (*Infra) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *Infra) GetProvider() Provider {
	if m != nil {
		return m.Provider
	}
	return UNKNOWN
}

func (m *Infra) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

func (m *Infra) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *Infra) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *Infra) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Infra) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Infra) GetMachineId() string {
	if m != nil {
		return m.MachineId
	}
	return ""
}

func (m *Infra) GetInterfaces() map[string]*Interface {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *Infra) GetHwInfo() *ves_io_schema_site.OsInfo {
	if m != nil {
		return m.HwInfo
	}
	return nil
}

func (m *Infra) GetCertifiedHw() string {
	if m != nil {
		return m.CertifiedHw
	}
	return ""
}

func (m *Infra) GetInternetProxy() *InternetProxy {
	if m != nil {
		return m.InternetProxy
	}
	return nil
}

func (m *Infra) GetTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// Internet Proxy configuration
//
// x-displayName: "Internet Proxy Configuration"
// Proxy describes options for HTTP or HTTPS proxy configurations
type InternetProxy struct {
	// Http Proxy
	//
	// x-displayName: "HTTP PROXY"
	// It will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by HTTPSProxy or NoProxy.
	// x-example: "http://USERNAME:PASSWORD@10.0.1.1:8080/"
	HttpProxy string `protobuf:"bytes,1,opt,name=http_proxy,json=httpProxy,proto3" json:"http_proxy,omitempty"`
	// Https Proxy
	//
	// x-displayName: "HTTPS PROXY"
	// It will be used as the proxy URL for HTTPS requests unless overridden by NoProxy.
	// x-example: "https://USERNAME:PASSWORD@10.0.0.1:8080/"
	HttpsProxy string `protobuf:"bytes,2,opt,name=https_proxy,json=httpsProxy,proto3" json:"https_proxy,omitempty"`
	// No Proxy
	//
	// x-displayName: "NO PROXY"
	// It specifies a string that contains comma-separated values
	// specifying hosts that should be excluded from proxying. Each value is
	// represented by an IP address prefix (1.2.3.4), an IP address prefix in
	// CIDR notation (1.2.3.4/8), a domain name, or a special DNS label (*).
	// An IP address prefix and domain name can also include a literal port
	// number (1.2.3.4:80).
	// A domain name matches that name and all subdomains. A domain name with
	// a leading "." matches subdomains only. For example "foo.com" matches
	// "foo.com" and "bar.foo.com"; ".y.com" matches "x.y.com" but not "y.com".
	// A single asterisk (*) indicates that no proxying should be done.
	// x-example: "master.hostname.example.com,10.1.0.0/16,172.30.0.0/16"
	NoProxy string `protobuf:"bytes,3,opt,name=no_proxy,json=noProxy,proto3" json:"no_proxy,omitempty"`
	// Proxy CA certificate URL
	//
	// x-displayName: "Proxy CA certificate URL"
	// Allow optional different trust-store for proxy in HTTP CONNECT step
	// by picking proxy ca certificate value.
	// x-example: "string:///LS0tLS1CRUdJTiBDRxxxx"
	ProxyCacertUrl string `protobuf:"bytes,4,opt,name=proxy_cacert_url,json=proxyCacertUrl,proto3" json:"proxy_cacert_url,omitempty"`
}

func (m *InternetProxy) Reset()                    { *m = InternetProxy{} }
func (*InternetProxy) ProtoMessage()               {}
func (*InternetProxy) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *InternetProxy) GetHttpProxy() string {
	if m != nil {
		return m.HttpProxy
	}
	return ""
}

func (m *InternetProxy) GetHttpsProxy() string {
	if m != nil {
		return m.HttpsProxy
	}
	return ""
}

func (m *InternetProxy) GetNoProxy() string {
	if m != nil {
		return m.NoProxy
	}
	return ""
}

func (m *InternetProxy) GetProxyCacertUrl() string {
	if m != nil {
		return m.ProxyCacertUrl
	}
	return ""
}

// Machine interface
//
// x-displayName: "Machine Interface"
// Interface describe network interface
type Interface struct {
	// IP Address
	//
	// x-displayName: "IP Address"
	// x-example: "192.168.100.1"
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// Prefix length
	//
	// x-displayName: "IP Prefix"
	// x-example: "24"
	Plen int32 `protobuf:"varint,2,opt,name=plen,proto3" json:"plen,omitempty"`
	// Interface name
	//
	// x-displayName: "Interface Name"
	// x-example: "eth0"
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Interface) Reset()                    { *m = Interface{} }
func (*Interface) ProtoMessage()               {}
func (*Interface) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *Interface) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Interface) GetPlen() int32 {
	if m != nil {
		return m.Plen
	}
	return 0
}

func (m *Interface) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Shape of the registration specification
//
// x-displayName: "Global Specification"
type GlobalSpecType struct {
	// Infra
	//
	// x-displayName: "Infrastructure"
	// x-required
	// Infrastructure metadata section
	Infra *Infra `protobuf:"bytes,1,opt,name=infra" json:"infra,omitempty"`
	// Token
	//
	// x-displayName: "Token"
	// x-example: "value"
	// x-required
	// Token is used for machine and tenant identification
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// Passport
	//
	// x-displayName: "Passport"
	// x-required
	// Passport is storing identification for instance as site name, latitude, longitude, etc.
	Passport *Passport `protobuf:"bytes,3,opt,name=passport" json:"passport,omitempty"`
	// Site
	//
	// x-displayName: "Site"
	// Site for this registration, assigned after registration is assigned to site.
	Site []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=site" json:"site,omitempty"`
	// Instance role
	//
	// x-displayName: "Role"
	// x-example: "k8s-master, etcd"
	// Role of registered node. Used by system to determine what roles should be enforced.
	Role []string `protobuf:"bytes,5,rep,name=role" json:"role,omitempty"`
	// Site to site tunnel type
	//
	// x-displayName: "Site to Site Tunnel Type"
	// Tunnel type specifies the type of tunnel to be used for traffic between the sites.
	TunnelType ves_io_schema4.SiteToSiteTunnelType `protobuf:"varint,6,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *GlobalSpecType) GetInfra() *Infra {
	if m != nil {
		return m.Infra
	}
	return nil
}

func (m *GlobalSpecType) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GlobalSpecType) GetPassport() *Passport {
	if m != nil {
		return m.Passport
	}
	return nil
}

func (m *GlobalSpecType) GetSite() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *GlobalSpecType) GetRole() []string {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *GlobalSpecType) GetTunnelType() ves_io_schema4.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return ves_io_schema4.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

// Passport
//
// x-displayName: "Passport"
// Passport stores information about identification and node configuration provided by CE during registration. It can be manually updated by user during approval.
type Passport struct {
	// cluster_name
	//
	// x-displayName: "Cluster Name"
	// x-example: "acme-ce01"
	// x-required
	ClusterName string `protobuf:"bytes,1,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	// cluster_type
	//
	// x-displayName: "Cluster Type"
	// x-example: "ce"
	// x-required
	ClusterType string `protobuf:"bytes,2,opt,name=cluster_type,json=clusterType,proto3" json:"cluster_type,omitempty"`
	// Latitude
	//
	// x-displayName: "Latitude"
	// x-example: "49.3156733"
	// Geographic location of this site
	Latitude float32 `protobuf:"fixed32,7,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// Longitude
	//
	// x-displayName: "Longitude"
	// x-example: "14.2484333"
	// Geographic location of this site
	Longitude float32 `protobuf:"fixed32,8,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// Cluster size
	//
	// x-displayName: "Cluster Size"
	// x-example: "3"
	// Defines how many master nodes is in the cluster, only 1 or 3 is allowed
	// 1 - cluster have single master, without HA
	// 3 - cluster have 3 masters, with HA, all nodes should be allowed at same time, cluster won't start until ALL nodes are ADMITTED
	// 0 - same as 1
	// This value can't be changed after installation.
	// It does not interact with auto-scaling as only pool nodes are scaled.
	ClusterSize int32 `protobuf:"varint,9,opt,name=cluster_size,json=clusterSize,proto3" json:"cluster_size,omitempty"`
	// VPM version
	//
	// x-displayName: "VPM Version"
	// x-example: "value"
	// vpm version used for registration
	// it'll be used to refuse registration from old vpms
	// Local control plane to manage volterra software appliance
	VpmVersion string `protobuf:"bytes,10,opt,name=vpm_version,json=vpmVersion,proto3" json:"vpm_version,omitempty"`
	// Private Network Name
	//
	// x-displayName: "Private Network Name"
	// x-example: "private-ntw"
	// Private Network name for private access connectivity to Volterra ADN.
	// It is used for PrivateLink, CloudLink and L3VPN.
	PrivateNetworkName string `protobuf:"bytes,11,opt,name=private_network_name,json=privateNetworkName,proto3" json:"private_network_name,omitempty"`
	// Select Volterra Software Version
	//
	// x-displayName: "Select Volterra Software Version"
	// Volterra Software Version is optional parameter, which allows to specify target SW version for particular site e.g. crt-20210329-1002.
	// If not specified, latest available version is used. If existing site/fleet already has version, this value is ignored.
	//
	// Types that are valid to be assigned to VolterraSwVersionChoice:
	//	*Passport_DefaultSwVersion
	//	*Passport_VolterraSoftwareVersion
	VolterraSwVersionChoice isPassport_VolterraSwVersionChoice `protobuf_oneof:"volterra_sw_version_choice"`
	// Select Operating System Version
	//
	// x-displayName: "Select Operating System Version"
	// Operating System Version is optional parameter, which allows to specify target SW version for particular site e.g. 7.2009.10.
	// If not specified, latest available version is used. If existing site/fleet already has version, this value is ignored.
	//
	// Types that are valid to be assigned to OperatingSystemVersionChoice:
	//	*Passport_DefaultOsVersion
	//	*Passport_OperatingSystemVersion
	OperatingSystemVersionChoice isPassport_OperatingSystemVersionChoice `protobuf_oneof:"operating_system_version_choice"`
}

func (m *Passport) Reset()                    { *m = Passport{} }
func (*Passport) ProtoMessage()               {}
func (*Passport) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isPassport_VolterraSwVersionChoice interface {
	isPassport_VolterraSwVersionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPassport_OperatingSystemVersionChoice interface {
	isPassport_OperatingSystemVersionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Passport_DefaultSwVersion struct {
	DefaultSwVersion *ves_io_schema4.Empty `protobuf:"bytes,13,opt,name=default_sw_version,json=defaultSwVersion,oneof"`
}
type Passport_VolterraSoftwareVersion struct {
	VolterraSoftwareVersion string `protobuf:"bytes,14,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3,oneof"`
}
type Passport_DefaultOsVersion struct {
	DefaultOsVersion *ves_io_schema4.Empty `protobuf:"bytes,16,opt,name=default_os_version,json=defaultOsVersion,oneof"`
}
type Passport_OperatingSystemVersion struct {
	OperatingSystemVersion string `protobuf:"bytes,17,opt,name=operating_system_version,json=operatingSystemVersion,proto3,oneof"`
}

func (*Passport_DefaultSwVersion) isPassport_VolterraSwVersionChoice()            {}
func (*Passport_VolterraSoftwareVersion) isPassport_VolterraSwVersionChoice()     {}
func (*Passport_DefaultOsVersion) isPassport_OperatingSystemVersionChoice()       {}
func (*Passport_OperatingSystemVersion) isPassport_OperatingSystemVersionChoice() {}

func (m *Passport) GetVolterraSwVersionChoice() isPassport_VolterraSwVersionChoice {
	if m != nil {
		return m.VolterraSwVersionChoice
	}
	return nil
}
func (m *Passport) GetOperatingSystemVersionChoice() isPassport_OperatingSystemVersionChoice {
	if m != nil {
		return m.OperatingSystemVersionChoice
	}
	return nil
}

func (m *Passport) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *Passport) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *Passport) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Passport) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *Passport) GetClusterSize() int32 {
	if m != nil {
		return m.ClusterSize
	}
	return 0
}

func (m *Passport) GetVpmVersion() string {
	if m != nil {
		return m.VpmVersion
	}
	return ""
}

func (m *Passport) GetPrivateNetworkName() string {
	if m != nil {
		return m.PrivateNetworkName
	}
	return ""
}

func (m *Passport) GetDefaultSwVersion() *ves_io_schema4.Empty {
	if x, ok := m.GetVolterraSwVersionChoice().(*Passport_DefaultSwVersion); ok {
		return x.DefaultSwVersion
	}
	return nil
}

func (m *Passport) GetVolterraSoftwareVersion() string {
	if x, ok := m.GetVolterraSwVersionChoice().(*Passport_VolterraSoftwareVersion); ok {
		return x.VolterraSoftwareVersion
	}
	return ""
}

func (m *Passport) GetDefaultOsVersion() *ves_io_schema4.Empty {
	if x, ok := m.GetOperatingSystemVersionChoice().(*Passport_DefaultOsVersion); ok {
		return x.DefaultOsVersion
	}
	return nil
}

func (m *Passport) GetOperatingSystemVersion() string {
	if x, ok := m.GetOperatingSystemVersionChoice().(*Passport_OperatingSystemVersion); ok {
		return x.OperatingSystemVersion
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Passport) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Passport_OneofMarshaler, _Passport_OneofUnmarshaler, _Passport_OneofSizer, []interface{}{
		(*Passport_DefaultSwVersion)(nil),
		(*Passport_VolterraSoftwareVersion)(nil),
		(*Passport_DefaultOsVersion)(nil),
		(*Passport_OperatingSystemVersion)(nil),
	}
}

func _Passport_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Passport)
	// volterra_sw_version_choice
	switch x := m.VolterraSwVersionChoice.(type) {
	case *Passport_DefaultSwVersion:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultSwVersion); err != nil {
			return err
		}
	case *Passport_VolterraSoftwareVersion:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.VolterraSoftwareVersion)
	case nil:
	default:
		return fmt.Errorf("Passport.VolterraSwVersionChoice has unexpected type %T", x)
	}
	// operating_system_version_choice
	switch x := m.OperatingSystemVersionChoice.(type) {
	case *Passport_DefaultOsVersion:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultOsVersion); err != nil {
			return err
		}
	case *Passport_OperatingSystemVersion:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.OperatingSystemVersion)
	case nil:
	default:
		return fmt.Errorf("Passport.OperatingSystemVersionChoice has unexpected type %T", x)
	}
	return nil
}

func _Passport_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Passport)
	switch tag {
	case 13: // volterra_sw_version_choice.default_sw_version
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.VolterraSwVersionChoice = &Passport_DefaultSwVersion{msg}
		return true, err
	case 14: // volterra_sw_version_choice.volterra_software_version
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.VolterraSwVersionChoice = &Passport_VolterraSoftwareVersion{x}
		return true, err
	case 16: // operating_system_version_choice.default_os_version
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.OperatingSystemVersionChoice = &Passport_DefaultOsVersion{msg}
		return true, err
	case 17: // operating_system_version_choice.operating_system_version
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.OperatingSystemVersionChoice = &Passport_OperatingSystemVersion{x}
		return true, err
	default:
		return false, nil
	}
}

func _Passport_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Passport)
	// volterra_sw_version_choice
	switch x := m.VolterraSwVersionChoice.(type) {
	case *Passport_DefaultSwVersion:
		s := proto.Size(x.DefaultSwVersion)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Passport_VolterraSoftwareVersion:
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.VolterraSoftwareVersion)))
		n += len(x.VolterraSoftwareVersion)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// operating_system_version_choice
	switch x := m.OperatingSystemVersionChoice.(type) {
	case *Passport_DefaultOsVersion:
		s := proto.Size(x.DefaultOsVersion)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Passport_OperatingSystemVersion:
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.OperatingSystemVersion)))
		n += len(x.OperatingSystemVersion)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Workload context
//
// x-displayName: "Workload Context"
// WorkloadContext defines context for workload templates and infrastructure configuration
// used in vpm
type WorkloadContext struct {
	// Params
	//
	// x-displayName: "Params"
	// x-example: "value"
	// map of workload params
	Params map[string]string `protobuf:"bytes,1,rep,name=params" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AppName
	//
	// x-displayName: "App Name"
	// x-example: "phobos"
	// application type name
	AppName string `protobuf:"bytes,2,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
}

func (m *WorkloadContext) Reset()                    { *m = WorkloadContext{} }
func (*WorkloadContext) ProtoMessage()               {}
func (*WorkloadContext) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *WorkloadContext) GetParams() map[string]string {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *WorkloadContext) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

// Create registration
//
// x-displayName: "Create Registration"
// VPM creates registration using this message, never used by users.
type CreateSpecType struct {
	Infra    *Infra    `protobuf:"bytes,1,opt,name=infra" json:"infra,omitempty"`
	Token    string    `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Passport *Passport `protobuf:"bytes,3,opt,name=passport" json:"passport,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *CreateSpecType) GetInfra() *Infra {
	if m != nil {
		return m.Infra
	}
	return nil
}

func (m *CreateSpecType) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *CreateSpecType) GetPassport() *Passport {
	if m != nil {
		return m.Passport
	}
	return nil
}

// Replace registration
//
// x-displayName: "Replace Registration"
// NO fields are allowed to be replaced
type ReplaceSpecType struct {
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

// Get registration
//
// x-displayName: "Get Registration"
// Get registration specification
type GetSpecType struct {
	Infra    *Infra    `protobuf:"bytes,1,opt,name=infra" json:"infra,omitempty"`
	Token    string    `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Passport *Passport `protobuf:"bytes,3,opt,name=passport" json:"passport,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *GetSpecType) GetInfra() *Infra {
	if m != nil {
		return m.Infra
	}
	return nil
}

func (m *GetSpecType) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GetSpecType) GetPassport() *Passport {
	if m != nil {
		return m.Passport
	}
	return nil
}

func init() {
	proto.RegisterType((*Infra)(nil), "ves.io.schema.registration.Infra")
	golang_proto.RegisterType((*Infra)(nil), "ves.io.schema.registration.Infra")
	proto.RegisterType((*InternetProxy)(nil), "ves.io.schema.registration.InternetProxy")
	golang_proto.RegisterType((*InternetProxy)(nil), "ves.io.schema.registration.InternetProxy")
	proto.RegisterType((*Interface)(nil), "ves.io.schema.registration.Interface")
	golang_proto.RegisterType((*Interface)(nil), "ves.io.schema.registration.Interface")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.registration.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.registration.GlobalSpecType")
	proto.RegisterType((*Passport)(nil), "ves.io.schema.registration.Passport")
	golang_proto.RegisterType((*Passport)(nil), "ves.io.schema.registration.Passport")
	proto.RegisterType((*WorkloadContext)(nil), "ves.io.schema.registration.WorkloadContext")
	golang_proto.RegisterType((*WorkloadContext)(nil), "ves.io.schema.registration.WorkloadContext")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.registration.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.registration.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.registration.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.registration.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.registration.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.registration.GetSpecType")
	proto.RegisterEnum("ves.io.schema.registration.Provider", Provider_name, Provider_value)
	golang_proto.RegisterEnum("ves.io.schema.registration.Provider", Provider_name, Provider_value)
	proto.RegisterEnum("ves.io.schema.registration.ObjectState", ObjectState_name, ObjectState_value)
	golang_proto.RegisterEnum("ves.io.schema.registration.ObjectState", ObjectState_name, ObjectState_value)
}
func (x Provider) String() string {
	s, ok := Provider_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ObjectState) String() string {
	s, ok := ObjectState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Infra) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Infra)
	if !ok {
		that2, ok := that.(Infra)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if this.InstanceId != that1.InstanceId {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.MachineId != that1.MachineId {
		return false
	}
	if len(this.Interfaces) != len(that1.Interfaces) {
		return false
	}
	for i := range this.Interfaces {
		if !this.Interfaces[i].Equal(that1.Interfaces[i]) {
			return false
		}
	}
	if !this.HwInfo.Equal(that1.HwInfo) {
		return false
	}
	if this.CertifiedHw != that1.CertifiedHw {
		return false
	}
	if !this.InternetProxy.Equal(that1.InternetProxy) {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	return true
}
func (this *InternetProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InternetProxy)
	if !ok {
		that2, ok := that.(InternetProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpProxy != that1.HttpProxy {
		return false
	}
	if this.HttpsProxy != that1.HttpsProxy {
		return false
	}
	if this.NoProxy != that1.NoProxy {
		return false
	}
	if this.ProxyCacertUrl != that1.ProxyCacertUrl {
		return false
	}
	return true
}
func (this *Interface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface)
	if !ok {
		that2, ok := that.(Interface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	if this.Plen != that1.Plen {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Infra.Equal(that1.Infra) {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if !this.Passport.Equal(that1.Passport) {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	if len(this.Role) != len(that1.Role) {
		return false
	}
	for i := range this.Role {
		if this.Role[i] != that1.Role[i] {
			return false
		}
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	return true
}
func (this *Passport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport)
	if !ok {
		that2, ok := that.(Passport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterName != that1.ClusterName {
		return false
	}
	if this.ClusterType != that1.ClusterType {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.ClusterSize != that1.ClusterSize {
		return false
	}
	if this.VpmVersion != that1.VpmVersion {
		return false
	}
	if this.PrivateNetworkName != that1.PrivateNetworkName {
		return false
	}
	if that1.VolterraSwVersionChoice == nil {
		if this.VolterraSwVersionChoice != nil {
			return false
		}
	} else if this.VolterraSwVersionChoice == nil {
		return false
	} else if !this.VolterraSwVersionChoice.Equal(that1.VolterraSwVersionChoice) {
		return false
	}
	if that1.OperatingSystemVersionChoice == nil {
		if this.OperatingSystemVersionChoice != nil {
			return false
		}
	} else if this.OperatingSystemVersionChoice == nil {
		return false
	} else if !this.OperatingSystemVersionChoice.Equal(that1.OperatingSystemVersionChoice) {
		return false
	}
	return true
}
func (this *Passport_DefaultSwVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport_DefaultSwVersion)
	if !ok {
		that2, ok := that.(Passport_DefaultSwVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultSwVersion.Equal(that1.DefaultSwVersion) {
		return false
	}
	return true
}
func (this *Passport_VolterraSoftwareVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport_VolterraSoftwareVersion)
	if !ok {
		that2, ok := that.(Passport_VolterraSoftwareVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	return true
}
func (this *Passport_DefaultOsVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport_DefaultOsVersion)
	if !ok {
		that2, ok := that.(Passport_DefaultOsVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultOsVersion.Equal(that1.DefaultOsVersion) {
		return false
	}
	return true
}
func (this *Passport_OperatingSystemVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport_OperatingSystemVersion)
	if !ok {
		that2, ok := that.(Passport_OperatingSystemVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	return true
}
func (this *WorkloadContext) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WorkloadContext)
	if !ok {
		that2, ok := that.(WorkloadContext)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if this.Params[i] != that1.Params[i] {
			return false
		}
	}
	if this.AppName != that1.AppName {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Infra.Equal(that1.Infra) {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if !this.Passport.Equal(that1.Passport) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Infra.Equal(that1.Infra) {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if !this.Passport.Equal(that1.Passport) {
		return false
	}
	return true
}
func (this *Infra) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&registration.Infra{")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	s = append(s, "InstanceId: "+fmt.Sprintf("%#v", this.InstanceId)+",\n")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "AvailabilityZone: "+fmt.Sprintf("%#v", this.AvailabilityZone)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "MachineId: "+fmt.Sprintf("%#v", this.MachineId)+",\n")
	keysForInterfaces := make([]string, 0, len(this.Interfaces))
	for k, _ := range this.Interfaces {
		keysForInterfaces = append(keysForInterfaces, k)
	}
	sortkeys.Strings(keysForInterfaces)
	mapStringForInterfaces := "map[string]*Interface{"
	for _, k := range keysForInterfaces {
		mapStringForInterfaces += fmt.Sprintf("%#v: %#v,", k, this.Interfaces[k])
	}
	mapStringForInterfaces += "}"
	if this.Interfaces != nil {
		s = append(s, "Interfaces: "+mapStringForInterfaces+",\n")
	}
	if this.HwInfo != nil {
		s = append(s, "HwInfo: "+fmt.Sprintf("%#v", this.HwInfo)+",\n")
	}
	s = append(s, "CertifiedHw: "+fmt.Sprintf("%#v", this.CertifiedHw)+",\n")
	if this.InternetProxy != nil {
		s = append(s, "InternetProxy: "+fmt.Sprintf("%#v", this.InternetProxy)+",\n")
	}
	if this.Timestamp != nil {
		s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InternetProxy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&registration.InternetProxy{")
	s = append(s, "HttpProxy: "+fmt.Sprintf("%#v", this.HttpProxy)+",\n")
	s = append(s, "HttpsProxy: "+fmt.Sprintf("%#v", this.HttpsProxy)+",\n")
	s = append(s, "NoProxy: "+fmt.Sprintf("%#v", this.NoProxy)+",\n")
	s = append(s, "ProxyCacertUrl: "+fmt.Sprintf("%#v", this.ProxyCacertUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Interface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&registration.Interface{")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "Plen: "+fmt.Sprintf("%#v", this.Plen)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&registration.GlobalSpecType{")
	if this.Infra != nil {
		s = append(s, "Infra: "+fmt.Sprintf("%#v", this.Infra)+",\n")
	}
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	if this.Passport != nil {
		s = append(s, "Passport: "+fmt.Sprintf("%#v", this.Passport)+",\n")
	}
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Passport) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&registration.Passport{")
	s = append(s, "ClusterName: "+fmt.Sprintf("%#v", this.ClusterName)+",\n")
	s = append(s, "ClusterType: "+fmt.Sprintf("%#v", this.ClusterType)+",\n")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "ClusterSize: "+fmt.Sprintf("%#v", this.ClusterSize)+",\n")
	s = append(s, "VpmVersion: "+fmt.Sprintf("%#v", this.VpmVersion)+",\n")
	s = append(s, "PrivateNetworkName: "+fmt.Sprintf("%#v", this.PrivateNetworkName)+",\n")
	if this.VolterraSwVersionChoice != nil {
		s = append(s, "VolterraSwVersionChoice: "+fmt.Sprintf("%#v", this.VolterraSwVersionChoice)+",\n")
	}
	if this.OperatingSystemVersionChoice != nil {
		s = append(s, "OperatingSystemVersionChoice: "+fmt.Sprintf("%#v", this.OperatingSystemVersionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Passport_DefaultSwVersion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&registration.Passport_DefaultSwVersion{` +
		`DefaultSwVersion:` + fmt.Sprintf("%#v", this.DefaultSwVersion) + `}`}, ", ")
	return s
}
func (this *Passport_VolterraSoftwareVersion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&registration.Passport_VolterraSoftwareVersion{` +
		`VolterraSoftwareVersion:` + fmt.Sprintf("%#v", this.VolterraSoftwareVersion) + `}`}, ", ")
	return s
}
func (this *Passport_DefaultOsVersion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&registration.Passport_DefaultOsVersion{` +
		`DefaultOsVersion:` + fmt.Sprintf("%#v", this.DefaultOsVersion) + `}`}, ", ")
	return s
}
func (this *Passport_OperatingSystemVersion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&registration.Passport_OperatingSystemVersion{` +
		`OperatingSystemVersion:` + fmt.Sprintf("%#v", this.OperatingSystemVersion) + `}`}, ", ")
	return s
}
func (this *WorkloadContext) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&registration.WorkloadContext{")
	keysForParams := make([]string, 0, len(this.Params))
	for k, _ := range this.Params {
		keysForParams = append(keysForParams, k)
	}
	sortkeys.Strings(keysForParams)
	mapStringForParams := "map[string]string{"
	for _, k := range keysForParams {
		mapStringForParams += fmt.Sprintf("%#v: %#v,", k, this.Params[k])
	}
	mapStringForParams += "}"
	if this.Params != nil {
		s = append(s, "Params: "+mapStringForParams+",\n")
	}
	s = append(s, "AppName: "+fmt.Sprintf("%#v", this.AppName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&registration.CreateSpecType{")
	if this.Infra != nil {
		s = append(s, "Infra: "+fmt.Sprintf("%#v", this.Infra)+",\n")
	}
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	if this.Passport != nil {
		s = append(s, "Passport: "+fmt.Sprintf("%#v", this.Passport)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&registration.ReplaceSpecType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&registration.GetSpecType{")
	if this.Infra != nil {
		s = append(s, "Infra: "+fmt.Sprintf("%#v", this.Infra)+",\n")
	}
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	if this.Passport != nil {
		s = append(s, "Passport: "+fmt.Sprintf("%#v", this.Passport)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Infra) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Infra) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Provider != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Provider))
	}
	if len(m.InstanceId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceId)))
		i += copy(dAtA[i:], m.InstanceId)
	}
	if len(m.Zone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.MachineId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MachineId)))
		i += copy(dAtA[i:], m.MachineId)
	}
	if len(m.Interfaces) > 0 {
		keysForInterfaces := make([]string, 0, len(m.Interfaces))
		for k, _ := range m.Interfaces {
			keysForInterfaces = append(keysForInterfaces, string(k))
		}
		sortkeys.Strings(keysForInterfaces)
		for _, k := range keysForInterfaces {
			dAtA[i] = 0x32
			i++
			v := m.Interfaces[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.Domain) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	if m.HwInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HwInfo.Size()))
		n2, err := m.HwInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.CertifiedHw) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CertifiedHw)))
		i += copy(dAtA[i:], m.CertifiedHw)
	}
	if m.InternetProxy != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InternetProxy.Size()))
		n3, err := m.InternetProxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.AvailabilityZone) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailabilityZone)))
		i += copy(dAtA[i:], m.AvailabilityZone)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Timestamp.Size()))
		n4, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *InternetProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternetProxy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HttpProxy) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HttpProxy)))
		i += copy(dAtA[i:], m.HttpProxy)
	}
	if len(m.HttpsProxy) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HttpsProxy)))
		i += copy(dAtA[i:], m.HttpsProxy)
	}
	if len(m.NoProxy) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NoProxy)))
		i += copy(dAtA[i:], m.NoProxy)
	}
	if len(m.ProxyCacertUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyCacertUrl)))
		i += copy(dAtA[i:], m.ProxyCacertUrl)
	}
	return i, nil
}

func (m *Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.Plen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Plen))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Infra != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Infra.Size()))
		n5, err := m.Infra.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.Passport != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Passport.Size()))
		n6, err := m.Passport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Site) > 0 {
		for _, msg := range m.Site {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Role) > 0 {
		for _, s := range m.Role {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TunnelType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
	}
	return i, nil
}

func (m *Passport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Passport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterName)))
		i += copy(dAtA[i:], m.ClusterName)
	}
	if len(m.ClusterType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterType)))
		i += copy(dAtA[i:], m.ClusterType)
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i += 4
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i += 4
	}
	if m.ClusterSize != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClusterSize))
	}
	if len(m.VpmVersion) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpmVersion)))
		i += copy(dAtA[i:], m.VpmVersion)
	}
	if len(m.PrivateNetworkName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateNetworkName)))
		i += copy(dAtA[i:], m.PrivateNetworkName)
	}
	if m.VolterraSwVersionChoice != nil {
		nn7, err := m.VolterraSwVersionChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if m.OperatingSystemVersionChoice != nil {
		nn8, err := m.OperatingSystemVersionChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *Passport_DefaultSwVersion) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultSwVersion != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultSwVersion.Size()))
		n9, err := m.DefaultSwVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Passport_VolterraSoftwareVersion) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x72
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
	i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	return i, nil
}
func (m *Passport_DefaultOsVersion) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultOsVersion != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultOsVersion.Size()))
		n10, err := m.DefaultOsVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Passport_OperatingSystemVersion) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
	i += copy(dAtA[i:], m.OperatingSystemVersion)
	return i, nil
}
func (m *WorkloadContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		keysForParams := make([]string, 0, len(m.Params))
		for k, _ := range m.Params {
			keysForParams = append(keysForParams, string(k))
		}
		sortkeys.Strings(keysForParams)
		for _, k := range keysForParams {
			dAtA[i] = 0xa
			i++
			v := m.Params[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	return i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Infra != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Infra.Size()))
		n11, err := m.Infra.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.Passport != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Passport.Size()))
		n12, err := m.Passport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Infra != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Infra.Size()))
		n13, err := m.Infra.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.Passport != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Passport.Size()))
		n14, err := m.Passport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Infra) Size() (n int) {
	var l int
	_ = l
	if m.Provider != 0 {
		n += 1 + sovTypes(uint64(m.Provider))
	}
	l = len(m.InstanceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MachineId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Interfaces) > 0 {
		for k, v := range m.Interfaces {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HwInfo != nil {
		l = m.HwInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CertifiedHw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.InternetProxy != nil {
		l = m.InternetProxy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *InternetProxy) Size() (n int) {
	var l int
	_ = l
	l = len(m.HttpProxy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HttpsProxy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NoProxy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProxyCacertUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Interface) Size() (n int) {
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Plen != 0 {
		n += 1 + sovTypes(uint64(m.Plen))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Infra != nil {
		l = m.Infra.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Passport != nil {
		l = m.Passport.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Role) > 0 {
		for _, s := range m.Role {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	return n
}

func (m *Passport) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.ClusterSize != 0 {
		n += 1 + sovTypes(uint64(m.ClusterSize))
	}
	l = len(m.VpmVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateNetworkName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VolterraSwVersionChoice != nil {
		n += m.VolterraSwVersionChoice.Size()
	}
	if m.OperatingSystemVersionChoice != nil {
		n += m.OperatingSystemVersionChoice.Size()
	}
	return n
}

func (m *Passport_DefaultSwVersion) Size() (n int) {
	var l int
	_ = l
	if m.DefaultSwVersion != nil {
		l = m.DefaultSwVersion.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Passport_VolterraSoftwareVersion) Size() (n int) {
	var l int
	_ = l
	l = len(m.VolterraSoftwareVersion)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Passport_DefaultOsVersion) Size() (n int) {
	var l int
	_ = l
	if m.DefaultOsVersion != nil {
		l = m.DefaultOsVersion.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Passport_OperatingSystemVersion) Size() (n int) {
	var l int
	_ = l
	l = len(m.OperatingSystemVersion)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *WorkloadContext) Size() (n int) {
	var l int
	_ = l
	if len(m.Params) > 0 {
		for k, v := range m.Params {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Infra != nil {
		l = m.Infra.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Passport != nil {
		l = m.Passport.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Infra != nil {
		l = m.Infra.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Passport != nil {
		l = m.Passport.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Infra) String() string {
	if this == nil {
		return "nil"
	}
	keysForInterfaces := make([]string, 0, len(this.Interfaces))
	for k, _ := range this.Interfaces {
		keysForInterfaces = append(keysForInterfaces, k)
	}
	sortkeys.Strings(keysForInterfaces)
	mapStringForInterfaces := "map[string]*Interface{"
	for _, k := range keysForInterfaces {
		mapStringForInterfaces += fmt.Sprintf("%v: %v,", k, this.Interfaces[k])
	}
	mapStringForInterfaces += "}"
	s := strings.Join([]string{`&Infra{`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`InstanceId:` + fmt.Sprintf("%v", this.InstanceId) + `,`,
		`Zone:` + fmt.Sprintf("%v", this.Zone) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`MachineId:` + fmt.Sprintf("%v", this.MachineId) + `,`,
		`Interfaces:` + mapStringForInterfaces + `,`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`HwInfo:` + strings.Replace(fmt.Sprintf("%v", this.HwInfo), "OsInfo", "ves_io_schema_site.OsInfo", 1) + `,`,
		`CertifiedHw:` + fmt.Sprintf("%v", this.CertifiedHw) + `,`,
		`InternetProxy:` + strings.Replace(fmt.Sprintf("%v", this.InternetProxy), "InternetProxy", "InternetProxy", 1) + `,`,
		`AvailabilityZone:` + fmt.Sprintf("%v", this.AvailabilityZone) + `,`,
		`Timestamp:` + strings.Replace(fmt.Sprintf("%v", this.Timestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InternetProxy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InternetProxy{`,
		`HttpProxy:` + fmt.Sprintf("%v", this.HttpProxy) + `,`,
		`HttpsProxy:` + fmt.Sprintf("%v", this.HttpsProxy) + `,`,
		`NoProxy:` + fmt.Sprintf("%v", this.NoProxy) + `,`,
		`ProxyCacertUrl:` + fmt.Sprintf("%v", this.ProxyCacertUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface{`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`Plen:` + fmt.Sprintf("%v", this.Plen) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Infra:` + strings.Replace(fmt.Sprintf("%v", this.Infra), "Infra", "Infra", 1) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Passport:` + strings.Replace(fmt.Sprintf("%v", this.Passport), "Passport", "Passport", 1) + `,`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport{`,
		`ClusterName:` + fmt.Sprintf("%v", this.ClusterName) + `,`,
		`ClusterType:` + fmt.Sprintf("%v", this.ClusterType) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`ClusterSize:` + fmt.Sprintf("%v", this.ClusterSize) + `,`,
		`VpmVersion:` + fmt.Sprintf("%v", this.VpmVersion) + `,`,
		`PrivateNetworkName:` + fmt.Sprintf("%v", this.PrivateNetworkName) + `,`,
		`VolterraSwVersionChoice:` + fmt.Sprintf("%v", this.VolterraSwVersionChoice) + `,`,
		`OperatingSystemVersionChoice:` + fmt.Sprintf("%v", this.OperatingSystemVersionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport_DefaultSwVersion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport_DefaultSwVersion{`,
		`DefaultSwVersion:` + strings.Replace(fmt.Sprintf("%v", this.DefaultSwVersion), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport_VolterraSoftwareVersion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport_VolterraSoftwareVersion{`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport_DefaultOsVersion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport_DefaultOsVersion{`,
		`DefaultOsVersion:` + strings.Replace(fmt.Sprintf("%v", this.DefaultOsVersion), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport_OperatingSystemVersion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport_OperatingSystemVersion{`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkloadContext) String() string {
	if this == nil {
		return "nil"
	}
	keysForParams := make([]string, 0, len(this.Params))
	for k, _ := range this.Params {
		keysForParams = append(keysForParams, k)
	}
	sortkeys.Strings(keysForParams)
	mapStringForParams := "map[string]string{"
	for _, k := range keysForParams {
		mapStringForParams += fmt.Sprintf("%v: %v,", k, this.Params[k])
	}
	mapStringForParams += "}"
	s := strings.Join([]string{`&WorkloadContext{`,
		`Params:` + mapStringForParams + `,`,
		`AppName:` + fmt.Sprintf("%v", this.AppName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Infra:` + strings.Replace(fmt.Sprintf("%v", this.Infra), "Infra", "Infra", 1) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Passport:` + strings.Replace(fmt.Sprintf("%v", this.Passport), "Passport", "Passport", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Infra:` + strings.Replace(fmt.Sprintf("%v", this.Infra), "Infra", "Infra", 1) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Passport:` + strings.Replace(fmt.Sprintf("%v", this.Passport), "Passport", "Passport", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Infra) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Infra: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Infra: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			m.Provider = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Provider |= (Provider(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MachineId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interfaces == nil {
				m.Interfaces = make(map[string]*Interface)
			}
			var mapkey string
			var mapvalue *Interface
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Interface{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Interfaces[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HwInfo == nil {
				m.HwInfo = &ves_io_schema_site.OsInfo{}
			}
			if err := m.HwInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertifiedHw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternetProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternetProxy == nil {
				m.InternetProxy = &InternetProxy{}
			}
			if err := m.InternetProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternetProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternetProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternetProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpProxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpProxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsProxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpsProxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoProxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoProxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyCacertUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyCacertUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plen", wireType)
			}
			m.Plen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infra == nil {
				m.Infra = &Infra{}
			}
			if err := m.Infra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Passport == nil {
				m.Passport = &Passport{}
			}
			if err := m.Passport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &ves_io_schema4.ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = append(m.Role, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (ves_io_schema4.SiteToSiteTunnelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Passport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Passport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Passport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterSize", wireType)
			}
			m.ClusterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpmVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpmVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateNetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateNetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSwVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VolterraSwVersionChoice = &Passport_DefaultSwVersion{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSwVersionChoice = &Passport_VolterraSoftwareVersion{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultOsVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OperatingSystemVersionChoice = &Passport_DefaultOsVersion{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersionChoice = &Passport_OperatingSystemVersion{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Params[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infra == nil {
				m.Infra = &Infra{}
			}
			if err := m.Infra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Passport == nil {
				m.Passport = &Passport{}
			}
			if err := m.Passport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infra == nil {
				m.Infra = &Infra{}
			}
			if err := m.Infra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Passport == nil {
				m.Passport = &Passport{}
			}
			if err := m.Passport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/registration/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/registration/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 1648 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0xcd, 0x6f, 0xe3, 0xc6,
	0x15, 0xd7, 0x58, 0xa4, 0x44, 0x0d, 0xfd, 0x41, 0x0f, 0x8c, 0x44, 0xab, 0x26, 0x5a, 0xc7, 0x4d,
	0x0a, 0x27, 0x95, 0xa5, 0xca, 0x76, 0xb3, 0x1f, 0x01, 0x16, 0x91, 0x6c, 0xd6, 0x2b, 0xc7, 0xa6,
	0xd4, 0x91, 0x6c, 0x03, 0x7b, 0x21, 0x68, 0x69, 0x24, 0xb1, 0xa6, 0x38, 0x04, 0x39, 0x92, 0xd6,
	0x0b, 0x2c, 0x50, 0xf4, 0xd0, 0x73, 0x0e, 0x3d, 0x6d, 0xff, 0x81, 0xa2, 0xe7, 0x1c, 0x8a, 0xfa,
	0xb2, 0x68, 0x2f, 0x45, 0x4f, 0x7b, 0x0c, 0x16, 0x28, 0xd0, 0x55, 0x2e, 0xc9, 0x2d, 0xc8, 0x5f,
	0x50, 0xcc, 0x90, 0xa2, 0x65, 0xa5, 0xd9, 0x45, 0x7b, 0xcc, 0x45, 0x9a, 0x79, 0xef, 0xf7, 0x7b,
	0x5f, 0xf3, 0xe6, 0x8d, 0x04, 0x7f, 0x36, 0x22, 0x41, 0xd1, 0xa6, 0xa5, 0xa0, 0xdd, 0x27, 0x03,
	0xab, 0xe4, 0x93, 0x9e, 0x1d, 0x30, 0xdf, 0x62, 0x36, 0x75, 0x4b, 0xec, 0xd2, 0x23, 0x41, 0xd1,
	0xf3, 0x29, 0xa3, 0x28, 0x17, 0xe2, 0x8a, 0x21, 0xae, 0x38, 0x8b, 0xcb, 0x6d, 0xf5, 0x6c, 0xd6,
	0x1f, 0x9e, 0x17, 0xdb, 0x74, 0x50, 0xea, 0xd1, 0x1e, 0x2d, 0x09, 0xca, 0xf9, 0xb0, 0x2b, 0x76,
	0x62, 0x23, 0x56, 0xa1, 0xa9, 0xdc, 0xed, 0x1e, 0xa5, 0x3d, 0x87, 0x5c, 0xa3, 0x98, 0x3d, 0x20,
	0x01, 0xb3, 0x06, 0x5e, 0x04, 0xf8, 0xc9, 0xcd, 0x98, 0xa8, 0xc7, 0xbd, 0x44, 0x81, 0xe4, 0xf2,
	0x37, 0x95, 0x81, 0xcd, 0xc8, 0x6c, 0xa0, 0xb9, 0x5b, 0x37, 0xf5, 0xb3, 0xaa, 0x77, 0x6e, 0xaa,
	0x46, 0x96, 0x63, 0x77, 0x2c, 0x46, 0x22, 0xed, 0xfa, 0x9c, 0xd6, 0x26, 0x63, 0xf3, 0x86, 0xeb,
	0x8d, 0x3f, 0xca, 0x50, 0xae, 0xb9, 0x5d, 0xdf, 0x42, 0x9f, 0x42, 0xc5, 0xf3, 0xe9, 0xc8, 0xee,
	0x10, 0x3f, 0x0b, 0xd6, 0xc1, 0xe6, 0xf2, 0xf6, 0xfb, 0xc5, 0x1f, 0x2e, 0x50, 0xb1, 0x11, 0x61,
	0x71, 0xcc, 0x42, 0xb7, 0xa1, 0x6a, 0xbb, 0x01, 0xb3, 0xdc, 0x36, 0x31, 0xed, 0x4e, 0x76, 0x61,
	0x1d, 0x6c, 0x66, 0x30, 0x9c, 0x8a, 0x6a, 0x1d, 0x84, 0xa0, 0xf4, 0x84, 0xba, 0x24, 0x9b, 0x14,
	0x1a, 0xb1, 0x46, 0x39, 0xa8, 0xf4, 0x69, 0xc0, 0x5c, 0x6b, 0x40, 0xb2, 0x92, 0x90, 0xc7, 0x7b,
	0xf4, 0x2e, 0x84, 0x03, 0xab, 0xdd, 0xb7, 0x5d, 0x61, 0x4f, 0x16, 0xda, 0x4c, 0x24, 0xa9, 0x75,
	0xd0, 0xaf, 0x21, 0xb4, 0x5d, 0x46, 0xfc, 0xae, 0xd5, 0x26, 0x41, 0x36, 0xb5, 0x9e, 0xdc, 0x54,
	0xb7, 0xcb, 0xaf, 0x8b, 0x59, 0x24, 0x5a, 0xac, 0xc5, 0x1c, 0xdd, 0x65, 0xfe, 0x25, 0x9e, 0x31,
	0x82, 0xde, 0x82, 0xa9, 0x0e, 0x1d, 0x58, 0xb6, 0x9b, 0x4d, 0x0b, 0x6f, 0xd1, 0x0e, 0xed, 0xc0,
	0x74, 0x7f, 0x6c, 0xda, 0x6e, 0x97, 0x66, 0x95, 0x75, 0xb0, 0xa9, 0x6e, 0xe7, 0xe6, 0xfc, 0xf0,
	0x33, 0x2b, 0xd6, 0x83, 0x9a, 0xdb, 0xa5, 0x38, 0xd5, 0x1f, 0xf3, 0x6f, 0xf4, 0x1e, 0x5c, 0x6c,
	0x13, 0x9f, 0xd9, 0x5d, 0x9b, 0x74, 0xcc, 0xfe, 0x38, 0x9b, 0x11, 0x26, 0xd5, 0x58, 0xf6, 0x70,
	0x8c, 0x1a, 0x70, 0x59, 0x78, 0x77, 0x09, 0x33, 0x3d, 0x9f, 0x3e, 0xbe, 0xcc, 0x42, 0x61, 0xfe,
	0xc3, 0xd7, 0xa7, 0x11, 0x32, 0x1a, 0x9c, 0x80, 0x97, 0xec, 0xd9, 0x2d, 0xfa, 0x39, 0x5c, 0xb5,
	0x46, 0x96, 0xed, 0x58, 0xe7, 0xb6, 0x63, 0xb3, 0x4b, 0x53, 0x14, 0x5c, 0x15, 0x9e, 0xb5, 0x59,
	0xc5, 0x23, 0x5e, 0xfc, 0xbb, 0x30, 0x13, 0x37, 0x6a, 0x76, 0x31, 0x4a, 0x2c, 0x6c, 0xe5, 0xe2,
	0xb4, 0x95, 0x8b, 0xad, 0x29, 0x02, 0x5f, 0x83, 0x73, 0x1d, 0xb8, 0x32, 0x57, 0x47, 0xa4, 0xc1,
	0xe4, 0x05, 0xb9, 0x14, 0xbd, 0x93, 0xc1, 0x7c, 0x89, 0x3e, 0x81, 0xf2, 0xc8, 0x72, 0x86, 0x44,
	0xb4, 0x82, 0xba, 0xfd, 0xc1, 0x1b, 0x93, 0xe2, 0xd6, 0x70, 0xc8, 0xb9, 0xbf, 0x70, 0x17, 0x6c,
	0xfc, 0x01, 0xc0, 0xa5, 0x1b, 0xd9, 0xf2, 0x96, 0xe8, 0x33, 0xe6, 0x45, 0xc5, 0x0a, 0x7d, 0x65,
	0xb8, 0x24, 0x54, 0xdf, 0x86, 0x2a, 0xdf, 0x04, 0x91, 0x3e, 0x6a, 0x41, 0x21, 0x0a, 0x01, 0xb7,
	0xa0, 0xe2, 0xd2, 0x48, 0x1b, 0xb6, 0x61, 0xda, 0xa5, 0xa1, 0x6a, 0x13, 0x6a, 0x42, 0x6e, 0xb6,
	0x2d, 0x7e, 0x44, 0xe6, 0xd0, 0x77, 0xa2, 0x8e, 0x5c, 0x16, 0xf2, 0x3d, 0x21, 0x3e, 0xf1, 0x9d,
	0x8d, 0x03, 0x98, 0x89, 0xc3, 0xe5, 0x4d, 0x6d, 0x75, 0x3a, 0x7e, 0x14, 0x8b, 0x58, 0x73, 0x99,
	0xe7, 0x10, 0x57, 0xf8, 0x97, 0xb1, 0x58, 0x73, 0x99, 0x68, 0xf2, 0xa8, 0xf9, 0xf9, 0x7a, 0xe3,
	0x9b, 0x05, 0xb8, 0x7c, 0xe0, 0xd0, 0x73, 0xcb, 0x69, 0x7a, 0xa4, 0xdd, 0xba, 0xf4, 0x08, 0xba,
	0x03, 0x65, 0x9b, 0xb7, 0xa9, 0xb0, 0xa7, 0x6e, 0xbf, 0xf7, 0xc6, 0x7e, 0xc6, 0x21, 0x1e, 0xad,
	0x41, 0x99, 0xd1, 0x8b, 0xc8, 0x69, 0x06, 0x87, 0x1b, 0x71, 0xab, 0xad, 0x20, 0xf0, 0xa8, 0xcf,
	0x84, 0x67, 0xf5, 0x0d, 0xb7, 0x3a, 0xc2, 0xe2, 0x98, 0x85, 0xee, 0x41, 0x89, 0x37, 0x77, 0x56,
	0x12, 0xf7, 0xeb, 0x9d, 0x39, 0x76, 0xfd, 0xfc, 0x37, 0xa4, 0xcd, 0x30, 0xe9, 0xf2, 0xe0, 0xab,
	0xe9, 0x3f, 0x3f, 0x15, 0x60, 0x2c, 0x3e, 0x79, 0xca, 0x3e, 0x75, 0x48, 0x56, 0x5e, 0x4f, 0xf2,
	0x94, 0xf9, 0x1a, 0x8d, 0xa1, 0xca, 0x86, 0xae, 0x4b, 0x1c, 0x93, 0x8f, 0xb1, 0x6c, 0x4a, 0x4c,
	0x9a, 0x9f, 0xce, 0x59, 0x6d, 0xda, 0x8c, 0xb4, 0xa8, 0xf8, 0x14, 0x58, 0x61, 0xbc, 0xfc, 0xf2,
	0x0a, 0xac, 0x37, 0x6b, 0x2d, 0xdd, 0x6c, 0xd5, 0xcd, 0xf0, 0xfb, 0xc4, 0x30, 0xf4, 0x23, 0xb3,
	0xd6, 0x68, 0xea, 0x7b, 0x66, 0x1d, 0x9b, 0xcd, 0xe6, 0xd1, 0x5f, 0xbf, 0x79, 0x9e, 0x54, 0x7e,
	0x07, 0xe4, 0x5c, 0x32, 0x01, 0x16, 0x30, 0x64, 0x31, 0x7d, 0xe3, 0xf3, 0x14, 0x54, 0xa6, 0xe9,
	0x89, 0xab, 0xe9, 0x0c, 0x03, 0x46, 0x7c, 0x53, 0x1c, 0x0a, 0x88, 0xae, 0x66, 0x28, 0x33, 0xf8,
	0xf0, 0xf9, 0xf0, 0x1a, 0x22, 0x22, 0x15, 0x65, 0xad, 0xa6, 0x5e, 0x5e, 0x81, 0x85, 0x36, 0x89,
	0xa1, 0xe2, 0xcc, 0xb6, 0xa0, 0xe2, 0x58, 0xcc, 0x66, 0xc3, 0x0e, 0x11, 0x73, 0x63, 0xa1, 0xba,
	0xca, 0xe3, 0x58, 0x84, 0xf0, 0xdd, 0x44, 0xe2, 0x8b, 0xea, 0x56, 0x22, 0xf1, 0xc5, 0xdf, 0x70,
	0x0c, 0x41, 0x25, 0x98, 0x71, 0xa8, 0xdb, 0x0b, 0xf1, 0xca, 0x3c, 0x7e, 0x77, 0x6f, 0x2b, 0x91,
	0xd8, 0xfd, 0x3b, 0xbe, 0xc6, 0xa0, 0xd2, 0x75, 0x28, 0x81, 0xfd, 0x84, 0x88, 0x41, 0x22, 0x57,
	0x17, 0x39, 0x27, 0x9d, 0x93, 0xb7, 0x93, 0x09, 0x90, 0x8c, 0x03, 0x6a, 0xda, 0x4f, 0x08, 0xfa,
	0x00, 0xaa, 0x23, 0x6f, 0x60, 0x8e, 0x88, 0x1f, 0xd8, 0xd4, 0x15, 0x33, 0x25, 0x53, 0x95, 0xbe,
	0xbe, 0x02, 0x00, 0xc3, 0x91, 0x37, 0x38, 0x0d, 0xe5, 0xe8, 0x13, 0xb8, 0xe6, 0xf9, 0xf6, 0xc8,
	0x62, 0xc4, 0x74, 0x09, 0x1b, 0x53, 0xff, 0x22, 0xac, 0x86, 0x18, 0x17, 0xd5, 0x0c, 0xb7, 0x2f,
	0xf9, 0x0b, 0x9b, 0x9f, 0x62, 0x14, 0xc1, 0x8c, 0x10, 0x25, 0xea, 0xb3, 0x0f, 0x51, 0x87, 0x74,
	0xad, 0xa1, 0xc3, 0xcc, 0x60, 0x1c, 0xbb, 0x5a, 0x12, 0x3d, 0xb6, 0x36, 0x77, 0x9e, 0xfa, 0xc0,
	0x63, 0x97, 0x0f, 0x13, 0x58, 0x8b, 0x18, 0xcd, 0xf1, 0x34, 0x84, 0x03, 0x78, 0x6b, 0x44, 0x1d,
	0x46, 0x7c, 0xdf, 0x32, 0x03, 0xda, 0x65, 0x63, 0xcb, 0x27, 0xb1, 0xb1, 0xe5, 0x1b, 0x71, 0x64,
	0xd7, 0x1e, 0x26, 0xf0, 0xdb, 0x53, 0x74, 0x33, 0x02, 0x4f, 0x0d, 0xcd, 0x84, 0x43, 0x83, 0xd8,
	0x82, 0xf6, 0x9a, 0x70, 0x40, 0x1c, 0x4e, 0x3d, 0x98, 0x5a, 0xd1, 0x61, 0x96, 0x7a, 0x84, 0x5f,
	0x06, 0xb7, 0x67, 0x06, 0x97, 0x01, 0x23, 0xd7, 0x55, 0x5c, 0x9d, 0x8f, 0x06, 0xe0, 0xb7, 0x62,
	0x70, 0x53, 0x60, 0x23, 0x33, 0xf7, 0x73, 0xdf, 0x3d, 0x78, 0xbb, 0x5c, 0xd8, 0x2e, 0xdc, 0x2b,
	0xdc, 0x29, 0xdc, 0x2d, 0xec, 0x16, 0x7e, 0x59, 0xf8, 0xb8, 0x50, 0xfe, 0x45, 0x61, 0xa7, 0x50,
	0x2e, 0x57, 0x4b, 0x30, 0x77, 0x9d, 0x71, 0x5c, 0x38, 0xb3, 0xdd, 0xa7, 0x76, 0x9b, 0xa0, 0xd5,
	0xe7, 0x57, 0x60, 0xe9, 0xc5, 0x15, 0x58, 0x9c, 0x5c, 0x01, 0xb9, 0xbc, 0x53, 0x28, 0xef, 0x56,
	0x77, 0xe1, 0xed, 0x1f, 0x8a, 0x69, 0x96, 0xa5, 0xbd, 0xb8, 0x02, 0x2b, 0x82, 0xf5, 0x71, 0xa1,
	0x7c, 0xe7, 0x50, 0x52, 0x92, 0x9a, 0x74, 0x28, 0x29, 0x92, 0x26, 0x1f, 0x4a, 0x8a, 0xac, 0xa5,
	0x0e, 0x25, 0x25, 0xa5, 0xa5, 0x0f, 0x25, 0x65, 0x51, 0x5b, 0x3a, 0x94, 0x94, 0x15, 0x4d, 0xdb,
	0xf8, 0x0b, 0x80, 0x2b, 0x67, 0xd4, 0xbf, 0x70, 0xa8, 0xd5, 0xd9, 0xa3, 0x2e, 0x23, 0x8f, 0x19,
	0xaa, 0xc3, 0x94, 0x67, 0xf9, 0xd6, 0x20, 0xc8, 0x02, 0x71, 0xe1, 0xef, 0xbc, 0x6e, 0x5c, 0xcc,
	0x91, 0x8b, 0x0d, 0xc1, 0x0c, 0x9f, 0xd5, 0xc8, 0x0c, 0x9f, 0xb8, 0x96, 0xe7, 0x85, 0x8d, 0x15,
	0x8e, 0xa6, 0xb4, 0xe5, 0x79, 0xbc, 0x85, 0x72, 0xf7, 0xa0, 0x3a, 0xc3, 0xf8, 0x2f, 0x0f, 0xc8,
	0xda, 0xec, 0x03, 0x92, 0x99, 0x7d, 0x19, 0xfe, 0x05, 0xe0, 0xf2, 0x9e, 0x4f, 0x2c, 0x46, 0xe2,
	0xc9, 0x59, 0xf9, 0x5f, 0x27, 0x67, 0x55, 0x79, 0xf6, 0x34, 0xa4, 0x4c, 0x67, 0x68, 0xfe, 0xc6,
	0x0c, 0x15, 0x7a, 0xb1, 0x9f, 0x4e, 0xd3, 0xe3, 0xff, 0x6f, 0x9a, 0x56, 0xd5, 0x67, 0x4f, 0x63,
	0xe2, 0xf5, 0x68, 0xbd, 0x7f, 0xeb, 0x9f, 0x0f, 0xe6, 0xc6, 0xff, 0x77, 0x0f, 0x64, 0xde, 0x37,
	0x3b, 0x1b, 0xef, 0xc3, 0x15, 0x4c, 0x3c, 0xc7, 0x6a, 0xc7, 0xf9, 0xdd, 0x5f, 0xfd, 0x1e, 0x7a,
	0xe3, 0x25, 0x80, 0xea, 0x01, 0x61, 0x3f, 0xca, 0x12, 0x7c, 0x44, 0xa0, 0x32, 0xfd, 0x91, 0x89,
	0x54, 0x98, 0x3e, 0x31, 0x3e, 0x33, 0xea, 0x67, 0x86, 0x96, 0x40, 0x69, 0x98, 0xac, 0x9c, 0x35,
	0x35, 0x80, 0x20, 0x4c, 0x1d, 0xd4, 0xeb, 0x07, 0x47, 0xba, 0xb6, 0x80, 0x32, 0x50, 0xae, 0x3c,
	0x3a, 0xc1, 0xba, 0x96, 0xe4, 0xe2, 0xd3, 0xe3, 0xb3, 0x0a, 0xd6, 0x35, 0x89, 0x63, 0x3f, 0x3b,
	0x3d, 0xd6, 0x64, 0xae, 0xaf, 0xb7, 0x1e, 0xea, 0x58, 0x4b, 0xa1, 0x45, 0xa8, 0x9c, 0xd6, 0x8f,
	0x5a, 0x3a, 0xc6, 0x15, 0x2d, 0xfd, 0xd1, 0x33, 0x00, 0xd5, 0xf0, 0x15, 0x6b, 0x32, 0x8b, 0x11,
	0xce, 0x36, 0xea, 0xad, 0xa6, 0xde, 0x0a, 0x3d, 0x19, 0xfa, 0x99, 0x06, 0x38, 0xa5, 0xd2, 0x68,
	0xe0, 0xfa, 0xa9, 0xbe, 0xaf, 0x2d, 0x88, 0xdd, 0xfe, 0x71, 0xad, 0xd5, 0xd2, 0xf7, 0xb5, 0x24,
	0x8f, 0x0d, 0xeb, 0xad, 0x1a, 0xd6, 0xf7, 0x35, 0x89, 0xb3, 0x7f, 0x55, 0xa9, 0x1d, 0xe9, 0xfb,
	0x9a, 0x8c, 0x14, 0x28, 0xed, 0xd7, 0x0d, 0x5d, 0x4b, 0x71, 0x48, 0x43, 0x37, 0xf6, 0x6b, 0xc6,
	0x81, 0x96, 0xe6, 0x90, 0xba, 0x71, 0x54, 0x33, 0x74, 0x4d, 0x41, 0x4b, 0x30, 0x73, 0xd2, 0x38,
	0xc0, 0x15, 0xa1, 0xca, 0xa0, 0x15, 0xa8, 0x1e, 0x57, 0x6a, 0x46, 0x4b, 0x37, 0x2a, 0xc6, 0x9e,
	0xae, 0xc1, 0xea, 0xef, 0xc1, 0x8b, 0x57, 0xf9, 0xc4, 0x97, 0xaf, 0xf2, 0x89, 0x6f, 0x5f, 0xe5,
	0xc1, 0x6f, 0x27, 0x79, 0xf0, 0xa7, 0x49, 0x1e, 0xfc, 0x63, 0x92, 0x07, 0x2f, 0x26, 0x79, 0xf0,
	0xe5, 0x24, 0x0f, 0xfe, 0x3d, 0xc9, 0x83, 0xaf, 0x27, 0xf9, 0xc4, 0xb7, 0x93, 0x3c, 0xf8, 0xfc,
	0xab, 0x7c, 0xe2, 0xf9, 0x57, 0x79, 0xf0, 0xa8, 0xd1, 0xa3, 0xde, 0x45, 0xaf, 0x38, 0x9d, 0x33,
	0xc5, 0x61, 0x50, 0x12, 0x8b, 0x2e, 0xf5, 0x07, 0x5b, 0xd3, 0xdf, 0xeb, 0x5b, 0x53, 0x75, 0xc9,
	0x3b, 0xef, 0xd1, 0x12, 0x79, 0xcc, 0xa6, 0xff, 0x3f, 0xbe, 0xff, 0xbf, 0xe9, 0x3c, 0x25, 0x7e,
	0x0e, 0xee, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0x1e, 0xb3, 0xcb, 0xec, 0x5c, 0x0d, 0x00, 0x00,
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/network_policy_rule/types.proto

package network_policy_rule

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	ves_io_schema3 "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	_ "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	_ "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	_ "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	_ "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema/views"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Network Policy Rule Action
//
// x-displayName: "Network Policy Rule Action"
// Network policy rule action configures the action to be taken on rule match
type NetworkPolicyRuleAction int32

const (
	// Apply deny action on rule match
	// x-displayName: "Deny"
	DENY NetworkPolicyRuleAction = 0
	// Apply allow action on rule match
	// x-displayName: "Allow"
	ALLOW NetworkPolicyRuleAction = 1
)

var NetworkPolicyRuleAction_name = map[int32]string{
	0: "DENY",
	1: "ALLOW",
}
var NetworkPolicyRuleAction_value = map[string]int32{
	"DENY":  0,
	"ALLOW": 1,
}

func (NetworkPolicyRuleAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// Log Action
//
// x-displayName: "Log Action"
// Choice to choose logging or no logging
// This works together with option selected via NetworkPolicyRuleAction or any other action specified
// x-example: (No Selection in NetworkPolicyRuleAction + AdvancedAction as LOG) = LOG Only, (ALLOW/DENY in NetworkPolicyRuleAction + AdvancedAction as LOG) = Log and Allow/Deny, (ALLOW/DENY in NetworkPolicyRuleAction + NOLOG in AdvancedAction) = Allow/Deny with no log
type LogAction int32

const (
	// Dont sample the traffic hitting the rule
	// x-displayName: "NoLog"
	NOLOG LogAction = 0
	// Sample the traffic hitting the rule
	// x-displayName: "Log"
	LOG LogAction = 1
)

var LogAction_name = map[int32]string{
	0: "NOLOG",
	1: "LOG",
}
var LogAction_value = map[string]int32{
	"NOLOG": 0,
	"LOG":   1,
}

func (LogAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// Network Policy Rule Action
//
// x-displayName: "Network Policy Rule Action"
// Network policy rule action configures the action to be taken on rule match
type NetworkPolicyPBRRuleAction struct {
	// Forwarding Class
	//
	// x-displayName: "Forwarding Class"
	// Ordered list of forwarding class to use for traffic that match enclosing rule
	// Action valid only when policy is part of PBR.
	ForwardingClass []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1,rep,name=forwarding_class,json=forwardingClass" json:"forwarding_class,omitempty"`
}

func (m *NetworkPolicyPBRRuleAction) Reset()                    { *m = NetworkPolicyPBRRuleAction{} }
func (*NetworkPolicyPBRRuleAction) ProtoMessage()               {}
func (*NetworkPolicyPBRRuleAction) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *NetworkPolicyPBRRuleAction) GetForwardingClass() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ForwardingClass
	}
	return nil
}

// Network Policy Rule Advanced Action
//
// x-displayName: "Network Policy Rule Advanced Action"
// Network Policy Rule Advanced Action provides additional options along with RuleAction and PBRRuleAction
type NetworkPolicyRuleAdvancedAction struct {
	// Action
	// x-displayName: "Action"
	//
	// Advanced action applied along with selection in NetworkPolicyRuleAction
	Action LogAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.LogAction" json:"action,omitempty"`
}

func (m *NetworkPolicyRuleAdvancedAction) Reset()      { *m = NetworkPolicyRuleAdvancedAction{} }
func (*NetworkPolicyRuleAdvancedAction) ProtoMessage() {}
func (*NetworkPolicyRuleAdvancedAction) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{1}
}

func (m *NetworkPolicyRuleAdvancedAction) GetAction() LogAction {
	if m != nil {
		return m.Action
	}
	return NOLOG
}

// Network Policy Rule Specification
//
// x-displayName: "Specification"
// Desired state of the network policy rule
type GlobalSpecType struct {
	// Action
	//
	// x-displayName: "Action"
	// Action to be taken at rule match. Currently supported actions are Allow and  Deny
	Action NetworkPolicyRuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.NetworkPolicyRuleAction" json:"action,omitempty"`
	// ports
	//
	// x-displayName: "Port Ranges"
	// x-example: "100-200"
	// Ports is list of port ranges as match criteria. Range is expressed as start port and end port
	Ports []string `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	// protocol
	//
	// x-displayName: "Protocol"
	// x-example: "tcp"
	// Protocol in IP packet to be used as match criteria
	// Values are tcp, udp, and icmp
	Protocol string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Remote Endpoint
	//
	// x-displayName: "Remote Endpoint"
	// Remote endpoint is the other endpoint for ingress or egress session with local endpoint
	// of network policy. If network policy rule is a ingress rule in network policy then remote
	// endpoint indicates the source endpoint from  which session is initiated. If network policy rule
	// is a egress rule in network policy then remote endpoint indicates the destination endpoint to which
	// session is initiated. Not specifying any endpoint will result in creation of ANY endpoint
	//
	// Types that are valid to be assigned to RemoteEndpoint:
	//	*GlobalSpecType_Prefix
	//	*GlobalSpecType_PrefixSelector
	//	*GlobalSpecType_IpPrefixSet
	RemoteEndpoint isGlobalSpecType_RemoteEndpoint `protobuf_oneof:"remote_endpoint"`
	// label matcher
	//
	// x-displayName: "Label Matcher"
	// x-example: label_matcher is "app" and say prefix_selector is "app == web, site in (abc, xyz)" then only label app will be matched and not site
	//
	// List of label keys to be matched in prefix_selector configured in remote_endpoint
	LabelMatcher *ves_io_schema4.LabelMatcherType `protobuf:"bytes,6,opt,name=label_matcher,json=labelMatcher" json:"label_matcher,omitempty"`
	// Policy Based Routing Action
	//
	// x-displayName: "Policy Based Routing Action"
	// Action valid only when policy is part of PBR.
	PbrAction *NetworkPolicyPBRRuleAction `protobuf:"bytes,8,opt,name=pbr_action,json=pbrAction" json:"pbr_action,omitempty"`
	// Advanced Action
	//
	// x-displayName: "Advanced Action"
	// Apart from the regular action(allow/deny) user can choose advanced action for a rule. Supported advanced actions are - Logging
	// Note: It is not necessary to choose NetworkPolicyRuleAction for advanced action. Only advanced action can be selected
	// x-example: For sampling a particular flow advanced action "Log" can be selected without choosing any NetworkPolicyRuleAction. Other example can be to choose
	// NetworkPolicyRuleAction for allow/deny and also log for sampling
	AdvancedAction *NetworkPolicyRuleAdvancedAction `protobuf:"bytes,10,opt,name=advanced_action,json=advancedAction" json:"advanced_action,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isGlobalSpecType_RemoteEndpoint interface {
	isGlobalSpecType_RemoteEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_Prefix struct {
	Prefix *ves_io_schema3.PrefixListType `protobuf:"bytes,4,opt,name=prefix,oneof"`
}
type GlobalSpecType_PrefixSelector struct {
	PrefixSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,5,opt,name=prefix_selector,json=prefixSelector,oneof"`
}
type GlobalSpecType_IpPrefixSet struct {
	IpPrefixSet *ves_io_schema4.IpPrefixSetRefType `protobuf:"bytes,7,opt,name=ip_prefix_set,json=ipPrefixSet,oneof"`
}

func (*GlobalSpecType_Prefix) isGlobalSpecType_RemoteEndpoint()         {}
func (*GlobalSpecType_PrefixSelector) isGlobalSpecType_RemoteEndpoint() {}
func (*GlobalSpecType_IpPrefixSet) isGlobalSpecType_RemoteEndpoint()    {}

func (m *GlobalSpecType) GetRemoteEndpoint() isGlobalSpecType_RemoteEndpoint {
	if m != nil {
		return m.RemoteEndpoint
	}
	return nil
}

func (m *GlobalSpecType) GetAction() NetworkPolicyRuleAction {
	if m != nil {
		return m.Action
	}
	return DENY
}

func (m *GlobalSpecType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *GlobalSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *GlobalSpecType) GetPrefix() *ves_io_schema3.PrefixListType {
	if x, ok := m.GetRemoteEndpoint().(*GlobalSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *GlobalSpecType) GetPrefixSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetRemoteEndpoint().(*GlobalSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *GlobalSpecType) GetIpPrefixSet() *ves_io_schema4.IpPrefixSetRefType {
	if x, ok := m.GetRemoteEndpoint().(*GlobalSpecType_IpPrefixSet); ok {
		return x.IpPrefixSet
	}
	return nil
}

func (m *GlobalSpecType) GetLabelMatcher() *ves_io_schema4.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetPbrAction() *NetworkPolicyPBRRuleAction {
	if m != nil {
		return m.PbrAction
	}
	return nil
}

func (m *GlobalSpecType) GetAdvancedAction() *NetworkPolicyRuleAdvancedAction {
	if m != nil {
		return m.AdvancedAction
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_Prefix)(nil),
		(*GlobalSpecType_PrefixSelector)(nil),
		(*GlobalSpecType_IpPrefixSet)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// remote_endpoint
	switch x := m.RemoteEndpoint.(type) {
	case *GlobalSpecType_Prefix:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *GlobalSpecType_PrefixSelector:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PrefixSelector); err != nil {
			return err
		}
	case *GlobalSpecType_IpPrefixSet:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpPrefixSet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.RemoteEndpoint has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 4: // remote_endpoint.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.PrefixListType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &GlobalSpecType_Prefix{msg}
		return true, err
	case 5: // remote_endpoint.prefix_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &GlobalSpecType_PrefixSelector{msg}
		return true, err
	case 7: // remote_endpoint.ip_prefix_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.IpPrefixSetRefType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &GlobalSpecType_IpPrefixSet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// remote_endpoint
	switch x := m.RemoteEndpoint.(type) {
	case *GlobalSpecType_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_PrefixSelector:
		s := proto.Size(x.PrefixSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_IpPrefixSet:
		s := proto.Size(x.IpPrefixSet)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create Network Policy Rule
//
// x-displayName: "Create Network Policy Rule"
// Creates a network policy rule with configured parameters in specified namespace
type CreateSpecType struct {
	Action   NetworkPolicyRuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.NetworkPolicyRuleAction" json:"action,omitempty"`
	Ports    []string                `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	Protocol string                  `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Types that are valid to be assigned to RemoteEndpoint:
	//	*CreateSpecType_Prefix
	//	*CreateSpecType_PrefixSelector
	//	*CreateSpecType_IpPrefixSet
	RemoteEndpoint isCreateSpecType_RemoteEndpoint  `protobuf_oneof:"remote_endpoint"`
	LabelMatcher   *ves_io_schema4.LabelMatcherType `protobuf:"bytes,6,opt,name=label_matcher,json=labelMatcher" json:"label_matcher,omitempty"`
	AdvancedAction *NetworkPolicyRuleAdvancedAction `protobuf:"bytes,10,opt,name=advanced_action,json=advancedAction" json:"advanced_action,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

type isCreateSpecType_RemoteEndpoint interface {
	isCreateSpecType_RemoteEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_Prefix struct {
	Prefix *ves_io_schema3.PrefixListType `protobuf:"bytes,4,opt,name=prefix,oneof"`
}
type CreateSpecType_PrefixSelector struct {
	PrefixSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,5,opt,name=prefix_selector,json=prefixSelector,oneof"`
}
type CreateSpecType_IpPrefixSet struct {
	IpPrefixSet *ves_io_schema4.IpPrefixSetRefType `protobuf:"bytes,7,opt,name=ip_prefix_set,json=ipPrefixSet,oneof"`
}

func (*CreateSpecType_Prefix) isCreateSpecType_RemoteEndpoint()         {}
func (*CreateSpecType_PrefixSelector) isCreateSpecType_RemoteEndpoint() {}
func (*CreateSpecType_IpPrefixSet) isCreateSpecType_RemoteEndpoint()    {}

func (m *CreateSpecType) GetRemoteEndpoint() isCreateSpecType_RemoteEndpoint {
	if m != nil {
		return m.RemoteEndpoint
	}
	return nil
}

func (m *CreateSpecType) GetAction() NetworkPolicyRuleAction {
	if m != nil {
		return m.Action
	}
	return DENY
}

func (m *CreateSpecType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *CreateSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *CreateSpecType) GetPrefix() *ves_io_schema3.PrefixListType {
	if x, ok := m.GetRemoteEndpoint().(*CreateSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *CreateSpecType) GetPrefixSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetRemoteEndpoint().(*CreateSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *CreateSpecType) GetIpPrefixSet() *ves_io_schema4.IpPrefixSetRefType {
	if x, ok := m.GetRemoteEndpoint().(*CreateSpecType_IpPrefixSet); ok {
		return x.IpPrefixSet
	}
	return nil
}

func (m *CreateSpecType) GetLabelMatcher() *ves_io_schema4.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAdvancedAction() *NetworkPolicyRuleAdvancedAction {
	if m != nil {
		return m.AdvancedAction
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_Prefix)(nil),
		(*CreateSpecType_PrefixSelector)(nil),
		(*CreateSpecType_IpPrefixSet)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// remote_endpoint
	switch x := m.RemoteEndpoint.(type) {
	case *CreateSpecType_Prefix:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *CreateSpecType_PrefixSelector:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PrefixSelector); err != nil {
			return err
		}
	case *CreateSpecType_IpPrefixSet:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpPrefixSet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.RemoteEndpoint has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 4: // remote_endpoint.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.PrefixListType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &CreateSpecType_Prefix{msg}
		return true, err
	case 5: // remote_endpoint.prefix_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &CreateSpecType_PrefixSelector{msg}
		return true, err
	case 7: // remote_endpoint.ip_prefix_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.IpPrefixSetRefType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &CreateSpecType_IpPrefixSet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// remote_endpoint
	switch x := m.RemoteEndpoint.(type) {
	case *CreateSpecType_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_PrefixSelector:
		s := proto.Size(x.PrefixSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_IpPrefixSet:
		s := proto.Size(x.IpPrefixSet)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace Network Policy Rule
//
// x-displayName: "Replace Network Policy Rule"
// Replaces a network policy rule with configured parameters in specified namespace
type ReplaceSpecType struct {
	Action   NetworkPolicyRuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.NetworkPolicyRuleAction" json:"action,omitempty"`
	Ports    []string                `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	Protocol string                  `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Types that are valid to be assigned to RemoteEndpoint:
	//	*ReplaceSpecType_Prefix
	//	*ReplaceSpecType_PrefixSelector
	//	*ReplaceSpecType_IpPrefixSet
	RemoteEndpoint isReplaceSpecType_RemoteEndpoint `protobuf_oneof:"remote_endpoint"`
	LabelMatcher   *ves_io_schema4.LabelMatcherType `protobuf:"bytes,6,opt,name=label_matcher,json=labelMatcher" json:"label_matcher,omitempty"`
	AdvancedAction *NetworkPolicyRuleAdvancedAction `protobuf:"bytes,10,opt,name=advanced_action,json=advancedAction" json:"advanced_action,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isReplaceSpecType_RemoteEndpoint interface {
	isReplaceSpecType_RemoteEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_Prefix struct {
	Prefix *ves_io_schema3.PrefixListType `protobuf:"bytes,4,opt,name=prefix,oneof"`
}
type ReplaceSpecType_PrefixSelector struct {
	PrefixSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,5,opt,name=prefix_selector,json=prefixSelector,oneof"`
}
type ReplaceSpecType_IpPrefixSet struct {
	IpPrefixSet *ves_io_schema4.IpPrefixSetRefType `protobuf:"bytes,7,opt,name=ip_prefix_set,json=ipPrefixSet,oneof"`
}

func (*ReplaceSpecType_Prefix) isReplaceSpecType_RemoteEndpoint()         {}
func (*ReplaceSpecType_PrefixSelector) isReplaceSpecType_RemoteEndpoint() {}
func (*ReplaceSpecType_IpPrefixSet) isReplaceSpecType_RemoteEndpoint()    {}

func (m *ReplaceSpecType) GetRemoteEndpoint() isReplaceSpecType_RemoteEndpoint {
	if m != nil {
		return m.RemoteEndpoint
	}
	return nil
}

func (m *ReplaceSpecType) GetAction() NetworkPolicyRuleAction {
	if m != nil {
		return m.Action
	}
	return DENY
}

func (m *ReplaceSpecType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ReplaceSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ReplaceSpecType) GetPrefix() *ves_io_schema3.PrefixListType {
	if x, ok := m.GetRemoteEndpoint().(*ReplaceSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *ReplaceSpecType) GetPrefixSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetRemoteEndpoint().(*ReplaceSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetIpPrefixSet() *ves_io_schema4.IpPrefixSetRefType {
	if x, ok := m.GetRemoteEndpoint().(*ReplaceSpecType_IpPrefixSet); ok {
		return x.IpPrefixSet
	}
	return nil
}

func (m *ReplaceSpecType) GetLabelMatcher() *ves_io_schema4.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAdvancedAction() *NetworkPolicyRuleAdvancedAction {
	if m != nil {
		return m.AdvancedAction
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_Prefix)(nil),
		(*ReplaceSpecType_PrefixSelector)(nil),
		(*ReplaceSpecType_IpPrefixSet)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// remote_endpoint
	switch x := m.RemoteEndpoint.(type) {
	case *ReplaceSpecType_Prefix:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *ReplaceSpecType_PrefixSelector:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PrefixSelector); err != nil {
			return err
		}
	case *ReplaceSpecType_IpPrefixSet:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpPrefixSet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.RemoteEndpoint has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 4: // remote_endpoint.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.PrefixListType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &ReplaceSpecType_Prefix{msg}
		return true, err
	case 5: // remote_endpoint.prefix_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &ReplaceSpecType_PrefixSelector{msg}
		return true, err
	case 7: // remote_endpoint.ip_prefix_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.IpPrefixSetRefType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &ReplaceSpecType_IpPrefixSet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// remote_endpoint
	switch x := m.RemoteEndpoint.(type) {
	case *ReplaceSpecType_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_PrefixSelector:
		s := proto.Size(x.PrefixSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_IpPrefixSet:
		s := proto.Size(x.IpPrefixSet)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get Network Policy Rule
//
// x-displayName: "Get Network Policy Rule"
// Get a network policy rule in specified namespace
type GetSpecType struct {
	Action   NetworkPolicyRuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.NetworkPolicyRuleAction" json:"action,omitempty"`
	Ports    []string                `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	Protocol string                  `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Types that are valid to be assigned to RemoteEndpoint:
	//	*GetSpecType_Prefix
	//	*GetSpecType_PrefixSelector
	//	*GetSpecType_IpPrefixSet
	RemoteEndpoint isGetSpecType_RemoteEndpoint     `protobuf_oneof:"remote_endpoint"`
	LabelMatcher   *ves_io_schema4.LabelMatcherType `protobuf:"bytes,6,opt,name=label_matcher,json=labelMatcher" json:"label_matcher,omitempty"`
	AdvancedAction *NetworkPolicyRuleAdvancedAction `protobuf:"bytes,10,opt,name=advanced_action,json=advancedAction" json:"advanced_action,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

type isGetSpecType_RemoteEndpoint interface {
	isGetSpecType_RemoteEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_Prefix struct {
	Prefix *ves_io_schema3.PrefixListType `protobuf:"bytes,4,opt,name=prefix,oneof"`
}
type GetSpecType_PrefixSelector struct {
	PrefixSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,5,opt,name=prefix_selector,json=prefixSelector,oneof"`
}
type GetSpecType_IpPrefixSet struct {
	IpPrefixSet *ves_io_schema4.IpPrefixSetRefType `protobuf:"bytes,7,opt,name=ip_prefix_set,json=ipPrefixSet,oneof"`
}

func (*GetSpecType_Prefix) isGetSpecType_RemoteEndpoint()         {}
func (*GetSpecType_PrefixSelector) isGetSpecType_RemoteEndpoint() {}
func (*GetSpecType_IpPrefixSet) isGetSpecType_RemoteEndpoint()    {}

func (m *GetSpecType) GetRemoteEndpoint() isGetSpecType_RemoteEndpoint {
	if m != nil {
		return m.RemoteEndpoint
	}
	return nil
}

func (m *GetSpecType) GetAction() NetworkPolicyRuleAction {
	if m != nil {
		return m.Action
	}
	return DENY
}

func (m *GetSpecType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *GetSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *GetSpecType) GetPrefix() *ves_io_schema3.PrefixListType {
	if x, ok := m.GetRemoteEndpoint().(*GetSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *GetSpecType) GetPrefixSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetRemoteEndpoint().(*GetSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *GetSpecType) GetIpPrefixSet() *ves_io_schema4.IpPrefixSetRefType {
	if x, ok := m.GetRemoteEndpoint().(*GetSpecType_IpPrefixSet); ok {
		return x.IpPrefixSet
	}
	return nil
}

func (m *GetSpecType) GetLabelMatcher() *ves_io_schema4.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *GetSpecType) GetAdvancedAction() *NetworkPolicyRuleAdvancedAction {
	if m != nil {
		return m.AdvancedAction
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_Prefix)(nil),
		(*GetSpecType_PrefixSelector)(nil),
		(*GetSpecType_IpPrefixSet)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// remote_endpoint
	switch x := m.RemoteEndpoint.(type) {
	case *GetSpecType_Prefix:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *GetSpecType_PrefixSelector:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PrefixSelector); err != nil {
			return err
		}
	case *GetSpecType_IpPrefixSet:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpPrefixSet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.RemoteEndpoint has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 4: // remote_endpoint.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.PrefixListType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &GetSpecType_Prefix{msg}
		return true, err
	case 5: // remote_endpoint.prefix_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &GetSpecType_PrefixSelector{msg}
		return true, err
	case 7: // remote_endpoint.ip_prefix_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.IpPrefixSetRefType)
		err := b.DecodeMessage(msg)
		m.RemoteEndpoint = &GetSpecType_IpPrefixSet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// remote_endpoint
	switch x := m.RemoteEndpoint.(type) {
	case *GetSpecType_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_PrefixSelector:
		s := proto.Size(x.PrefixSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_IpPrefixSet:
		s := proto.Size(x.IpPrefixSet)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*NetworkPolicyPBRRuleAction)(nil), "ves.io.schema.network_policy_rule.NetworkPolicyPBRRuleAction")
	golang_proto.RegisterType((*NetworkPolicyPBRRuleAction)(nil), "ves.io.schema.network_policy_rule.NetworkPolicyPBRRuleAction")
	proto.RegisterType((*NetworkPolicyRuleAdvancedAction)(nil), "ves.io.schema.network_policy_rule.NetworkPolicyRuleAdvancedAction")
	golang_proto.RegisterType((*NetworkPolicyRuleAdvancedAction)(nil), "ves.io.schema.network_policy_rule.NetworkPolicyRuleAdvancedAction")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_policy_rule.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_policy_rule.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_policy_rule.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_policy_rule.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_policy_rule.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_policy_rule.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_policy_rule.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_policy_rule.GetSpecType")
	proto.RegisterEnum("ves.io.schema.network_policy_rule.NetworkPolicyRuleAction", NetworkPolicyRuleAction_name, NetworkPolicyRuleAction_value)
	golang_proto.RegisterEnum("ves.io.schema.network_policy_rule.NetworkPolicyRuleAction", NetworkPolicyRuleAction_name, NetworkPolicyRuleAction_value)
	proto.RegisterEnum("ves.io.schema.network_policy_rule.LogAction", LogAction_name, LogAction_value)
	golang_proto.RegisterEnum("ves.io.schema.network_policy_rule.LogAction", LogAction_name, LogAction_value)
}
func (x NetworkPolicyRuleAction) String() string {
	s, ok := NetworkPolicyRuleAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LogAction) String() string {
	s, ok := LogAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NetworkPolicyPBRRuleAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyPBRRuleAction)
	if !ok {
		that2, ok := that.(NetworkPolicyPBRRuleAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ForwardingClass) != len(that1.ForwardingClass) {
		return false
	}
	for i := range this.ForwardingClass {
		if !this.ForwardingClass[i].Equal(that1.ForwardingClass[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkPolicyRuleAdvancedAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleAdvancedAction)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleAdvancedAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.RemoteEndpoint == nil {
		if this.RemoteEndpoint != nil {
			return false
		}
	} else if this.RemoteEndpoint == nil {
		return false
	} else if !this.RemoteEndpoint.Equal(that1.RemoteEndpoint) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.PbrAction.Equal(that1.PbrAction) {
		return false
	}
	if !this.AdvancedAction.Equal(that1.AdvancedAction) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Prefix)
	if !ok {
		that2, ok := that.(GlobalSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *GlobalSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IpPrefixSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IpPrefixSet)
	if !ok {
		that2, ok := that.(GlobalSpecType_IpPrefixSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixSet.Equal(that1.IpPrefixSet) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.RemoteEndpoint == nil {
		if this.RemoteEndpoint != nil {
			return false
		}
	} else if this.RemoteEndpoint == nil {
		return false
	} else if !this.RemoteEndpoint.Equal(that1.RemoteEndpoint) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.AdvancedAction.Equal(that1.AdvancedAction) {
		return false
	}
	return true
}
func (this *CreateSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Prefix)
	if !ok {
		that2, ok := that.(CreateSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *CreateSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(CreateSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *CreateSpecType_IpPrefixSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IpPrefixSet)
	if !ok {
		that2, ok := that.(CreateSpecType_IpPrefixSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixSet.Equal(that1.IpPrefixSet) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.RemoteEndpoint == nil {
		if this.RemoteEndpoint != nil {
			return false
		}
	} else if this.RemoteEndpoint == nil {
		return false
	} else if !this.RemoteEndpoint.Equal(that1.RemoteEndpoint) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.AdvancedAction.Equal(that1.AdvancedAction) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Prefix)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(ReplaceSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IpPrefixSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IpPrefixSet)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IpPrefixSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixSet.Equal(that1.IpPrefixSet) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.RemoteEndpoint == nil {
		if this.RemoteEndpoint != nil {
			return false
		}
	} else if this.RemoteEndpoint == nil {
		return false
	} else if !this.RemoteEndpoint.Equal(that1.RemoteEndpoint) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.AdvancedAction.Equal(that1.AdvancedAction) {
		return false
	}
	return true
}
func (this *GetSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Prefix)
	if !ok {
		that2, ok := that.(GetSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *GetSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(GetSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *GetSpecType_IpPrefixSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IpPrefixSet)
	if !ok {
		that2, ok := that.(GetSpecType_IpPrefixSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixSet.Equal(that1.IpPrefixSet) {
		return false
	}
	return true
}
func (this *NetworkPolicyPBRRuleAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_policy_rule.NetworkPolicyPBRRuleAction{")
	if this.ForwardingClass != nil {
		s = append(s, "ForwardingClass: "+fmt.Sprintf("%#v", this.ForwardingClass)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkPolicyRuleAdvancedAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_policy_rule.NetworkPolicyRuleAdvancedAction{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&network_policy_rule.GlobalSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.RemoteEndpoint != nil {
		s = append(s, "RemoteEndpoint: "+fmt.Sprintf("%#v", this.RemoteEndpoint)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.PbrAction != nil {
		s = append(s, "PbrAction: "+fmt.Sprintf("%#v", this.PbrAction)+",\n")
	}
	if this.AdvancedAction != nil {
		s = append(s, "AdvancedAction: "+fmt.Sprintf("%#v", this.AdvancedAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GlobalSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GlobalSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IpPrefixSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GlobalSpecType_IpPrefixSet{` +
		`IpPrefixSet:` + fmt.Sprintf("%#v", this.IpPrefixSet) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&network_policy_rule.CreateSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.RemoteEndpoint != nil {
		s = append(s, "RemoteEndpoint: "+fmt.Sprintf("%#v", this.RemoteEndpoint)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.AdvancedAction != nil {
		s = append(s, "AdvancedAction: "+fmt.Sprintf("%#v", this.AdvancedAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.CreateSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.CreateSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IpPrefixSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.CreateSpecType_IpPrefixSet{` +
		`IpPrefixSet:` + fmt.Sprintf("%#v", this.IpPrefixSet) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&network_policy_rule.ReplaceSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.RemoteEndpoint != nil {
		s = append(s, "RemoteEndpoint: "+fmt.Sprintf("%#v", this.RemoteEndpoint)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.AdvancedAction != nil {
		s = append(s, "AdvancedAction: "+fmt.Sprintf("%#v", this.AdvancedAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.ReplaceSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.ReplaceSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IpPrefixSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.ReplaceSpecType_IpPrefixSet{` +
		`IpPrefixSet:` + fmt.Sprintf("%#v", this.IpPrefixSet) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&network_policy_rule.GetSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.RemoteEndpoint != nil {
		s = append(s, "RemoteEndpoint: "+fmt.Sprintf("%#v", this.RemoteEndpoint)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.AdvancedAction != nil {
		s = append(s, "AdvancedAction: "+fmt.Sprintf("%#v", this.AdvancedAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GetSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *GetSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GetSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IpPrefixSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GetSpecType_IpPrefixSet{` +
		`IpPrefixSet:` + fmt.Sprintf("%#v", this.IpPrefixSet) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NetworkPolicyPBRRuleAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPolicyPBRRuleAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ForwardingClass) > 0 {
		for _, msg := range m.ForwardingClass {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NetworkPolicyRuleAdvancedAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPolicyRuleAdvancedAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.RemoteEndpoint != nil {
		nn1, err := m.RemoteEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.LabelMatcher != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LabelMatcher.Size()))
		n2, err := m.LabelMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.PbrAction != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PbrAction.Size()))
		n3, err := m.PbrAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.AdvancedAction != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AdvancedAction.Size()))
		n4, err := m.AdvancedAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *GlobalSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n5, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *GlobalSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PrefixSelector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixSelector.Size()))
		n6, err := m.PrefixSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *GlobalSpecType_IpPrefixSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpPrefixSet != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixSet.Size()))
		n7, err := m.IpPrefixSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.RemoteEndpoint != nil {
		nn8, err := m.RemoteEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	if m.LabelMatcher != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LabelMatcher.Size()))
		n9, err := m.LabelMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.AdvancedAction != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AdvancedAction.Size()))
		n10, err := m.AdvancedAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *CreateSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n11, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *CreateSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PrefixSelector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixSelector.Size()))
		n12, err := m.PrefixSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *CreateSpecType_IpPrefixSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpPrefixSet != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixSet.Size()))
		n13, err := m.IpPrefixSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.RemoteEndpoint != nil {
		nn14, err := m.RemoteEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.LabelMatcher != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LabelMatcher.Size()))
		n15, err := m.LabelMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.AdvancedAction != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AdvancedAction.Size()))
		n16, err := m.AdvancedAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *ReplaceSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n17, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *ReplaceSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PrefixSelector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixSelector.Size()))
		n18, err := m.PrefixSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *ReplaceSpecType_IpPrefixSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpPrefixSet != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixSet.Size()))
		n19, err := m.IpPrefixSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.RemoteEndpoint != nil {
		nn20, err := m.RemoteEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	if m.LabelMatcher != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LabelMatcher.Size()))
		n21, err := m.LabelMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.AdvancedAction != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AdvancedAction.Size()))
		n22, err := m.AdvancedAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *GetSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n23, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *GetSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PrefixSelector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixSelector.Size()))
		n24, err := m.PrefixSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *GetSpecType_IpPrefixSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpPrefixSet != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixSet.Size()))
		n25, err := m.IpPrefixSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedNetworkPolicyPBRRuleAction(r randyTypes, easy bool) *NetworkPolicyPBRRuleAction {
	this := &NetworkPolicyPBRRuleAction{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.ForwardingClass = make([]*ves_io_schema4.ObjectRefType, v1)
		for i := 0; i < v1; i++ {
			this.ForwardingClass[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNetworkPolicyRuleAdvancedAction(r randyTypes, easy bool) *NetworkPolicyRuleAdvancedAction {
	this := &NetworkPolicyRuleAdvancedAction{}
	this.Action = LogAction([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	this.Action = NetworkPolicyRuleAction([]int32{0, 1}[r.Intn(2)])
	v2 := r.Intn(10)
	this.Ports = make([]string, v2)
	for i := 0; i < v2; i++ {
		this.Ports[i] = string(randStringTypes(r))
	}
	this.Protocol = string(randStringTypes(r))
	oneofNumber_RemoteEndpoint := []int32{4, 5, 7}[r.Intn(3)]
	switch oneofNumber_RemoteEndpoint {
	case 4:
		this.RemoteEndpoint = NewPopulatedGlobalSpecType_Prefix(r, easy)
	case 5:
		this.RemoteEndpoint = NewPopulatedGlobalSpecType_PrefixSelector(r, easy)
	case 7:
		this.RemoteEndpoint = NewPopulatedGlobalSpecType_IpPrefixSet(r, easy)
	}
	if r.Intn(10) != 0 {
		this.LabelMatcher = ves_io_schema4.NewPopulatedLabelMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.PbrAction = NewPopulatedNetworkPolicyPBRRuleAction(r, easy)
	}
	if r.Intn(10) != 0 {
		this.AdvancedAction = NewPopulatedNetworkPolicyRuleAdvancedAction(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType_Prefix(r randyTypes, easy bool) *GlobalSpecType_Prefix {
	this := &GlobalSpecType_Prefix{}
	this.Prefix = ves_io_schema3.NewPopulatedPrefixListType(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_PrefixSelector(r randyTypes, easy bool) *GlobalSpecType_PrefixSelector {
	this := &GlobalSpecType_PrefixSelector{}
	this.PrefixSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_IpPrefixSet(r randyTypes, easy bool) *GlobalSpecType_IpPrefixSet {
	this := &GlobalSpecType_IpPrefixSet{}
	this.IpPrefixSet = ves_io_schema4.NewPopulatedIpPrefixSetRefType(r, easy)
	return this
}
func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	this.Action = NetworkPolicyRuleAction([]int32{0, 1}[r.Intn(2)])
	v3 := r.Intn(10)
	this.Ports = make([]string, v3)
	for i := 0; i < v3; i++ {
		this.Ports[i] = string(randStringTypes(r))
	}
	this.Protocol = string(randStringTypes(r))
	oneofNumber_RemoteEndpoint := []int32{4, 5, 7}[r.Intn(3)]
	switch oneofNumber_RemoteEndpoint {
	case 4:
		this.RemoteEndpoint = NewPopulatedCreateSpecType_Prefix(r, easy)
	case 5:
		this.RemoteEndpoint = NewPopulatedCreateSpecType_PrefixSelector(r, easy)
	case 7:
		this.RemoteEndpoint = NewPopulatedCreateSpecType_IpPrefixSet(r, easy)
	}
	if r.Intn(10) != 0 {
		this.LabelMatcher = ves_io_schema4.NewPopulatedLabelMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.AdvancedAction = NewPopulatedNetworkPolicyRuleAdvancedAction(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType_Prefix(r randyTypes, easy bool) *CreateSpecType_Prefix {
	this := &CreateSpecType_Prefix{}
	this.Prefix = ves_io_schema3.NewPopulatedPrefixListType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_PrefixSelector(r randyTypes, easy bool) *CreateSpecType_PrefixSelector {
	this := &CreateSpecType_PrefixSelector{}
	this.PrefixSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_IpPrefixSet(r randyTypes, easy bool) *CreateSpecType_IpPrefixSet {
	this := &CreateSpecType_IpPrefixSet{}
	this.IpPrefixSet = ves_io_schema4.NewPopulatedIpPrefixSetRefType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	this.Action = NetworkPolicyRuleAction([]int32{0, 1}[r.Intn(2)])
	v4 := r.Intn(10)
	this.Ports = make([]string, v4)
	for i := 0; i < v4; i++ {
		this.Ports[i] = string(randStringTypes(r))
	}
	this.Protocol = string(randStringTypes(r))
	oneofNumber_RemoteEndpoint := []int32{4, 5, 7}[r.Intn(3)]
	switch oneofNumber_RemoteEndpoint {
	case 4:
		this.RemoteEndpoint = NewPopulatedReplaceSpecType_Prefix(r, easy)
	case 5:
		this.RemoteEndpoint = NewPopulatedReplaceSpecType_PrefixSelector(r, easy)
	case 7:
		this.RemoteEndpoint = NewPopulatedReplaceSpecType_IpPrefixSet(r, easy)
	}
	if r.Intn(10) != 0 {
		this.LabelMatcher = ves_io_schema4.NewPopulatedLabelMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.AdvancedAction = NewPopulatedNetworkPolicyRuleAdvancedAction(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType_Prefix(r randyTypes, easy bool) *ReplaceSpecType_Prefix {
	this := &ReplaceSpecType_Prefix{}
	this.Prefix = ves_io_schema3.NewPopulatedPrefixListType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_PrefixSelector(r randyTypes, easy bool) *ReplaceSpecType_PrefixSelector {
	this := &ReplaceSpecType_PrefixSelector{}
	this.PrefixSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_IpPrefixSet(r randyTypes, easy bool) *ReplaceSpecType_IpPrefixSet {
	this := &ReplaceSpecType_IpPrefixSet{}
	this.IpPrefixSet = ves_io_schema4.NewPopulatedIpPrefixSetRefType(r, easy)
	return this
}
func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	this.Action = NetworkPolicyRuleAction([]int32{0, 1}[r.Intn(2)])
	v5 := r.Intn(10)
	this.Ports = make([]string, v5)
	for i := 0; i < v5; i++ {
		this.Ports[i] = string(randStringTypes(r))
	}
	this.Protocol = string(randStringTypes(r))
	oneofNumber_RemoteEndpoint := []int32{4, 5, 7}[r.Intn(3)]
	switch oneofNumber_RemoteEndpoint {
	case 4:
		this.RemoteEndpoint = NewPopulatedGetSpecType_Prefix(r, easy)
	case 5:
		this.RemoteEndpoint = NewPopulatedGetSpecType_PrefixSelector(r, easy)
	case 7:
		this.RemoteEndpoint = NewPopulatedGetSpecType_IpPrefixSet(r, easy)
	}
	if r.Intn(10) != 0 {
		this.LabelMatcher = ves_io_schema4.NewPopulatedLabelMatcherType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.AdvancedAction = NewPopulatedNetworkPolicyRuleAdvancedAction(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType_Prefix(r randyTypes, easy bool) *GetSpecType_Prefix {
	this := &GetSpecType_Prefix{}
	this.Prefix = ves_io_schema3.NewPopulatedPrefixListType(r, easy)
	return this
}
func NewPopulatedGetSpecType_PrefixSelector(r randyTypes, easy bool) *GetSpecType_PrefixSelector {
	this := &GetSpecType_PrefixSelector{}
	this.PrefixSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedGetSpecType_IpPrefixSet(r randyTypes, easy bool) *GetSpecType_IpPrefixSet {
	this := &GetSpecType_IpPrefixSet{}
	this.IpPrefixSet = ves_io_schema4.NewPopulatedIpPrefixSetRefType(r, easy)
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v6 := r.Intn(100)
	tmps := make([]rune, v6)
	for i := 0; i < v6; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v7 := r.Int63()
		if r.Intn(2) == 0 {
			v7 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v7))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *NetworkPolicyPBRRuleAction) Size() (n int) {
	var l int
	_ = l
	if len(m.ForwardingClass) > 0 {
		for _, e := range m.ForwardingClass {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkPolicyRuleAdvancedAction) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteEndpoint != nil {
		n += m.RemoteEndpoint.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PbrAction != nil {
		l = m.PbrAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvancedAction != nil {
		l = m.AdvancedAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_PrefixSelector) Size() (n int) {
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IpPrefixSet) Size() (n int) {
	var l int
	_ = l
	if m.IpPrefixSet != nil {
		l = m.IpPrefixSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteEndpoint != nil {
		n += m.RemoteEndpoint.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvancedAction != nil {
		l = m.AdvancedAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_PrefixSelector) Size() (n int) {
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IpPrefixSet) Size() (n int) {
	var l int
	_ = l
	if m.IpPrefixSet != nil {
		l = m.IpPrefixSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteEndpoint != nil {
		n += m.RemoteEndpoint.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvancedAction != nil {
		l = m.AdvancedAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_PrefixSelector) Size() (n int) {
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IpPrefixSet) Size() (n int) {
	var l int
	_ = l
	if m.IpPrefixSet != nil {
		l = m.IpPrefixSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteEndpoint != nil {
		n += m.RemoteEndpoint.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvancedAction != nil {
		l = m.AdvancedAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_PrefixSelector) Size() (n int) {
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IpPrefixSet) Size() (n int) {
	var l int
	_ = l
	if m.IpPrefixSet != nil {
		l = m.IpPrefixSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NetworkPolicyPBRRuleAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyPBRRuleAction{`,
		`ForwardingClass:` + strings.Replace(fmt.Sprintf("%v", this.ForwardingClass), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleAdvancedAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleAdvancedAction{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`RemoteEndpoint:` + fmt.Sprintf("%v", this.RemoteEndpoint) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "ves_io_schema4.LabelMatcherType", 1) + `,`,
		`PbrAction:` + strings.Replace(fmt.Sprintf("%v", this.PbrAction), "NetworkPolicyPBRRuleAction", "NetworkPolicyPBRRuleAction", 1) + `,`,
		`AdvancedAction:` + strings.Replace(fmt.Sprintf("%v", this.AdvancedAction), "NetworkPolicyRuleAdvancedAction", "NetworkPolicyRuleAdvancedAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "ves_io_schema3.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IpPrefixSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IpPrefixSet{`,
		`IpPrefixSet:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixSet), "IpPrefixSetRefType", "ves_io_schema4.IpPrefixSetRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`RemoteEndpoint:` + fmt.Sprintf("%v", this.RemoteEndpoint) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "ves_io_schema4.LabelMatcherType", 1) + `,`,
		`AdvancedAction:` + strings.Replace(fmt.Sprintf("%v", this.AdvancedAction), "NetworkPolicyRuleAdvancedAction", "NetworkPolicyRuleAdvancedAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "ves_io_schema3.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IpPrefixSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IpPrefixSet{`,
		`IpPrefixSet:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixSet), "IpPrefixSetRefType", "ves_io_schema4.IpPrefixSetRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`RemoteEndpoint:` + fmt.Sprintf("%v", this.RemoteEndpoint) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "ves_io_schema4.LabelMatcherType", 1) + `,`,
		`AdvancedAction:` + strings.Replace(fmt.Sprintf("%v", this.AdvancedAction), "NetworkPolicyRuleAdvancedAction", "NetworkPolicyRuleAdvancedAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "ves_io_schema3.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IpPrefixSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IpPrefixSet{`,
		`IpPrefixSet:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixSet), "IpPrefixSetRefType", "ves_io_schema4.IpPrefixSetRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`RemoteEndpoint:` + fmt.Sprintf("%v", this.RemoteEndpoint) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "ves_io_schema4.LabelMatcherType", 1) + `,`,
		`AdvancedAction:` + strings.Replace(fmt.Sprintf("%v", this.AdvancedAction), "NetworkPolicyRuleAdvancedAction", "NetworkPolicyRuleAdvancedAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "ves_io_schema3.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IpPrefixSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IpPrefixSet{`,
		`IpPrefixSet:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixSet), "IpPrefixSetRefType", "ves_io_schema4.IpPrefixSetRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NetworkPolicyPBRRuleAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPolicyPBRRuleAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPolicyPBRRuleAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingClass = append(m.ForwardingClass, &ves_io_schema4.ObjectRefType{})
			if err := m.ForwardingClass[len(m.ForwardingClass)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPolicyRuleAdvancedAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPolicyRuleAdvancedAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPolicyRuleAdvancedAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (LogAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (NetworkPolicyRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GlobalSpecType_Prefix{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GlobalSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &ves_io_schema4.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.IpPrefixSetRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GlobalSpecType_IpPrefixSet{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbrAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PbrAction == nil {
				m.PbrAction = &NetworkPolicyPBRRuleAction{}
			}
			if err := m.PbrAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAction == nil {
				m.AdvancedAction = &NetworkPolicyRuleAdvancedAction{}
			}
			if err := m.AdvancedAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (NetworkPolicyRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &CreateSpecType_Prefix{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &CreateSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &ves_io_schema4.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.IpPrefixSetRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &CreateSpecType_IpPrefixSet{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAction == nil {
				m.AdvancedAction = &NetworkPolicyRuleAdvancedAction{}
			}
			if err := m.AdvancedAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (NetworkPolicyRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &ReplaceSpecType_Prefix{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &ReplaceSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &ves_io_schema4.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.IpPrefixSetRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &ReplaceSpecType_IpPrefixSet{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAction == nil {
				m.AdvancedAction = &NetworkPolicyRuleAdvancedAction{}
			}
			if err := m.AdvancedAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (NetworkPolicyRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GetSpecType_Prefix{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GetSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &ves_io_schema4.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.IpPrefixSetRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GetSpecType_IpPrefixSet{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAction == nil {
				m.AdvancedAction = &NetworkPolicyRuleAdvancedAction{}
			}
			if err := m.AdvancedAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/network_policy_rule/types.proto", fileDescriptorTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/network_policy_rule/types.proto", fileDescriptorTypes)
}

var fileDescriptorTypes = []byte{
	// 900 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x97, 0x4f, 0x6b, 0x1b, 0x47,
	0x18, 0xc6, 0xf7, 0xcd, 0x4a, 0xb2, 0x34, 0x6e, 0x24, 0xb1, 0x3d, 0x58, 0x51, 0x92, 0xb5, 0x22,
	0x9a, 0x22, 0x82, 0xbc, 0x4a, 0x9c, 0xb6, 0x81, 0x40, 0x03, 0x5e, 0xbb, 0x38, 0x69, 0x15, 0x5b,
	0x4c, 0x52, 0x42, 0x7b, 0x59, 0x76, 0x57, 0xa3, 0xf5, 0xd6, 0x2b, 0xcd, 0x32, 0x3b, 0x92, 0xe3,
	0x43, 0x20, 0x94, 0x7e, 0x80, 0xe2, 0x5b, 0xbf, 0x41, 0xe9, 0xa9, 0xc7, 0x52, 0x5f, 0x7c, 0x2c,
	0x3d, 0xf9, 0x68, 0x7a, 0xaa, 0x36, 0x14, 0xd2, 0x5b, 0x28, 0x85, 0x86, 0x9e, 0xca, 0xfe, 0x91,
	0xe3, 0x5d, 0x25, 0xfd, 0x07, 0xf1, 0x49, 0xb7, 0x99, 0x79, 0x9e, 0xf7, 0x99, 0x77, 0x34, 0x3f,
	0x09, 0x0d, 0x5a, 0x1a, 0x11, 0x4f, 0xb1, 0x69, 0xcb, 0x33, 0xb7, 0x48, 0x5f, 0x6f, 0x0d, 0x08,
	0xdf, 0xa1, 0x6c, 0x5b, 0x73, 0xa9, 0x63, 0x9b, 0xbb, 0x1a, 0x1b, 0x3a, 0xa4, 0xc5, 0x77, 0x5d,
	0xe2, 0x29, 0x2e, 0xa3, 0x9c, 0x4a, 0x97, 0x22, 0xbb, 0x12, 0xd9, 0x95, 0x97, 0xd8, 0xab, 0x4b,
	0x96, 0xcd, 0xb7, 0x86, 0x86, 0x62, 0xd2, 0x7e, 0xcb, 0xa2, 0x16, 0x6d, 0x85, 0x95, 0xc6, 0xb0,
	0x17, 0xce, 0xc2, 0x49, 0x38, 0x8a, 0x12, 0xab, 0x0b, 0x53, 0x0d, 0xc4, 0xc2, 0xf9, 0xa4, 0x40,
	0x5d, 0x6e, 0xd3, 0x41, 0xdc, 0x47, 0xf5, 0x5c, 0x52, 0x3c, 0xd1, 0x62, 0xf5, 0x42, 0x52, 0x1a,
	0xe9, 0x8e, 0xdd, 0xd5, 0x39, 0x89, 0xd5, 0x5a, 0x4a, 0xb5, 0xc9, 0x8e, 0x96, 0x8c, 0x5e, 0x9c,
	0x76, 0x78, 0x27, 0x37, 0xa8, 0x7f, 0x01, 0xa8, 0xba, 0x11, 0x1d, 0xbc, 0x13, 0x9e, 0xbb, 0xa3,
	0x62, 0x3c, 0x74, 0xc8, 0x8a, 0x19, 0xc4, 0x48, 0x3d, 0x54, 0xee, 0x51, 0xb6, 0xa3, 0xb3, 0xae,
	0x3d, 0xb0, 0x34, 0xd3, 0xd1, 0x3d, 0xaf, 0x02, 0x35, 0xb1, 0x31, 0xbf, 0x7c, 0x41, 0x49, 0x7e,
	0x7a, 0x9b, 0xc6, 0x67, 0xc4, 0xe4, 0x98, 0xf4, 0xee, 0xef, 0xba, 0x44, 0xbd, 0xf8, 0xcd, 0xa3,
	0xa9, 0xc2, 0xef, 0x7f, 0x3d, 0x10, 0xb3, 0x7b, 0x70, 0xa6, 0x2c, 0xe2, 0xd2, 0x0b, 0x6d, 0x35,
	0x90, 0xea, 0x16, 0x5a, 0x4c, 0x74, 0x11, 0xb6, 0xd0, 0x1d, 0xe9, 0x03, 0x93, 0x74, 0xe3, 0x56,
	0xd6, 0x50, 0x4e, 0x0f, 0x47, 0x15, 0xa8, 0x41, 0xa3, 0xb8, 0xdc, 0x54, 0xfe, 0xf1, 0xfa, 0x94,
	0x36, 0xb5, 0xa2, 0x6a, 0x1c, 0xd7, 0xd6, 0x7f, 0xc9, 0xa2, 0xe2, 0xba, 0x43, 0x0d, 0xdd, 0xb9,
	0xe7, 0x12, 0x33, 0xe8, 0x55, 0xc2, 0xa9, 0xe0, 0x9b, 0xff, 0x22, 0x78, 0xba, 0xd9, 0xc4, 0x36,
	0xd2, 0x55, 0x94, 0x75, 0x29, 0xe3, 0x5e, 0xe5, 0x4c, 0x4d, 0x6c, 0x14, 0xd4, 0x6a, 0x70, 0x76,
	0xb4, 0x07, 0x73, 0xf5, 0x2c, 0x13, 0xbf, 0x05, 0x08, 0xa6, 0xb9, 0x3d, 0x10, 0xcb, 0x8f, 0x01,
	0x47, 0x46, 0x69, 0x05, 0xe5, 0xc3, 0x1b, 0x31, 0xa9, 0x53, 0x11, 0x6b, 0xd0, 0x28, 0xa8, 0x97,
	0x7f, 0xda, 0x07, 0x71, 0xa5, 0xdd, 0x0e, 0xcc, 0xe7, 0xd8, 0x02, 0x16, 0x70, 0x30, 0xc3, 0xe2,
	0xfd, 0xd5, 0x0e, 0x16, 0x3f, 0x5e, 0xeb, 0xe0, 0xcc, 0x9d, 0xd5, 0xbb, 0x1d, 0x7c, 0x5c, 0x26,
	0xdd, 0x40, 0x39, 0x97, 0x91, 0x9e, 0xfd, 0xb0, 0x92, 0xa9, 0x41, 0x63, 0x7e, 0xf9, 0x62, 0xea,
	0x20, 0x9d, 0x50, 0x6c, 0xdb, 0x1e, 0x0f, 0xce, 0x7d, 0x5b, 0xc0, 0xb1, 0x5d, 0xfa, 0x08, 0x95,
	0xa2, 0x91, 0xe6, 0x11, 0x87, 0x98, 0x9c, 0xb2, 0x4a, 0x36, 0x4c, 0xa8, 0xa5, 0x12, 0xda, 0xba,
	0x41, 0x9c, 0x7b, 0xb1, 0x27, 0x0e, 0x29, 0x46, 0xa5, 0x93, 0x55, 0x69, 0x0d, 0x9d, 0x75, 0x02,
	0x9b, 0xd6, 0xd7, 0xb9, 0xb9, 0x45, 0x58, 0x25, 0x17, 0x46, 0x2d, 0xbe, 0x2c, 0xea, 0x6e, 0x64,
	0x09, 0x92, 0xf0, 0x1b, 0xce, 0x89, 0x15, 0x69, 0x1d, 0x9d, 0xb5, 0x5d, 0xed, 0xb8, 0x2b, 0x5e,
	0x99, 0x0b, 0x53, 0x2e, 0xa5, 0x52, 0xee, 0xb8, 0x9d, 0x78, 0xf7, 0x09, 0x7a, 0xb7, 0x05, 0x3c,
	0x6f, 0xbf, 0x58, 0x95, 0x08, 0x42, 0xae, 0xc1, 0xb4, 0xf8, 0x86, 0xf3, 0x61, 0xca, 0xfb, 0xff,
	0xf5, 0x86, 0x13, 0x5f, 0x0a, 0x75, 0xee, 0xe8, 0x11, 0x3c, 0xdd, 0x07, 0xc0, 0x05, 0xd7, 0x60,
	0x31, 0x9d, 0xdb, 0xa8, 0xa4, 0xc7, 0xbc, 0x4e, 0xf6, 0x42, 0xe1, 0x5e, 0xea, 0xff, 0xa2, 0x29,
	0x81, 0x3e, 0x2e, 0xea, 0x89, 0xb9, 0x7a, 0x1e, 0x95, 0x18, 0xe9, 0x53, 0x4e, 0x34, 0x32, 0xe8,
	0xba, 0xd4, 0x1e, 0x70, 0x29, 0x7f, 0xb0, 0x0f, 0x99, 0xc3, 0x7d, 0x28, 0x7c, 0x98, 0xc9, 0x17,
	0xca, 0xa8, 0xfe, 0x47, 0x06, 0x15, 0x57, 0x19, 0xd1, 0x39, 0x79, 0xad, 0x9c, 0x5f, 0x4e, 0x72,
	0x5e, 0x4a, 0x71, 0x3e, 0x81, 0xbb, 0x9a, 0x86, 0x7b, 0x46, 0xed, 0xdf, 0x53, 0x7b, 0x9a, 0x38,
	0xdd, 0x7c, 0xeb, 0xc7, 0x5b, 0xa9, 0xdf, 0xc4, 0xdf, 0x6e, 0x95, 0xaf, 0x35, 0xdf, 0x69, 0xbe,
	0xdb, 0xbc, 0xd1, 0xbc, 0xde, 0x5c, 0x6e, 0xbe, 0xd7, 0xbc, 0x76, 0x55, 0x7d, 0x7b, 0x1a, 0xba,
	0x37, 0x3f, 0xff, 0x13, 0xd2, 0x8b, 0xf5, 0xe7, 0x19, 0x54, 0xc2, 0xc4, 0x75, 0x74, 0x73, 0x86,
	0xde, 0x0c, 0xbd, 0x53, 0x45, 0xef, 0xf7, 0x0c, 0x9a, 0x5f, 0x27, 0x7c, 0x86, 0xdd, 0x0c, 0xbb,
	0x53, 0xc4, 0xee, 0x8a, 0x82, 0x16, 0x5e, 0x41, 0x8d, 0x94, 0x47, 0x99, 0xb5, 0x0f, 0x36, 0x3e,
	0x29, 0x0b, 0x52, 0x01, 0x65, 0x57, 0xda, 0xed, 0xcd, 0x07, 0x65, 0xb8, 0xb2, 0x88, 0x0a, 0xc7,
	0x7f, 0x4c, 0x83, 0xf5, 0x8d, 0xcd, 0xf6, 0xe6, 0x7a, 0x59, 0x90, 0xe6, 0x90, 0x18, 0x0c, 0x40,
	0xfd, 0x0a, 0x0e, 0xc7, 0xb2, 0x70, 0x34, 0x96, 0x85, 0x67, 0x63, 0x19, 0x9e, 0x8f, 0x65, 0x78,
	0xec, 0xcb, 0xf0, 0xb5, 0x2f, 0xc3, 0x77, 0xbe, 0x0c, 0x07, 0xbe, 0x0c, 0x3f, 0xf8, 0x32, 0x1c,
	0xfa, 0x32, 0x1c, 0xf9, 0x32, 0xfc, 0xec, 0xcb, 0xf0, 0xd4, 0x97, 0x85, 0x67, 0xbe, 0x0c, 0x5f,
	0x3e, 0x91, 0x85, 0x83, 0x27, 0x32, 0x7c, 0xfa, 0xc0, 0xa2, 0xee, 0xb6, 0xa5, 0x8c, 0xa8, 0xc3,
	0x09, 0x63, 0xba, 0x32, 0xf4, 0x5a, 0xe1, 0xa0, 0x47, 0x59, 0x7f, 0xc9, 0x65, 0x74, 0x64, 0x77,
	0x09, 0x5b, 0x9a, 0xc8, 0x2d, 0xd7, 0xb0, 0x68, 0x8b, 0x3c, 0xe4, 0xf1, 0x3b, 0xe1, 0xd5, 0x0f,
	0x28, 0x23, 0x17, 0x62, 0x7c, 0xfd, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x16, 0x14, 0x6c, 0xd5,
	0x6c, 0x0d, 0x00, 0x00,
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/k8s_pod_security_policy/types.proto

package k8s_pod_security_policy

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Capability List
//
// x-displayName: "Capability List"
// List of capabilities that docker container has.
type CapabilityListType struct {
	// Capability List
	//
	// x-displayName: "Capability List"
	// x-required
	// List of capabilities that docker container has.
	Capabilities []string `protobuf:"bytes,1,rep,name=capabilities" json:"capabilities,omitempty"`
}

func (m *CapabilityListType) Reset()                    { *m = CapabilityListType{} }
func (*CapabilityListType) ProtoMessage()               {}
func (*CapabilityListType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *CapabilityListType) GetCapabilities() []string {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// Host Path
//
// x-displayName: "Host Path"
// Host path and read/write or read-only
type HostPathType struct {
	// Host Path Prefix
	//
	// x-displayName: "Host Path Prefix"
	// x-required
	// Host path prefix is the path prefix that the host volume must match. It does not support *.
	PathPrefix string `protobuf:"bytes,1,opt,name=path_prefix,json=pathPrefix,proto3" json:"path_prefix,omitempty"`
	// Read Only
	//
	// x-displayName: "Read Only"
	// This volume will be allowed to mount read only.
	ReadOnly bool `protobuf:"varint,2,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
}

func (m *HostPathType) Reset()                    { *m = HostPathType{} }
func (*HostPathType) ProtoMessage()               {}
func (*HostPathType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *HostPathType) GetPathPrefix() string {
	if m != nil {
		return m.PathPrefix
	}
	return ""
}

func (m *HostPathType) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type IDRangeType struct {
	// Starting ID
	//
	// x-displayName: "Starting ID"
	// x-required
	// x-example: "2000"
	// Starting(minimum) ID for for ID range
	MinId uint32 `protobuf:"varint,1,opt,name=min_id,json=minId,proto3" json:"min_id,omitempty"`
	// Ending ID
	//
	// x-displayName: "Ending ID"
	// x-required
	// x-example: "3000"
	// Ending(maximum) ID for for ID range
	MaxId uint32 `protobuf:"varint,2,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
}

func (m *IDRangeType) Reset()                    { *m = IDRangeType{} }
func (*IDRangeType) ProtoMessage()               {}
func (*IDRangeType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *IDRangeType) GetMinId() uint32 {
	if m != nil {
		return m.MinId
	}
	return 0
}

func (m *IDRangeType) GetMaxId() uint32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

// ID(User,Group,FSGroup) Strategy
//
// x-displayName: "ID(User,Group,FSGroup) Strategy"
// ID ranges and rules
type IDStrategyOptionsType struct {
	// ID Ranges
	//
	// x-displayName: "ID Ranges"
	// List of range of  ID(s)
	IdRanges []*IDRangeType `protobuf:"bytes,1,rep,name=id_ranges,json=idRanges" json:"id_ranges,omitempty"`
	// Rule
	//
	// x-displayName: "Rule"
	// x-example: "MustRunAs"
	// Rule indicated how the FS group ID range is used
	Rule string `protobuf:"bytes,2,opt,name=rule,proto3" json:"rule,omitempty"`
}

func (m *IDStrategyOptionsType) Reset()                    { *m = IDStrategyOptionsType{} }
func (*IDStrategyOptionsType) ProtoMessage()               {}
func (*IDStrategyOptionsType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *IDStrategyOptionsType) GetIdRanges() []*IDRangeType {
	if m != nil {
		return m.IdRanges
	}
	return nil
}

func (m *IDStrategyOptionsType) GetRule() string {
	if m != nil {
		return m.Rule
	}
	return ""
}

// Runtime Class Strategy
//
// x-displayName: "Runtime Class Strategy"
// Allowed runtime classes
type RuntimeClassStrategyOptions struct {
	// Allowed Runtime Classes
	//
	// x-displayName: "Allowed Runtime Classes"
	// List of allowed runtime class names
	AllowedRuntimeClassNames []string `protobuf:"bytes,1,rep,name=allowed_runtime_class_names,json=allowedRuntimeClassNames" json:"allowed_runtime_class_names,omitempty"`
	// Default Runtime Class
	//
	// x-displayName: "Default Runtime Class"
	// description
	DefaultRuntimeClassName string `protobuf:"bytes,2,opt,name=default_runtime_class_name,json=defaultRuntimeClassName,proto3" json:"default_runtime_class_name,omitempty"`
}

func (m *RuntimeClassStrategyOptions) Reset()      { *m = RuntimeClassStrategyOptions{} }
func (*RuntimeClassStrategyOptions) ProtoMessage() {}
func (*RuntimeClassStrategyOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{4}
}

func (m *RuntimeClassStrategyOptions) GetAllowedRuntimeClassNames() []string {
	if m != nil {
		return m.AllowedRuntimeClassNames
	}
	return nil
}

func (m *RuntimeClassStrategyOptions) GetDefaultRuntimeClassName() string {
	if m != nil {
		return m.DefaultRuntimeClassName
	}
	return ""
}

// SE Linux Strategy
//
// x-displayName: "SE Linux Strategy"
//
type SELinuxStrategyOptions struct {
	// Rule
	//
	// x-displayName: "Rule"
	// x-example: "MustRunAs"
	// Rule indicated how the FS group ID range is used
	Rule string `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
	// SE Linux Level
	//
	// x-displayName: "SE Linux Level"
	// x-example: "secret"
	// Run as SE linux level label
	Level string `protobuf:"bytes,2,opt,name=Level,proto3" json:"Level,omitempty"`
	// SE Linux Role
	//
	// x-displayName: "SE Linux Role"
	// x-example: "admin_r"
	// Run as SE linux label
	Role string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	// SE Linux Type
	//
	// x-displayName: "SE Linux Type"
	// x-example: "admin_t"
	// Run as SE linux type label
	Type string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	// SE Linux User
	//
	// x-displayName: "SE Linux User"
	// x-example: "system_u"
	// Run as SE linux user label
	User string `protobuf:"bytes,5,opt,name=user,proto3" json:"user,omitempty"`
}

func (m *SELinuxStrategyOptions) Reset()                    { *m = SELinuxStrategyOptions{} }
func (*SELinuxStrategyOptions) ProtoMessage()               {}
func (*SELinuxStrategyOptions) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *SELinuxStrategyOptions) GetRule() string {
	if m != nil {
		return m.Rule
	}
	return ""
}

func (m *SELinuxStrategyOptions) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *SELinuxStrategyOptions) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SELinuxStrategyOptions) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SELinuxStrategyOptions) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

// Pod Security Policy Specification
//
// x-displayName: "Pod Security Policy Specification"
// Form based pod security specification
type PodSecurityPolicySpecType struct {
	// Privileged
	//
	// x-displayName: "Privileged"
	// Privileged determines if a pod can request to be run as privileged.
	Privileged bool `protobuf:"varint,1,opt,name=privileged,proto3" json:"privileged,omitempty"`
	// Allow Privilege Escalation
	//
	// x-displayName: "Allow Privilege Escalation"
	// Pod can request to privilege escalation
	AllowPrivilegeEscalation bool `protobuf:"varint,2,opt,name=allow_privilege_escalation,json=allowPrivilegeEscalation,proto3" json:"allow_privilege_escalation,omitempty"`
	// Default Allow Privilege Escalation
	//
	// x-displayName: "Default Allow Privilege Escalation"
	// Pod has permission for privilege escalation by default
	DefaultAllowPrivilegeEscalation bool `protobuf:"varint,3,opt,name=default_allow_privilege_escalation,json=defaultAllowPrivilegeEscalation,proto3" json:"default_allow_privilege_escalation,omitempty"`
	// Change Default Capabilities
	//
	// x-displayName: "Change Default Capabilities"
	// x-required
	// Select to use K8s default or custom default capabilities
	//
	// Types that are valid to be assigned to DefaultCapabilitiesChoice:
	//	*PodSecurityPolicySpecType_NoDefaultCapabilities
	//	*PodSecurityPolicySpecType_DefaultCapabilities
	DefaultCapabilitiesChoice isPodSecurityPolicySpecType_DefaultCapabilitiesChoice `protobuf_oneof:"default_capabilities_choice"`
	// Allowed Add Capabilities
	//
	// x-displayName: "Allowed Add Capabilities"
	// x-required
	// Select to allow adding of capabilities to the POD
	//
	// Types that are valid to be assigned to AllowedCapabilitiesChoice:
	//	*PodSecurityPolicySpecType_NoAllowedCapabilities
	//	*PodSecurityPolicySpecType_AllowedCapabilities
	AllowedCapabilitiesChoice isPodSecurityPolicySpecType_AllowedCapabilitiesChoice `protobuf_oneof:"allowed_capabilities_choice"`
	// Drop from K8s Default Capabilities
	//
	// x-displayName: "Drop from K8s Default Capabilities"
	// x-required
	// Select to drop from default capabilities
	//
	// Types that are valid to be assigned to DropCapabilitiesChoice:
	//	*PodSecurityPolicySpecType_NoDropCapabilities
	//	*PodSecurityPolicySpecType_DropCapabilities
	DropCapabilitiesChoice isPodSecurityPolicySpecType_DropCapabilitiesChoice `protobuf_oneof:"drop_capabilities_choice"`
	// Volumes
	//
	// x-displayName: "Volume"
	// Allow List of volume plugins. Empty no volumes are allowed
	Volumes []string `protobuf:"bytes,13,rep,name=volumes" json:"volumes,omitempty"`
	// Allowed Flex Volumes
	//
	// x-displayName: "Allowed Flex Volumes"
	// Restrict list of Flex volumes, default all volumes are allowed
	AllowedFlexVolumes []string `protobuf:"bytes,14,rep,name=allowed_flex_volumes,json=allowedFlexVolumes" json:"allowed_flex_volumes,omitempty"`
	// Allowed Host Paths
	//
	// x-displayName: "Allowed Host Paths"
	// Restrict list of host paths, default all host paths are allowed
	AllowedHostPaths []*HostPathType `protobuf:"bytes,15,rep,name=allowed_host_paths,json=allowedHostPaths" json:"allowed_host_paths,omitempty"`
	// Allowed Proc Mounts
	//
	// x-displayName: "Allowed Proc Mounts"
	// allowed list of proc mounts, empty list allows default proc mounts.
	AllowedProcMounts []string `protobuf:"bytes,16,rep,name=allowed_proc_mounts,json=allowedProcMounts" json:"allowed_proc_mounts,omitempty"`
	// Read Only Root Filesystem
	//
	// x-displayName: "Read Only Root Filesystem"
	// Containers can only run with read only root filesystem.
	ReadOnlyRootFilesystem bool `protobuf:"varint,17,opt,name=read_only_root_filesystem,json=readOnlyRootFilesystem,proto3" json:"read_only_root_filesystem,omitempty"`
	// Allowed CSI drivers
	//
	// x-displayName: "Allowed CSI drivers"
	// Restrict the available CSI drivers for POD, default all drivers are available.
	AllowedCsiDrivers []string `protobuf:"bytes,18,rep,name=allowed_csi_drivers,json=allowedCsiDrivers" json:"allowed_csi_drivers,omitempty"`
	// Host Network
	//
	// x-displayName: "Host Network"
	// Host Network determines if the policy allows the use of host network in the pod spec.
	HostNetwork bool `protobuf:"varint,19,opt,name=host_network,json=hostNetwork,proto3" json:"host_network,omitempty"`
	// Host Port Ranges
	//
	// x-displayName: "Host Ports Ranges"
	// x-example: "80,443,8080-8191,9080"
	// Host port ranges determines which ports ranges are allowed to be exposed
	HostPortRanges string `protobuf:"bytes,20,opt,name=host_port_ranges,json=hostPortRanges,proto3" json:"host_port_ranges,omitempty"`
	// Host IPC
	//
	// x-displayName: "Host IPC"
	// Host IPC determines if the policy allows the use of host IPC in the pod spec.
	HostIpc bool `protobuf:"varint,21,opt,name=host_ipc,json=hostIpc,proto3" json:"host_ipc,omitempty"`
	// Host PID
	//
	// x-displayName: "Host PID"
	// Host PID determines if the policy allows the use of host PID in the pod spec.
	HostPid bool `protobuf:"varint,22,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty"`
	// Allowed Unsafe Sysctls
	//
	// x-displayName: "Allowed Unsafe Sysctls"
	// allowed list of unsafe sysctls, empty list allows none. supports prefix reg-ex
	AllowedUnsafeSysctls []string `protobuf:"bytes,23,rep,name=allowed_unsafe_sysctls,json=allowedUnsafeSysctls" json:"allowed_unsafe_sysctls,omitempty"`
	// Forbidden Sysctls
	//
	// x-displayName: "Forbidden Sysctls"
	// Forbidden list of sysctls, empty list forbids none. supports prefix reg-ex
	ForbiddenSysctls []string `protobuf:"bytes,24,rep,name=forbidden_sysctls,json=forbiddenSysctls" json:"forbidden_sysctls,omitempty"`
	// Runs As User
	//
	// x-displayName: "Select Runs As User"
	// x-required
	// Restrict user id  allowed in runs as user
	//
	// Types that are valid to be assigned to UserChoice:
	//	*PodSecurityPolicySpecType_NoRunAsUser
	//	*PodSecurityPolicySpecType_RunAsUser
	UserChoice isPodSecurityPolicySpecType_UserChoice `protobuf_oneof:"user_choice"`
	// Runs As Group
	//
	// x-displayName: "Select Runs As Group"
	// x-required
	// Restrict user id  allowed in runs as user
	//
	// Types that are valid to be assigned to GroupChoice:
	//	*PodSecurityPolicySpecType_NoRunAsGroup
	//	*PodSecurityPolicySpecType_RunAsGroup
	GroupChoice isPodSecurityPolicySpecType_GroupChoice `protobuf_oneof:"group_choice"`
	// Supplemental Groups
	//
	// x-displayName: "Select Supplemental Groups"
	// x-required
	// Restrict supplemental groups that are allowed
	//
	// Types that are valid to be assigned to SupplementalGroupChoice:
	//	*PodSecurityPolicySpecType_NoSupplementalGroups
	//	*PodSecurityPolicySpecType_SupplementalGroups
	SupplementalGroupChoice isPodSecurityPolicySpecType_SupplementalGroupChoice `protobuf_oneof:"supplemental_group_choice"`
	// FS Groups
	//
	// x-displayName: "Select FS Groups"
	// x-required
	// Restrict FS groups that are allowed
	//
	// Types that are valid to be assigned to FsGroupChoice:
	//	*PodSecurityPolicySpecType_NoFsGroups
	//	*PodSecurityPolicySpecType_FsGroupStrategyOptions
	FsGroupChoice isPodSecurityPolicySpecType_FsGroupChoice `protobuf_oneof:"fs_group_choice"`
	// Select SE Linux Options
	//
	// x-displayName: "Select SE Linux Options"
	// x-required
	// Select if SE Linux options are allowed in security context
	//
	// Types that are valid to be assigned to SeLinuxChoice:
	//	*PodSecurityPolicySpecType_NoSeLinuxOptions
	//	*PodSecurityPolicySpecType_SeLinuxOptions
	SeLinuxChoice isPodSecurityPolicySpecType_SeLinuxChoice `protobuf_oneof:"se_linux_choice"`
	// Select Run Time Class Option
	//
	// x-displayName: "Select Run Time Class Option"
	// x-required
	// Select if runtime class is allowed in security context
	//
	// Types that are valid to be assigned to RuntimeClassChoice:
	//	*PodSecurityPolicySpecType_NoRuntimeClass
	//	*PodSecurityPolicySpecType_RuntimeClass
	RuntimeClassChoice isPodSecurityPolicySpecType_RuntimeClassChoice `protobuf_oneof:"runtime_class_choice"`
}

func (m *PodSecurityPolicySpecType) Reset()                    { *m = PodSecurityPolicySpecType{} }
func (*PodSecurityPolicySpecType) ProtoMessage()               {}
func (*PodSecurityPolicySpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

type isPodSecurityPolicySpecType_DefaultCapabilitiesChoice interface {
	isPodSecurityPolicySpecType_DefaultCapabilitiesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_AllowedCapabilitiesChoice interface {
	isPodSecurityPolicySpecType_AllowedCapabilitiesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_DropCapabilitiesChoice interface {
	isPodSecurityPolicySpecType_DropCapabilitiesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_UserChoice interface {
	isPodSecurityPolicySpecType_UserChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_GroupChoice interface {
	isPodSecurityPolicySpecType_GroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_SupplementalGroupChoice interface {
	isPodSecurityPolicySpecType_SupplementalGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_FsGroupChoice interface {
	isPodSecurityPolicySpecType_FsGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_SeLinuxChoice interface {
	isPodSecurityPolicySpecType_SeLinuxChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_RuntimeClassChoice interface {
	isPodSecurityPolicySpecType_RuntimeClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PodSecurityPolicySpecType_NoDefaultCapabilities struct {
	NoDefaultCapabilities *ves_io_schema4.Empty `protobuf:"bytes,5,opt,name=no_default_capabilities,json=noDefaultCapabilities,oneof"`
}
type PodSecurityPolicySpecType_DefaultCapabilities struct {
	DefaultCapabilities *CapabilityListType `protobuf:"bytes,6,opt,name=default_capabilities,json=defaultCapabilities,oneof"`
}
type PodSecurityPolicySpecType_NoAllowedCapabilities struct {
	NoAllowedCapabilities *ves_io_schema4.Empty `protobuf:"bytes,8,opt,name=no_allowed_capabilities,json=noAllowedCapabilities,oneof"`
}
type PodSecurityPolicySpecType_AllowedCapabilities struct {
	AllowedCapabilities *CapabilityListType `protobuf:"bytes,9,opt,name=allowed_capabilities,json=allowedCapabilities,oneof"`
}
type PodSecurityPolicySpecType_NoDropCapabilities struct {
	NoDropCapabilities *ves_io_schema4.Empty `protobuf:"bytes,11,opt,name=no_drop_capabilities,json=noDropCapabilities,oneof"`
}
type PodSecurityPolicySpecType_DropCapabilities struct {
	DropCapabilities *CapabilityListType `protobuf:"bytes,12,opt,name=drop_capabilities,json=dropCapabilities,oneof"`
}
type PodSecurityPolicySpecType_NoRunAsUser struct {
	NoRunAsUser *ves_io_schema4.Empty `protobuf:"bytes,26,opt,name=no_run_as_user,json=noRunAsUser,oneof"`
}
type PodSecurityPolicySpecType_RunAsUser struct {
	RunAsUser *IDStrategyOptionsType `protobuf:"bytes,27,opt,name=run_as_user,json=runAsUser,oneof"`
}
type PodSecurityPolicySpecType_NoRunAsGroup struct {
	NoRunAsGroup *ves_io_schema4.Empty `protobuf:"bytes,29,opt,name=no_run_as_group,json=noRunAsGroup,oneof"`
}
type PodSecurityPolicySpecType_RunAsGroup struct {
	RunAsGroup *IDStrategyOptionsType `protobuf:"bytes,30,opt,name=run_as_group,json=runAsGroup,oneof"`
}
type PodSecurityPolicySpecType_NoSupplementalGroups struct {
	NoSupplementalGroups *ves_io_schema4.Empty `protobuf:"bytes,32,opt,name=no_supplemental_groups,json=noSupplementalGroups,oneof"`
}
type PodSecurityPolicySpecType_SupplementalGroups struct {
	SupplementalGroups *IDStrategyOptionsType `protobuf:"bytes,33,opt,name=supplemental_groups,json=supplementalGroups,oneof"`
}
type PodSecurityPolicySpecType_NoFsGroups struct {
	NoFsGroups *ves_io_schema4.Empty `protobuf:"bytes,35,opt,name=no_fs_groups,json=noFsGroups,oneof"`
}
type PodSecurityPolicySpecType_FsGroupStrategyOptions struct {
	FsGroupStrategyOptions *IDStrategyOptionsType `protobuf:"bytes,36,opt,name=fs_group_strategy_options,json=fsGroupStrategyOptions,oneof"`
}
type PodSecurityPolicySpecType_NoSeLinuxOptions struct {
	NoSeLinuxOptions *ves_io_schema4.Empty `protobuf:"bytes,38,opt,name=no_se_linux_options,json=noSeLinuxOptions,oneof"`
}
type PodSecurityPolicySpecType_SeLinuxOptions struct {
	SeLinuxOptions *SELinuxStrategyOptions `protobuf:"bytes,39,opt,name=se_linux_options,json=seLinuxOptions,oneof"`
}
type PodSecurityPolicySpecType_NoRuntimeClass struct {
	NoRuntimeClass *ves_io_schema4.Empty `protobuf:"bytes,41,opt,name=no_runtime_class,json=noRuntimeClass,oneof"`
}
type PodSecurityPolicySpecType_RuntimeClass struct {
	RuntimeClass *RuntimeClassStrategyOptions `protobuf:"bytes,42,opt,name=runtime_class,json=runtimeClass,oneof"`
}

func (*PodSecurityPolicySpecType_NoDefaultCapabilities) isPodSecurityPolicySpecType_DefaultCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_DefaultCapabilities) isPodSecurityPolicySpecType_DefaultCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_NoAllowedCapabilities) isPodSecurityPolicySpecType_AllowedCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_AllowedCapabilities) isPodSecurityPolicySpecType_AllowedCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_NoDropCapabilities) isPodSecurityPolicySpecType_DropCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_DropCapabilities) isPodSecurityPolicySpecType_DropCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_NoRunAsUser) isPodSecurityPolicySpecType_UserChoice()   {}
func (*PodSecurityPolicySpecType_RunAsUser) isPodSecurityPolicySpecType_UserChoice()     {}
func (*PodSecurityPolicySpecType_NoRunAsGroup) isPodSecurityPolicySpecType_GroupChoice() {}
func (*PodSecurityPolicySpecType_RunAsGroup) isPodSecurityPolicySpecType_GroupChoice()   {}
func (*PodSecurityPolicySpecType_NoSupplementalGroups) isPodSecurityPolicySpecType_SupplementalGroupChoice() {
}
func (*PodSecurityPolicySpecType_SupplementalGroups) isPodSecurityPolicySpecType_SupplementalGroupChoice() {
}
func (*PodSecurityPolicySpecType_NoFsGroups) isPodSecurityPolicySpecType_FsGroupChoice() {}
func (*PodSecurityPolicySpecType_FsGroupStrategyOptions) isPodSecurityPolicySpecType_FsGroupChoice() {
}
func (*PodSecurityPolicySpecType_NoSeLinuxOptions) isPodSecurityPolicySpecType_SeLinuxChoice()    {}
func (*PodSecurityPolicySpecType_SeLinuxOptions) isPodSecurityPolicySpecType_SeLinuxChoice()      {}
func (*PodSecurityPolicySpecType_NoRuntimeClass) isPodSecurityPolicySpecType_RuntimeClassChoice() {}
func (*PodSecurityPolicySpecType_RuntimeClass) isPodSecurityPolicySpecType_RuntimeClassChoice()   {}

func (m *PodSecurityPolicySpecType) GetDefaultCapabilitiesChoice() isPodSecurityPolicySpecType_DefaultCapabilitiesChoice {
	if m != nil {
		return m.DefaultCapabilitiesChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetAllowedCapabilitiesChoice() isPodSecurityPolicySpecType_AllowedCapabilitiesChoice {
	if m != nil {
		return m.AllowedCapabilitiesChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetDropCapabilitiesChoice() isPodSecurityPolicySpecType_DropCapabilitiesChoice {
	if m != nil {
		return m.DropCapabilitiesChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetUserChoice() isPodSecurityPolicySpecType_UserChoice {
	if m != nil {
		return m.UserChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetGroupChoice() isPodSecurityPolicySpecType_GroupChoice {
	if m != nil {
		return m.GroupChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetSupplementalGroupChoice() isPodSecurityPolicySpecType_SupplementalGroupChoice {
	if m != nil {
		return m.SupplementalGroupChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetFsGroupChoice() isPodSecurityPolicySpecType_FsGroupChoice {
	if m != nil {
		return m.FsGroupChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetSeLinuxChoice() isPodSecurityPolicySpecType_SeLinuxChoice {
	if m != nil {
		return m.SeLinuxChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetRuntimeClassChoice() isPodSecurityPolicySpecType_RuntimeClassChoice {
	if m != nil {
		return m.RuntimeClassChoice
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetAllowPrivilegeEscalation() bool {
	if m != nil {
		return m.AllowPrivilegeEscalation
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetDefaultAllowPrivilegeEscalation() bool {
	if m != nil {
		return m.DefaultAllowPrivilegeEscalation
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetNoDefaultCapabilities() *ves_io_schema4.Empty {
	if x, ok := m.GetDefaultCapabilitiesChoice().(*PodSecurityPolicySpecType_NoDefaultCapabilities); ok {
		return x.NoDefaultCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetDefaultCapabilities() *CapabilityListType {
	if x, ok := m.GetDefaultCapabilitiesChoice().(*PodSecurityPolicySpecType_DefaultCapabilities); ok {
		return x.DefaultCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoAllowedCapabilities() *ves_io_schema4.Empty {
	if x, ok := m.GetAllowedCapabilitiesChoice().(*PodSecurityPolicySpecType_NoAllowedCapabilities); ok {
		return x.NoAllowedCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetAllowedCapabilities() *CapabilityListType {
	if x, ok := m.GetAllowedCapabilitiesChoice().(*PodSecurityPolicySpecType_AllowedCapabilities); ok {
		return x.AllowedCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoDropCapabilities() *ves_io_schema4.Empty {
	if x, ok := m.GetDropCapabilitiesChoice().(*PodSecurityPolicySpecType_NoDropCapabilities); ok {
		return x.NoDropCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetDropCapabilities() *CapabilityListType {
	if x, ok := m.GetDropCapabilitiesChoice().(*PodSecurityPolicySpecType_DropCapabilities); ok {
		return x.DropCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetVolumes() []string {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetAllowedFlexVolumes() []string {
	if m != nil {
		return m.AllowedFlexVolumes
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetAllowedHostPaths() []*HostPathType {
	if m != nil {
		return m.AllowedHostPaths
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetAllowedProcMounts() []string {
	if m != nil {
		return m.AllowedProcMounts
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetReadOnlyRootFilesystem() bool {
	if m != nil {
		return m.ReadOnlyRootFilesystem
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetAllowedCsiDrivers() []string {
	if m != nil {
		return m.AllowedCsiDrivers
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetHostNetwork() bool {
	if m != nil {
		return m.HostNetwork
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetHostPortRanges() string {
	if m != nil {
		return m.HostPortRanges
	}
	return ""
}

func (m *PodSecurityPolicySpecType) GetHostIpc() bool {
	if m != nil {
		return m.HostIpc
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetHostPid() bool {
	if m != nil {
		return m.HostPid
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetAllowedUnsafeSysctls() []string {
	if m != nil {
		return m.AllowedUnsafeSysctls
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetForbiddenSysctls() []string {
	if m != nil {
		return m.ForbiddenSysctls
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoRunAsUser() *ves_io_schema4.Empty {
	if x, ok := m.GetUserChoice().(*PodSecurityPolicySpecType_NoRunAsUser); ok {
		return x.NoRunAsUser
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetRunAsUser() *IDStrategyOptionsType {
	if x, ok := m.GetUserChoice().(*PodSecurityPolicySpecType_RunAsUser); ok {
		return x.RunAsUser
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoRunAsGroup() *ves_io_schema4.Empty {
	if x, ok := m.GetGroupChoice().(*PodSecurityPolicySpecType_NoRunAsGroup); ok {
		return x.NoRunAsGroup
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetRunAsGroup() *IDStrategyOptionsType {
	if x, ok := m.GetGroupChoice().(*PodSecurityPolicySpecType_RunAsGroup); ok {
		return x.RunAsGroup
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoSupplementalGroups() *ves_io_schema4.Empty {
	if x, ok := m.GetSupplementalGroupChoice().(*PodSecurityPolicySpecType_NoSupplementalGroups); ok {
		return x.NoSupplementalGroups
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetSupplementalGroups() *IDStrategyOptionsType {
	if x, ok := m.GetSupplementalGroupChoice().(*PodSecurityPolicySpecType_SupplementalGroups); ok {
		return x.SupplementalGroups
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoFsGroups() *ves_io_schema4.Empty {
	if x, ok := m.GetFsGroupChoice().(*PodSecurityPolicySpecType_NoFsGroups); ok {
		return x.NoFsGroups
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetFsGroupStrategyOptions() *IDStrategyOptionsType {
	if x, ok := m.GetFsGroupChoice().(*PodSecurityPolicySpecType_FsGroupStrategyOptions); ok {
		return x.FsGroupStrategyOptions
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoSeLinuxOptions() *ves_io_schema4.Empty {
	if x, ok := m.GetSeLinuxChoice().(*PodSecurityPolicySpecType_NoSeLinuxOptions); ok {
		return x.NoSeLinuxOptions
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetSeLinuxOptions() *SELinuxStrategyOptions {
	if x, ok := m.GetSeLinuxChoice().(*PodSecurityPolicySpecType_SeLinuxOptions); ok {
		return x.SeLinuxOptions
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoRuntimeClass() *ves_io_schema4.Empty {
	if x, ok := m.GetRuntimeClassChoice().(*PodSecurityPolicySpecType_NoRuntimeClass); ok {
		return x.NoRuntimeClass
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetRuntimeClass() *RuntimeClassStrategyOptions {
	if x, ok := m.GetRuntimeClassChoice().(*PodSecurityPolicySpecType_RuntimeClass); ok {
		return x.RuntimeClass
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PodSecurityPolicySpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PodSecurityPolicySpecType_OneofMarshaler, _PodSecurityPolicySpecType_OneofUnmarshaler, _PodSecurityPolicySpecType_OneofSizer, []interface{}{
		(*PodSecurityPolicySpecType_NoDefaultCapabilities)(nil),
		(*PodSecurityPolicySpecType_DefaultCapabilities)(nil),
		(*PodSecurityPolicySpecType_NoAllowedCapabilities)(nil),
		(*PodSecurityPolicySpecType_AllowedCapabilities)(nil),
		(*PodSecurityPolicySpecType_NoDropCapabilities)(nil),
		(*PodSecurityPolicySpecType_DropCapabilities)(nil),
		(*PodSecurityPolicySpecType_NoRunAsUser)(nil),
		(*PodSecurityPolicySpecType_RunAsUser)(nil),
		(*PodSecurityPolicySpecType_NoRunAsGroup)(nil),
		(*PodSecurityPolicySpecType_RunAsGroup)(nil),
		(*PodSecurityPolicySpecType_NoSupplementalGroups)(nil),
		(*PodSecurityPolicySpecType_SupplementalGroups)(nil),
		(*PodSecurityPolicySpecType_NoFsGroups)(nil),
		(*PodSecurityPolicySpecType_FsGroupStrategyOptions)(nil),
		(*PodSecurityPolicySpecType_NoSeLinuxOptions)(nil),
		(*PodSecurityPolicySpecType_SeLinuxOptions)(nil),
		(*PodSecurityPolicySpecType_NoRuntimeClass)(nil),
		(*PodSecurityPolicySpecType_RuntimeClass)(nil),
	}
}

func _PodSecurityPolicySpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PodSecurityPolicySpecType)
	// default_capabilities_choice
	switch x := m.DefaultCapabilitiesChoice.(type) {
	case *PodSecurityPolicySpecType_NoDefaultCapabilities:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoDefaultCapabilities); err != nil {
			return err
		}
	case *PodSecurityPolicySpecType_DefaultCapabilities:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultCapabilities); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodSecurityPolicySpecType.DefaultCapabilitiesChoice has unexpected type %T", x)
	}
	// allowed_capabilities_choice
	switch x := m.AllowedCapabilitiesChoice.(type) {
	case *PodSecurityPolicySpecType_NoAllowedCapabilities:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoAllowedCapabilities); err != nil {
			return err
		}
	case *PodSecurityPolicySpecType_AllowedCapabilities:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AllowedCapabilities); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodSecurityPolicySpecType.AllowedCapabilitiesChoice has unexpected type %T", x)
	}
	// drop_capabilities_choice
	switch x := m.DropCapabilitiesChoice.(type) {
	case *PodSecurityPolicySpecType_NoDropCapabilities:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoDropCapabilities); err != nil {
			return err
		}
	case *PodSecurityPolicySpecType_DropCapabilities:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DropCapabilities); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodSecurityPolicySpecType.DropCapabilitiesChoice has unexpected type %T", x)
	}
	// user_choice
	switch x := m.UserChoice.(type) {
	case *PodSecurityPolicySpecType_NoRunAsUser:
		_ = b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoRunAsUser); err != nil {
			return err
		}
	case *PodSecurityPolicySpecType_RunAsUser:
		_ = b.EncodeVarint(27<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RunAsUser); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodSecurityPolicySpecType.UserChoice has unexpected type %T", x)
	}
	// group_choice
	switch x := m.GroupChoice.(type) {
	case *PodSecurityPolicySpecType_NoRunAsGroup:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoRunAsGroup); err != nil {
			return err
		}
	case *PodSecurityPolicySpecType_RunAsGroup:
		_ = b.EncodeVarint(30<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RunAsGroup); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodSecurityPolicySpecType.GroupChoice has unexpected type %T", x)
	}
	// supplemental_group_choice
	switch x := m.SupplementalGroupChoice.(type) {
	case *PodSecurityPolicySpecType_NoSupplementalGroups:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoSupplementalGroups); err != nil {
			return err
		}
	case *PodSecurityPolicySpecType_SupplementalGroups:
		_ = b.EncodeVarint(33<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SupplementalGroups); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodSecurityPolicySpecType.SupplementalGroupChoice has unexpected type %T", x)
	}
	// fs_group_choice
	switch x := m.FsGroupChoice.(type) {
	case *PodSecurityPolicySpecType_NoFsGroups:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoFsGroups); err != nil {
			return err
		}
	case *PodSecurityPolicySpecType_FsGroupStrategyOptions:
		_ = b.EncodeVarint(36<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FsGroupStrategyOptions); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodSecurityPolicySpecType.FsGroupChoice has unexpected type %T", x)
	}
	// se_linux_choice
	switch x := m.SeLinuxChoice.(type) {
	case *PodSecurityPolicySpecType_NoSeLinuxOptions:
		_ = b.EncodeVarint(38<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoSeLinuxOptions); err != nil {
			return err
		}
	case *PodSecurityPolicySpecType_SeLinuxOptions:
		_ = b.EncodeVarint(39<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SeLinuxOptions); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodSecurityPolicySpecType.SeLinuxChoice has unexpected type %T", x)
	}
	// runtime_class_choice
	switch x := m.RuntimeClassChoice.(type) {
	case *PodSecurityPolicySpecType_NoRuntimeClass:
		_ = b.EncodeVarint(41<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoRuntimeClass); err != nil {
			return err
		}
	case *PodSecurityPolicySpecType_RuntimeClass:
		_ = b.EncodeVarint(42<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RuntimeClass); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodSecurityPolicySpecType.RuntimeClassChoice has unexpected type %T", x)
	}
	return nil
}

func _PodSecurityPolicySpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PodSecurityPolicySpecType)
	switch tag {
	case 5: // default_capabilities_choice.no_default_capabilities
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DefaultCapabilitiesChoice = &PodSecurityPolicySpecType_NoDefaultCapabilities{msg}
		return true, err
	case 6: // default_capabilities_choice.default_capabilities
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CapabilityListType)
		err := b.DecodeMessage(msg)
		m.DefaultCapabilitiesChoice = &PodSecurityPolicySpecType_DefaultCapabilities{msg}
		return true, err
	case 8: // allowed_capabilities_choice.no_allowed_capabilities
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.AllowedCapabilitiesChoice = &PodSecurityPolicySpecType_NoAllowedCapabilities{msg}
		return true, err
	case 9: // allowed_capabilities_choice.allowed_capabilities
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CapabilityListType)
		err := b.DecodeMessage(msg)
		m.AllowedCapabilitiesChoice = &PodSecurityPolicySpecType_AllowedCapabilities{msg}
		return true, err
	case 11: // drop_capabilities_choice.no_drop_capabilities
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DropCapabilitiesChoice = &PodSecurityPolicySpecType_NoDropCapabilities{msg}
		return true, err
	case 12: // drop_capabilities_choice.drop_capabilities
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CapabilityListType)
		err := b.DecodeMessage(msg)
		m.DropCapabilitiesChoice = &PodSecurityPolicySpecType_DropCapabilities{msg}
		return true, err
	case 26: // user_choice.no_run_as_user
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.UserChoice = &PodSecurityPolicySpecType_NoRunAsUser{msg}
		return true, err
	case 27: // user_choice.run_as_user
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IDStrategyOptionsType)
		err := b.DecodeMessage(msg)
		m.UserChoice = &PodSecurityPolicySpecType_RunAsUser{msg}
		return true, err
	case 29: // group_choice.no_run_as_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GroupChoice = &PodSecurityPolicySpecType_NoRunAsGroup{msg}
		return true, err
	case 30: // group_choice.run_as_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IDStrategyOptionsType)
		err := b.DecodeMessage(msg)
		m.GroupChoice = &PodSecurityPolicySpecType_RunAsGroup{msg}
		return true, err
	case 32: // supplemental_group_choice.no_supplemental_groups
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.SupplementalGroupChoice = &PodSecurityPolicySpecType_NoSupplementalGroups{msg}
		return true, err
	case 33: // supplemental_group_choice.supplemental_groups
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IDStrategyOptionsType)
		err := b.DecodeMessage(msg)
		m.SupplementalGroupChoice = &PodSecurityPolicySpecType_SupplementalGroups{msg}
		return true, err
	case 35: // fs_group_choice.no_fs_groups
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.FsGroupChoice = &PodSecurityPolicySpecType_NoFsGroups{msg}
		return true, err
	case 36: // fs_group_choice.fs_group_strategy_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IDStrategyOptionsType)
		err := b.DecodeMessage(msg)
		m.FsGroupChoice = &PodSecurityPolicySpecType_FsGroupStrategyOptions{msg}
		return true, err
	case 38: // se_linux_choice.no_se_linux_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.SeLinuxChoice = &PodSecurityPolicySpecType_NoSeLinuxOptions{msg}
		return true, err
	case 39: // se_linux_choice.se_linux_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SELinuxStrategyOptions)
		err := b.DecodeMessage(msg)
		m.SeLinuxChoice = &PodSecurityPolicySpecType_SeLinuxOptions{msg}
		return true, err
	case 41: // runtime_class_choice.no_runtime_class
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.RuntimeClassChoice = &PodSecurityPolicySpecType_NoRuntimeClass{msg}
		return true, err
	case 42: // runtime_class_choice.runtime_class
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RuntimeClassStrategyOptions)
		err := b.DecodeMessage(msg)
		m.RuntimeClassChoice = &PodSecurityPolicySpecType_RuntimeClass{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PodSecurityPolicySpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PodSecurityPolicySpecType)
	// default_capabilities_choice
	switch x := m.DefaultCapabilitiesChoice.(type) {
	case *PodSecurityPolicySpecType_NoDefaultCapabilities:
		s := proto.Size(x.NoDefaultCapabilities)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodSecurityPolicySpecType_DefaultCapabilities:
		s := proto.Size(x.DefaultCapabilities)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// allowed_capabilities_choice
	switch x := m.AllowedCapabilitiesChoice.(type) {
	case *PodSecurityPolicySpecType_NoAllowedCapabilities:
		s := proto.Size(x.NoAllowedCapabilities)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodSecurityPolicySpecType_AllowedCapabilities:
		s := proto.Size(x.AllowedCapabilities)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// drop_capabilities_choice
	switch x := m.DropCapabilitiesChoice.(type) {
	case *PodSecurityPolicySpecType_NoDropCapabilities:
		s := proto.Size(x.NoDropCapabilities)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodSecurityPolicySpecType_DropCapabilities:
		s := proto.Size(x.DropCapabilities)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// user_choice
	switch x := m.UserChoice.(type) {
	case *PodSecurityPolicySpecType_NoRunAsUser:
		s := proto.Size(x.NoRunAsUser)
		n += proto.SizeVarint(26<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodSecurityPolicySpecType_RunAsUser:
		s := proto.Size(x.RunAsUser)
		n += proto.SizeVarint(27<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// group_choice
	switch x := m.GroupChoice.(type) {
	case *PodSecurityPolicySpecType_NoRunAsGroup:
		s := proto.Size(x.NoRunAsGroup)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodSecurityPolicySpecType_RunAsGroup:
		s := proto.Size(x.RunAsGroup)
		n += proto.SizeVarint(30<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// supplemental_group_choice
	switch x := m.SupplementalGroupChoice.(type) {
	case *PodSecurityPolicySpecType_NoSupplementalGroups:
		s := proto.Size(x.NoSupplementalGroups)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodSecurityPolicySpecType_SupplementalGroups:
		s := proto.Size(x.SupplementalGroups)
		n += proto.SizeVarint(33<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// fs_group_choice
	switch x := m.FsGroupChoice.(type) {
	case *PodSecurityPolicySpecType_NoFsGroups:
		s := proto.Size(x.NoFsGroups)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodSecurityPolicySpecType_FsGroupStrategyOptions:
		s := proto.Size(x.FsGroupStrategyOptions)
		n += proto.SizeVarint(36<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// se_linux_choice
	switch x := m.SeLinuxChoice.(type) {
	case *PodSecurityPolicySpecType_NoSeLinuxOptions:
		s := proto.Size(x.NoSeLinuxOptions)
		n += proto.SizeVarint(38<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodSecurityPolicySpecType_SeLinuxOptions:
		s := proto.Size(x.SeLinuxOptions)
		n += proto.SizeVarint(39<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// runtime_class_choice
	switch x := m.RuntimeClassChoice.(type) {
	case *PodSecurityPolicySpecType_NoRuntimeClass:
		s := proto.Size(x.NoRuntimeClass)
		n += proto.SizeVarint(41<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodSecurityPolicySpecType_RuntimeClass:
		s := proto.Size(x.RuntimeClass)
		n += proto.SizeVarint(42<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for K8s Pod Security Policy
type GlobalSpecType struct {
	// Configuration Method
	//
	// x-displayName: "Configuration Method"
	// x-required
	// Select Configuration method, form based or direct K8s YAML
	//
	// Types that are valid to be assigned to ConfigMethodChoice:
	//	*GlobalSpecType_PspSpec
	//	*GlobalSpecType_Yaml
	ConfigMethodChoice isGlobalSpecType_ConfigMethodChoice `protobuf_oneof:"config_method_choice"`
	// K8s YAML
	//
	// x-displayName: "K8s YAML"
	// K8s YAML for ClusterRoleBinding
	GeneratedYaml string `protobuf:"bytes,1001,opt,name=generated_yaml,json=generatedYaml,proto3" json:"generated_yaml,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

type isGlobalSpecType_ConfigMethodChoice interface {
	isGlobalSpecType_ConfigMethodChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_PspSpec struct {
	PspSpec *PodSecurityPolicySpecType `protobuf:"bytes,2,opt,name=psp_spec,json=pspSpec,oneof"`
}
type GlobalSpecType_Yaml struct {
	Yaml string `protobuf:"bytes,3,opt,name=yaml,proto3,oneof"`
}

func (*GlobalSpecType_PspSpec) isGlobalSpecType_ConfigMethodChoice() {}
func (*GlobalSpecType_Yaml) isGlobalSpecType_ConfigMethodChoice()    {}

func (m *GlobalSpecType) GetConfigMethodChoice() isGlobalSpecType_ConfigMethodChoice {
	if m != nil {
		return m.ConfigMethodChoice
	}
	return nil
}

func (m *GlobalSpecType) GetPspSpec() *PodSecurityPolicySpecType {
	if x, ok := m.GetConfigMethodChoice().(*GlobalSpecType_PspSpec); ok {
		return x.PspSpec
	}
	return nil
}

func (m *GlobalSpecType) GetYaml() string {
	if x, ok := m.GetConfigMethodChoice().(*GlobalSpecType_Yaml); ok {
		return x.Yaml
	}
	return ""
}

func (m *GlobalSpecType) GetGeneratedYaml() string {
	if m != nil {
		return m.GeneratedYaml
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_PspSpec)(nil),
		(*GlobalSpecType_Yaml)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// config_method_choice
	switch x := m.ConfigMethodChoice.(type) {
	case *GlobalSpecType_PspSpec:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PspSpec); err != nil {
			return err
		}
	case *GlobalSpecType_Yaml:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Yaml)
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.ConfigMethodChoice has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 2: // config_method_choice.psp_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PodSecurityPolicySpecType)
		err := b.DecodeMessage(msg)
		m.ConfigMethodChoice = &GlobalSpecType_PspSpec{msg}
		return true, err
	case 3: // config_method_choice.yaml
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ConfigMethodChoice = &GlobalSpecType_Yaml{x}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// config_method_choice
	switch x := m.ConfigMethodChoice.(type) {
	case *GlobalSpecType_PspSpec:
		s := proto.Size(x.PspSpec)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_Yaml:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Yaml)))
		n += len(x.Yaml)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create k8s_pod_security_policy
//
// x-displayName: "Create Configuration Specification"
// Create k8s_pod_security_policy will create the object in the storage backend for namespace metadata.namespace
type CreateSpecType struct {
	// Types that are valid to be assigned to ConfigMethodChoice:
	//	*CreateSpecType_PspSpec
	//	*CreateSpecType_Yaml
	ConfigMethodChoice isCreateSpecType_ConfigMethodChoice `protobuf_oneof:"config_method_choice"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

type isCreateSpecType_ConfigMethodChoice interface {
	isCreateSpecType_ConfigMethodChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_PspSpec struct {
	PspSpec *PodSecurityPolicySpecType `protobuf:"bytes,2,opt,name=psp_spec,json=pspSpec,oneof"`
}
type CreateSpecType_Yaml struct {
	Yaml string `protobuf:"bytes,3,opt,name=yaml,proto3,oneof"`
}

func (*CreateSpecType_PspSpec) isCreateSpecType_ConfigMethodChoice() {}
func (*CreateSpecType_Yaml) isCreateSpecType_ConfigMethodChoice()    {}

func (m *CreateSpecType) GetConfigMethodChoice() isCreateSpecType_ConfigMethodChoice {
	if m != nil {
		return m.ConfigMethodChoice
	}
	return nil
}

func (m *CreateSpecType) GetPspSpec() *PodSecurityPolicySpecType {
	if x, ok := m.GetConfigMethodChoice().(*CreateSpecType_PspSpec); ok {
		return x.PspSpec
	}
	return nil
}

func (m *CreateSpecType) GetYaml() string {
	if x, ok := m.GetConfigMethodChoice().(*CreateSpecType_Yaml); ok {
		return x.Yaml
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_PspSpec)(nil),
		(*CreateSpecType_Yaml)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// config_method_choice
	switch x := m.ConfigMethodChoice.(type) {
	case *CreateSpecType_PspSpec:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PspSpec); err != nil {
			return err
		}
	case *CreateSpecType_Yaml:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Yaml)
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.ConfigMethodChoice has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 2: // config_method_choice.psp_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PodSecurityPolicySpecType)
		err := b.DecodeMessage(msg)
		m.ConfigMethodChoice = &CreateSpecType_PspSpec{msg}
		return true, err
	case 3: // config_method_choice.yaml
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ConfigMethodChoice = &CreateSpecType_Yaml{x}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// config_method_choice
	switch x := m.ConfigMethodChoice.(type) {
	case *CreateSpecType_PspSpec:
		s := proto.Size(x.PspSpec)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_Yaml:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Yaml)))
		n += len(x.Yaml)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace k8s_pod_security_policy
//
// x-displayName: "Replace Configuration Specification"
// Replacing an k8s_pod_security_policy object will update the object by replacing the existing spec with the provided one.
// For read-then-write operations a resourceVersion mismatch will occur if the object was modified between the read and write
type ReplaceSpecType struct {
	// Types that are valid to be assigned to ConfigMethodChoice:
	//	*ReplaceSpecType_PspSpec
	//	*ReplaceSpecType_Yaml
	ConfigMethodChoice isReplaceSpecType_ConfigMethodChoice `protobuf_oneof:"config_method_choice"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

type isReplaceSpecType_ConfigMethodChoice interface {
	isReplaceSpecType_ConfigMethodChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_PspSpec struct {
	PspSpec *PodSecurityPolicySpecType `protobuf:"bytes,2,opt,name=psp_spec,json=pspSpec,oneof"`
}
type ReplaceSpecType_Yaml struct {
	Yaml string `protobuf:"bytes,3,opt,name=yaml,proto3,oneof"`
}

func (*ReplaceSpecType_PspSpec) isReplaceSpecType_ConfigMethodChoice() {}
func (*ReplaceSpecType_Yaml) isReplaceSpecType_ConfigMethodChoice()    {}

func (m *ReplaceSpecType) GetConfigMethodChoice() isReplaceSpecType_ConfigMethodChoice {
	if m != nil {
		return m.ConfigMethodChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetPspSpec() *PodSecurityPolicySpecType {
	if x, ok := m.GetConfigMethodChoice().(*ReplaceSpecType_PspSpec); ok {
		return x.PspSpec
	}
	return nil
}

func (m *ReplaceSpecType) GetYaml() string {
	if x, ok := m.GetConfigMethodChoice().(*ReplaceSpecType_Yaml); ok {
		return x.Yaml
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_PspSpec)(nil),
		(*ReplaceSpecType_Yaml)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// config_method_choice
	switch x := m.ConfigMethodChoice.(type) {
	case *ReplaceSpecType_PspSpec:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PspSpec); err != nil {
			return err
		}
	case *ReplaceSpecType_Yaml:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Yaml)
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.ConfigMethodChoice has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 2: // config_method_choice.psp_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PodSecurityPolicySpecType)
		err := b.DecodeMessage(msg)
		m.ConfigMethodChoice = &ReplaceSpecType_PspSpec{msg}
		return true, err
	case 3: // config_method_choice.yaml
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ConfigMethodChoice = &ReplaceSpecType_Yaml{x}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// config_method_choice
	switch x := m.ConfigMethodChoice.(type) {
	case *ReplaceSpecType_PspSpec:
		s := proto.Size(x.PspSpec)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_Yaml:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Yaml)))
		n += len(x.Yaml)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get k8s_pod_security_policy
//
// x-displayName: "Get Configuration Specification"
// Get k8s_pod_security_policy will get the object from the storage backend for namespace metadata.namespace
type GetSpecType struct {
	// Types that are valid to be assigned to ConfigMethodChoice:
	//	*GetSpecType_PspSpec
	//	*GetSpecType_Yaml
	ConfigMethodChoice isGetSpecType_ConfigMethodChoice `protobuf_oneof:"config_method_choice"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

type isGetSpecType_ConfigMethodChoice interface {
	isGetSpecType_ConfigMethodChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_PspSpec struct {
	PspSpec *PodSecurityPolicySpecType `protobuf:"bytes,2,opt,name=psp_spec,json=pspSpec,oneof"`
}
type GetSpecType_Yaml struct {
	Yaml string `protobuf:"bytes,3,opt,name=yaml,proto3,oneof"`
}

func (*GetSpecType_PspSpec) isGetSpecType_ConfigMethodChoice() {}
func (*GetSpecType_Yaml) isGetSpecType_ConfigMethodChoice()    {}

func (m *GetSpecType) GetConfigMethodChoice() isGetSpecType_ConfigMethodChoice {
	if m != nil {
		return m.ConfigMethodChoice
	}
	return nil
}

func (m *GetSpecType) GetPspSpec() *PodSecurityPolicySpecType {
	if x, ok := m.GetConfigMethodChoice().(*GetSpecType_PspSpec); ok {
		return x.PspSpec
	}
	return nil
}

func (m *GetSpecType) GetYaml() string {
	if x, ok := m.GetConfigMethodChoice().(*GetSpecType_Yaml); ok {
		return x.Yaml
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_PspSpec)(nil),
		(*GetSpecType_Yaml)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// config_method_choice
	switch x := m.ConfigMethodChoice.(type) {
	case *GetSpecType_PspSpec:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PspSpec); err != nil {
			return err
		}
	case *GetSpecType_Yaml:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Yaml)
	case nil:
	default:
		return fmt.Errorf("GetSpecType.ConfigMethodChoice has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 2: // config_method_choice.psp_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PodSecurityPolicySpecType)
		err := b.DecodeMessage(msg)
		m.ConfigMethodChoice = &GetSpecType_PspSpec{msg}
		return true, err
	case 3: // config_method_choice.yaml
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ConfigMethodChoice = &GetSpecType_Yaml{x}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// config_method_choice
	switch x := m.ConfigMethodChoice.(type) {
	case *GetSpecType_PspSpec:
		s := proto.Size(x.PspSpec)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_Yaml:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Yaml)))
		n += len(x.Yaml)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*CapabilityListType)(nil), "ves.io.schema.k8s_pod_security_policy.CapabilityListType")
	golang_proto.RegisterType((*CapabilityListType)(nil), "ves.io.schema.k8s_pod_security_policy.CapabilityListType")
	proto.RegisterType((*HostPathType)(nil), "ves.io.schema.k8s_pod_security_policy.HostPathType")
	golang_proto.RegisterType((*HostPathType)(nil), "ves.io.schema.k8s_pod_security_policy.HostPathType")
	proto.RegisterType((*IDRangeType)(nil), "ves.io.schema.k8s_pod_security_policy.IDRangeType")
	golang_proto.RegisterType((*IDRangeType)(nil), "ves.io.schema.k8s_pod_security_policy.IDRangeType")
	proto.RegisterType((*IDStrategyOptionsType)(nil), "ves.io.schema.k8s_pod_security_policy.IDStrategyOptionsType")
	golang_proto.RegisterType((*IDStrategyOptionsType)(nil), "ves.io.schema.k8s_pod_security_policy.IDStrategyOptionsType")
	proto.RegisterType((*RuntimeClassStrategyOptions)(nil), "ves.io.schema.k8s_pod_security_policy.RuntimeClassStrategyOptions")
	golang_proto.RegisterType((*RuntimeClassStrategyOptions)(nil), "ves.io.schema.k8s_pod_security_policy.RuntimeClassStrategyOptions")
	proto.RegisterType((*SELinuxStrategyOptions)(nil), "ves.io.schema.k8s_pod_security_policy.SELinuxStrategyOptions")
	golang_proto.RegisterType((*SELinuxStrategyOptions)(nil), "ves.io.schema.k8s_pod_security_policy.SELinuxStrategyOptions")
	proto.RegisterType((*PodSecurityPolicySpecType)(nil), "ves.io.schema.k8s_pod_security_policy.PodSecurityPolicySpecType")
	golang_proto.RegisterType((*PodSecurityPolicySpecType)(nil), "ves.io.schema.k8s_pod_security_policy.PodSecurityPolicySpecType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.GetSpecType")
}
func (this *CapabilityListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CapabilityListType)
	if !ok {
		that2, ok := that.(CapabilityListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return false
	}
	for i := range this.Capabilities {
		if this.Capabilities[i] != that1.Capabilities[i] {
			return false
		}
	}
	return true
}
func (this *HostPathType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostPathType)
	if !ok {
		that2, ok := that.(HostPathType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathPrefix != that1.PathPrefix {
		return false
	}
	if this.ReadOnly != that1.ReadOnly {
		return false
	}
	return true
}
func (this *IDRangeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IDRangeType)
	if !ok {
		that2, ok := that.(IDRangeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinId != that1.MinId {
		return false
	}
	if this.MaxId != that1.MaxId {
		return false
	}
	return true
}
func (this *IDStrategyOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IDStrategyOptionsType)
	if !ok {
		that2, ok := that.(IDStrategyOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.IdRanges) != len(that1.IdRanges) {
		return false
	}
	for i := range this.IdRanges {
		if !this.IdRanges[i].Equal(that1.IdRanges[i]) {
			return false
		}
	}
	if this.Rule != that1.Rule {
		return false
	}
	return true
}
func (this *RuntimeClassStrategyOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RuntimeClassStrategyOptions)
	if !ok {
		that2, ok := that.(RuntimeClassStrategyOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AllowedRuntimeClassNames) != len(that1.AllowedRuntimeClassNames) {
		return false
	}
	for i := range this.AllowedRuntimeClassNames {
		if this.AllowedRuntimeClassNames[i] != that1.AllowedRuntimeClassNames[i] {
			return false
		}
	}
	if this.DefaultRuntimeClassName != that1.DefaultRuntimeClassName {
		return false
	}
	return true
}
func (this *SELinuxStrategyOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SELinuxStrategyOptions)
	if !ok {
		that2, ok := that.(SELinuxStrategyOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Rule != that1.Rule {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.AllowPrivilegeEscalation != that1.AllowPrivilegeEscalation {
		return false
	}
	if this.DefaultAllowPrivilegeEscalation != that1.DefaultAllowPrivilegeEscalation {
		return false
	}
	if that1.DefaultCapabilitiesChoice == nil {
		if this.DefaultCapabilitiesChoice != nil {
			return false
		}
	} else if this.DefaultCapabilitiesChoice == nil {
		return false
	} else if !this.DefaultCapabilitiesChoice.Equal(that1.DefaultCapabilitiesChoice) {
		return false
	}
	if that1.AllowedCapabilitiesChoice == nil {
		if this.AllowedCapabilitiesChoice != nil {
			return false
		}
	} else if this.AllowedCapabilitiesChoice == nil {
		return false
	} else if !this.AllowedCapabilitiesChoice.Equal(that1.AllowedCapabilitiesChoice) {
		return false
	}
	if that1.DropCapabilitiesChoice == nil {
		if this.DropCapabilitiesChoice != nil {
			return false
		}
	} else if this.DropCapabilitiesChoice == nil {
		return false
	} else if !this.DropCapabilitiesChoice.Equal(that1.DropCapabilitiesChoice) {
		return false
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if this.Volumes[i] != that1.Volumes[i] {
			return false
		}
	}
	if len(this.AllowedFlexVolumes) != len(that1.AllowedFlexVolumes) {
		return false
	}
	for i := range this.AllowedFlexVolumes {
		if this.AllowedFlexVolumes[i] != that1.AllowedFlexVolumes[i] {
			return false
		}
	}
	if len(this.AllowedHostPaths) != len(that1.AllowedHostPaths) {
		return false
	}
	for i := range this.AllowedHostPaths {
		if !this.AllowedHostPaths[i].Equal(that1.AllowedHostPaths[i]) {
			return false
		}
	}
	if len(this.AllowedProcMounts) != len(that1.AllowedProcMounts) {
		return false
	}
	for i := range this.AllowedProcMounts {
		if this.AllowedProcMounts[i] != that1.AllowedProcMounts[i] {
			return false
		}
	}
	if this.ReadOnlyRootFilesystem != that1.ReadOnlyRootFilesystem {
		return false
	}
	if len(this.AllowedCsiDrivers) != len(that1.AllowedCsiDrivers) {
		return false
	}
	for i := range this.AllowedCsiDrivers {
		if this.AllowedCsiDrivers[i] != that1.AllowedCsiDrivers[i] {
			return false
		}
	}
	if this.HostNetwork != that1.HostNetwork {
		return false
	}
	if this.HostPortRanges != that1.HostPortRanges {
		return false
	}
	if this.HostIpc != that1.HostIpc {
		return false
	}
	if this.HostPid != that1.HostPid {
		return false
	}
	if len(this.AllowedUnsafeSysctls) != len(that1.AllowedUnsafeSysctls) {
		return false
	}
	for i := range this.AllowedUnsafeSysctls {
		if this.AllowedUnsafeSysctls[i] != that1.AllowedUnsafeSysctls[i] {
			return false
		}
	}
	if len(this.ForbiddenSysctls) != len(that1.ForbiddenSysctls) {
		return false
	}
	for i := range this.ForbiddenSysctls {
		if this.ForbiddenSysctls[i] != that1.ForbiddenSysctls[i] {
			return false
		}
	}
	if that1.UserChoice == nil {
		if this.UserChoice != nil {
			return false
		}
	} else if this.UserChoice == nil {
		return false
	} else if !this.UserChoice.Equal(that1.UserChoice) {
		return false
	}
	if that1.GroupChoice == nil {
		if this.GroupChoice != nil {
			return false
		}
	} else if this.GroupChoice == nil {
		return false
	} else if !this.GroupChoice.Equal(that1.GroupChoice) {
		return false
	}
	if that1.SupplementalGroupChoice == nil {
		if this.SupplementalGroupChoice != nil {
			return false
		}
	} else if this.SupplementalGroupChoice == nil {
		return false
	} else if !this.SupplementalGroupChoice.Equal(that1.SupplementalGroupChoice) {
		return false
	}
	if that1.FsGroupChoice == nil {
		if this.FsGroupChoice != nil {
			return false
		}
	} else if this.FsGroupChoice == nil {
		return false
	} else if !this.FsGroupChoice.Equal(that1.FsGroupChoice) {
		return false
	}
	if that1.SeLinuxChoice == nil {
		if this.SeLinuxChoice != nil {
			return false
		}
	} else if this.SeLinuxChoice == nil {
		return false
	} else if !this.SeLinuxChoice.Equal(that1.SeLinuxChoice) {
		return false
	}
	if that1.RuntimeClassChoice == nil {
		if this.RuntimeClassChoice != nil {
			return false
		}
	} else if this.RuntimeClassChoice == nil {
		return false
	} else if !this.RuntimeClassChoice.Equal(that1.RuntimeClassChoice) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoDefaultCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoDefaultCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoDefaultCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDefaultCapabilities.Equal(that1.NoDefaultCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_DefaultCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_DefaultCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_DefaultCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultCapabilities.Equal(that1.DefaultCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoAllowedCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoAllowedCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoAllowedCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoAllowedCapabilities.Equal(that1.NoAllowedCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_AllowedCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_AllowedCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_AllowedCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowedCapabilities.Equal(that1.AllowedCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoDropCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoDropCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoDropCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDropCapabilities.Equal(that1.NoDropCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_DropCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_DropCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_DropCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DropCapabilities.Equal(that1.DropCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoRunAsUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoRunAsUser)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoRunAsUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoRunAsUser.Equal(that1.NoRunAsUser) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_RunAsUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_RunAsUser)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_RunAsUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RunAsUser.Equal(that1.RunAsUser) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoRunAsGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoRunAsGroup)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoRunAsGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoRunAsGroup.Equal(that1.NoRunAsGroup) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_RunAsGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_RunAsGroup)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_RunAsGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RunAsGroup.Equal(that1.RunAsGroup) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoSupplementalGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoSupplementalGroups)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoSupplementalGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoSupplementalGroups.Equal(that1.NoSupplementalGroups) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_SupplementalGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_SupplementalGroups)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_SupplementalGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SupplementalGroups.Equal(that1.SupplementalGroups) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoFsGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoFsGroups)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoFsGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoFsGroups.Equal(that1.NoFsGroups) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_FsGroupStrategyOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_FsGroupStrategyOptions)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_FsGroupStrategyOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FsGroupStrategyOptions.Equal(that1.FsGroupStrategyOptions) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoSeLinuxOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoSeLinuxOptions)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoSeLinuxOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoSeLinuxOptions.Equal(that1.NoSeLinuxOptions) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_SeLinuxOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_SeLinuxOptions)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_SeLinuxOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SeLinuxOptions.Equal(that1.SeLinuxOptions) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoRuntimeClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoRuntimeClass)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoRuntimeClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoRuntimeClass.Equal(that1.NoRuntimeClass) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_RuntimeClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_RuntimeClass)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_RuntimeClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuntimeClass.Equal(that1.RuntimeClass) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigMethodChoice == nil {
		if this.ConfigMethodChoice != nil {
			return false
		}
	} else if this.ConfigMethodChoice == nil {
		return false
	} else if !this.ConfigMethodChoice.Equal(that1.ConfigMethodChoice) {
		return false
	}
	if this.GeneratedYaml != that1.GeneratedYaml {
		return false
	}
	return true
}
func (this *GlobalSpecType_PspSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PspSpec)
	if !ok {
		that2, ok := that.(GlobalSpecType_PspSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PspSpec.Equal(that1.PspSpec) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Yaml) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Yaml)
	if !ok {
		that2, ok := that.(GlobalSpecType_Yaml)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Yaml != that1.Yaml {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigMethodChoice == nil {
		if this.ConfigMethodChoice != nil {
			return false
		}
	} else if this.ConfigMethodChoice == nil {
		return false
	} else if !this.ConfigMethodChoice.Equal(that1.ConfigMethodChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_PspSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_PspSpec)
	if !ok {
		that2, ok := that.(CreateSpecType_PspSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PspSpec.Equal(that1.PspSpec) {
		return false
	}
	return true
}
func (this *CreateSpecType_Yaml) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Yaml)
	if !ok {
		that2, ok := that.(CreateSpecType_Yaml)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Yaml != that1.Yaml {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigMethodChoice == nil {
		if this.ConfigMethodChoice != nil {
			return false
		}
	} else if this.ConfigMethodChoice == nil {
		return false
	} else if !this.ConfigMethodChoice.Equal(that1.ConfigMethodChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_PspSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_PspSpec)
	if !ok {
		that2, ok := that.(ReplaceSpecType_PspSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PspSpec.Equal(that1.PspSpec) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Yaml) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Yaml)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Yaml)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Yaml != that1.Yaml {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigMethodChoice == nil {
		if this.ConfigMethodChoice != nil {
			return false
		}
	} else if this.ConfigMethodChoice == nil {
		return false
	} else if !this.ConfigMethodChoice.Equal(that1.ConfigMethodChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_PspSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_PspSpec)
	if !ok {
		that2, ok := that.(GetSpecType_PspSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PspSpec.Equal(that1.PspSpec) {
		return false
	}
	return true
}
func (this *GetSpecType_Yaml) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Yaml)
	if !ok {
		that2, ok := that.(GetSpecType_Yaml)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Yaml != that1.Yaml {
		return false
	}
	return true
}
func (this *CapabilityListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&k8s_pod_security_policy.CapabilityListType{")
	s = append(s, "Capabilities: "+fmt.Sprintf("%#v", this.Capabilities)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostPathType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.HostPathType{")
	s = append(s, "PathPrefix: "+fmt.Sprintf("%#v", this.PathPrefix)+",\n")
	s = append(s, "ReadOnly: "+fmt.Sprintf("%#v", this.ReadOnly)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IDRangeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.IDRangeType{")
	s = append(s, "MinId: "+fmt.Sprintf("%#v", this.MinId)+",\n")
	s = append(s, "MaxId: "+fmt.Sprintf("%#v", this.MaxId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IDStrategyOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.IDStrategyOptionsType{")
	if this.IdRanges != nil {
		s = append(s, "IdRanges: "+fmt.Sprintf("%#v", this.IdRanges)+",\n")
	}
	s = append(s, "Rule: "+fmt.Sprintf("%#v", this.Rule)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RuntimeClassStrategyOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.RuntimeClassStrategyOptions{")
	s = append(s, "AllowedRuntimeClassNames: "+fmt.Sprintf("%#v", this.AllowedRuntimeClassNames)+",\n")
	s = append(s, "DefaultRuntimeClassName: "+fmt.Sprintf("%#v", this.DefaultRuntimeClassName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SELinuxStrategyOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&k8s_pod_security_policy.SELinuxStrategyOptions{")
	s = append(s, "Rule: "+fmt.Sprintf("%#v", this.Rule)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodSecurityPolicySpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 37)
	s = append(s, "&k8s_pod_security_policy.PodSecurityPolicySpecType{")
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	s = append(s, "AllowPrivilegeEscalation: "+fmt.Sprintf("%#v", this.AllowPrivilegeEscalation)+",\n")
	s = append(s, "DefaultAllowPrivilegeEscalation: "+fmt.Sprintf("%#v", this.DefaultAllowPrivilegeEscalation)+",\n")
	if this.DefaultCapabilitiesChoice != nil {
		s = append(s, "DefaultCapabilitiesChoice: "+fmt.Sprintf("%#v", this.DefaultCapabilitiesChoice)+",\n")
	}
	if this.AllowedCapabilitiesChoice != nil {
		s = append(s, "AllowedCapabilitiesChoice: "+fmt.Sprintf("%#v", this.AllowedCapabilitiesChoice)+",\n")
	}
	if this.DropCapabilitiesChoice != nil {
		s = append(s, "DropCapabilitiesChoice: "+fmt.Sprintf("%#v", this.DropCapabilitiesChoice)+",\n")
	}
	s = append(s, "Volumes: "+fmt.Sprintf("%#v", this.Volumes)+",\n")
	s = append(s, "AllowedFlexVolumes: "+fmt.Sprintf("%#v", this.AllowedFlexVolumes)+",\n")
	if this.AllowedHostPaths != nil {
		s = append(s, "AllowedHostPaths: "+fmt.Sprintf("%#v", this.AllowedHostPaths)+",\n")
	}
	s = append(s, "AllowedProcMounts: "+fmt.Sprintf("%#v", this.AllowedProcMounts)+",\n")
	s = append(s, "ReadOnlyRootFilesystem: "+fmt.Sprintf("%#v", this.ReadOnlyRootFilesystem)+",\n")
	s = append(s, "AllowedCsiDrivers: "+fmt.Sprintf("%#v", this.AllowedCsiDrivers)+",\n")
	s = append(s, "HostNetwork: "+fmt.Sprintf("%#v", this.HostNetwork)+",\n")
	s = append(s, "HostPortRanges: "+fmt.Sprintf("%#v", this.HostPortRanges)+",\n")
	s = append(s, "HostIpc: "+fmt.Sprintf("%#v", this.HostIpc)+",\n")
	s = append(s, "HostPid: "+fmt.Sprintf("%#v", this.HostPid)+",\n")
	s = append(s, "AllowedUnsafeSysctls: "+fmt.Sprintf("%#v", this.AllowedUnsafeSysctls)+",\n")
	s = append(s, "ForbiddenSysctls: "+fmt.Sprintf("%#v", this.ForbiddenSysctls)+",\n")
	if this.UserChoice != nil {
		s = append(s, "UserChoice: "+fmt.Sprintf("%#v", this.UserChoice)+",\n")
	}
	if this.GroupChoice != nil {
		s = append(s, "GroupChoice: "+fmt.Sprintf("%#v", this.GroupChoice)+",\n")
	}
	if this.SupplementalGroupChoice != nil {
		s = append(s, "SupplementalGroupChoice: "+fmt.Sprintf("%#v", this.SupplementalGroupChoice)+",\n")
	}
	if this.FsGroupChoice != nil {
		s = append(s, "FsGroupChoice: "+fmt.Sprintf("%#v", this.FsGroupChoice)+",\n")
	}
	if this.SeLinuxChoice != nil {
		s = append(s, "SeLinuxChoice: "+fmt.Sprintf("%#v", this.SeLinuxChoice)+",\n")
	}
	if this.RuntimeClassChoice != nil {
		s = append(s, "RuntimeClassChoice: "+fmt.Sprintf("%#v", this.RuntimeClassChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodSecurityPolicySpecType_NoDefaultCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoDefaultCapabilities{` +
		`NoDefaultCapabilities:` + fmt.Sprintf("%#v", this.NoDefaultCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_DefaultCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_DefaultCapabilities{` +
		`DefaultCapabilities:` + fmt.Sprintf("%#v", this.DefaultCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoAllowedCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoAllowedCapabilities{` +
		`NoAllowedCapabilities:` + fmt.Sprintf("%#v", this.NoAllowedCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_AllowedCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_AllowedCapabilities{` +
		`AllowedCapabilities:` + fmt.Sprintf("%#v", this.AllowedCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoDropCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoDropCapabilities{` +
		`NoDropCapabilities:` + fmt.Sprintf("%#v", this.NoDropCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_DropCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_DropCapabilities{` +
		`DropCapabilities:` + fmt.Sprintf("%#v", this.DropCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoRunAsUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoRunAsUser{` +
		`NoRunAsUser:` + fmt.Sprintf("%#v", this.NoRunAsUser) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_RunAsUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_RunAsUser{` +
		`RunAsUser:` + fmt.Sprintf("%#v", this.RunAsUser) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoRunAsGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoRunAsGroup{` +
		`NoRunAsGroup:` + fmt.Sprintf("%#v", this.NoRunAsGroup) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_RunAsGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_RunAsGroup{` +
		`RunAsGroup:` + fmt.Sprintf("%#v", this.RunAsGroup) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoSupplementalGroups) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoSupplementalGroups{` +
		`NoSupplementalGroups:` + fmt.Sprintf("%#v", this.NoSupplementalGroups) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_SupplementalGroups) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_SupplementalGroups{` +
		`SupplementalGroups:` + fmt.Sprintf("%#v", this.SupplementalGroups) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoFsGroups) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoFsGroups{` +
		`NoFsGroups:` + fmt.Sprintf("%#v", this.NoFsGroups) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_FsGroupStrategyOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_FsGroupStrategyOptions{` +
		`FsGroupStrategyOptions:` + fmt.Sprintf("%#v", this.FsGroupStrategyOptions) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoSeLinuxOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoSeLinuxOptions{` +
		`NoSeLinuxOptions:` + fmt.Sprintf("%#v", this.NoSeLinuxOptions) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_SeLinuxOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_SeLinuxOptions{` +
		`SeLinuxOptions:` + fmt.Sprintf("%#v", this.SeLinuxOptions) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoRuntimeClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoRuntimeClass{` +
		`NoRuntimeClass:` + fmt.Sprintf("%#v", this.NoRuntimeClass) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_RuntimeClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_RuntimeClass{` +
		`RuntimeClass:` + fmt.Sprintf("%#v", this.RuntimeClass) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&k8s_pod_security_policy.GlobalSpecType{")
	if this.ConfigMethodChoice != nil {
		s = append(s, "ConfigMethodChoice: "+fmt.Sprintf("%#v", this.ConfigMethodChoice)+",\n")
	}
	s = append(s, "GeneratedYaml: "+fmt.Sprintf("%#v", this.GeneratedYaml)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_PspSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.GlobalSpecType_PspSpec{` +
		`PspSpec:` + fmt.Sprintf("%#v", this.PspSpec) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Yaml) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.GlobalSpecType_Yaml{` +
		`Yaml:` + fmt.Sprintf("%#v", this.Yaml) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.CreateSpecType{")
	if this.ConfigMethodChoice != nil {
		s = append(s, "ConfigMethodChoice: "+fmt.Sprintf("%#v", this.ConfigMethodChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_PspSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.CreateSpecType_PspSpec{` +
		`PspSpec:` + fmt.Sprintf("%#v", this.PspSpec) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Yaml) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.CreateSpecType_Yaml{` +
		`Yaml:` + fmt.Sprintf("%#v", this.Yaml) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.ReplaceSpecType{")
	if this.ConfigMethodChoice != nil {
		s = append(s, "ConfigMethodChoice: "+fmt.Sprintf("%#v", this.ConfigMethodChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_PspSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.ReplaceSpecType_PspSpec{` +
		`PspSpec:` + fmt.Sprintf("%#v", this.PspSpec) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Yaml) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.ReplaceSpecType_Yaml{` +
		`Yaml:` + fmt.Sprintf("%#v", this.Yaml) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.GetSpecType{")
	if this.ConfigMethodChoice != nil {
		s = append(s, "ConfigMethodChoice: "+fmt.Sprintf("%#v", this.ConfigMethodChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_PspSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.GetSpecType_PspSpec{` +
		`PspSpec:` + fmt.Sprintf("%#v", this.PspSpec) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Yaml) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.GetSpecType_Yaml{` +
		`Yaml:` + fmt.Sprintf("%#v", this.Yaml) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CapabilityListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapabilityListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for _, s := range m.Capabilities {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HostPathType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostPathType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PathPrefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PathPrefix)))
		i += copy(dAtA[i:], m.PathPrefix)
	}
	if m.ReadOnly {
		dAtA[i] = 0x10
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *IDRangeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDRangeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MinId))
	}
	if m.MaxId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxId))
	}
	return i, nil
}

func (m *IDStrategyOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDStrategyOptionsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IdRanges) > 0 {
		for _, msg := range m.IdRanges {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Rule) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Rule)))
		i += copy(dAtA[i:], m.Rule)
	}
	return i, nil
}

func (m *RuntimeClassStrategyOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeClassStrategyOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllowedRuntimeClassNames) > 0 {
		for _, s := range m.AllowedRuntimeClassNames {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DefaultRuntimeClassName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultRuntimeClassName)))
		i += copy(dAtA[i:], m.DefaultRuntimeClassName)
	}
	return i, nil
}

func (m *SELinuxStrategyOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SELinuxStrategyOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rule) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Rule)))
		i += copy(dAtA[i:], m.Rule)
	}
	if len(m.Level) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Level)))
		i += copy(dAtA[i:], m.Level)
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.User) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *PodSecurityPolicySpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodSecurityPolicySpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Privileged {
		dAtA[i] = 0x8
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AllowPrivilegeEscalation {
		dAtA[i] = 0x10
		i++
		if m.AllowPrivilegeEscalation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultAllowPrivilegeEscalation {
		dAtA[i] = 0x18
		i++
		if m.DefaultAllowPrivilegeEscalation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultCapabilitiesChoice != nil {
		nn1, err := m.DefaultCapabilitiesChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.AllowedCapabilitiesChoice != nil {
		nn2, err := m.AllowedCapabilitiesChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	if m.DropCapabilitiesChoice != nil {
		nn3, err := m.DropCapabilitiesChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if len(m.Volumes) > 0 {
		for _, s := range m.Volumes {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AllowedFlexVolumes) > 0 {
		for _, s := range m.AllowedFlexVolumes {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AllowedHostPaths) > 0 {
		for _, msg := range m.AllowedHostPaths {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AllowedProcMounts) > 0 {
		for _, s := range m.AllowedProcMounts {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ReadOnlyRootFilesystem {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.ReadOnlyRootFilesystem {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AllowedCsiDrivers) > 0 {
		for _, s := range m.AllowedCsiDrivers {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.HostNetwork {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.HostNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.HostPortRanges) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostPortRanges)))
		i += copy(dAtA[i:], m.HostPortRanges)
	}
	if m.HostIpc {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.HostIpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HostPid {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.HostPid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AllowedUnsafeSysctls) > 0 {
		for _, s := range m.AllowedUnsafeSysctls {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ForbiddenSysctls) > 0 {
		for _, s := range m.ForbiddenSysctls {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.UserChoice != nil {
		nn4, err := m.UserChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.GroupChoice != nil {
		nn5, err := m.GroupChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.SupplementalGroupChoice != nil {
		nn6, err := m.SupplementalGroupChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if m.FsGroupChoice != nil {
		nn7, err := m.FsGroupChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if m.SeLinuxChoice != nil {
		nn8, err := m.SeLinuxChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	if m.RuntimeClassChoice != nil {
		nn9, err := m.RuntimeClassChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	return i, nil
}

func (m *PodSecurityPolicySpecType_NoDefaultCapabilities) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoDefaultCapabilities != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoDefaultCapabilities.Size()))
		n10, err := m.NoDefaultCapabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_DefaultCapabilities) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultCapabilities != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultCapabilities.Size()))
		n11, err := m.DefaultCapabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_NoAllowedCapabilities) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoAllowedCapabilities != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoAllowedCapabilities.Size()))
		n12, err := m.NoAllowedCapabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_AllowedCapabilities) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AllowedCapabilities != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AllowedCapabilities.Size()))
		n13, err := m.AllowedCapabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_NoDropCapabilities) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoDropCapabilities != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoDropCapabilities.Size()))
		n14, err := m.NoDropCapabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_DropCapabilities) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DropCapabilities != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DropCapabilities.Size()))
		n15, err := m.DropCapabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_NoRunAsUser) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoRunAsUser != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoRunAsUser.Size()))
		n16, err := m.NoRunAsUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_RunAsUser) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RunAsUser != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RunAsUser.Size()))
		n17, err := m.RunAsUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_NoRunAsGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoRunAsGroup != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoRunAsGroup.Size()))
		n18, err := m.NoRunAsGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_RunAsGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RunAsGroup != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RunAsGroup.Size()))
		n19, err := m.RunAsGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_NoSupplementalGroups) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoSupplementalGroups != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoSupplementalGroups.Size()))
		n20, err := m.NoSupplementalGroups.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_SupplementalGroups) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SupplementalGroups != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SupplementalGroups.Size()))
		n21, err := m.SupplementalGroups.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_NoFsGroups) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoFsGroups != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoFsGroups.Size()))
		n22, err := m.NoFsGroups.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_FsGroupStrategyOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FsGroupStrategyOptions != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.FsGroupStrategyOptions.Size()))
		n23, err := m.FsGroupStrategyOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_NoSeLinuxOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoSeLinuxOptions != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoSeLinuxOptions.Size()))
		n24, err := m.NoSeLinuxOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_SeLinuxOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SeLinuxOptions != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SeLinuxOptions.Size()))
		n25, err := m.SeLinuxOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_NoRuntimeClass) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoRuntimeClass != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoRuntimeClass.Size()))
		n26, err := m.NoRuntimeClass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *PodSecurityPolicySpecType_RuntimeClass) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RuntimeClass != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RuntimeClass.Size()))
		n27, err := m.RuntimeClass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		nn28, err := m.ConfigMethodChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn28
	}
	if len(m.GeneratedYaml) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GeneratedYaml)))
		i += copy(dAtA[i:], m.GeneratedYaml)
	}
	return i, nil
}

func (m *GlobalSpecType_PspSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PspSpec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PspSpec.Size()))
		n29, err := m.PspSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *GlobalSpecType_Yaml) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Yaml)))
	i += copy(dAtA[i:], m.Yaml)
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		nn30, err := m.ConfigMethodChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn30
	}
	return i, nil
}

func (m *CreateSpecType_PspSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PspSpec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PspSpec.Size()))
		n31, err := m.PspSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *CreateSpecType_Yaml) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Yaml)))
	i += copy(dAtA[i:], m.Yaml)
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		nn32, err := m.ConfigMethodChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn32
	}
	return i, nil
}

func (m *ReplaceSpecType_PspSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PspSpec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PspSpec.Size()))
		n33, err := m.PspSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *ReplaceSpecType_Yaml) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Yaml)))
	i += copy(dAtA[i:], m.Yaml)
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		nn34, err := m.ConfigMethodChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn34
	}
	return i, nil
}

func (m *GetSpecType_PspSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PspSpec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PspSpec.Size()))
		n35, err := m.PspSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *GetSpecType_Yaml) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Yaml)))
	i += copy(dAtA[i:], m.Yaml)
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CapabilityListType) Size() (n int) {
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for _, s := range m.Capabilities {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *HostPathType) Size() (n int) {
	var l int
	_ = l
	l = len(m.PathPrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	return n
}

func (m *IDRangeType) Size() (n int) {
	var l int
	_ = l
	if m.MinId != 0 {
		n += 1 + sovTypes(uint64(m.MinId))
	}
	if m.MaxId != 0 {
		n += 1 + sovTypes(uint64(m.MaxId))
	}
	return n
}

func (m *IDStrategyOptionsType) Size() (n int) {
	var l int
	_ = l
	if len(m.IdRanges) > 0 {
		for _, e := range m.IdRanges {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Rule)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RuntimeClassStrategyOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.AllowedRuntimeClassNames) > 0 {
		for _, s := range m.AllowedRuntimeClassNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.DefaultRuntimeClassName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SELinuxStrategyOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Rule)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PodSecurityPolicySpecType) Size() (n int) {
	var l int
	_ = l
	if m.Privileged {
		n += 2
	}
	if m.AllowPrivilegeEscalation {
		n += 2
	}
	if m.DefaultAllowPrivilegeEscalation {
		n += 2
	}
	if m.DefaultCapabilitiesChoice != nil {
		n += m.DefaultCapabilitiesChoice.Size()
	}
	if m.AllowedCapabilitiesChoice != nil {
		n += m.AllowedCapabilitiesChoice.Size()
	}
	if m.DropCapabilitiesChoice != nil {
		n += m.DropCapabilitiesChoice.Size()
	}
	if len(m.Volumes) > 0 {
		for _, s := range m.Volumes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowedFlexVolumes) > 0 {
		for _, s := range m.AllowedFlexVolumes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowedHostPaths) > 0 {
		for _, e := range m.AllowedHostPaths {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowedProcMounts) > 0 {
		for _, s := range m.AllowedProcMounts {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.ReadOnlyRootFilesystem {
		n += 3
	}
	if len(m.AllowedCsiDrivers) > 0 {
		for _, s := range m.AllowedCsiDrivers {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.HostNetwork {
		n += 3
	}
	l = len(m.HostPortRanges)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.HostIpc {
		n += 3
	}
	if m.HostPid {
		n += 3
	}
	if len(m.AllowedUnsafeSysctls) > 0 {
		for _, s := range m.AllowedUnsafeSysctls {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ForbiddenSysctls) > 0 {
		for _, s := range m.ForbiddenSysctls {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UserChoice != nil {
		n += m.UserChoice.Size()
	}
	if m.GroupChoice != nil {
		n += m.GroupChoice.Size()
	}
	if m.SupplementalGroupChoice != nil {
		n += m.SupplementalGroupChoice.Size()
	}
	if m.FsGroupChoice != nil {
		n += m.FsGroupChoice.Size()
	}
	if m.SeLinuxChoice != nil {
		n += m.SeLinuxChoice.Size()
	}
	if m.RuntimeClassChoice != nil {
		n += m.RuntimeClassChoice.Size()
	}
	return n
}

func (m *PodSecurityPolicySpecType_NoDefaultCapabilities) Size() (n int) {
	var l int
	_ = l
	if m.NoDefaultCapabilities != nil {
		l = m.NoDefaultCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_DefaultCapabilities) Size() (n int) {
	var l int
	_ = l
	if m.DefaultCapabilities != nil {
		l = m.DefaultCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoAllowedCapabilities) Size() (n int) {
	var l int
	_ = l
	if m.NoAllowedCapabilities != nil {
		l = m.NoAllowedCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_AllowedCapabilities) Size() (n int) {
	var l int
	_ = l
	if m.AllowedCapabilities != nil {
		l = m.AllowedCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoDropCapabilities) Size() (n int) {
	var l int
	_ = l
	if m.NoDropCapabilities != nil {
		l = m.NoDropCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_DropCapabilities) Size() (n int) {
	var l int
	_ = l
	if m.DropCapabilities != nil {
		l = m.DropCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoRunAsUser) Size() (n int) {
	var l int
	_ = l
	if m.NoRunAsUser != nil {
		l = m.NoRunAsUser.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_RunAsUser) Size() (n int) {
	var l int
	_ = l
	if m.RunAsUser != nil {
		l = m.RunAsUser.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoRunAsGroup) Size() (n int) {
	var l int
	_ = l
	if m.NoRunAsGroup != nil {
		l = m.NoRunAsGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_RunAsGroup) Size() (n int) {
	var l int
	_ = l
	if m.RunAsGroup != nil {
		l = m.RunAsGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoSupplementalGroups) Size() (n int) {
	var l int
	_ = l
	if m.NoSupplementalGroups != nil {
		l = m.NoSupplementalGroups.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_SupplementalGroups) Size() (n int) {
	var l int
	_ = l
	if m.SupplementalGroups != nil {
		l = m.SupplementalGroups.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoFsGroups) Size() (n int) {
	var l int
	_ = l
	if m.NoFsGroups != nil {
		l = m.NoFsGroups.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_FsGroupStrategyOptions) Size() (n int) {
	var l int
	_ = l
	if m.FsGroupStrategyOptions != nil {
		l = m.FsGroupStrategyOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoSeLinuxOptions) Size() (n int) {
	var l int
	_ = l
	if m.NoSeLinuxOptions != nil {
		l = m.NoSeLinuxOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_SeLinuxOptions) Size() (n int) {
	var l int
	_ = l
	if m.SeLinuxOptions != nil {
		l = m.SeLinuxOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoRuntimeClass) Size() (n int) {
	var l int
	_ = l
	if m.NoRuntimeClass != nil {
		l = m.NoRuntimeClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_RuntimeClass) Size() (n int) {
	var l int
	_ = l
	if m.RuntimeClass != nil {
		l = m.RuntimeClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		n += m.ConfigMethodChoice.Size()
	}
	l = len(m.GeneratedYaml)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_PspSpec) Size() (n int) {
	var l int
	_ = l
	if m.PspSpec != nil {
		l = m.PspSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Yaml) Size() (n int) {
	var l int
	_ = l
	l = len(m.Yaml)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		n += m.ConfigMethodChoice.Size()
	}
	return n
}

func (m *CreateSpecType_PspSpec) Size() (n int) {
	var l int
	_ = l
	if m.PspSpec != nil {
		l = m.PspSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_Yaml) Size() (n int) {
	var l int
	_ = l
	l = len(m.Yaml)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		n += m.ConfigMethodChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_PspSpec) Size() (n int) {
	var l int
	_ = l
	if m.PspSpec != nil {
		l = m.PspSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_Yaml) Size() (n int) {
	var l int
	_ = l
	l = len(m.Yaml)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		n += m.ConfigMethodChoice.Size()
	}
	return n
}

func (m *GetSpecType_PspSpec) Size() (n int) {
	var l int
	_ = l
	if m.PspSpec != nil {
		l = m.PspSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Yaml) Size() (n int) {
	var l int
	_ = l
	l = len(m.Yaml)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CapabilityListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapabilityListType{`,
		`Capabilities:` + fmt.Sprintf("%v", this.Capabilities) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostPathType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostPathType{`,
		`PathPrefix:` + fmt.Sprintf("%v", this.PathPrefix) + `,`,
		`ReadOnly:` + fmt.Sprintf("%v", this.ReadOnly) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IDRangeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IDRangeType{`,
		`MinId:` + fmt.Sprintf("%v", this.MinId) + `,`,
		`MaxId:` + fmt.Sprintf("%v", this.MaxId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IDStrategyOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IDStrategyOptionsType{`,
		`IdRanges:` + strings.Replace(fmt.Sprintf("%v", this.IdRanges), "IDRangeType", "IDRangeType", 1) + `,`,
		`Rule:` + fmt.Sprintf("%v", this.Rule) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RuntimeClassStrategyOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RuntimeClassStrategyOptions{`,
		`AllowedRuntimeClassNames:` + fmt.Sprintf("%v", this.AllowedRuntimeClassNames) + `,`,
		`DefaultRuntimeClassName:` + fmt.Sprintf("%v", this.DefaultRuntimeClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SELinuxStrategyOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SELinuxStrategyOptions{`,
		`Rule:` + fmt.Sprintf("%v", this.Rule) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType{`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`AllowPrivilegeEscalation:` + fmt.Sprintf("%v", this.AllowPrivilegeEscalation) + `,`,
		`DefaultAllowPrivilegeEscalation:` + fmt.Sprintf("%v", this.DefaultAllowPrivilegeEscalation) + `,`,
		`DefaultCapabilitiesChoice:` + fmt.Sprintf("%v", this.DefaultCapabilitiesChoice) + `,`,
		`AllowedCapabilitiesChoice:` + fmt.Sprintf("%v", this.AllowedCapabilitiesChoice) + `,`,
		`DropCapabilitiesChoice:` + fmt.Sprintf("%v", this.DropCapabilitiesChoice) + `,`,
		`Volumes:` + fmt.Sprintf("%v", this.Volumes) + `,`,
		`AllowedFlexVolumes:` + fmt.Sprintf("%v", this.AllowedFlexVolumes) + `,`,
		`AllowedHostPaths:` + strings.Replace(fmt.Sprintf("%v", this.AllowedHostPaths), "HostPathType", "HostPathType", 1) + `,`,
		`AllowedProcMounts:` + fmt.Sprintf("%v", this.AllowedProcMounts) + `,`,
		`ReadOnlyRootFilesystem:` + fmt.Sprintf("%v", this.ReadOnlyRootFilesystem) + `,`,
		`AllowedCsiDrivers:` + fmt.Sprintf("%v", this.AllowedCsiDrivers) + `,`,
		`HostNetwork:` + fmt.Sprintf("%v", this.HostNetwork) + `,`,
		`HostPortRanges:` + fmt.Sprintf("%v", this.HostPortRanges) + `,`,
		`HostIpc:` + fmt.Sprintf("%v", this.HostIpc) + `,`,
		`HostPid:` + fmt.Sprintf("%v", this.HostPid) + `,`,
		`AllowedUnsafeSysctls:` + fmt.Sprintf("%v", this.AllowedUnsafeSysctls) + `,`,
		`ForbiddenSysctls:` + fmt.Sprintf("%v", this.ForbiddenSysctls) + `,`,
		`UserChoice:` + fmt.Sprintf("%v", this.UserChoice) + `,`,
		`GroupChoice:` + fmt.Sprintf("%v", this.GroupChoice) + `,`,
		`SupplementalGroupChoice:` + fmt.Sprintf("%v", this.SupplementalGroupChoice) + `,`,
		`FsGroupChoice:` + fmt.Sprintf("%v", this.FsGroupChoice) + `,`,
		`SeLinuxChoice:` + fmt.Sprintf("%v", this.SeLinuxChoice) + `,`,
		`RuntimeClassChoice:` + fmt.Sprintf("%v", this.RuntimeClassChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoDefaultCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoDefaultCapabilities{`,
		`NoDefaultCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.NoDefaultCapabilities), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_DefaultCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_DefaultCapabilities{`,
		`DefaultCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.DefaultCapabilities), "CapabilityListType", "CapabilityListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoAllowedCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoAllowedCapabilities{`,
		`NoAllowedCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.NoAllowedCapabilities), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_AllowedCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_AllowedCapabilities{`,
		`AllowedCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.AllowedCapabilities), "CapabilityListType", "CapabilityListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoDropCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoDropCapabilities{`,
		`NoDropCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.NoDropCapabilities), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_DropCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_DropCapabilities{`,
		`DropCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.DropCapabilities), "CapabilityListType", "CapabilityListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoRunAsUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoRunAsUser{`,
		`NoRunAsUser:` + strings.Replace(fmt.Sprintf("%v", this.NoRunAsUser), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_RunAsUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_RunAsUser{`,
		`RunAsUser:` + strings.Replace(fmt.Sprintf("%v", this.RunAsUser), "IDStrategyOptionsType", "IDStrategyOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoRunAsGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoRunAsGroup{`,
		`NoRunAsGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoRunAsGroup), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_RunAsGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_RunAsGroup{`,
		`RunAsGroup:` + strings.Replace(fmt.Sprintf("%v", this.RunAsGroup), "IDStrategyOptionsType", "IDStrategyOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoSupplementalGroups) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoSupplementalGroups{`,
		`NoSupplementalGroups:` + strings.Replace(fmt.Sprintf("%v", this.NoSupplementalGroups), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_SupplementalGroups) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_SupplementalGroups{`,
		`SupplementalGroups:` + strings.Replace(fmt.Sprintf("%v", this.SupplementalGroups), "IDStrategyOptionsType", "IDStrategyOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoFsGroups) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoFsGroups{`,
		`NoFsGroups:` + strings.Replace(fmt.Sprintf("%v", this.NoFsGroups), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_FsGroupStrategyOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_FsGroupStrategyOptions{`,
		`FsGroupStrategyOptions:` + strings.Replace(fmt.Sprintf("%v", this.FsGroupStrategyOptions), "IDStrategyOptionsType", "IDStrategyOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoSeLinuxOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoSeLinuxOptions{`,
		`NoSeLinuxOptions:` + strings.Replace(fmt.Sprintf("%v", this.NoSeLinuxOptions), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_SeLinuxOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_SeLinuxOptions{`,
		`SeLinuxOptions:` + strings.Replace(fmt.Sprintf("%v", this.SeLinuxOptions), "SELinuxStrategyOptions", "SELinuxStrategyOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoRuntimeClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoRuntimeClass{`,
		`NoRuntimeClass:` + strings.Replace(fmt.Sprintf("%v", this.NoRuntimeClass), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_RuntimeClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_RuntimeClass{`,
		`RuntimeClass:` + strings.Replace(fmt.Sprintf("%v", this.RuntimeClass), "RuntimeClassStrategyOptions", "RuntimeClassStrategyOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`ConfigMethodChoice:` + fmt.Sprintf("%v", this.ConfigMethodChoice) + `,`,
		`GeneratedYaml:` + fmt.Sprintf("%v", this.GeneratedYaml) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PspSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PspSpec{`,
		`PspSpec:` + strings.Replace(fmt.Sprintf("%v", this.PspSpec), "PodSecurityPolicySpecType", "PodSecurityPolicySpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Yaml) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Yaml{`,
		`Yaml:` + fmt.Sprintf("%v", this.Yaml) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`ConfigMethodChoice:` + fmt.Sprintf("%v", this.ConfigMethodChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_PspSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_PspSpec{`,
		`PspSpec:` + strings.Replace(fmt.Sprintf("%v", this.PspSpec), "PodSecurityPolicySpecType", "PodSecurityPolicySpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Yaml) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Yaml{`,
		`Yaml:` + fmt.Sprintf("%v", this.Yaml) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`ConfigMethodChoice:` + fmt.Sprintf("%v", this.ConfigMethodChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_PspSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_PspSpec{`,
		`PspSpec:` + strings.Replace(fmt.Sprintf("%v", this.PspSpec), "PodSecurityPolicySpecType", "PodSecurityPolicySpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Yaml) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Yaml{`,
		`Yaml:` + fmt.Sprintf("%v", this.Yaml) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`ConfigMethodChoice:` + fmt.Sprintf("%v", this.ConfigMethodChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_PspSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_PspSpec{`,
		`PspSpec:` + strings.Replace(fmt.Sprintf("%v", this.PspSpec), "PodSecurityPolicySpecType", "PodSecurityPolicySpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Yaml) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Yaml{`,
		`Yaml:` + fmt.Sprintf("%v", this.Yaml) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CapabilityListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapabilityListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapabilityListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capabilities = append(m.Capabilities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostPathType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostPathType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostPathType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDRangeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDRangeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDRangeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinId", wireType)
			}
			m.MinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDStrategyOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDStrategyOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDStrategyOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdRanges = append(m.IdRanges, &IDRangeType{})
			if err := m.IdRanges[len(m.IdRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeClassStrategyOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeClassStrategyOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeClassStrategyOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedRuntimeClassNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedRuntimeClassNames = append(m.AllowedRuntimeClassNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRuntimeClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultRuntimeClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SELinuxStrategyOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SELinuxStrategyOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SELinuxStrategyOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodSecurityPolicySpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodSecurityPolicySpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodSecurityPolicySpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPrivilegeEscalation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPrivilegeEscalation = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAllowPrivilegeEscalation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultAllowPrivilegeEscalation = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDefaultCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultCapabilitiesChoice = &PodSecurityPolicySpecType_NoDefaultCapabilities{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CapabilityListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultCapabilitiesChoice = &PodSecurityPolicySpecType_DefaultCapabilities{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAllowedCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllowedCapabilitiesChoice = &PodSecurityPolicySpecType_NoAllowedCapabilities{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CapabilityListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllowedCapabilitiesChoice = &PodSecurityPolicySpecType_AllowedCapabilities{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDropCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DropCapabilitiesChoice = &PodSecurityPolicySpecType_NoDropCapabilities{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CapabilityListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DropCapabilitiesChoice = &PodSecurityPolicySpecType_DropCapabilities{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedFlexVolumes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedFlexVolumes = append(m.AllowedFlexVolumes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedHostPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedHostPaths = append(m.AllowedHostPaths, &HostPathType{})
			if err := m.AllowedHostPaths[len(m.AllowedHostPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedProcMounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedProcMounts = append(m.AllowedProcMounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnlyRootFilesystem", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnlyRootFilesystem = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCsiDrivers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCsiDrivers = append(m.AllowedCsiDrivers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostNetwork = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPortRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostIpc = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostPid = bool(v != 0)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedUnsafeSysctls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedUnsafeSysctls = append(m.AllowedUnsafeSysctls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenSysctls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenSysctls = append(m.ForbiddenSysctls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRunAsUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UserChoice = &PodSecurityPolicySpecType_NoRunAsUser{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IDStrategyOptionsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UserChoice = &PodSecurityPolicySpecType_RunAsUser{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRunAsGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GroupChoice = &PodSecurityPolicySpecType_NoRunAsGroup{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IDStrategyOptionsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GroupChoice = &PodSecurityPolicySpecType_RunAsGroup{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoSupplementalGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SupplementalGroupChoice = &PodSecurityPolicySpecType_NoSupplementalGroups{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplementalGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IDStrategyOptionsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SupplementalGroupChoice = &PodSecurityPolicySpecType_SupplementalGroups{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoFsGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FsGroupChoice = &PodSecurityPolicySpecType_NoFsGroups{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsGroupStrategyOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IDStrategyOptionsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FsGroupChoice = &PodSecurityPolicySpecType_FsGroupStrategyOptions{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoSeLinuxOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SeLinuxChoice = &PodSecurityPolicySpecType_NoSeLinuxOptions{v}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeLinuxOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SELinuxStrategyOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SeLinuxChoice = &PodSecurityPolicySpecType_SeLinuxOptions{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRuntimeClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuntimeClassChoice = &PodSecurityPolicySpecType_NoRuntimeClass{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuntimeClassStrategyOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuntimeClassChoice = &PodSecurityPolicySpecType_RuntimeClass{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PspSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSecurityPolicySpecType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigMethodChoice = &GlobalSpecType_PspSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigMethodChoice = &GlobalSpecType_Yaml{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedYaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedYaml = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PspSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSecurityPolicySpecType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigMethodChoice = &CreateSpecType_PspSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigMethodChoice = &CreateSpecType_Yaml{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PspSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSecurityPolicySpecType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigMethodChoice = &ReplaceSpecType_PspSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigMethodChoice = &ReplaceSpecType_Yaml{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PspSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSecurityPolicySpecType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigMethodChoice = &GetSpecType_PspSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigMethodChoice = &GetSpecType_Yaml{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("ves.io/schema/k8s_pod_security_policy/types.proto", fileDescriptorTypes)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/k8s_pod_security_policy/types.proto", fileDescriptorTypes)
}

var fileDescriptorTypes = []byte{
	// 4095 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0x5f, 0x6c, 0x1b, 0x47,
	0x7a, 0xf7, 0x4a, 0x94, 0x44, 0x8d, 0x64, 0x9b, 0xde, 0x28, 0x0e, 0x65, 0x27, 0xca, 0x58, 0x89,
	0x13, 0x2a, 0x47, 0x51, 0x11, 0x25, 0xc7, 0x76, 0x9c, 0x1c, 0xc2, 0x7f, 0x92, 0x28, 0x8b, 0x22,
	0xb1, 0xa4, 0xec, 0x4b, 0xda, 0xbb, 0xed, 0x68, 0x77, 0x48, 0x4e, 0xb4, 0xbb, 0xb3, 0x99, 0x99,
	0x95, 0xcc, 0x02, 0x07, 0xb8, 0x45, 0x80, 0xa2, 0x2f, 0xc5, 0xd5, 0x6f, 0x6d, 0x9f, 0x0f, 0xb8,
	0xbe, 0xb4, 0x7d, 0xae, 0x52, 0xc0, 0xb8, 0x87, 0x22, 0x28, 0x50, 0x40, 0x7d, 0x29, 0xf2, 0x54,
	0x34, 0x3a, 0xa0, 0xb8, 0xa0, 0x0f, 0xbd, 0xc7, 0xa2, 0x2f, 0x57, 0xcc, 0xec, 0x2e, 0x45, 0xfd,
	0xb1, 0xa2, 0xe2, 0x52, 0xe0, 0x70, 0x6f, 0xbb, 0x33, 0xdf, 0xf7, 0xfb, 0xbe, 0xf9, 0xe6, 0xfb,
	0xbb, 0x24, 0x58, 0xdc, 0xc5, 0x3c, 0x47, 0xe8, 0x02, 0xb7, 0xba, 0xd8, 0x45, 0x0b, 0x3b, 0xf7,
	0xb8, 0xe9, 0x53, 0xdb, 0xe4, 0xd8, 0x0a, 0x18, 0x11, 0x3d, 0xd3, 0xa7, 0x0e, 0xb1, 0x7a, 0x0b,
	0xa2, 0xe7, 0x63, 0x9e, 0xf3, 0x19, 0x15, 0x54, 0xbf, 0x1d, 0xb2, 0xe4, 0x42, 0x96, 0xdc, 0x0b,
	0x58, 0x6e, 0xcc, 0x77, 0x88, 0xe8, 0x06, 0xdb, 0x39, 0x8b, 0xba, 0x0b, 0x1d, 0xda, 0xa1, 0x0b,
	0x8a, 0x7b, 0x3b, 0x68, 0xab, 0x37, 0xf5, 0xa2, 0x9e, 0x42, 0xd4, 0x1b, 0x37, 0x8f, 0x2b, 0x42,
	0x7d, 0x41, 0xa8, 0x17, 0x89, 0xbc, 0x31, 0x7d, 0x7c, 0x73, 0x40, 0x9b, 0x1b, 0xaf, 0x1e, 0xdf,
	0xda, 0x45, 0x0e, 0xb1, 0x91, 0xc0, 0xd1, 0x2e, 0x3c, 0xb1, 0x4b, 0xf0, 0x9e, 0x79, 0x0c, 0x7a,
	0xf6, 0xa7, 0xd3, 0x40, 0x2f, 0x21, 0x1f, 0x6d, 0x13, 0x87, 0x88, 0xde, 0x06, 0xe1, 0xa2, 0xd5,
	0xf3, 0xb1, 0xfe, 0x67, 0xd3, 0x60, 0xd2, 0x8a, 0x97, 0x09, 0xe6, 0x69, 0x0d, 0x0e, 0x67, 0xc6,
	0x8b, 0xdf, 0xa4, 0x9f, 0x7d, 0xa1, 0xfd, 0x63, 0x1a, 0x3c, 0xd5, 0xc0, 0xe5, 0xc2, 0x56, 0xb9,
	0xda, 0x32, 0x4b, 0xf5, 0xcd, 0x96, 0x51, 0xdf, 0xd0, 0x69, 0xc5, 0x43, 0xdb, 0x0e, 0x86, 0xc8,
	0xb3, 0xa1, 0x4d, 0xb8, 0x7a, 0xde, 0xc1, 0xcc, 0xc3, 0x0e, 0x44, 0x81, 0x4d, 0x04, 0xf1, 0x3a,
	0x0f, 0xa0, 0xd5, 0x45, 0x5e, 0x07, 0xf7, 0x17, 0x60, 0x9b, 0x38, 0x02, 0x33, 0xc8, 0x02, 0x07,
	0xf3, 0x07, 0x90, 0x61, 0xc1, 0x08, 0xde, 0x1d, 0xd8, 0xe7, 0x02, 0x89, 0x80, 0x2b, 0xcc, 0x90,
	0x54, 0x2e, 0x2a, 0xea, 0x1c, 0x58, 0x05, 0x20, 0xd4, 0xc0, 0xa8, 0x14, 0xca, 0xfa, 0xfd, 0x82,
	0xe3, 0xd0, 0x3d, 0xc8, 0x30, 0xb2, 0x25, 0x8d, 0xe8, 0x46, 0x28, 0xd0, 0xa1, 0x1d, 0xb8, 0x4b,
	0x10, 0x74, 0x03, 0x47, 0x10, 0x0b, 0x71, 0x01, 0x3d, 0x2c, 0x1c, 0xe2, 0xed, 0x40, 0x4e, 0xad,
	0x1d, 0x2c, 0x72, 0x20, 0x0f, 0x2e, 0x17, 0x37, 0xea, 0xa5, 0x87, 0x66, 0x73, 0xab, 0xd9, 0xa8,
	0x6c, 0x96, 0xf5, 0x5b, 0x21, 0x96, 0xcf, 0xf0, 0x2e, 0xf6, 0x42, 0x3d, 0x7a, 0x5c, 0x60, 0x17,
	0xf2, 0x80, 0xfb, 0xd8, 0xb3, 0x79, 0x0e, 0x30, 0x30, 0x5c, 0x6c, 0xac, 0xe8, 0x3b, 0x21, 0xa5,
	0xc5, 0x30, 0x52, 0x74, 0xc5, 0xc6, 0x0a, 0x74, 0x91, 0xcf, 0xb3, 0xd0, 0xa1, 0xa1, 0x22, 0x72,
	0x45, 0x1a, 0x14, 0xae, 0x50, 0xe6, 0x22, 0x01, 0x33, 0xc5, 0xd6, 0xca, 0x1c, 0xb4, 0x91, 0x40,
	0xd9, 0xa3, 0xf3, 0xae, 0x57, 0x5b, 0xd8, 0x86, 0x16, 0xb5, 0x31, 0xa4, 0x6d, 0xc5, 0xe2, 0x33,
	0xda, 0x61, 0xc8, 0xe5, 0x59, 0x75, 0x76, 0x97, 0x32, 0x9c, 0x03, 0xbf, 0x0f, 0xf4, 0xd2, 0x5a,
	0xa5, 0xf4, 0xb0, 0x51, 0xaf, 0x6e, 0xca, 0x53, 0x37, 0x5b, 0x75, 0xa3, 0xa2, 0xaf, 0x44, 0x2a,
	0x74, 0xb1, 0xb5, 0xe3, 0x53, 0xe2, 0x89, 0x05, 0x86, 0xb9, 0xa0, 0x0c, 0x43, 0x86, 0x1d, 0x24,
	0xb0, 0x0d, 0xa9, 0x8f, 0x19, 0x0a, 0xaf, 0x1c, 0x56, 0x3d, 0xc1, 0xa8, 0x1d, 0x58, 0xd8, 0x86,
	0xc4, 0x8b, 0xef, 0xe7, 0x4e, 0xee, 0x7e, 0x0e, 0x74, 0xc0, 0xd5, 0x72, 0xa1, 0xa4, 0x8c, 0x69,
	0x36, 0x2b, 0x05, 0xa3, 0xb4, 0xa6, 0xb7, 0x8a, 0x3d, 0x1f, 0x71, 0x2e, 0x4d, 0x8f, 0x95, 0x65,
	0xa1, 0x8f, 0x99, 0x4b, 0x38, 0x27, 0xd4, 0x0b, 0x05, 0xf2, 0xe8, 0xba, 0x19, 0xb6, 0x04, 0x65,
	0xbd, 0x90, 0x48, 0x2e, 0xe1, 0x27, 0xd8, 0x0a, 0x04, 0x3e, 0xcd, 0x90, 0x03, 0x65, 0x90, 0xac,
	0x36, 0x4a, 0xa6, 0xb4, 0xb8, 0x7e, 0x6f, 0x83, 0x5a, 0x3b, 0xd0, 0xc5, 0xae, 0x64, 0xce, 0xb8,
	0x0e, 0xb5, 0x76, 0x32, 0xf9, 0xb9, 0x2c, 0x54, 0x4f, 0xc8, 0x71, 0xc2, 0x17, 0x17, 0xf9, 0xea,
	0x81, 0x77, 0x5d, 0x4b, 0xc8, 0xb5, 0xb9, 0x1c, 0xa8, 0x81, 0x71, 0x89, 0x52, 0x7f, 0xbc, 0x59,
	0x31, 0xf4, 0x8f, 0x22, 0x45, 0x4f, 0xab, 0xd7, 0xa6, 0x6c, 0xe0, 0xfc, 0x90, 0x7a, 0xb0, 0x19,
	0x5e, 0xe5, 0x23, 0x58, 0x6d, 0x94, 0x20, 0xdd, 0xfe, 0x14, 0x5b, 0x82, 0xe7, 0xc0, 0x07, 0x60,
	0x64, 0xa3, 0x52, 0x68, 0x56, 0xf4, 0xa5, 0x0a, 0x17, 0x68, 0xdb, 0x21, 0xbc, 0x0b, 0x1d, 0x8c,
	0x38, 0x56, 0x3c, 0x88, 0x6d, 0x13, 0xc1, 0x10, 0xeb, 0x29, 0x53, 0x70, 0x98, 0xe1, 0x18, 0xc3,
	0xb6, 0xe5, 0xc5, 0xca, 0x54, 0xc1, 0xd5, 0x8d, 0xea, 0xe6, 0xd6, 0x0f, 0xcc, 0x6a, 0xad, 0xb6,
	0xd5, 0x2a, 0x14, 0x37, 0x2a, 0xfa, 0x7b, 0x4d, 0x2c, 0x94, 0x17, 0xae, 0x34, 0xcd, 0x42, 0x43,
	0xba, 0x95, 0xb9, 0xb2, 0xa1, 0x4c, 0xb3, 0xd2, 0x3c, 0x22, 0x93, 0x6b, 0x64, 0xde, 0x93, 0x17,
	0xdf, 0x76, 0x50, 0x87, 0xe7, 0xc0, 0x16, 0x18, 0xaf, 0x15, 0x4a, 0x66, 0xa1, 0x5c, 0xab, 0x6e,
	0xea, 0x6b, 0xe1, 0xdd, 0xd6, 0x0a, 0x25, 0x68, 0x51, 0xaf, 0x4d, 0x3a, 0x41, 0x78, 0x10, 0x48,
	0x99, 0x0a, 0x0d, 0x1c, 0x05, 0x94, 0xbc, 0x58, 0xd7, 0x77, 0xb0, 0x8b, 0x3d, 0x79, 0xe1, 0xf2,
	0xd0, 0x52, 0x74, 0xd3, 0x45, 0xd6, 0x0e, 0xdc, 0x68, 0xd6, 0x72, 0x80, 0x82, 0x49, 0x09, 0x5b,
	0x7f, 0x54, 0x31, 0x8c, 0x6a, 0xb9, 0xa2, 0x9b, 0xf5, 0x5d, 0xcc, 0x18, 0xb1, 0x31, 0xac, 0x21,
	0xcf, 0x46, 0xea, 0xf2, 0x0a, 0x96, 0x85, 0x39, 0x87, 0x25, 0x2a, 0x7d, 0xc4, 0x81, 0x99, 0x5a,
	0xa1, 0x34, 0x77, 0x2e, 0x30, 0xf1, 0x82, 0x27, 0xb0, 0x19, 0xa5, 0x3d, 0x58, 0xa3, 0x76, 0xe0,
	0x60, 0x98, 0xd9, 0x68, 0xd6, 0xe6, 0x72, 0xe0, 0x1e, 0x18, 0xdf, 0xac, 0xb4, 0xa2, 0x73, 0x7c,
	0xaf, 0x81, 0x59, 0x9b, 0x32, 0x17, 0xee, 0x22, 0x46, 0x68, 0xc0, 0x65, 0x08, 0xee, 0x51, 0xb6,
	0x33, 0x7f, 0x86, 0x8b, 0x82, 0x22, 0xb8, 0x2c, 0x39, 0x8b, 0x46, 0xbd, 0x50, 0x2e, 0x15, 0x9a,
	0x2d, 0x7d, 0xb1, 0x86, 0x76, 0x70, 0x14, 0xad, 0x70, 0x9b, 0x51, 0x64, 0xcb, 0x30, 0x8e, 0x42,
	0xc3, 0x21, 0x5c, 0x60, 0x0f, 0x0a, 0x7a, 0x14, 0xe0, 0x3c, 0x07, 0x3e, 0xd7, 0xc0, 0x58, 0xa3,
	0x62, 0xac, 0xd4, 0xea, 0x9b, 0x7a, 0x2f, 0x34, 0x62, 0x14, 0xc2, 0x7e, 0xa8, 0x09, 0xf2, 0xac,
	0x30, 0x55, 0xd1, 0x6d, 0x8e, 0xd9, 0x6e, 0x94, 0xfd, 0xa0, 0xcf, 0xc8, 0x2e, 0x71, 0x70, 0xe7,
	0x98, 0x4a, 0x30, 0xe0, 0x32, 0x92, 0x25, 0xa7, 0xa9, 0x32, 0x02, 0xcf, 0x42, 0x72, 0x7f, 0xf1,
	0x8e, 0x29, 0x57, 0x42, 0x10, 0xd1, 0xc5, 0x2c, 0x8e, 0x26, 0x1e, 0x6c, 0x87, 0xb2, 0x38, 0x28,
	0x80, 0xf1, 0xe6, 0xc7, 0xcd, 0xc8, 0x08, 0xcb, 0xb1, 0x11, 0x10, 0x64, 0x2a, 0x0b, 0xd2, 0x76,
	0xac, 0x14, 0xb2, 0x5d, 0xe2, 0x11, 0x2e, 0xe2, 0xdb, 0x1d, 0xb0, 0xc6, 0x8f, 0x40, 0x52, 0x42,
	0x14, 0xeb, 0xf5, 0x96, 0x6e, 0x6c, 0x71, 0x19, 0x87, 0xdb, 0x94, 0x8a, 0x4c, 0x7e, 0x4e, 0x49,
	0xde, 0x91, 0x81, 0x66, 0xca, 0x64, 0xa3, 0x22, 0x24, 0xdc, 0x0c, 0x0d, 0x43, 0x65, 0x28, 0x42,
	0x0f, 0xef, 0xc5, 0x8a, 0xc9, 0xdb, 0x93, 0xe6, 0x66, 0x51, 0x74, 0x12, 0xea, 0xe5, 0xc0, 0x3c,
	0x00, 0x12, 0xbf, 0x56, 0x2f, 0x6f, 0x6d, 0x54, 0xf4, 0xd7, 0x37, 0x68, 0x14, 0xc0, 0x81, 0xa7,
	0x00, 0x22, 0x56, 0x57, 0xdd, 0x2d, 0xcf, 0x81, 0xcf, 0x42, 0x75, 0x36, 0xab, 0xa5, 0x8a, 0x8e,
	0x0d, 0x44, 0x38, 0x96, 0xa9, 0x4a, 0xf9, 0x8d, 0x47, 0x2c, 0x0c, 0x77, 0x91, 0x13, 0x60, 0x98,
	0x91, 0xcf, 0x61, 0xc8, 0x62, 0xe1, 0x33, 0x42, 0xa5, 0x83, 0xc8, 0x50, 0x51, 0xd0, 0x51, 0x11,
	0x90, 0x8e, 0x34, 0xc0, 0x23, 0xb5, 0x3b, 0x8a, 0xb3, 0x08, 0x54, 0x8a, 0xfc, 0x7e, 0x68, 0xc4,
	0x46, 0xa1, 0x54, 0x6a, 0xe9, 0x8b, 0xd2, 0x04, 0xc8, 0xb2, 0x44, 0x88, 0xbe, 0x47, 0x84, 0xd5,
	0xed, 0x6b, 0x80, 0x2c, 0x8b, 0x06, 0x61, 0xc2, 0x0e, 0x63, 0x84, 0xb6, 0xdb, 0xd2, 0x13, 0xd5,
	0x09, 0x1b, 0x2d, 0xa3, 0x50, 0xaa, 0xe8, 0xef, 0xb4, 0x18, 0x92, 0x57, 0x7f, 0x5a, 0x52, 0x7c,
	0xcd, 0x42, 0x12, 0x64, 0xf2, 0x73, 0xb9, 0xf8, 0xfa, 0x8c, 0xc2, 0xe3, 0x6a, 0xfd, 0xe8, 0xfa,
	0xaa, 0x0b, 0x75, 0xe8, 0x53, 0x26, 0x06, 0x3d, 0x24, 0x43, 0xa8, 0xef, 0xc4, 0x77, 0x42, 0xe4,
	0x86, 0x1b, 0x66, 0x86, 0x39, 0x30, 0xa9, 0x20, 0x2a, 0xcd, 0xfa, 0x96, 0x51, 0xaa, 0xe8, 0xd3,
	0xfd, 0xb8, 0x63, 0x98, 0xd3, 0x80, 0x59, 0x18, 0x6e, 0x10, 0x97, 0x48, 0x9f, 0x6d, 0x87, 0xa6,
	0x6d, 0x55, 0x6b, 0x15, 0xfd, 0x13, 0x99, 0x3d, 0x22, 0xe7, 0xb0, 0x64, 0x2e, 0x94, 0x29, 0x47,
	0x08, 0xe2, 0x62, 0xda, 0xb6, 0x51, 0x2f, 0x3c, 0xbc, 0x7c, 0x55, 0x4f, 0xc8, 0xfe, 0x54, 0x3e,
	0x3f, 0x91, 0x22, 0x1f, 0x48, 0x93, 0xcb, 0x3c, 0xec, 0xcc, 0xcb, 0x35, 0x98, 0xe9, 0x22, 0x66,
	0xef, 0x21, 0x86, 0xe7, 0x42, 0xa0, 0x1c, 0xc0, 0xe0, 0x8a, 0x92, 0xd3, 0xfa, 0x58, 0xd6, 0xee,
	0x95, 0xea, 0xaa, 0xde, 0x94, 0x46, 0xdd, 0x95, 0xb7, 0x12, 0xc8, 0x44, 0xfb, 0x00, 0x62, 0xd7,
	0x77, 0x68, 0xaf, 0x1f, 0xad, 0x03, 0x51, 0x41, 0x68, 0x98, 0x81, 0x4f, 0x24, 0xd5, 0x5d, 0xc2,
	0x44, 0x80, 0x1c, 0x28, 0x64, 0x02, 0xf6, 0x90, 0xc3, 0x65, 0x55, 0x1d, 0x6d, 0x7e, 0xdc, 0xdc,
	0xa8, 0xaf, 0xea, 0x99, 0xd8, 0x72, 0x03, 0x38, 0xbc, 0xc7, 0x1d, 0xda, 0x39, 0x0e, 0x94, 0x03,
	0x1f, 0x02, 0xf0, 0xb8, 0xf0, 0xb0, 0x62, 0x16, 0x36, 0x0a, 0x46, 0x4d, 0x5f, 0x68, 0x31, 0xd2,
	0xe9, 0x60, 0x06, 0x39, 0x75, 0xb1, 0xe8, 0x86, 0x65, 0x1d, 0x09, 0xb8, 0x47, 0x1c, 0x07, 0xee,
	0xc9, 0x9c, 0x10, 0xf8, 0xca, 0x8b, 0x42, 0x43, 0xe5, 0xc0, 0x32, 0x98, 0x08, 0x3b, 0x82, 0xc7,
	0x46, 0xb5, 0x55, 0xd1, 0x6f, 0x3f, 0x66, 0x44, 0x48, 0x43, 0x5b, 0x94, 0xd9, 0x5c, 0xa6, 0x88,
	0x13, 0xfd, 0x88, 0xec, 0x0d, 0x72, 0xa0, 0x02, 0x46, 0x4a, 0x6b, 0xf5, 0xc7, 0x9b, 0xfa, 0x07,
	0x2a, 0xcf, 0x1c, 0x79, 0x46, 0x94, 0x5b, 0x25, 0xa3, 0xaa, 0x80, 0x5b, 0xd5, 0x72, 0x58, 0xef,
	0x56, 0xe5, 0x83, 0xaa, 0x01, 0x56, 0x97, 0xee, 0x79, 0xe1, 0x4d, 0xaf, 0x82, 0xc9, 0xf2, 0x60,
	0x86, 0xbd, 0x7b, 0xb2, 0x78, 0x66, 0xe1, 0x9e, 0xd4, 0x27, 0xfb, 0x6d, 0xf5, 0xf1, 0x4f, 0x34,
	0x30, 0xba, 0x12, 0xd6, 0xb5, 0x1f, 0xbf, 0xb0, 0xae, 0x1d, 0xcb, 0x12, 0xa1, 0x59, 0x3c, 0x99,
	0xd6, 0x1c, 0x47, 0x16, 0xe1, 0xcf, 0x02, 0xc2, 0xc2, 0x00, 0x53, 0xd2, 0x23, 0x47, 0xda, 0xaa,
	0x96, 0x65, 0xce, 0x91, 0xcb, 0x71, 0xc4, 0xc8, 0xb4, 0x89, 0x64, 0x08, 0xc9, 0xc5, 0x81, 0x7d,
	0xc9, 0x96, 0x03, 0x3f, 0x04, 0xa3, 0x2b, 0xcd, 0x4a, 0xab, 0x5a, 0xd6, 0x9b, 0x65, 0xea, 0x1d,
	0x3e, 0xfd, 0x0b, 0x01, 0x2d, 0x07, 0x23, 0x26, 0x5d, 0x6c, 0x3e, 0xe0, 0x98, 0xcd, 0x57, 0xcb,
	0xea, 0x34, 0xf2, 0xbd, 0xc3, 0x68, 0xe0, 0xcb, 0x85, 0x01, 0x65, 0xb7, 0x89, 0xe0, 0x70, 0xaf,
	0x8b, 0x3d, 0x88, 0x42, 0x4d, 0x08, 0x97, 0xa9, 0x84, 0xb4, 0x09, 0xb6, 0x73, 0xe0, 0x0e, 0x48,
	0x3c, 0xac, 0x6e, 0x6c, 0xe8, 0xf3, 0xe7, 0x56, 0x6f, 0x8e, 0x3d, 0xd5, 0x48, 0x71, 0xd2, 0x09,
	0x1d, 0x6b, 0x1e, 0x8c, 0xd4, 0x1e, 0x6e, 0xd6, 0xcb, 0xfa, 0x9b, 0x25, 0xd9, 0x76, 0x61, 0xc8,
	0x7d, 0x6c, 0x11, 0xe4, 0x44, 0xb5, 0x39, 0x8c, 0x62, 0x77, 0xc7, 0xa3, 0xb6, 0x0a, 0x62, 0x1b,
	0xa4, 0x54, 0x39, 0xa9, 0x6e, 0xca, 0xbe, 0xc6, 0x78, 0x24, 0x33, 0x57, 0xa3, 0x48, 0x3c, 0x99,
	0x1c, 0xa3, 0x9a, 0x22, 0x28, 0x24, 0x9e, 0x90, 0xbe, 0x21, 0xa0, 0x4d, 0x5d, 0x44, 0xbc, 0x41,
	0x57, 0x95, 0xb1, 0xce, 0x61, 0x46, 0x85, 0xbc, 0x17, 0xb8, 0xdb, 0x98, 0x71, 0xe8, 0x28, 0xe3,
	0x75, 0x91, 0x07, 0x17, 0xdf, 0xcd, 0x2f, 0xcf, 0xe5, 0xc0, 0x5b, 0x60, 0x4c, 0x4a, 0x31, 0x0a,
	0x8f, 0xf5, 0x9b, 0x32, 0x9a, 0x8c, 0xc2, 0x63, 0x65, 0x99, 0x46, 0xa1, 0xf4, 0xb0, 0xd2, 0x8a,
	0x04, 0xf1, 0x1c, 0xb8, 0x05, 0xc6, 0x9a, 0x95, 0xd6, 0x4a, 0xa9, 0xd0, 0xd0, 0xaf, 0xcb, 0x18,
	0x57, 0x56, 0x19, 0xec, 0xb3, 0x73, 0xc0, 0x00, 0xa3, 0xcd, 0x4a, 0x6b, 0xb5, 0x5a, 0xd6, 0xd7,
	0x4e, 0x38, 0xa4, 0x8b, 0x3c, 0xe2, 0x07, 0x4e, 0x1c, 0x76, 0xed, 0xfe, 0x35, 0xae, 0xc6, 0x9e,
	0xc9, 0x03, 0x3f, 0xaa, 0xd6, 0x92, 0x7e, 0xb5, 0x5a, 0x56, 0xf5, 0x31, 0x07, 0xde, 0x56, 0x62,
	0x1b, 0x52, 0xec, 0xab, 0x35, 0x79, 0x01, 0xfd, 0xbc, 0x77, 0x42, 0xf8, 0x5d, 0x25, 0x7c, 0xab,
	0x5a, 0xd6, 0xe7, 0x2f, 0x2a, 0x5c, 0x86, 0x45, 0x0e, 0x2c, 0x85, 0x59, 0xb6, 0xb4, 0x66, 0xc8,
	0x4a, 0x75, 0x5b, 0xda, 0xc0, 0xea, 0xb2, 0xb0, 0x52, 0x65, 0xe3, 0x94, 0x2f, 0xdf, 0x8f, 0xba,
	0xc5, 0xdc, 0xdf, 0x7f, 0xf3, 0x7c, 0x78, 0xe4, 0x99, 0x36, 0x94, 0xfa, 0x28, 0x7e, 0x4a, 0x6a,
	0xf1, 0x53, 0x5a, 0x33, 0x8e, 0xcd, 0x1f, 0xb3, 0x9f, 0x80, 0xc9, 0x35, 0xca, 0x45, 0x03, 0x89,
	0xae, 0x1a, 0x50, 0xe6, 0xc1, 0x84, 0x8f, 0x44, 0xd7, 0xf4, 0x19, 0x6e, 0x93, 0x27, 0x69, 0x0d,
	0x6a, 0x99, 0xf1, 0xe2, 0xa4, 0x64, 0x1f, 0x63, 0x23, 0x29, 0x2d, 0xfd, 0x54, 0x33, 0x80, 0x24,
	0x68, 0xa8, 0x7d, 0xfd, 0x26, 0x18, 0x97, 0x41, 0x68, 0x52, 0xcf, 0xe9, 0xa5, 0x87, 0xa0, 0x96,
	0x49, 0x1a, 0x49, 0xb9, 0x50, 0xf7, 0x9c, 0xde, 0xec, 0xc7, 0x60, 0xa2, 0x5a, 0x36, 0xa4, 0x8a,
	0x0a, 0xfa, 0x4d, 0x30, 0xea, 0x12, 0xcf, 0x24, 0xb6, 0x42, 0xbd, 0x5c, 0xbc, 0x2c, 0x51, 0x93,
	0xef, 0x8c, 0xa6, 0x7f, 0xfd, 0xeb, 0xe1, 0x8c, 0x66, 0x8c, 0xb8, 0xc4, 0xab, 0xda, 0x8a, 0x0a,
	0x3d, 0x91, 0x54, 0x43, 0x67, 0x53, 0xa1, 0x27, 0x55, 0x7b, 0xf6, 0xef, 0x12, 0xe0, 0xe5, 0x6a,
	0xb9, 0x29, 0x4b, 0x3b, 0xee, 0xf4, 0xea, 0xe1, 0xe8, 0xa5, 0xa4, 0x60, 0x30, 0x4e, 0x6c, 0x53,
	0xb5, 0x02, 0xe1, 0x74, 0x35, 0x91, 0xcf, 0xe7, 0x2e, 0x34, 0x5a, 0xe6, 0x06, 0x94, 0x2d, 0x4e,
	0xf5, 0xad, 0x98, 0x3a, 0xb2, 0xa2, 0x91, 0x24, 0xb6, 0x22, 0xe1, 0xfa, 0xdf, 0x0e, 0x83, 0x84,
	0x9c, 0x98, 0x94, 0x96, 0xe3, 0xc5, 0xbf, 0x1c, 0x7e, 0xf6, 0x85, 0xf6, 0xa7, 0xc3, 0xe0, 0x99,
	0x06, 0xc6, 0x6b, 0x01, 0x17, 0x46, 0xe0, 0x15, 0xb8, 0xfe, 0xb9, 0x66, 0x84, 0x49, 0x83, 0x43,
	0x24, 0x54, 0xe3, 0x2b, 0x20, 0xf5, 0x70, 0xd4, 0xa8, 0x08, 0x0a, 0xb7, 0xa3, 0x30, 0x53, 0x91,
	0x0b, 0xb7, 0x64, 0xb9, 0x94, 0x79, 0x42, 0xb6, 0x2d, 0x6e, 0xe0, 0x46, 0x25, 0xbc, 0x9f, 0x3c,
	0x18, 0x17, 0x11, 0x2b, 0x0a, 0xe9, 0x6c, 0xdc, 0x46, 0x81, 0x23, 0x72, 0xf0, 0x51, 0x34, 0x9e,
	0x72, 0x88, 0x3a, 0x88, 0x78, 0x5c, 0x40, 0xe4, 0x38, 0x21, 0x2d, 0xcf, 0x81, 0x9f, 0x69, 0x20,
	0x59, 0x43, 0xbd, 0x50, 0xa7, 0xbf, 0xfa, 0xbf, 0xe9, 0xa4, 0xba, 0x3c, 0x0e, 0x57, 0x9a, 0xab,
	0x32, 0x11, 0xf1, 0x88, 0xc0, 0xc1, 0x6d, 0x01, 0x03, 0x4f, 0xd6, 0xc4, 0x3d, 0x22, 0xba, 0x34,
	0x10, 0xd2, 0x6f, 0x77, 0x89, 0x4a, 0x29, 0xe8, 0x62, 0x7a, 0x41, 0xd2, 0x3e, 0x82, 0x25, 0x5c,
	0x66, 0x3b, 0x99, 0xee, 0x93, 0x4a, 0xcd, 0x82, 0xd7, 0xd3, 0x1f, 0x6c, 0xd2, 0x18, 0x29, 0x42,
	0x1f, 0x50, 0x08, 0x79, 0x3d, 0xd8, 0xe6, 0x8a, 0x1b, 0x56, 0xcb, 0xa7, 0xf4, 0x8e, 0x1c, 0x16,
	0x6a, 0x99, 0xa7, 0x9a, 0xa1, 0x2e, 0x6a, 0xf6, 0x5f, 0x35, 0x70, 0xd3, 0x90, 0x7d, 0x8c, 0x8b,
	0x4b, 0x0e, 0xe2, 0xfc, 0x84, 0xf3, 0xe8, 0x2e, 0xb8, 0x89, 0x24, 0x36, 0xb6, 0x4d, 0x16, 0x92,
	0x99, 0x96, 0xa4, 0x33, 0x3d, 0xe4, 0xf6, 0x07, 0x75, 0x05, 0x3c, 0xf1, 0x4c, 0x4b, 0xce, 0x8e,
	0xb2, 0x04, 0xd4, 0x32, 0xfd, 0x10, 0x4b, 0x25, 0xce, 0x0c, 0xb6, 0x74, 0x04, 0x39, 0x28, 0x78,
	0x53, 0xe2, 0xe9, 0x6b, 0xe0, 0x46, 0x74, 0xb8, 0x33, 0xc4, 0x45, 0x5e, 0x35, 0x21, 0x91, 0x22,
	0x41, 0xc6, 0x2b, 0x11, 0xf9, 0x49, 0xa8, 0xd9, 0x9f, 0x0e, 0x83, 0xeb, 0xcd, 0x8a, 0x1a, 0x1b,
	0x4e, 0x9e, 0xe9, 0xf3, 0xa1, 0xc8, 0x4b, 0xc3, 0x38, 0xfe, 0x2f, 0xed, 0xd9, 0x17, 0xda, 0xbf,
	0x69, 0xbf, 0x9d, 0x5e, 0xfa, 0xff, 0x77, 0xf5, 0xfa, 0x2d, 0x30, 0xb2, 0x81, 0x77, 0xb1, 0x73,
	0x96, 0x59, 0xc3, 0x1d, 0xfd, 0x75, 0x90, 0x60, 0xd4, 0xc1, 0xe9, 0xe1, 0xd3, 0x14, 0x6a, 0x43,
	0x12, 0x88, 0x9e, 0x8f, 0xd3, 0x89, 0x33, 0x08, 0xe4, 0x86, 0x24, 0x90, 0xc5, 0x3b, 0x3d, 0x72,
	0x06, 0x81, 0xdc, 0x98, 0xfd, 0xcf, 0x9b, 0x60, 0xba, 0x41, 0xed, 0x78, 0xb2, 0x6b, 0xa8, 0xa4,
	0xd3, 0xf4, 0xb1, 0xa5, 0xf2, 0xd6, 0x0c, 0x00, 0x47, 0xd5, 0x51, 0xdd, 0x57, 0xd2, 0x18, 0x58,
	0xd1, 0x3f, 0x00, 0x37, 0x94, 0x2f, 0x99, 0xfd, 0x35, 0x13, 0x73, 0x0b, 0x85, 0x95, 0x23, 0x4a,
	0xbd, 0xa1, 0xb7, 0x35, 0x62, 0x82, 0x4a, 0x7f, 0x5f, 0x7f, 0x08, 0x66, 0x63, 0x6f, 0x3b, 0x07,
	0x65, 0x58, 0xa1, 0xbc, 0x1e, 0x51, 0x16, 0x5e, 0x04, 0xb6, 0x09, 0x5e, 0xf1, 0xa8, 0x19, 0xe3,
	0x1d, 0xfb, 0x9c, 0x25, 0x0f, 0x3f, 0x91, 0x9f, 0x3a, 0x91, 0x70, 0x2b, 0xae, 0x2f, 0x7a, 0x6b,
	0x97, 0x8c, 0x97, 0x3d, 0x5a, 0x0e, 0xb9, 0x4a, 0x03, 0x4c, 0xba, 0x07, 0xa6, 0xce, 0x04, 0x1b,
	0x55, 0x60, 0xf7, 0x2f, 0x98, 0xbd, 0x4f, 0x7f, 0x6d, 0x5b, 0xbb, 0x64, 0xbc, 0x64, 0x9f, 0x21,
	0x2f, 0xd4, 0x3f, 0x0e, 0xf6, 0x63, 0x22, 0x93, 0xe7, 0xe8, 0xaf, 0x49, 0xfd, 0x0b, 0x21, 0xd7,
	0x49, 0xfd, 0xcf, 0x04, 0x1b, 0xff, 0x4d, 0xf5, 0xd7, 0x8c, 0x97, 0xd0, 0x19, 0xf2, 0xd6, 0xc0,
	0x94, 0xb4, 0x3f, 0xa3, 0xfe, 0x71, 0x79, 0x13, 0xe7, 0x28, 0x3f, 0x64, 0xe8, 0x1e, 0x2d, 0x33,
	0xea, 0x1f, 0x43, 0xea, 0x82, 0x6b, 0xa7, 0x61, 0x26, 0x7f, 0x53, 0xb5, 0x87, 0x8c, 0x94, 0x7d,
	0x52, 0xd2, 0x1f, 0x0d, 0x83, 0xb1, 0x5d, 0xea, 0x04, 0x32, 0x95, 0x5e, 0x56, 0xa9, 0xf4, 0x3f,
	0x86, 0x0e, 0xf7, 0xb5, 0x7f, 0x18, 0x02, 0xda, 0x3b, 0x60, 0x0a, 0xed, 0xf1, 0x8a, 0x83, 0xb8,
	0x20, 0x56, 0x51, 0x4e, 0x53, 0x4d, 0x41, 0x19, 0x06, 0xe3, 0xe8, 0x0f, 0x03, 0x86, 0xcb, 0x84,
	0xef, 0x44, 0x8f, 0x2b, 0xc4, 0xc1, 0x60, 0xd4, 0xc2, 0x7e, 0x77, 0xa5, 0x09, 0x46, 0x2d, 0xe2,
	0xd9, 0x98, 0x81, 0xf1, 0xf0, 0x13, 0x4e, 0x0d, 0xf9, 0x60, 0xd8, 0xe2, 0x04, 0x4c, 0xd8, 0x74,
	0xcf, 0xdb, 0x43, 0xcc, 0x2e, 0x34, 0xaa, 0x20, 0x89, 0xe5, 0xe1, 0xcb, 0x84, 0x81, 0xa1, 0xb6,
	0x05, 0x40, 0xdb, 0xc1, 0x4f, 0x1e, 0x29, 0x25, 0xc0, 0x58, 0x5b, 0x0a, 0xc2, 0x0c, 0x5c, 0xeb,
	0x58, 0xb8, 0x81, 0x19, 0x57, 0x1f, 0x3c, 0x84, 0x92, 0x36, 0xd6, 0x21, 0xc2, 0xc0, 0x3e, 0x05,
	0xe3, 0x1d, 0x27, 0xe0, 0x02, 0xb3, 0x36, 0x07, 0xc9, 0x6e, 0xd4, 0x25, 0x81, 0x11, 0xc2, 0xa5,
	0x9c, 0x61, 0xaf, 0xcd, 0xc1, 0xcb, 0x7e, 0x9f, 0x33, 0xc4, 0x2d, 0x39, 0x88, 0xb8, 0x60, 0xca,
	0xef, 0x52, 0x41, 0xbd, 0x13, 0xb0, 0x57, 0x64, 0xaf, 0xbb, 0x47, 0x59, 0xac, 0xc2, 0xb8, 0xcf,
	0xe8, 0xa7, 0xd8, 0x12, 0xd8, 0x06, 0x63, 0x9f, 0x05, 0x74, 0xbb, 0x27, 0x30, 0x18, 0x66, 0xdb,
	0x36, 0x18, 0x93, 0xa1, 0x86, 0xab, 0x75, 0x30, 0xca, 0xb1, 0xc5, 0xb0, 0x00, 0xe3, 0x5c, 0x50,
	0x86, 0x3a, 0x98, 0x72, 0x70, 0x79, 0x97, 0xfb, 0x5d, 0xcc, 0x70, 0x88, 0xf1, 0xc2, 0x6a, 0x94,
	0x1c, 0xa8, 0x41, 0xb1, 0xdd, 0xf5, 0x47, 0x47, 0x7e, 0x2a, 0x2d, 0x61, 0xc6, 0xf7, 0x71, 0x45,
	0xdd, 0xc7, 0x9b, 0x17, 0x02, 0xd3, 0x23, 0x84, 0x95, 0xbe, 0x29, 0xb9, 0xbe, 0x07, 0xe2, 0x55,
	0x53, 0x5a, 0xc9, 0x94, 0xfd, 0x21, 0x4f, 0x5f, 0x55, 0xbd, 0xd7, 0xd2, 0x05, 0xdd, 0x68, 0xb0,
	0x09, 0x1d, 0x68, 0xbe, 0x06, 0x45, 0xa7, 0x22, 0x21, 0x31, 0x29, 0xd7, 0xcb, 0x20, 0x8e, 0x0f,
	0x53, 0xb6, 0xcd, 0xa6, 0x4b, 0x03, 0x4f, 0xf0, 0x74, 0x4a, 0x9d, 0xe7, 0x6c, 0x90, 0x6b, 0x11,
	0x43, 0x83, 0x51, 0xab, 0xa6, 0xc8, 0xf5, 0xfb, 0x60, 0xba, 0xdf, 0xc3, 0x9a, 0xb2, 0x97, 0x36,
	0xd5, 0xc8, 0xa3, 0xa6, 0xbb, 0xf4, 0x35, 0x95, 0x12, 0xaf, 0xc7, 0x3d, 0xad, 0x41, 0xa9, 0x58,
	0xe9, 0xef, 0xea, 0x3f, 0x38, 0x52, 0xc0, 0xe2, 0xc4, 0xb4, 0x19, 0xd9, 0xc5, 0x8c, 0xa7, 0x75,
	0xa5, 0x40, 0xe6, 0xf9, 0xbe, 0xa6, 0x5d, 0xc8, 0xa8, 0xb1, 0x52, 0x25, 0x4e, 0xca, 0x21, 0x84,
	0x7e, 0x0b, 0x4c, 0x2a, 0x5b, 0x46, 0x9f, 0xf4, 0xd2, 0x2f, 0x29, 0x3d, 0x26, 0xe4, 0xda, 0x66,
	0xb8, 0xa4, 0x2f, 0x83, 0x54, 0x68, 0x6e, 0xca, 0x44, 0xdc, 0xf0, 0x4e, 0xa9, 0xe2, 0x03, 0x14,
	0x36, 0x1b, 0xfe, 0x72, 0x48, 0x33, 0xae, 0x28, 0xc7, 0xa5, 0x4c, 0x44, 0x8d, 0xeb, 0x74, 0xe8,
	0xca, 0x26, 0xf1, 0xad, 0xf4, 0xcb, 0x0a, 0x74, 0x4c, 0xbe, 0x57, 0x7d, 0xab, 0xbf, 0xe5, 0x13,
	0x3b, 0x7d, 0xfd, 0x68, 0xab, 0x41, 0x6c, 0x7d, 0x13, 0x5c, 0x8f, 0x0f, 0x1a, 0x78, 0x1c, 0xb5,
	0xb1, 0xc9, 0x7b, 0xdc, 0x12, 0x0e, 0x4f, 0xbf, 0xa2, 0xce, 0x9a, 0x8e, 0xcf, 0x7a, 0xbc, 0x65,
	0x4e, 0x6b, 0x46, 0xec, 0x72, 0x5b, 0x8a, 0xad, 0x19, 0x72, 0xe9, 0x15, 0x70, 0xad, 0x4d, 0xd9,
	0x36, 0xb1, 0x6d, 0xec, 0xf5, 0xa1, 0xd2, 0xdf, 0x02, 0x95, 0xea, 0xb3, 0xc4, 0x30, 0x0f, 0xc0,
	0x15, 0x8f, 0xca, 0xfe, 0xc9, 0x44, 0xdc, 0x54, 0xd5, 0xf7, 0xc6, 0x39, 0x39, 0x70, 0xd8, 0x98,
	0xf0, 0xa8, 0xea, 0x31, 0xb6, 0x38, 0x66, 0xfa, 0x8f, 0xc0, 0xc4, 0x20, 0xe7, 0x4d, 0xc5, 0xf9,
	0xc1, 0x85, 0x67, 0x85, 0x33, 0x86, 0x8f, 0xb5, 0x61, 0x63, 0x9c, 0xf5, 0xf1, 0x3f, 0x04, 0x57,
	0x8f, 0x94, 0x53, 0x73, 0x7c, 0xfa, 0xb5, 0x73, 0xb4, 0x4b, 0x18, 0x93, 0x91, 0x76, 0xaa, 0xb5,
	0xd1, 0xff, 0x00, 0x4c, 0x1e, 0xe3, 0x9d, 0xf9, 0x0e, 0xf4, 0x4b, 0x18, 0x80, 0x1d, 0x49, 0xd8,
	0x00, 0xd7, 0x3d, 0x6a, 0x0e, 0x0c, 0xb7, 0x4e, 0x28, 0x8a, 0xa7, 0xe1, 0x39, 0x7a, 0x8e, 0x18,
	0x53, 0x1e, 0x6d, 0x0e, 0x30, 0x85, 0x2d, 0xbc, 0x4e, 0xc1, 0x4b, 0x67, 0x41, 0xdd, 0xfa, 0x0e,
	0xd4, 0x1e, 0x31, 0x74, 0x7e, 0x5a, 0xe0, 0x3d, 0x30, 0xe9, 0x51, 0xb3, 0xcd, 0x63, 0x49, 0x6f,
	0x9c, 0xa3, 0xf4, 0xa8, 0x01, 0x3c, 0xba, 0xc2, 0x23, 0xce, 0x1e, 0x98, 0x8e, 0xd9, 0x4c, 0x1e,
	0xc9, 0x8b, 0x7f, 0xbf, 0x4b, 0xbf, 0xf9, 0x1d, 0x28, 0x3c, 0x6a, 0x5c, 0x8f, 0x3a, 0xd4, 0x93,
	0x1d, 0xf9, 0x43, 0xf0, 0x92, 0xb4, 0x39, 0x36, 0x1d, 0xd9, 0xaf, 0xf7, 0x85, 0xbe, 0xf5, 0x62,
	0xdd, 0x8b, 0x09, 0x19, 0x10, 0x6b, 0x63, 0x46, 0xca, 0xa3, 0x4d, 0xac, 0xda, 0xfc, 0x18, 0x8c,
	0x83, 0xd4, 0x29, 0xa4, 0xb7, 0x15, 0xd2, 0x87, 0x17, 0x54, 0xff, 0xec, 0xb9, 0xa1, 0x98, 0x94,
	0x22, 0x7f, 0x19, 0x8a, 0xbd, 0xc2, 0x8f, 0x0b, 0x5d, 0x01, 0xa9, 0xd0, 0xad, 0x8f, 0x66, 0x96,
	0xf4, 0xdc, 0xb7, 0xaa, 0x9f, 0x34, 0xae, 0x28, 0xef, 0xee, 0x8f, 0x2e, 0x3a, 0x07, 0x97, 0x8f,
	0x83, 0xbc, 0xa3, 0x40, 0x8a, 0x17, 0xd4, 0xfc, 0x9c, 0x51, 0x6e, 0x40, 0xfd, 0xa4, 0x31, 0xc9,
	0x06, 0x08, 0xdf, 0xff, 0x1b, 0xed, 0xe7, 0xfb, 0xda, 0x5f, 0x6b, 0xe0, 0x1d, 0x70, 0xa3, 0xdf,
	0xd9, 0xaa, 0x4f, 0x3c, 0xc7, 0x9a, 0x95, 0xc9, 0xc5, 0x6c, 0x3e, 0xbb, 0x94, 0x5d, 0xce, 0xde,
	0xcd, 0x2e, 0xbe, 0x0b, 0xde, 0x06, 0x7a, 0x54, 0xe9, 0x14, 0x65, 0x54, 0x35, 0xae, 0x2d, 0x2e,
	0x65, 0x17, 0x97, 0xb3, 0x8b, 0x77, 0xb2, 0x8b, 0xef, 0x65, 0x17, 0xef, 0x66, 0x17, 0xef, 0x81,
	0xef, 0x81, 0xeb, 0xb2, 0x36, 0xc5, 0xbf, 0xf8, 0x48, 0xe2, 0x30, 0x51, 0xe9, 0xd7, 0x16, 0xef,
	0x67, 0xf3, 0xef, 0x66, 0xf3, 0x8b, 0xd9, 0x7c, 0x3e, 0x9b, 0x5f, 0xca, 0xe6, 0x97, 0xc1, 0x6d,
	0x90, 0xea, 0xff, 0xc6, 0x53, 0xa2, 0x9e, 0xc0, 0x4f, 0x84, 0x7e, 0x2d, 0x7f, 0x27, 0x9b, 0xbf,
	0x97, 0x5d, 0x5a, 0xcc, 0x2e, 0x2d, 0x67, 0x97, 0xee, 0x66, 0x97, 0xdf, 0x2d, 0xe6, 0xc0, 0xcd,
	0xb3, 0x7a, 0x63, 0xd3, 0xea, 0x52, 0x62, 0x61, 0xfd, 0xea, 0xf3, 0x7d, 0x6d, 0xe4, 0x60, 0x5f,
	0x4b, 0x1c, 0xee, 0x6b, 0xc3, 0x77, 0xb2, 0xef, 0x49, 0xfa, 0xb3, 0x7a, 0xd1, 0x41, 0xfa, 0xe4,
	0xc1, 0xbe, 0x36, 0x26, 0xe9, 0xef, 0x65, 0xef, 0x17, 0xe7, 0x41, 0xfa, 0x54, 0x07, 0x18, 0x13,
	0x5f, 0x7b, 0xbe, 0xaf, 0x4d, 0x1c, 0xec, 0x6b, 0xe0, 0x70, 0x5f, 0x1b, 0x59, 0x5c, 0xcc, 0x2e,
	0xe6, 0x8b, 0x10, 0x4c, 0xc8, 0x64, 0x39, 0x48, 0x71, 0xe3, 0x60, 0x5f, 0x9b, 0x96, 0x14, 0xf9,
	0xf7, 0xb2, 0xf9, 0xbb, 0xc5, 0x5b, 0x60, 0x32, 0x0c, 0xac, 0x01, 0x92, 0xd7, 0x0e, 0xf6, 0xb5,
	0x57, 0x15, 0xc9, 0xfd, 0xec, 0x92, 0x3c, 0xd3, 0xf4, 0xe9, 0x4c, 0x31, 0x48, 0x0f, 0x0f, 0xf6,
	0xb5, 0xd7, 0x25, 0xfd, 0x52, 0x3e, 0xbb, 0xb4, 0x54, 0x7c, 0x13, 0x5c, 0xed, 0x87, 0xeb, 0x00,
	0xd5, 0x1b, 0x07, 0xfb, 0xda, 0xac, 0xa2, 0xba, 0x93, 0x5d, 0x7a, 0xaf, 0x98, 0x01, 0x57, 0xfb,
	0xc1, 0x10, 0x51, 0xbd, 0xfc, 0x7c, 0x5f, 0x7b, 0xeb, 0xcb, 0x7d, 0x4d, 0x3b, 0xd8, 0xd7, 0x6e,
	0x2b, 0xca, 0x7b, 0xd9, 0x25, 0x79, 0xe6, 0xa9, 0xe3, 0x23, 0xf7, 0x00, 0xf9, 0x5c, 0x44, 0x9e,
	0x91, 0xe4, 0xcb, 0x8b, 0xd9, 0xe5, 0xfc, 0x7a, 0x22, 0x99, 0x48, 0x8d, 0xac, 0x27, 0x92, 0x63,
	0xa9, 0xe4, 0x7a, 0x22, 0x09, 0x52, 0x13, 0xeb, 0x89, 0xe4, 0x74, 0xea, 0xc6, 0x7a, 0x22, 0xf9,
	0x6a, 0xea, 0xb5, 0xf5, 0x44, 0xf2, 0xf5, 0x14, 0x5c, 0x4f, 0x24, 0x67, 0x53, 0x6f, 0xac, 0x27,
	0x92, 0xb7, 0x53, 0x6f, 0xad, 0x27, 0x92, 0x99, 0xd4, 0xdc, 0xec, 0x97, 0x43, 0xe0, 0xca, 0xaa,
	0x43, 0xb7, 0x91, 0xd3, 0x1f, 0xf1, 0x2c, 0x90, 0xf4, 0xb9, 0x6f, 0xca, 0x51, 0x55, 0x0d, 0x6c,
	0x13, 0xf9, 0x8f, 0x2e, 0xe8, 0xec, 0x2f, 0x1c, 0x1b, 0x8b, 0x89, 0x03, 0xe9, 0xe6, 0x97, 0x8c,
	0x31, 0x9f, 0xfb, 0x72, 0x51, 0xcf, 0x83, 0x44, 0x0f, 0xb9, 0x4e, 0x34, 0xc8, 0xbe, 0x2a, 0x23,
	0xe1, 0xbf, 0xf7, 0xb5, 0x44, 0xd4, 0x11, 0xa4, 0x0f, 0x16, 0xa2, 0xa7, 0x9f, 0x28, 0x36, 0x45,
	0xab, 0x97, 0xc0, 0x95, 0x0e, 0xf6, 0xb0, 0x0c, 0x22, 0xdb, 0x54, 0xdc, 0xdf, 0x8c, 0x29, 0xf6,
	0x9b, 0x5f, 0xfd, 0x58, 0xc5, 0xd1, 0x59, 0xdc, 0xc6, 0xe5, 0x3e, 0xcf, 0xc7, 0xc8, 0x75, 0xde,
	0x9f, 0xfb, 0xf9, 0xbe, 0x76, 0x1b, 0xbc, 0x01, 0x66, 0x1a, 0xd4, 0x3e, 0xfa, 0xf9, 0x32, 0x54,
	0x17, 0x36, 0x10, 0x43, 0x2e, 0x16, 0xb2, 0xb3, 0xd1, 0x16, 0x8b, 0x6f, 0x83, 0xa9, 0xb0, 0x6b,
	0x37, 0x5d, 0x2c, 0xba, 0xd4, 0x1e, 0xf4, 0xce, 0x21, 0x79, 0x20, 0xe9, 0x9d, 0xf9, 0xec, 0xd2,
	0x7a, 0x22, 0xa9, 0xa5, 0x86, 0x66, 0x0f, 0x34, 0x70, 0x25, 0xfc, 0x28, 0xdd, 0x37, 0xe5, 0x0f,
	0xbf, 0x7b, 0x53, 0x0e, 0x1a, 0x71, 0x6a, 0xd0, 0x88, 0xb1, 0x99, 0xde, 0xbf, 0xf6, 0x4f, 0xdf,
	0x3f, 0x71, 0xa5, 0xc5, 0x77, 0x5f, 0x70, 0x92, 0xf4, 0x1f, 0xff, 0x8f, 0x76, 0xe6, 0x4e, 0x74,
	0xa4, 0x7f, 0xd1, 0xc0, 0x55, 0x03, 0xfb, 0x0e, 0xb2, 0x7e, 0x77, 0xce, 0xf4, 0xcf, 0x1a, 0x98,
	0x58, 0xc5, 0xe2, 0x77, 0xe5, 0x3c, 0xc5, 0x3f, 0xd7, 0x0e, 0xbe, 0x9e, 0xb9, 0xf4, 0xd5, 0xd7,
	0x33, 0x97, 0x7e, 0xf5, 0xf5, 0x8c, 0xf6, 0xf4, 0x70, 0x46, 0xfb, 0xd9, 0xe1, 0x8c, 0xf6, 0xe5,
	0xe1, 0x8c, 0x76, 0x70, 0x38, 0xa3, 0x7d, 0x75, 0x38, 0xa3, 0xfd, 0xfb, 0xe1, 0x8c, 0xf6, 0xcb,
	0xc3, 0x99, 0x4b, 0xbf, 0x3a, 0x9c, 0xd1, 0x7e, 0xf2, 0x8b, 0x99, 0x4b, 0xcf, 0x7f, 0x31, 0xa3,
	0x7d, 0xf2, 0x7b, 0x1d, 0xea, 0xef, 0x74, 0x72, 0xbb, 0xd4, 0x11, 0x98, 0x31, 0x94, 0x0b, 0xf8,
	0x82, 0x7a, 0x68, 0x53, 0xe6, 0xce, 0x47, 0x1f, 0xb3, 0xd8, 0x7c, 0xbc, 0xbd, 0xe0, 0x6f, 0x77,
	0xe8, 0x02, 0x7e, 0x22, 0xa2, 0xbf, 0x12, 0x9d, 0xff, 0x87, 0xa9, 0xed, 0x51, 0xf5, 0xef, 0xa2,
	0xa5, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x5f, 0xbc, 0xaf, 0xba, 0x60, 0x25, 0x00, 0x00,
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/certified_hardware/types.proto

package certified_hardware

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/gogo/protobuf/types"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema_usb_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/usb_policy"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

import strconv "strconv"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Hardware Device Types
//
// x-displayName: "Device Types"
// Different type of devices supported
type HardwareDeviceType int32

const (
	// x-displayName: "Invalid"
	// Invalid device or device thats not supported
	HARDWARE_DEVICE_INVALID HardwareDeviceType = 0
	// x-displayName: "Ethernet"
	// Ethernet device
	HARDWARE_DEVICE_ETHERNET HardwareDeviceType = 1
	// x-displayName: "Virtio"
	// VIRTIO device
	HARDWARE_DEVICE_VIRTIO HardwareDeviceType = 2
	// x-displayName: "Tuntap"
	// TUNTAP device
	HARDWARE_DEVICE_TUNTAP HardwareDeviceType = 3
	// x-displayName: "Bond (Link Aggregation)"
	// LACP based bond interface
	HARDWARE_DEVICE_BOND HardwareDeviceType = 4
	// x-displayName: "External iSCSI Storage"
	// External iSCSI devices supported
	HARDWARE_DEVICE_EXTERNAL_ISCSI_STORTAGE HardwareDeviceType = 5
	// x-displayName: "Nvidia GPU device"
	// Nvidia GPU device used for machine learning
	HARDWARE_DEVICE_NVIDIA_GPU HardwareDeviceType = 6
)

var HardwareDeviceType_name = map[int32]string{
	0: "HARDWARE_DEVICE_INVALID",
	1: "HARDWARE_DEVICE_ETHERNET",
	2: "HARDWARE_DEVICE_VIRTIO",
	3: "HARDWARE_DEVICE_TUNTAP",
	4: "HARDWARE_DEVICE_BOND",
	5: "HARDWARE_DEVICE_EXTERNAL_ISCSI_STORTAGE",
	6: "HARDWARE_DEVICE_NVIDIA_GPU",
}
var HardwareDeviceType_value = map[string]int32{
	"HARDWARE_DEVICE_INVALID":                 0,
	"HARDWARE_DEVICE_ETHERNET":                1,
	"HARDWARE_DEVICE_VIRTIO":                  2,
	"HARDWARE_DEVICE_TUNTAP":                  3,
	"HARDWARE_DEVICE_BOND":                    4,
	"HARDWARE_DEVICE_EXTERNAL_ISCSI_STORTAGE": 5,
	"HARDWARE_DEVICE_NVIDIA_GPU":              6,
}

func (HardwareDeviceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// Hardware Device Instance Use
//
// x-displayName: "Device Use"
// Defines how the device instance must be used
type HardwareDeviceInstanceUseType int32

const (
	// x-displayName: "Device Regular"
	// If the device is owned by volterra software, it is available for users to configure as required
	HARDWARE_DEVICE_USE_REGULAR HardwareDeviceInstanceUseType = 0
	// x-displayName: "Device Internal"
	// Device reserved for internal use by volterra Node
	HARDWARE_DEVICE_USE_INTERNAL HardwareDeviceInstanceUseType = 1
	// x-displayName: "Network Device Regular"
	// If the Network device is owned by VER, it is available for users to configure as required
	HARDWARE_NETWORK_DEVICE_USE_REGULAR HardwareDeviceInstanceUseType = 2
	// x-displayName: "Network Device Internal"
	// Networking device available for internal use by VER
	HARDWARE_NETWORK_DEVICE_USE_INTERNAL HardwareDeviceInstanceUseType = 3
	// x-displayName: "Network Device Management"
	// Networking device to be used for Management access
	HARDWARE_NETWORK_DEVICE_USE_MANAGEMENT HardwareDeviceInstanceUseType = 4
	// x-displayName: "Network Device Outside"
	// Networking device to be used as member of outside network as part of bootstrap
	HARDWARE_NETWORK_DEVICE_USE_OUTSIDE HardwareDeviceInstanceUseType = 5
	// x-displayName: "Network Device Inside"
	// Networking device to be used as member of inside network as part of bootstrap
	HARDWARE_NETWORK_DEVICE_USE_INSIDE HardwareDeviceInstanceUseType = 6
	// x-displayName: "Network Device Outside Lag"
	// LAG device to be used as member of outside network
	HARDWARE_NETWORK_DEVICE_USE_OUTSIDE_LAG HardwareDeviceInstanceUseType = 7
	// x-displayName: "Network Device Inside Lag"
	// LAG device to be used as member of inside network
	HARDWARE_NETWORK_DEVICE_USE_INSIDE_LAG HardwareDeviceInstanceUseType = 8
	// x-displayName: "Network Device Lag Member"
	// Network device to be used as member of another LAG device
	HARDWARE_NETWORK_DEVICE_USE_LAG_MEMBER HardwareDeviceInstanceUseType = 9
	// x-displayName: "Network Device Use Storage"
	// Network device to be used exclusive for storage networks
	HARDWARE_NETWORK_DEVICE_USE_STORAGE HardwareDeviceInstanceUseType = 10
	// x-displayName: "Network Device Fallback Management"
	// Networking device to be used for fallback Management access
	HARDWARE_NETWORK_DEVICE_USE_FALLBACK_MANAGEMENT HardwareDeviceInstanceUseType = 11
)

var HardwareDeviceInstanceUseType_name = map[int32]string{
	0:  "HARDWARE_DEVICE_USE_REGULAR",
	1:  "HARDWARE_DEVICE_USE_INTERNAL",
	2:  "HARDWARE_NETWORK_DEVICE_USE_REGULAR",
	3:  "HARDWARE_NETWORK_DEVICE_USE_INTERNAL",
	4:  "HARDWARE_NETWORK_DEVICE_USE_MANAGEMENT",
	5:  "HARDWARE_NETWORK_DEVICE_USE_OUTSIDE",
	6:  "HARDWARE_NETWORK_DEVICE_USE_INSIDE",
	7:  "HARDWARE_NETWORK_DEVICE_USE_OUTSIDE_LAG",
	8:  "HARDWARE_NETWORK_DEVICE_USE_INSIDE_LAG",
	9:  "HARDWARE_NETWORK_DEVICE_USE_LAG_MEMBER",
	10: "HARDWARE_NETWORK_DEVICE_USE_STORAGE",
	11: "HARDWARE_NETWORK_DEVICE_USE_FALLBACK_MANAGEMENT",
}
var HardwareDeviceInstanceUseType_value = map[string]int32{
	"HARDWARE_DEVICE_USE_REGULAR":                     0,
	"HARDWARE_DEVICE_USE_INTERNAL":                    1,
	"HARDWARE_NETWORK_DEVICE_USE_REGULAR":             2,
	"HARDWARE_NETWORK_DEVICE_USE_INTERNAL":            3,
	"HARDWARE_NETWORK_DEVICE_USE_MANAGEMENT":          4,
	"HARDWARE_NETWORK_DEVICE_USE_OUTSIDE":             5,
	"HARDWARE_NETWORK_DEVICE_USE_INSIDE":              6,
	"HARDWARE_NETWORK_DEVICE_USE_OUTSIDE_LAG":         7,
	"HARDWARE_NETWORK_DEVICE_USE_INSIDE_LAG":          8,
	"HARDWARE_NETWORK_DEVICE_USE_LAG_MEMBER":          9,
	"HARDWARE_NETWORK_DEVICE_USE_STORAGE":             10,
	"HARDWARE_NETWORK_DEVICE_USE_FALLBACK_MANAGEMENT": 11,
}

func (HardwareDeviceInstanceUseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{1}
}

// Certified Hardware Types
//
// x-displayName: "Certified Hardware Types"
// Different type of certified HW for billing rate
type HardwareType int32

const (
	// x-displayName: "Billed as VoltMesh"
	VOLTMESH HardwareType = 0
	// x-displayName: "Billed as VoltStack Combo"
	VOLTSTACK_COMBO HardwareType = 1
	// x-displayName: "Not Billed by Volterra"
	CLOUD_MARKET_PLACE HardwareType = 2
)

var HardwareType_name = map[int32]string{
	0: "VOLTMESH",
	1: "VOLTSTACK_COMBO",
	2: "CLOUD_MARKET_PLACE",
}
var HardwareType_value = map[string]int32{
	"VOLTMESH":           0,
	"VOLTSTACK_COMBO":    1,
	"CLOUD_MARKET_PLACE": 2,
}

func (HardwareType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// Memory Page Size
//
// x-displayName: "Memory Page Size"
// Memory for packets buffers etc are allocated in blocks of pages. Size of each memory page is defined here.
type MemPageSize int32

const (
	// x-displayName: "Invalid"
	// Invalid Page size
	HARDWARE_MEM_PAGE_SIZE_INVALID MemPageSize = 0
	// x-displayName: "4 KBytes"
	// Page size of 4KB
	HARDWARE_MEM_PAGE_SIZE_4KB MemPageSize = 1
	// x-displayName: "4 MBytes"
	// Page size of 2MB
	HARDWARE_MEM_PAGE_SIZE_2MB MemPageSize = 2
	// x-displayName: "1 GBytes"
	// Page size of 1GB
	HARDWARE_MEM_PAGE_SIZE_1GB MemPageSize = 3
)

var MemPageSize_name = map[int32]string{
	0: "HARDWARE_MEM_PAGE_SIZE_INVALID",
	1: "HARDWARE_MEM_PAGE_SIZE_4KB",
	2: "HARDWARE_MEM_PAGE_SIZE_2MB",
	3: "HARDWARE_MEM_PAGE_SIZE_1GB",
}
var MemPageSize_value = map[string]int32{
	"HARDWARE_MEM_PAGE_SIZE_INVALID": 0,
	"HARDWARE_MEM_PAGE_SIZE_4KB":     1,
	"HARDWARE_MEM_PAGE_SIZE_2MB":     2,
	"HARDWARE_MEM_PAGE_SIZE_1GB":     3,
}

func (MemPageSize) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// Device Type
//
// x-displayName: "Device"
// Different type of devices supported by Certified Hardware
type DeviceType struct {
	// Type
	//
	// x-displayName: "Type"
	// Defines type of device supported in certified hardware
	Type HardwareDeviceType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.certified_hardware.HardwareDeviceType" json:"type,omitempty"`
	// Use
	//
	// x-displayName: "Use"
	// Defines how the device is used in the certified hardware
	Use HardwareDeviceInstanceUseType `protobuf:"varint,2,opt,name=use,proto3,enum=ves.io.schema.certified_hardware.HardwareDeviceInstanceUseType" json:"use,omitempty"`
	// Name
	//
	// x-displayName: "device"
	// x-example: "eth"
	// Name of the device
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Start unit number for device
	//
	// x-displayName: "Start Unit"
	// x-example: "0"
	// first unit number of the device supported in this certified hardware
	MinUnit int32 `protobuf:"varint,4,opt,name=min_unit,json=minUnit,proto3" json:"min_unit,omitempty"`
	// End unit number for device
	//
	// x-displayName: "End Unit"
	// x-example: "7"
	// last unit number of the device supported in this certified hardware
	MaxUnit int32 `protobuf:"varint,5,opt,name=max_unit,json=maxUnit,proto3" json:"max_unit,omitempty"`
	// Device List
	//
	// x-displayName: "Device List"
	// In case of logical boot strap devices like LACP Link aggregation or RAID
	DeviceList []string `protobuf:"bytes,6,rep,name=device_list,json=deviceList" json:"device_list,omitempty"`
}

func (m *DeviceType) Reset()                    { *m = DeviceType{} }
func (*DeviceType) ProtoMessage()               {}
func (*DeviceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *DeviceType) GetType() HardwareDeviceType {
	if m != nil {
		return m.Type
	}
	return HARDWARE_DEVICE_INVALID
}

func (m *DeviceType) GetUse() HardwareDeviceInstanceUseType {
	if m != nil {
		return m.Use
	}
	return HARDWARE_DEVICE_USE_REGULAR
}

func (m *DeviceType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceType) GetMinUnit() int32 {
	if m != nil {
		return m.MinUnit
	}
	return 0
}

func (m *DeviceType) GetMaxUnit() int32 {
	if m != nil {
		return m.MaxUnit
	}
	return 0
}

func (m *DeviceType) GetDeviceList() []string {
	if m != nil {
		return m.DeviceList
	}
	return nil
}

// Vendor and Model
//
// x-displayName: "Vendor and Model"
// Gives vendor and model for the hardware device
type HardwareVendorModel struct {
	// Vendor
	//
	// x-displayName: "Vendor"
	// Vendor could be Volterra, Dell, Cloud provider like AWS or Azure
	Vendor string `protobuf:"bytes,1,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// Model
	//
	// x-displayName: "Model"
	// Hw Model or instance type from cloud provider like number of interfaces, vCPUs, memory
	Model string `protobuf:"bytes,2,opt,name=model,proto3" json:"model,omitempty"`
}

func (m *HardwareVendorModel) Reset()                    { *m = HardwareVendorModel{} }
func (*HardwareVendorModel) ProtoMessage()               {}
func (*HardwareVendorModel) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *HardwareVendorModel) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *HardwareVendorModel) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

// Image Type
//
// x-displayName: "Image Type"
// Describes the image to be used for this certified hardware
type ImageType struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "ami-0f99d090261d2acd5"
	// Image name to use for this hardware
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Provider
	//
	// x-displayName: "Provider"
	// x-example: "Volterra"
	// Image provider Volterra, Cloud provider like AWS or Azure
	Provider string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	// CloudProvider
	//
	// x-displayName: "Cloud Provider"
	// Cloud provider image specific information like AWS or Azure
	//
	// Types that are valid to be assigned to CloudProvider:
	//	*ImageType_Azure
	//	*ImageType_Aws
	//	*ImageType_Gcp
	CloudProvider isImageType_CloudProvider `protobuf_oneof:"cloud_provider"`
}

func (m *ImageType) Reset()                    { *m = ImageType{} }
func (*ImageType) ProtoMessage()               {}
func (*ImageType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isImageType_CloudProvider interface {
	isImageType_CloudProvider()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ImageType_Azure struct {
	Azure *Azure `protobuf:"bytes,3,opt,name=azure,oneof"`
}
type ImageType_Aws struct {
	Aws *Aws `protobuf:"bytes,4,opt,name=aws,oneof"`
}
type ImageType_Gcp struct {
	Gcp *Gcp `protobuf:"bytes,5,opt,name=gcp,oneof"`
}

func (*ImageType_Azure) isImageType_CloudProvider() {}
func (*ImageType_Aws) isImageType_CloudProvider()   {}
func (*ImageType_Gcp) isImageType_CloudProvider()   {}

func (m *ImageType) GetCloudProvider() isImageType_CloudProvider {
	if m != nil {
		return m.CloudProvider
	}
	return nil
}

func (m *ImageType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ImageType) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *ImageType) GetAzure() *Azure {
	if x, ok := m.GetCloudProvider().(*ImageType_Azure); ok {
		return x.Azure
	}
	return nil
}

func (m *ImageType) GetAws() *Aws {
	if x, ok := m.GetCloudProvider().(*ImageType_Aws); ok {
		return x.Aws
	}
	return nil
}

func (m *ImageType) GetGcp() *Gcp {
	if x, ok := m.GetCloudProvider().(*ImageType_Gcp); ok {
		return x.Gcp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ImageType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ImageType_OneofMarshaler, _ImageType_OneofUnmarshaler, _ImageType_OneofSizer, []interface{}{
		(*ImageType_Azure)(nil),
		(*ImageType_Aws)(nil),
		(*ImageType_Gcp)(nil),
	}
}

func _ImageType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ImageType)
	// cloud_provider
	switch x := m.CloudProvider.(type) {
	case *ImageType_Azure:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Azure); err != nil {
			return err
		}
	case *ImageType_Aws:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Aws); err != nil {
			return err
		}
	case *ImageType_Gcp:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Gcp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ImageType.CloudProvider has unexpected type %T", x)
	}
	return nil
}

func _ImageType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ImageType)
	switch tag {
	case 3: // cloud_provider.azure
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Azure)
		err := b.DecodeMessage(msg)
		m.CloudProvider = &ImageType_Azure{msg}
		return true, err
	case 4: // cloud_provider.aws
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Aws)
		err := b.DecodeMessage(msg)
		m.CloudProvider = &ImageType_Aws{msg}
		return true, err
	case 5: // cloud_provider.gcp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Gcp)
		err := b.DecodeMessage(msg)
		m.CloudProvider = &ImageType_Gcp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ImageType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ImageType)
	// cloud_provider
	switch x := m.CloudProvider.(type) {
	case *ImageType_Azure:
		s := proto.Size(x.Azure)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ImageType_Aws:
		s := proto.Size(x.Aws)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ImageType_Gcp:
		s := proto.Size(x.Gcp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Azure
//
// x-displayName: "Azure"
// Azure specific information
type Azure struct {
	// Types that are valid to be assigned to Image:
	//	*Azure_Marketplace
	//	*Azure_ImageId
	Image isAzure_Image `protobuf_oneof:"image"`
}

func (m *Azure) Reset()                    { *m = Azure{} }
func (*Azure) ProtoMessage()               {}
func (*Azure) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

type isAzure_Image interface {
	isAzure_Image()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Azure_Marketplace struct {
	Marketplace *Marketplace `protobuf:"bytes,1,opt,name=marketplace,oneof"`
}
type Azure_ImageId struct {
	ImageId *AzureImage `protobuf:"bytes,2,opt,name=image_id,json=imageId,oneof"`
}

func (*Azure_Marketplace) isAzure_Image() {}
func (*Azure_ImageId) isAzure_Image()     {}

func (m *Azure) GetImage() isAzure_Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Azure) GetMarketplace() *Marketplace {
	if x, ok := m.GetImage().(*Azure_Marketplace); ok {
		return x.Marketplace
	}
	return nil
}

func (m *Azure) GetImageId() *AzureImage {
	if x, ok := m.GetImage().(*Azure_ImageId); ok {
		return x.ImageId
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Azure) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Azure_OneofMarshaler, _Azure_OneofUnmarshaler, _Azure_OneofSizer, []interface{}{
		(*Azure_Marketplace)(nil),
		(*Azure_ImageId)(nil),
	}
}

func _Azure_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Azure)
	// image
	switch x := m.Image.(type) {
	case *Azure_Marketplace:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Marketplace); err != nil {
			return err
		}
	case *Azure_ImageId:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImageId); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Azure.Image has unexpected type %T", x)
	}
	return nil
}

func _Azure_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Azure)
	switch tag {
	case 1: // image.marketplace
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Marketplace)
		err := b.DecodeMessage(msg)
		m.Image = &Azure_Marketplace{msg}
		return true, err
	case 2: // image.image_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AzureImage)
		err := b.DecodeMessage(msg)
		m.Image = &Azure_ImageId{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Azure_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Azure)
	// image
	switch x := m.Image.(type) {
	case *Azure_Marketplace:
		s := proto.Size(x.Marketplace)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Azure_ImageId:
		s := proto.Size(x.ImageId)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AzureImage struct {
	// ImageId
	//
	// x-displayName: "Azure image id info"
	// Azure image id
	ImageId string `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
}

func (m *AzureImage) Reset()                    { *m = AzureImage{} }
func (*AzureImage) ProtoMessage()               {}
func (*AzureImage) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *AzureImage) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

// Marketplace
//
// x-displayName: "Azure Marketplace image info"
// Azure Marketplace image information
type Marketplace struct {
	// Offer
	//
	// x-displayName: "Azure Marketplace offer"
	// Azure Marketplace offer
	Offer string `protobuf:"bytes,1,opt,name=offer,proto3" json:"offer,omitempty"`
	// SKU
	//
	// x-displayName: "Azure Marketplace SKU"
	// Azure Marketplace SKU
	Sku string `protobuf:"bytes,2,opt,name=sku,proto3" json:"sku,omitempty"`
	// Version
	//
	// x-displayName: "Azure Marketplace Version"
	// Azure Marketplace Version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Name
	//
	// x-displayName: "Azure Marketplace Name"
	// Azure Marketplace Name
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Publisher
	//
	// x-displayName: "Azure Marketplace Publisher"
	// Azure Marketplace Publisher
	Publisher string `protobuf:"bytes,5,opt,name=publisher,proto3" json:"publisher,omitempty"`
}

func (m *Marketplace) Reset()                    { *m = Marketplace{} }
func (*Marketplace) ProtoMessage()               {}
func (*Marketplace) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *Marketplace) GetOffer() string {
	if m != nil {
		return m.Offer
	}
	return ""
}

func (m *Marketplace) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *Marketplace) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Marketplace) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Marketplace) GetPublisher() string {
	if m != nil {
		return m.Publisher
	}
	return ""
}

// AWS
//
// x-displayName: "AWS"
// AWS specific information
type Aws struct {
	// Types that are valid to be assigned to Image:
	//	*Aws_ImageId
	Image isAws_Image `protobuf_oneof:"image"`
}

func (m *Aws) Reset()                    { *m = Aws{} }
func (*Aws) ProtoMessage()               {}
func (*Aws) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

type isAws_Image interface {
	isAws_Image()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Aws_ImageId struct {
	ImageId *AwsImage `protobuf:"bytes,1,opt,name=image_id,json=imageId,oneof"`
}

func (*Aws_ImageId) isAws_Image() {}

func (m *Aws) GetImage() isAws_Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Aws) GetImageId() *AwsImage {
	if x, ok := m.GetImage().(*Aws_ImageId); ok {
		return x.ImageId
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Aws) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Aws_OneofMarshaler, _Aws_OneofUnmarshaler, _Aws_OneofSizer, []interface{}{
		(*Aws_ImageId)(nil),
	}
}

func _Aws_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Aws)
	// image
	switch x := m.Image.(type) {
	case *Aws_ImageId:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImageId); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Aws.Image has unexpected type %T", x)
	}
	return nil
}

func _Aws_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Aws)
	switch tag {
	case 1: // image.image_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AwsImage)
		err := b.DecodeMessage(msg)
		m.Image = &Aws_ImageId{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Aws_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Aws)
	// image
	switch x := m.Image.(type) {
	case *Aws_ImageId:
		s := proto.Size(x.ImageId)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AwsImage struct {
	// ImageId
	//
	// x-displayName: "AWS ami image name"
	// AWS ami image
	ImageId string `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	// Region
	//
	// x-displayName: "AWS ami image region"
	// AWS ami image region
	Region string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
}

func (m *AwsImage) Reset()                    { *m = AwsImage{} }
func (*AwsImage) ProtoMessage()               {}
func (*AwsImage) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *AwsImage) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

func (m *AwsImage) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

// GCP
//
// x-displayName: "GCP"
// GCP specific information
type Gcp struct {
	// Types that are valid to be assigned to Image:
	//	*Gcp_ImageId
	Image isGcp_Image `protobuf_oneof:"image"`
}

func (m *Gcp) Reset()                    { *m = Gcp{} }
func (*Gcp) ProtoMessage()               {}
func (*Gcp) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

type isGcp_Image interface {
	isGcp_Image()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Gcp_ImageId struct {
	ImageId *GcpImage `protobuf:"bytes,1,opt,name=image_id,json=imageId,oneof"`
}

func (*Gcp_ImageId) isGcp_Image() {}

func (m *Gcp) GetImage() isGcp_Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Gcp) GetImageId() *GcpImage {
	if x, ok := m.GetImage().(*Gcp_ImageId); ok {
		return x.ImageId
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Gcp) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Gcp_OneofMarshaler, _Gcp_OneofUnmarshaler, _Gcp_OneofSizer, []interface{}{
		(*Gcp_ImageId)(nil),
	}
}

func _Gcp_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Gcp)
	// image
	switch x := m.Image.(type) {
	case *Gcp_ImageId:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImageId); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Gcp.Image has unexpected type %T", x)
	}
	return nil
}

func _Gcp_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Gcp)
	switch tag {
	case 1: // image.image_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GcpImage)
		err := b.DecodeMessage(msg)
		m.Image = &Gcp_ImageId{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Gcp_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Gcp)
	// image
	switch x := m.Image.(type) {
	case *Gcp_ImageId:
		s := proto.Size(x.ImageId)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GcpImage struct {
	// ImageId
	//
	// x-displayName: "GCP image name"
	// GCP image
	ImageId string `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
}

func (m *GcpImage) Reset()                    { *m = GcpImage{} }
func (*GcpImage) ProtoMessage()               {}
func (*GcpImage) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *GcpImage) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

// NUMA Memory Specification
//
// x-displayName: "NUMA Memory Specification"
// Defines amount of memory (in MB) allocated for a NUMA node
type NumaMem struct {
	// Memory Size
	//
	// x-displayName: "Memory Size"
	// x-example: "1024"
	// The number of MB of instance memory to map to instance NUMA node N
	Memory int32 `protobuf:"varint,1,opt,name=memory,proto3" json:"memory,omitempty"`
	// Node
	//
	// x-displayName: "Node"
	// x-example: "1"
	// NUMA node instance with mapped memory
	Node int32 `protobuf:"varint,2,opt,name=node,proto3" json:"node,omitempty"`
}

func (m *NumaMem) Reset()                    { *m = NumaMem{} }
func (*NumaMem) ProtoMessage()               {}
func (*NumaMem) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *NumaMem) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *NumaMem) GetNode() int32 {
	if m != nil {
		return m.Node
	}
	return 0
}

// Global Specification
//
// x-displayName: "Global Specification"
// Certified Hardware Specification
type GlobalSpecType struct {
	// Vendor and Model
	//
	// x-displayName: "Vendor and Model"
	// List of supported hardware vendor and model for this certified hardware
	VendorModelList []*HardwareVendorModel `protobuf:"bytes,1,rep,name=vendor_model_list,json=vendorModelList" json:"vendor_model_list,omitempty"`
	// Devices
	//
	// x-displayName: "Devices"
	// List of supported devices in this model
	Devices []*DeviceType `protobuf:"bytes,2,rep,name=devices" json:"devices,omitempty"`
	// Image List
	//
	// x-displayName: "Image List"
	// List of image names with providers for this certified hardware, e.g. AWS ami-0f99d090261d2acd5
	ImageList []*ImageType `protobuf:"bytes,4,rep,name=image_list,json=imageList" json:"image_list,omitempty"`
	// NUMA Node Count
	//
	// x-displayName: "NUMA Node Count"
	// x-example: "2"
	// The number of host NUMA nodes used in certified hardware
	NumaNodes int32 `protobuf:"varint,5,opt,name=numa_nodes,json=numaNodes,proto3" json:"numa_nodes,omitempty"`
	// Memory Page Size
	//
	// x-displayName: "Memory Page Size"
	// An explicit page size used in certified hardware, 4KB, 2Mi, 2048, 1Gi
	MemPageSize MemPageSize `protobuf:"varint,6,opt,name=mem_page_size,json=memPageSize,proto3,enum=ves.io.schema.certified_hardware.MemPageSize" json:"mem_page_size,omitempty"`
	// Number of pages
	//
	// x-displayName: "Number of pages"
	// x-example: "2"
	// Number of pages allocated in this certified hardware for Hugepages. Each page size is defined above in 'mem_page_size'
	// Total memory reserved for Hugepages is 'mem_page_size * mem_page_number'
	MemPageNumber int32 `protobuf:"varint,7,opt,name=mem_page_number,json=memPageNumber,proto3" json:"mem_page_number,omitempty"`
	// NUMA Memory
	//
	// x-displayName: "NUMA Memory"
	// List of Numa nodes with the number of MB of instance memory to map to node instance
	// If not specified, memory is evenly divided among available NUMA nodes
	NumaMem []*NumaMem `protobuf:"bytes,8,rep,name=numa_mem,json=numaMem" json:"numa_mem,omitempty"`
	// Certified Hardware Type
	//
	// x-displayName: "Certified Hardware Type"
	// x-example: "VOLTMESH"
	// HW type defines billing rate per billing node.
	CertifiedHardwareType HardwareType `protobuf:"varint,9,opt,name=certified_hardware_type,json=certifiedHardwareType,proto3,enum=ves.io.schema.certified_hardware.HardwareType" json:"certified_hardware_type,omitempty"`
	// InternalUSBDeviceRule
	//
	// x-displayName: "Internal USB device rules"
	// List of internal USB device rules for server
	InternalUsbDeviceRule []*ves_io_schema_usb_policy.Rule `protobuf:"bytes,10,rep,name=internal_usb_device_rule,json=internalUsbDeviceRule" json:"internal_usb_device_rule,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *GlobalSpecType) GetVendorModelList() []*HardwareVendorModel {
	if m != nil {
		return m.VendorModelList
	}
	return nil
}

func (m *GlobalSpecType) GetDevices() []*DeviceType {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *GlobalSpecType) GetImageList() []*ImageType {
	if m != nil {
		return m.ImageList
	}
	return nil
}

func (m *GlobalSpecType) GetNumaNodes() int32 {
	if m != nil {
		return m.NumaNodes
	}
	return 0
}

func (m *GlobalSpecType) GetMemPageSize() MemPageSize {
	if m != nil {
		return m.MemPageSize
	}
	return HARDWARE_MEM_PAGE_SIZE_INVALID
}

func (m *GlobalSpecType) GetMemPageNumber() int32 {
	if m != nil {
		return m.MemPageNumber
	}
	return 0
}

func (m *GlobalSpecType) GetNumaMem() []*NumaMem {
	if m != nil {
		return m.NumaMem
	}
	return nil
}

func (m *GlobalSpecType) GetCertifiedHardwareType() HardwareType {
	if m != nil {
		return m.CertifiedHardwareType
	}
	return VOLTMESH
}

func (m *GlobalSpecType) GetInternalUsbDeviceRule() []*ves_io_schema_usb_policy.Rule {
	if m != nil {
		return m.InternalUsbDeviceRule
	}
	return nil
}

// Get certified hardware
//
// x-displayName: "Get Certified Hardware"
// Get Certified Hardware object
type GetSpecType struct {
	VendorModelList       []*HardwareVendorModel           `protobuf:"bytes,1,rep,name=vendor_model_list,json=vendorModelList" json:"vendor_model_list,omitempty"`
	Devices               []*DeviceType                    `protobuf:"bytes,2,rep,name=devices" json:"devices,omitempty"`
	ImageList             []*ImageType                     `protobuf:"bytes,4,rep,name=image_list,json=imageList" json:"image_list,omitempty"`
	NumaNodes             int32                            `protobuf:"varint,5,opt,name=numa_nodes,json=numaNodes,proto3" json:"numa_nodes,omitempty"`
	MemPageSize           MemPageSize                      `protobuf:"varint,6,opt,name=mem_page_size,json=memPageSize,proto3,enum=ves.io.schema.certified_hardware.MemPageSize" json:"mem_page_size,omitempty"`
	MemPageNumber         int32                            `protobuf:"varint,7,opt,name=mem_page_number,json=memPageNumber,proto3" json:"mem_page_number,omitempty"`
	NumaMem               []*NumaMem                       `protobuf:"bytes,8,rep,name=numa_mem,json=numaMem" json:"numa_mem,omitempty"`
	CertifiedHardwareType HardwareType                     `protobuf:"varint,9,opt,name=certified_hardware_type,json=certifiedHardwareType,proto3,enum=ves.io.schema.certified_hardware.HardwareType" json:"certified_hardware_type,omitempty"`
	InternalUsbDeviceRule []*ves_io_schema_usb_policy.Rule `protobuf:"bytes,10,rep,name=internal_usb_device_rule,json=internalUsbDeviceRule" json:"internal_usb_device_rule,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

func (m *GetSpecType) GetVendorModelList() []*HardwareVendorModel {
	if m != nil {
		return m.VendorModelList
	}
	return nil
}

func (m *GetSpecType) GetDevices() []*DeviceType {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *GetSpecType) GetImageList() []*ImageType {
	if m != nil {
		return m.ImageList
	}
	return nil
}

func (m *GetSpecType) GetNumaNodes() int32 {
	if m != nil {
		return m.NumaNodes
	}
	return 0
}

func (m *GetSpecType) GetMemPageSize() MemPageSize {
	if m != nil {
		return m.MemPageSize
	}
	return HARDWARE_MEM_PAGE_SIZE_INVALID
}

func (m *GetSpecType) GetMemPageNumber() int32 {
	if m != nil {
		return m.MemPageNumber
	}
	return 0
}

func (m *GetSpecType) GetNumaMem() []*NumaMem {
	if m != nil {
		return m.NumaMem
	}
	return nil
}

func (m *GetSpecType) GetCertifiedHardwareType() HardwareType {
	if m != nil {
		return m.CertifiedHardwareType
	}
	return VOLTMESH
}

func (m *GetSpecType) GetInternalUsbDeviceRule() []*ves_io_schema_usb_policy.Rule {
	if m != nil {
		return m.InternalUsbDeviceRule
	}
	return nil
}

// Certified Hardware Status
//
// x-displayName: "Status"
// Current status of Certified Hardware
type CertifiedHardwareStatus struct {
	// Latest Version
	//
	// x-displayName: "Latest Version"
	// Latest version for the certified hardware
	LatestVersion string `protobuf:"bytes,1,opt,name=latest_version,json=latestVersion,proto3" json:"latest_version,omitempty"`
}

func (m *CertifiedHardwareStatus) Reset()                    { *m = CertifiedHardwareStatus{} }
func (*CertifiedHardwareStatus) ProtoMessage()               {}
func (*CertifiedHardwareStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *CertifiedHardwareStatus) GetLatestVersion() string {
	if m != nil {
		return m.LatestVersion
	}
	return ""
}

func init() {
	proto.RegisterType((*DeviceType)(nil), "ves.io.schema.certified_hardware.DeviceType")
	golang_proto.RegisterType((*DeviceType)(nil), "ves.io.schema.certified_hardware.DeviceType")
	proto.RegisterType((*HardwareVendorModel)(nil), "ves.io.schema.certified_hardware.HardwareVendorModel")
	golang_proto.RegisterType((*HardwareVendorModel)(nil), "ves.io.schema.certified_hardware.HardwareVendorModel")
	proto.RegisterType((*ImageType)(nil), "ves.io.schema.certified_hardware.ImageType")
	golang_proto.RegisterType((*ImageType)(nil), "ves.io.schema.certified_hardware.ImageType")
	proto.RegisterType((*Azure)(nil), "ves.io.schema.certified_hardware.Azure")
	golang_proto.RegisterType((*Azure)(nil), "ves.io.schema.certified_hardware.Azure")
	proto.RegisterType((*AzureImage)(nil), "ves.io.schema.certified_hardware.AzureImage")
	golang_proto.RegisterType((*AzureImage)(nil), "ves.io.schema.certified_hardware.AzureImage")
	proto.RegisterType((*Marketplace)(nil), "ves.io.schema.certified_hardware.Marketplace")
	golang_proto.RegisterType((*Marketplace)(nil), "ves.io.schema.certified_hardware.Marketplace")
	proto.RegisterType((*Aws)(nil), "ves.io.schema.certified_hardware.Aws")
	golang_proto.RegisterType((*Aws)(nil), "ves.io.schema.certified_hardware.Aws")
	proto.RegisterType((*AwsImage)(nil), "ves.io.schema.certified_hardware.AwsImage")
	golang_proto.RegisterType((*AwsImage)(nil), "ves.io.schema.certified_hardware.AwsImage")
	proto.RegisterType((*Gcp)(nil), "ves.io.schema.certified_hardware.Gcp")
	golang_proto.RegisterType((*Gcp)(nil), "ves.io.schema.certified_hardware.Gcp")
	proto.RegisterType((*GcpImage)(nil), "ves.io.schema.certified_hardware.GcpImage")
	golang_proto.RegisterType((*GcpImage)(nil), "ves.io.schema.certified_hardware.GcpImage")
	proto.RegisterType((*NumaMem)(nil), "ves.io.schema.certified_hardware.NumaMem")
	golang_proto.RegisterType((*NumaMem)(nil), "ves.io.schema.certified_hardware.NumaMem")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.certified_hardware.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.certified_hardware.GlobalSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.certified_hardware.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.certified_hardware.GetSpecType")
	proto.RegisterType((*CertifiedHardwareStatus)(nil), "ves.io.schema.certified_hardware.CertifiedHardwareStatus")
	golang_proto.RegisterType((*CertifiedHardwareStatus)(nil), "ves.io.schema.certified_hardware.CertifiedHardwareStatus")
	proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareDeviceType", HardwareDeviceType_name, HardwareDeviceType_value)
	golang_proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareDeviceType", HardwareDeviceType_name, HardwareDeviceType_value)
	proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareDeviceInstanceUseType", HardwareDeviceInstanceUseType_name, HardwareDeviceInstanceUseType_value)
	golang_proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareDeviceInstanceUseType", HardwareDeviceInstanceUseType_name, HardwareDeviceInstanceUseType_value)
	proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareType", HardwareType_name, HardwareType_value)
	golang_proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareType", HardwareType_name, HardwareType_value)
	proto.RegisterEnum("ves.io.schema.certified_hardware.MemPageSize", MemPageSize_name, MemPageSize_value)
	golang_proto.RegisterEnum("ves.io.schema.certified_hardware.MemPageSize", MemPageSize_name, MemPageSize_value)
}
func (x HardwareDeviceType) String() string {
	s, ok := HardwareDeviceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HardwareDeviceInstanceUseType) String() string {
	s, ok := HardwareDeviceInstanceUseType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HardwareType) String() string {
	s, ok := HardwareType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MemPageSize) String() string {
	s, ok := MemPageSize_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *DeviceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceType)
	if !ok {
		that2, ok := that.(DeviceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Use != that1.Use {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.MinUnit != that1.MinUnit {
		return false
	}
	if this.MaxUnit != that1.MaxUnit {
		return false
	}
	if len(this.DeviceList) != len(that1.DeviceList) {
		return false
	}
	for i := range this.DeviceList {
		if this.DeviceList[i] != that1.DeviceList[i] {
			return false
		}
	}
	return true
}
func (this *HardwareVendorModel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HardwareVendorModel)
	if !ok {
		that2, ok := that.(HardwareVendorModel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	return true
}
func (this *ImageType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType)
	if !ok {
		that2, ok := that.(ImageType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if that1.CloudProvider == nil {
		if this.CloudProvider != nil {
			return false
		}
	} else if this.CloudProvider == nil {
		return false
	} else if !this.CloudProvider.Equal(that1.CloudProvider) {
		return false
	}
	return true
}
func (this *ImageType_Azure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType_Azure)
	if !ok {
		that2, ok := that.(ImageType_Azure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Azure.Equal(that1.Azure) {
		return false
	}
	return true
}
func (this *ImageType_Aws) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType_Aws)
	if !ok {
		that2, ok := that.(ImageType_Aws)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Aws.Equal(that1.Aws) {
		return false
	}
	return true
}
func (this *ImageType_Gcp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType_Gcp)
	if !ok {
		that2, ok := that.(ImageType_Gcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Gcp.Equal(that1.Gcp) {
		return false
	}
	return true
}
func (this *Azure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Azure)
	if !ok {
		that2, ok := that.(Azure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Image == nil {
		if this.Image != nil {
			return false
		}
	} else if this.Image == nil {
		return false
	} else if !this.Image.Equal(that1.Image) {
		return false
	}
	return true
}
func (this *Azure_Marketplace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Azure_Marketplace)
	if !ok {
		that2, ok := that.(Azure_Marketplace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Marketplace.Equal(that1.Marketplace) {
		return false
	}
	return true
}
func (this *Azure_ImageId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Azure_ImageId)
	if !ok {
		that2, ok := that.(Azure_ImageId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ImageId.Equal(that1.ImageId) {
		return false
	}
	return true
}
func (this *AzureImage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureImage)
	if !ok {
		that2, ok := that.(AzureImage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ImageId != that1.ImageId {
		return false
	}
	return true
}
func (this *Marketplace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Marketplace)
	if !ok {
		that2, ok := that.(Marketplace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Offer != that1.Offer {
		return false
	}
	if this.Sku != that1.Sku {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Publisher != that1.Publisher {
		return false
	}
	return true
}
func (this *Aws) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Aws)
	if !ok {
		that2, ok := that.(Aws)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Image == nil {
		if this.Image != nil {
			return false
		}
	} else if this.Image == nil {
		return false
	} else if !this.Image.Equal(that1.Image) {
		return false
	}
	return true
}
func (this *Aws_ImageId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Aws_ImageId)
	if !ok {
		that2, ok := that.(Aws_ImageId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ImageId.Equal(that1.ImageId) {
		return false
	}
	return true
}
func (this *AwsImage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AwsImage)
	if !ok {
		that2, ok := that.(AwsImage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ImageId != that1.ImageId {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	return true
}
func (this *Gcp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Gcp)
	if !ok {
		that2, ok := that.(Gcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Image == nil {
		if this.Image != nil {
			return false
		}
	} else if this.Image == nil {
		return false
	} else if !this.Image.Equal(that1.Image) {
		return false
	}
	return true
}
func (this *Gcp_ImageId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Gcp_ImageId)
	if !ok {
		that2, ok := that.(Gcp_ImageId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ImageId.Equal(that1.ImageId) {
		return false
	}
	return true
}
func (this *GcpImage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GcpImage)
	if !ok {
		that2, ok := that.(GcpImage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ImageId != that1.ImageId {
		return false
	}
	return true
}
func (this *NumaMem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NumaMem)
	if !ok {
		that2, ok := that.(NumaMem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VendorModelList) != len(that1.VendorModelList) {
		return false
	}
	for i := range this.VendorModelList {
		if !this.VendorModelList[i].Equal(that1.VendorModelList[i]) {
			return false
		}
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(that1.Devices[i]) {
			return false
		}
	}
	if len(this.ImageList) != len(that1.ImageList) {
		return false
	}
	for i := range this.ImageList {
		if !this.ImageList[i].Equal(that1.ImageList[i]) {
			return false
		}
	}
	if this.NumaNodes != that1.NumaNodes {
		return false
	}
	if this.MemPageSize != that1.MemPageSize {
		return false
	}
	if this.MemPageNumber != that1.MemPageNumber {
		return false
	}
	if len(this.NumaMem) != len(that1.NumaMem) {
		return false
	}
	for i := range this.NumaMem {
		if !this.NumaMem[i].Equal(that1.NumaMem[i]) {
			return false
		}
	}
	if this.CertifiedHardwareType != that1.CertifiedHardwareType {
		return false
	}
	if len(this.InternalUsbDeviceRule) != len(that1.InternalUsbDeviceRule) {
		return false
	}
	for i := range this.InternalUsbDeviceRule {
		if !this.InternalUsbDeviceRule[i].Equal(that1.InternalUsbDeviceRule[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VendorModelList) != len(that1.VendorModelList) {
		return false
	}
	for i := range this.VendorModelList {
		if !this.VendorModelList[i].Equal(that1.VendorModelList[i]) {
			return false
		}
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(that1.Devices[i]) {
			return false
		}
	}
	if len(this.ImageList) != len(that1.ImageList) {
		return false
	}
	for i := range this.ImageList {
		if !this.ImageList[i].Equal(that1.ImageList[i]) {
			return false
		}
	}
	if this.NumaNodes != that1.NumaNodes {
		return false
	}
	if this.MemPageSize != that1.MemPageSize {
		return false
	}
	if this.MemPageNumber != that1.MemPageNumber {
		return false
	}
	if len(this.NumaMem) != len(that1.NumaMem) {
		return false
	}
	for i := range this.NumaMem {
		if !this.NumaMem[i].Equal(that1.NumaMem[i]) {
			return false
		}
	}
	if this.CertifiedHardwareType != that1.CertifiedHardwareType {
		return false
	}
	if len(this.InternalUsbDeviceRule) != len(that1.InternalUsbDeviceRule) {
		return false
	}
	for i := range this.InternalUsbDeviceRule {
		if !this.InternalUsbDeviceRule[i].Equal(that1.InternalUsbDeviceRule[i]) {
			return false
		}
	}
	return true
}
func (this *CertifiedHardwareStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CertifiedHardwareStatus)
	if !ok {
		that2, ok := that.(CertifiedHardwareStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LatestVersion != that1.LatestVersion {
		return false
	}
	return true
}
func (this *DeviceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&certified_hardware.DeviceType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Use: "+fmt.Sprintf("%#v", this.Use)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "MinUnit: "+fmt.Sprintf("%#v", this.MinUnit)+",\n")
	s = append(s, "MaxUnit: "+fmt.Sprintf("%#v", this.MaxUnit)+",\n")
	s = append(s, "DeviceList: "+fmt.Sprintf("%#v", this.DeviceList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HardwareVendorModel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&certified_hardware.HardwareVendorModel{")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&certified_hardware.ImageType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	if this.CloudProvider != nil {
		s = append(s, "CloudProvider: "+fmt.Sprintf("%#v", this.CloudProvider)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageType_Azure) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.ImageType_Azure{` +
		`Azure:` + fmt.Sprintf("%#v", this.Azure) + `}`}, ", ")
	return s
}
func (this *ImageType_Aws) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.ImageType_Aws{` +
		`Aws:` + fmt.Sprintf("%#v", this.Aws) + `}`}, ", ")
	return s
}
func (this *ImageType_Gcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.ImageType_Gcp{` +
		`Gcp:` + fmt.Sprintf("%#v", this.Gcp) + `}`}, ", ")
	return s
}
func (this *Azure) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&certified_hardware.Azure{")
	if this.Image != nil {
		s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Azure_Marketplace) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.Azure_Marketplace{` +
		`Marketplace:` + fmt.Sprintf("%#v", this.Marketplace) + `}`}, ", ")
	return s
}
func (this *Azure_ImageId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.Azure_ImageId{` +
		`ImageId:` + fmt.Sprintf("%#v", this.ImageId) + `}`}, ", ")
	return s
}
func (this *AzureImage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.AzureImage{")
	s = append(s, "ImageId: "+fmt.Sprintf("%#v", this.ImageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Marketplace) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&certified_hardware.Marketplace{")
	s = append(s, "Offer: "+fmt.Sprintf("%#v", this.Offer)+",\n")
	s = append(s, "Sku: "+fmt.Sprintf("%#v", this.Sku)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Publisher: "+fmt.Sprintf("%#v", this.Publisher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Aws) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.Aws{")
	if this.Image != nil {
		s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Aws_ImageId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.Aws_ImageId{` +
		`ImageId:` + fmt.Sprintf("%#v", this.ImageId) + `}`}, ", ")
	return s
}
func (this *AwsImage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&certified_hardware.AwsImage{")
	s = append(s, "ImageId: "+fmt.Sprintf("%#v", this.ImageId)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Gcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.Gcp{")
	if this.Image != nil {
		s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Gcp_ImageId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.Gcp_ImageId{` +
		`ImageId:` + fmt.Sprintf("%#v", this.ImageId) + `}`}, ", ")
	return s
}
func (this *GcpImage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.GcpImage{")
	s = append(s, "ImageId: "+fmt.Sprintf("%#v", this.ImageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NumaMem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&certified_hardware.NumaMem{")
	s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&certified_hardware.GlobalSpecType{")
	if this.VendorModelList != nil {
		s = append(s, "VendorModelList: "+fmt.Sprintf("%#v", this.VendorModelList)+",\n")
	}
	if this.Devices != nil {
		s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	}
	if this.ImageList != nil {
		s = append(s, "ImageList: "+fmt.Sprintf("%#v", this.ImageList)+",\n")
	}
	s = append(s, "NumaNodes: "+fmt.Sprintf("%#v", this.NumaNodes)+",\n")
	s = append(s, "MemPageSize: "+fmt.Sprintf("%#v", this.MemPageSize)+",\n")
	s = append(s, "MemPageNumber: "+fmt.Sprintf("%#v", this.MemPageNumber)+",\n")
	if this.NumaMem != nil {
		s = append(s, "NumaMem: "+fmt.Sprintf("%#v", this.NumaMem)+",\n")
	}
	s = append(s, "CertifiedHardwareType: "+fmt.Sprintf("%#v", this.CertifiedHardwareType)+",\n")
	if this.InternalUsbDeviceRule != nil {
		s = append(s, "InternalUsbDeviceRule: "+fmt.Sprintf("%#v", this.InternalUsbDeviceRule)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&certified_hardware.GetSpecType{")
	if this.VendorModelList != nil {
		s = append(s, "VendorModelList: "+fmt.Sprintf("%#v", this.VendorModelList)+",\n")
	}
	if this.Devices != nil {
		s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	}
	if this.ImageList != nil {
		s = append(s, "ImageList: "+fmt.Sprintf("%#v", this.ImageList)+",\n")
	}
	s = append(s, "NumaNodes: "+fmt.Sprintf("%#v", this.NumaNodes)+",\n")
	s = append(s, "MemPageSize: "+fmt.Sprintf("%#v", this.MemPageSize)+",\n")
	s = append(s, "MemPageNumber: "+fmt.Sprintf("%#v", this.MemPageNumber)+",\n")
	if this.NumaMem != nil {
		s = append(s, "NumaMem: "+fmt.Sprintf("%#v", this.NumaMem)+",\n")
	}
	s = append(s, "CertifiedHardwareType: "+fmt.Sprintf("%#v", this.CertifiedHardwareType)+",\n")
	if this.InternalUsbDeviceRule != nil {
		s = append(s, "InternalUsbDeviceRule: "+fmt.Sprintf("%#v", this.InternalUsbDeviceRule)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CertifiedHardwareStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.CertifiedHardwareStatus{")
	s = append(s, "LatestVersion: "+fmt.Sprintf("%#v", this.LatestVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DeviceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.Use != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Use))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.MinUnit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MinUnit))
	}
	if m.MaxUnit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxUnit))
	}
	if len(m.DeviceList) > 0 {
		for _, s := range m.DeviceList {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HardwareVendorModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardwareVendorModel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vendor) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Model) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	return i, nil
}

func (m *ImageType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Provider) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.CloudProvider != nil {
		nn1, err := m.CloudProvider.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *ImageType_Azure) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Azure != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Azure.Size()))
		n2, err := m.Azure.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *ImageType_Aws) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Aws != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Aws.Size()))
		n3, err := m.Aws.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *ImageType_Gcp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Gcp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Gcp.Size()))
		n4, err := m.Gcp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Azure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Azure) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		nn5, err := m.Image.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *Azure_Marketplace) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Marketplace != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Marketplace.Size()))
		n6, err := m.Marketplace.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Azure_ImageId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ImageId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ImageId.Size()))
		n7, err := m.ImageId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *AzureImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureImage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ImageId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ImageId)))
		i += copy(dAtA[i:], m.ImageId)
	}
	return i, nil
}

func (m *Marketplace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Marketplace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Offer) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Offer)))
		i += copy(dAtA[i:], m.Offer)
	}
	if len(m.Sku) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sku)))
		i += copy(dAtA[i:], m.Sku)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Publisher) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Publisher)))
		i += copy(dAtA[i:], m.Publisher)
	}
	return i, nil
}

func (m *Aws) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aws) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		nn8, err := m.Image.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *Aws_ImageId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ImageId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ImageId.Size()))
		n9, err := m.ImageId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *AwsImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwsImage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ImageId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ImageId)))
		i += copy(dAtA[i:], m.ImageId)
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	return i, nil
}

func (m *Gcp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gcp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		nn10, err := m.Image.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *Gcp_ImageId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ImageId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ImageId.Size()))
		n11, err := m.ImageId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *GcpImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GcpImage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ImageId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ImageId)))
		i += copy(dAtA[i:], m.ImageId)
	}
	return i, nil
}

func (m *NumaMem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumaMem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Memory != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Memory))
	}
	if m.Node != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Node))
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VendorModelList) > 0 {
		for _, msg := range m.VendorModelList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImageList) > 0 {
		for _, msg := range m.ImageList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NumaNodes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NumaNodes))
	}
	if m.MemPageSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MemPageSize))
	}
	if m.MemPageNumber != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MemPageNumber))
	}
	if len(m.NumaMem) > 0 {
		for _, msg := range m.NumaMem {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CertifiedHardwareType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CertifiedHardwareType))
	}
	if len(m.InternalUsbDeviceRule) > 0 {
		for _, msg := range m.InternalUsbDeviceRule {
			dAtA[i] = 0x52
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VendorModelList) > 0 {
		for _, msg := range m.VendorModelList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImageList) > 0 {
		for _, msg := range m.ImageList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NumaNodes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NumaNodes))
	}
	if m.MemPageSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MemPageSize))
	}
	if m.MemPageNumber != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MemPageNumber))
	}
	if len(m.NumaMem) > 0 {
		for _, msg := range m.NumaMem {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CertifiedHardwareType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CertifiedHardwareType))
	}
	if len(m.InternalUsbDeviceRule) > 0 {
		for _, msg := range m.InternalUsbDeviceRule {
			dAtA[i] = 0x52
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CertifiedHardwareStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertifiedHardwareStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LatestVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LatestVersion)))
		i += copy(dAtA[i:], m.LatestVersion)
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedDeviceType(r randyTypes, easy bool) *DeviceType {
	this := &DeviceType{}
	this.Type = HardwareDeviceType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	this.Use = HardwareDeviceInstanceUseType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}[r.Intn(12)])
	this.Name = string(randStringTypes(r))
	this.MinUnit = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MinUnit *= -1
	}
	this.MaxUnit = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaxUnit *= -1
	}
	v1 := r.Intn(10)
	this.DeviceList = make([]string, v1)
	for i := 0; i < v1; i++ {
		this.DeviceList[i] = string(randStringTypes(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHardwareVendorModel(r randyTypes, easy bool) *HardwareVendorModel {
	this := &HardwareVendorModel{}
	this.Vendor = string(randStringTypes(r))
	this.Model = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedImageType(r randyTypes, easy bool) *ImageType {
	this := &ImageType{}
	this.Name = string(randStringTypes(r))
	this.Provider = string(randStringTypes(r))
	oneofNumber_CloudProvider := []int32{3, 4, 5}[r.Intn(3)]
	switch oneofNumber_CloudProvider {
	case 3:
		this.CloudProvider = NewPopulatedImageType_Azure(r, easy)
	case 4:
		this.CloudProvider = NewPopulatedImageType_Aws(r, easy)
	case 5:
		this.CloudProvider = NewPopulatedImageType_Gcp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedImageType_Azure(r randyTypes, easy bool) *ImageType_Azure {
	this := &ImageType_Azure{}
	this.Azure = NewPopulatedAzure(r, easy)
	return this
}
func NewPopulatedImageType_Aws(r randyTypes, easy bool) *ImageType_Aws {
	this := &ImageType_Aws{}
	this.Aws = NewPopulatedAws(r, easy)
	return this
}
func NewPopulatedImageType_Gcp(r randyTypes, easy bool) *ImageType_Gcp {
	this := &ImageType_Gcp{}
	this.Gcp = NewPopulatedGcp(r, easy)
	return this
}
func NewPopulatedAzure(r randyTypes, easy bool) *Azure {
	this := &Azure{}
	oneofNumber_Image := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_Image {
	case 1:
		this.Image = NewPopulatedAzure_Marketplace(r, easy)
	case 2:
		this.Image = NewPopulatedAzure_ImageId(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAzure_Marketplace(r randyTypes, easy bool) *Azure_Marketplace {
	this := &Azure_Marketplace{}
	this.Marketplace = NewPopulatedMarketplace(r, easy)
	return this
}
func NewPopulatedAzure_ImageId(r randyTypes, easy bool) *Azure_ImageId {
	this := &Azure_ImageId{}
	this.ImageId = NewPopulatedAzureImage(r, easy)
	return this
}
func NewPopulatedAzureImage(r randyTypes, easy bool) *AzureImage {
	this := &AzureImage{}
	this.ImageId = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMarketplace(r randyTypes, easy bool) *Marketplace {
	this := &Marketplace{}
	this.Offer = string(randStringTypes(r))
	this.Sku = string(randStringTypes(r))
	this.Version = string(randStringTypes(r))
	this.Name = string(randStringTypes(r))
	this.Publisher = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAws(r randyTypes, easy bool) *Aws {
	this := &Aws{}
	oneofNumber_Image := []int32{1}[r.Intn(1)]
	switch oneofNumber_Image {
	case 1:
		this.Image = NewPopulatedAws_ImageId(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAws_ImageId(r randyTypes, easy bool) *Aws_ImageId {
	this := &Aws_ImageId{}
	this.ImageId = NewPopulatedAwsImage(r, easy)
	return this
}
func NewPopulatedAwsImage(r randyTypes, easy bool) *AwsImage {
	this := &AwsImage{}
	this.ImageId = string(randStringTypes(r))
	this.Region = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGcp(r randyTypes, easy bool) *Gcp {
	this := &Gcp{}
	oneofNumber_Image := []int32{1}[r.Intn(1)]
	switch oneofNumber_Image {
	case 1:
		this.Image = NewPopulatedGcp_ImageId(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGcp_ImageId(r randyTypes, easy bool) *Gcp_ImageId {
	this := &Gcp_ImageId{}
	this.ImageId = NewPopulatedGcpImage(r, easy)
	return this
}
func NewPopulatedGcpImage(r randyTypes, easy bool) *GcpImage {
	this := &GcpImage{}
	this.ImageId = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNumaMem(r randyTypes, easy bool) *NumaMem {
	this := &NumaMem{}
	this.Memory = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Memory *= -1
	}
	this.Node = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Node *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.VendorModelList = make([]*HardwareVendorModel, v2)
		for i := 0; i < v2; i++ {
			this.VendorModelList[i] = NewPopulatedHardwareVendorModel(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Devices = make([]*DeviceType, v3)
		for i := 0; i < v3; i++ {
			this.Devices[i] = NewPopulatedDeviceType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.ImageList = make([]*ImageType, v4)
		for i := 0; i < v4; i++ {
			this.ImageList[i] = NewPopulatedImageType(r, easy)
		}
	}
	this.NumaNodes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.NumaNodes *= -1
	}
	this.MemPageSize = MemPageSize([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.MemPageNumber = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MemPageNumber *= -1
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.NumaMem = make([]*NumaMem, v5)
		for i := 0; i < v5; i++ {
			this.NumaMem[i] = NewPopulatedNumaMem(r, easy)
		}
	}
	this.CertifiedHardwareType = HardwareType([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.InternalUsbDeviceRule = make([]*ves_io_schema_usb_policy.Rule, v6)
		for i := 0; i < v6; i++ {
			this.InternalUsbDeviceRule[i] = ves_io_schema_usb_policy.NewPopulatedRule(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.VendorModelList = make([]*HardwareVendorModel, v7)
		for i := 0; i < v7; i++ {
			this.VendorModelList[i] = NewPopulatedHardwareVendorModel(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.Devices = make([]*DeviceType, v8)
		for i := 0; i < v8; i++ {
			this.Devices[i] = NewPopulatedDeviceType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.ImageList = make([]*ImageType, v9)
		for i := 0; i < v9; i++ {
			this.ImageList[i] = NewPopulatedImageType(r, easy)
		}
	}
	this.NumaNodes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.NumaNodes *= -1
	}
	this.MemPageSize = MemPageSize([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.MemPageNumber = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MemPageNumber *= -1
	}
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.NumaMem = make([]*NumaMem, v10)
		for i := 0; i < v10; i++ {
			this.NumaMem[i] = NewPopulatedNumaMem(r, easy)
		}
	}
	this.CertifiedHardwareType = HardwareType([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(10) != 0 {
		v11 := r.Intn(5)
		this.InternalUsbDeviceRule = make([]*ves_io_schema_usb_policy.Rule, v11)
		for i := 0; i < v11; i++ {
			this.InternalUsbDeviceRule[i] = ves_io_schema_usb_policy.NewPopulatedRule(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCertifiedHardwareStatus(r randyTypes, easy bool) *CertifiedHardwareStatus {
	this := &CertifiedHardwareStatus{}
	this.LatestVersion = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v12 := r.Intn(100)
	tmps := make([]rune, v12)
	for i := 0; i < v12; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v13 := r.Int63()
		if r.Intn(2) == 0 {
			v13 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v13))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *DeviceType) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Use != 0 {
		n += 1 + sovTypes(uint64(m.Use))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MinUnit != 0 {
		n += 1 + sovTypes(uint64(m.MinUnit))
	}
	if m.MaxUnit != 0 {
		n += 1 + sovTypes(uint64(m.MaxUnit))
	}
	if len(m.DeviceList) > 0 {
		for _, s := range m.DeviceList {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *HardwareVendorModel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ImageType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CloudProvider != nil {
		n += m.CloudProvider.Size()
	}
	return n
}

func (m *ImageType_Azure) Size() (n int) {
	var l int
	_ = l
	if m.Azure != nil {
		l = m.Azure.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ImageType_Aws) Size() (n int) {
	var l int
	_ = l
	if m.Aws != nil {
		l = m.Aws.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ImageType_Gcp) Size() (n int) {
	var l int
	_ = l
	if m.Gcp != nil {
		l = m.Gcp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Azure) Size() (n int) {
	var l int
	_ = l
	if m.Image != nil {
		n += m.Image.Size()
	}
	return n
}

func (m *Azure_Marketplace) Size() (n int) {
	var l int
	_ = l
	if m.Marketplace != nil {
		l = m.Marketplace.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Azure_ImageId) Size() (n int) {
	var l int
	_ = l
	if m.ImageId != nil {
		l = m.ImageId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AzureImage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Marketplace) Size() (n int) {
	var l int
	_ = l
	l = len(m.Offer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Publisher)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Aws) Size() (n int) {
	var l int
	_ = l
	if m.Image != nil {
		n += m.Image.Size()
	}
	return n
}

func (m *Aws_ImageId) Size() (n int) {
	var l int
	_ = l
	if m.ImageId != nil {
		l = m.ImageId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AwsImage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Gcp) Size() (n int) {
	var l int
	_ = l
	if m.Image != nil {
		n += m.Image.Size()
	}
	return n
}

func (m *Gcp_ImageId) Size() (n int) {
	var l int
	_ = l
	if m.ImageId != nil {
		l = m.ImageId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GcpImage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NumaMem) Size() (n int) {
	var l int
	_ = l
	if m.Memory != 0 {
		n += 1 + sovTypes(uint64(m.Memory))
	}
	if m.Node != 0 {
		n += 1 + sovTypes(uint64(m.Node))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.VendorModelList) > 0 {
		for _, e := range m.VendorModelList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ImageList) > 0 {
		for _, e := range m.ImageList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NumaNodes != 0 {
		n += 1 + sovTypes(uint64(m.NumaNodes))
	}
	if m.MemPageSize != 0 {
		n += 1 + sovTypes(uint64(m.MemPageSize))
	}
	if m.MemPageNumber != 0 {
		n += 1 + sovTypes(uint64(m.MemPageNumber))
	}
	if len(m.NumaMem) > 0 {
		for _, e := range m.NumaMem {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CertifiedHardwareType != 0 {
		n += 1 + sovTypes(uint64(m.CertifiedHardwareType))
	}
	if len(m.InternalUsbDeviceRule) > 0 {
		for _, e := range m.InternalUsbDeviceRule {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if len(m.VendorModelList) > 0 {
		for _, e := range m.VendorModelList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ImageList) > 0 {
		for _, e := range m.ImageList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NumaNodes != 0 {
		n += 1 + sovTypes(uint64(m.NumaNodes))
	}
	if m.MemPageSize != 0 {
		n += 1 + sovTypes(uint64(m.MemPageSize))
	}
	if m.MemPageNumber != 0 {
		n += 1 + sovTypes(uint64(m.MemPageNumber))
	}
	if len(m.NumaMem) > 0 {
		for _, e := range m.NumaMem {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CertifiedHardwareType != 0 {
		n += 1 + sovTypes(uint64(m.CertifiedHardwareType))
	}
	if len(m.InternalUsbDeviceRule) > 0 {
		for _, e := range m.InternalUsbDeviceRule {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CertifiedHardwareStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.LatestVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DeviceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Use:` + fmt.Sprintf("%v", this.Use) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`MinUnit:` + fmt.Sprintf("%v", this.MinUnit) + `,`,
		`MaxUnit:` + fmt.Sprintf("%v", this.MaxUnit) + `,`,
		`DeviceList:` + fmt.Sprintf("%v", this.DeviceList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HardwareVendorModel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HardwareVendorModel{`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`CloudProvider:` + fmt.Sprintf("%v", this.CloudProvider) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType_Azure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType_Azure{`,
		`Azure:` + strings.Replace(fmt.Sprintf("%v", this.Azure), "Azure", "Azure", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType_Aws) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType_Aws{`,
		`Aws:` + strings.Replace(fmt.Sprintf("%v", this.Aws), "Aws", "Aws", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType_Gcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType_Gcp{`,
		`Gcp:` + strings.Replace(fmt.Sprintf("%v", this.Gcp), "Gcp", "Gcp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Azure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Azure{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Azure_Marketplace) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Azure_Marketplace{`,
		`Marketplace:` + strings.Replace(fmt.Sprintf("%v", this.Marketplace), "Marketplace", "Marketplace", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Azure_ImageId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Azure_ImageId{`,
		`ImageId:` + strings.Replace(fmt.Sprintf("%v", this.ImageId), "AzureImage", "AzureImage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureImage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureImage{`,
		`ImageId:` + fmt.Sprintf("%v", this.ImageId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Marketplace) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Marketplace{`,
		`Offer:` + fmt.Sprintf("%v", this.Offer) + `,`,
		`Sku:` + fmt.Sprintf("%v", this.Sku) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Publisher:` + fmt.Sprintf("%v", this.Publisher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Aws) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Aws{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Aws_ImageId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Aws_ImageId{`,
		`ImageId:` + strings.Replace(fmt.Sprintf("%v", this.ImageId), "AwsImage", "AwsImage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AwsImage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AwsImage{`,
		`ImageId:` + fmt.Sprintf("%v", this.ImageId) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Gcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Gcp{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Gcp_ImageId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Gcp_ImageId{`,
		`ImageId:` + strings.Replace(fmt.Sprintf("%v", this.ImageId), "GcpImage", "GcpImage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GcpImage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GcpImage{`,
		`ImageId:` + fmt.Sprintf("%v", this.ImageId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NumaMem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NumaMem{`,
		`Memory:` + fmt.Sprintf("%v", this.Memory) + `,`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`VendorModelList:` + strings.Replace(fmt.Sprintf("%v", this.VendorModelList), "HardwareVendorModel", "HardwareVendorModel", 1) + `,`,
		`Devices:` + strings.Replace(fmt.Sprintf("%v", this.Devices), "DeviceType", "DeviceType", 1) + `,`,
		`ImageList:` + strings.Replace(fmt.Sprintf("%v", this.ImageList), "ImageType", "ImageType", 1) + `,`,
		`NumaNodes:` + fmt.Sprintf("%v", this.NumaNodes) + `,`,
		`MemPageSize:` + fmt.Sprintf("%v", this.MemPageSize) + `,`,
		`MemPageNumber:` + fmt.Sprintf("%v", this.MemPageNumber) + `,`,
		`NumaMem:` + strings.Replace(fmt.Sprintf("%v", this.NumaMem), "NumaMem", "NumaMem", 1) + `,`,
		`CertifiedHardwareType:` + fmt.Sprintf("%v", this.CertifiedHardwareType) + `,`,
		`InternalUsbDeviceRule:` + strings.Replace(fmt.Sprintf("%v", this.InternalUsbDeviceRule), "Rule", "ves_io_schema_usb_policy.Rule", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`VendorModelList:` + strings.Replace(fmt.Sprintf("%v", this.VendorModelList), "HardwareVendorModel", "HardwareVendorModel", 1) + `,`,
		`Devices:` + strings.Replace(fmt.Sprintf("%v", this.Devices), "DeviceType", "DeviceType", 1) + `,`,
		`ImageList:` + strings.Replace(fmt.Sprintf("%v", this.ImageList), "ImageType", "ImageType", 1) + `,`,
		`NumaNodes:` + fmt.Sprintf("%v", this.NumaNodes) + `,`,
		`MemPageSize:` + fmt.Sprintf("%v", this.MemPageSize) + `,`,
		`MemPageNumber:` + fmt.Sprintf("%v", this.MemPageNumber) + `,`,
		`NumaMem:` + strings.Replace(fmt.Sprintf("%v", this.NumaMem), "NumaMem", "NumaMem", 1) + `,`,
		`CertifiedHardwareType:` + fmt.Sprintf("%v", this.CertifiedHardwareType) + `,`,
		`InternalUsbDeviceRule:` + strings.Replace(fmt.Sprintf("%v", this.InternalUsbDeviceRule), "Rule", "ves_io_schema_usb_policy.Rule", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CertifiedHardwareStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CertifiedHardwareStatus{`,
		`LatestVersion:` + fmt.Sprintf("%v", this.LatestVersion) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DeviceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (HardwareDeviceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			m.Use = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Use |= (HardwareDeviceInstanceUseType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUnit", wireType)
			}
			m.MinUnit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUnit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnit", wireType)
			}
			m.MaxUnit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUnit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceList = append(m.DeviceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardwareVendorModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardwareVendorModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardwareVendorModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Azure{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudProvider = &ImageType_Azure{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Aws{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudProvider = &ImageType_Aws{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Gcp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudProvider = &ImageType_Gcp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Azure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Azure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Azure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marketplace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Marketplace{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Image = &Azure_Marketplace{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Image = &Azure_ImageId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Marketplace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Marketplace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Marketplace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publisher = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aws) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aws: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aws: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AwsImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Image = &Aws_ImageId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwsImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwsImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwsImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gcp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gcp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gcp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GcpImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Image = &Gcp_ImageId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GcpImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GcpImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GcpImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumaMem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumaMem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumaMem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorModelList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorModelList = append(m.VendorModelList, &HardwareVendorModel{})
			if err := m.VendorModelList[len(m.VendorModelList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceType{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageList = append(m.ImageList, &ImageType{})
			if err := m.ImageList[len(m.ImageList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaNodes", wireType)
			}
			m.NumaNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumaNodes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPageSize", wireType)
			}
			m.MemPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemPageSize |= (MemPageSize(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPageNumber", wireType)
			}
			m.MemPageNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemPageNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaMem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumaMem = append(m.NumaMem, &NumaMem{})
			if err := m.NumaMem[len(m.NumaMem)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHardwareType", wireType)
			}
			m.CertifiedHardwareType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertifiedHardwareType |= (HardwareType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalUsbDeviceRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalUsbDeviceRule = append(m.InternalUsbDeviceRule, &ves_io_schema_usb_policy.Rule{})
			if err := m.InternalUsbDeviceRule[len(m.InternalUsbDeviceRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorModelList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorModelList = append(m.VendorModelList, &HardwareVendorModel{})
			if err := m.VendorModelList[len(m.VendorModelList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceType{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageList = append(m.ImageList, &ImageType{})
			if err := m.ImageList[len(m.ImageList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaNodes", wireType)
			}
			m.NumaNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumaNodes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPageSize", wireType)
			}
			m.MemPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemPageSize |= (MemPageSize(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPageNumber", wireType)
			}
			m.MemPageNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemPageNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaMem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumaMem = append(m.NumaMem, &NumaMem{})
			if err := m.NumaMem[len(m.NumaMem)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHardwareType", wireType)
			}
			m.CertifiedHardwareType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertifiedHardwareType |= (HardwareType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalUsbDeviceRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalUsbDeviceRule = append(m.InternalUsbDeviceRule, &ves_io_schema_usb_policy.Rule{})
			if err := m.InternalUsbDeviceRule[len(m.InternalUsbDeviceRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertifiedHardwareStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertifiedHardwareStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertifiedHardwareStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/certified_hardware/types.proto", fileDescriptorTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/certified_hardware/types.proto", fileDescriptorTypes)
}

var fileDescriptorTypes = []byte{
	// 1523 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x4b, 0x6f, 0xdb, 0xda,
	0x11, 0x16, 0xf5, 0xd6, 0x28, 0x71, 0x98, 0x93, 0xc4, 0x66, 0x1c, 0x87, 0x11, 0xd4, 0x24, 0x76,
	0x9d, 0x58, 0x42, 0x95, 0x64, 0xd1, 0x02, 0x6d, 0x4a, 0x49, 0x8c, 0x44, 0x5b, 0x0f, 0x87, 0x7a,
	0xa4, 0xc8, 0x86, 0xa0, 0xa4, 0x63, 0x99, 0x88, 0xf8, 0x00, 0x49, 0xc9, 0x71, 0x56, 0xed, 0x3f,
	0x68, 0x81, 0x16, 0xe8, 0xa2, 0x3f, 0x20, 0x3f, 0x21, 0x40, 0x80, 0x22, 0xcb, 0xa2, 0x2b, 0x2f,
	0xb3, 0xbc, 0x56, 0x36, 0x77, 0x75, 0x91, 0xe5, 0x5d, 0x5e, 0xf0, 0x90, 0x7a, 0x3a, 0x91, 0x74,
	0xef, 0xea, 0x2e, 0xb2, 0x3b, 0x73, 0xe6, 0x9b, 0x99, 0x6f, 0xe6, 0xcc, 0x19, 0x1e, 0x09, 0x1e,
	0x0e, 0xb0, 0x95, 0x52, 0xf4, 0xb4, 0xd5, 0x3e, 0xc6, 0xaa, 0x9c, 0x6e, 0x63, 0xd3, 0x56, 0x8e,
	0x14, 0xdc, 0x91, 0x8e, 0x65, 0xb3, 0x73, 0x22, 0x9b, 0x38, 0x6d, 0x9f, 0x1a, 0xd8, 0x4a, 0x19,
	0xa6, 0x6e, 0xeb, 0x28, 0xe1, 0xa2, 0x53, 0x2e, 0x3a, 0x75, 0x11, 0xbd, 0xb9, 0xd7, 0x55, 0xec,
	0xe3, 0x7e, 0x2b, 0xd5, 0xd6, 0xd5, 0x74, 0x57, 0xef, 0xea, 0x69, 0x62, 0xd8, 0xea, 0x1f, 0x11,
	0x89, 0x08, 0x64, 0xe5, 0x3a, 0xdc, 0xbc, 0xd3, 0xd5, 0xf5, 0x6e, 0x0f, 0x4f, 0x50, 0xb6, 0xa2,
	0x62, 0xcb, 0x96, 0x55, 0xc3, 0x03, 0x6c, 0xcc, 0xf2, 0xd3, 0xb0, 0xed, 0x29, 0x6e, 0xcd, 0x2a,
	0x74, 0xc3, 0x56, 0x74, 0xcd, 0xe3, 0xb9, 0x79, 0x7b, 0x56, 0x69, 0x0c, 0x6c, 0x69, 0x2a, 0x8d,
	0xcd, 0x9b, 0xb3, 0xea, 0x69, 0xd5, 0xdd, 0x59, 0x55, 0xdf, 0x6a, 0x49, 0x86, 0xde, 0x53, 0xda,
	0xa7, 0x33, 0xa8, 0xad, 0x59, 0xd4, 0x40, 0xee, 0x29, 0x1d, 0xd9, 0xc6, 0x9e, 0x36, 0x31, 0xa7,
	0x55, 0xf0, 0x89, 0x34, 0xc3, 0x2f, 0xf9, 0x4f, 0x3f, 0x40, 0x1e, 0x0f, 0x94, 0x36, 0xae, 0x9f,
	0x1a, 0x18, 0x15, 0x21, 0xe8, 0x78, 0x67, 0xa8, 0x04, 0xb5, 0xb3, 0x96, 0x79, 0x9c, 0x5a, 0x56,
	0xe5, 0x54, 0xd1, 0x5b, 0x4c, 0x7c, 0x88, 0xc4, 0x03, 0x7a, 0x0e, 0x81, 0xbe, 0x85, 0x19, 0x3f,
	0x71, 0xf4, 0xf4, 0xe7, 0x3a, 0x12, 0x34, 0xcb, 0x96, 0xb5, 0x36, 0x6e, 0x58, 0xae, 0x4f, 0xc7,
	0x17, 0x42, 0x10, 0xd4, 0x64, 0x15, 0x33, 0x81, 0x04, 0xb5, 0x13, 0x13, 0xc9, 0x1a, 0xdd, 0x84,
	0xa8, 0xaa, 0x68, 0x52, 0x5f, 0x53, 0x6c, 0x26, 0x98, 0xa0, 0x76, 0x42, 0x62, 0x44, 0x55, 0xb4,
	0x86, 0xa6, 0xd8, 0x44, 0x25, 0xbf, 0x76, 0x55, 0x21, 0x4f, 0x25, 0xbf, 0x26, 0xaa, 0x3b, 0x10,
	0xef, 0x90, 0x38, 0x52, 0x4f, 0xb1, 0x6c, 0x26, 0x9c, 0x08, 0xec, 0xc4, 0x44, 0x70, 0xb7, 0x4a,
	0x8a, 0x65, 0x27, 0x73, 0x70, 0x6d, 0x44, 0xa8, 0x89, 0xb5, 0x8e, 0x6e, 0x96, 0xf5, 0x0e, 0xee,
	0xa1, 0x75, 0x08, 0x0f, 0x88, 0x48, 0x0a, 0x14, 0x13, 0x3d, 0x09, 0x5d, 0x87, 0x90, 0xea, 0x00,
	0x48, 0xba, 0x31, 0xd1, 0x15, 0x92, 0xff, 0xf1, 0x43, 0x4c, 0x50, 0xe5, 0xae, 0x5b, 0xda, 0x75,
	0x8f, 0x3d, 0xb1, 0xcc, 0xfa, 0x19, 0xca, 0xcb, 0x80, 0x85, 0xa8, 0x61, 0xea, 0x03, 0xa5, 0x83,
	0x4d, 0xd7, 0x9c, 0xe8, 0xc6, 0x7b, 0xe8, 0x29, 0x84, 0xe4, 0x37, 0x7d, 0xd3, 0x4d, 0x3b, 0x9e,
	0xd9, 0x5e, 0x5e, 0x4a, 0xce, 0x81, 0x17, 0x7d, 0xa2, 0x6b, 0x87, 0x7e, 0x0f, 0x01, 0xf9, 0xc4,
	0x22, 0xd5, 0x89, 0x67, 0xee, 0xad, 0x60, 0x7e, 0x62, 0x15, 0x7d, 0xa2, 0x63, 0xe3, 0x98, 0x76,
	0xdb, 0x06, 0xa9, 0xde, 0x4a, 0xa6, 0x85, 0xb6, 0xe1, 0x98, 0x76, 0xdb, 0x46, 0x76, 0x13, 0xd6,
	0xda, 0x3d, 0xbd, 0xdf, 0x91, 0xc6, 0x89, 0x44, 0x3f, 0xbc, 0xa7, 0x82, 0x67, 0xef, 0xa9, 0xf0,
	0x7e, 0x30, 0x1a, 0xa6, 0x23, 0xc9, 0xff, 0x52, 0x10, 0x22, 0x54, 0xd1, 0x73, 0x88, 0xab, 0xb2,
	0xf9, 0x0a, 0xdb, 0x46, 0x4f, 0x6e, 0xbb, 0x15, 0x8a, 0x67, 0xf6, 0x96, 0x87, 0x2b, 0x4f, 0x8c,
	0x8a, 0x3e, 0x71, 0xda, 0x07, 0x12, 0x20, 0xaa, 0x38, 0xa5, 0x97, 0x94, 0x0e, 0xa9, 0x6a, 0x3c,
	0xf3, 0x70, 0xc5, 0xc2, 0x91, 0x13, 0x2b, 0xfa, 0xc4, 0x08, 0xb1, 0x17, 0x3a, 0xd9, 0xab, 0x10,
	0x22, 0x4b, 0x92, 0x00, 0x75, 0xf6, 0x9e, 0x0a, 0xec, 0x07, 0xa3, 0x01, 0x3a, 0x98, 0xdc, 0x06,
	0x98, 0x58, 0x38, 0xed, 0x36, 0x8e, 0xe8, 0x76, 0xc7, 0xc8, 0x43, 0xf2, 0x6f, 0x14, 0xc4, 0xa7,
	0xb8, 0x3a, 0xed, 0xa2, 0x1f, 0x1d, 0xe1, 0x51, 0x17, 0xb9, 0x02, 0xa2, 0x21, 0x60, 0xbd, 0xea,
	0x7b, 0x2d, 0xe4, 0x2c, 0x11, 0x03, 0x91, 0x01, 0x36, 0x2d, 0x45, 0xd7, 0xbc, 0x9e, 0x1f, 0x89,
	0xe3, 0xab, 0x10, 0x9c, 0xba, 0x0a, 0x5b, 0x10, 0x33, 0xfa, 0xad, 0x9e, 0x62, 0x1d, 0x63, 0x93,
	0x1c, 0x59, 0x4c, 0x9c, 0x6c, 0x24, 0xbb, 0x10, 0xe0, 0x4e, 0x2c, 0x54, 0x98, 0x63, 0x19, 0xcf,
	0xec, 0xae, 0xd4, 0x11, 0xcb, 0xab, 0xe2, 0xdf, 0x0f, 0x46, 0xfd, 0x74, 0x20, 0xf9, 0x47, 0x88,
	0x8e, 0xf0, 0x0b, 0x6a, 0xe2, 0x5c, 0x25, 0x13, 0x77, 0x9d, 0xd4, 0xdc, 0x84, 0x3d, 0xc9, 0xe1,
	0x59, 0x68, 0x1b, 0xbf, 0x8c, 0x67, 0xa1, 0x6d, 0xac, 0xce, 0xf3, 0x1e, 0x44, 0x47, 0xf8, 0x45,
	0x67, 0xf7, 0x04, 0x22, 0x95, 0xbe, 0x2a, 0x97, 0xb1, 0xea, 0x50, 0x56, 0xb1, 0xaa, 0x9b, 0xa7,
	0x04, 0x13, 0x12, 0x3d, 0x89, 0x1c, 0x86, 0xde, 0x71, 0x67, 0x5d, 0x48, 0x24, 0xeb, 0xe4, 0xdb,
	0x10, 0xac, 0x15, 0x7a, 0x7a, 0x4b, 0xee, 0xd5, 0x0c, 0xdc, 0x26, 0x03, 0x40, 0x86, 0xab, 0xee,
	0xb8, 0x90, 0xc8, 0x78, 0x70, 0x47, 0x0f, 0x95, 0x08, 0xec, 0xc4, 0x33, 0x4f, 0x56, 0x9f, 0x8f,
	0x53, 0xe3, 0x48, 0xbc, 0x32, 0x98, 0x08, 0xce, 0xd8, 0x42, 0xcf, 0x20, 0xe2, 0x0e, 0x31, 0x8b,
	0xf1, 0x13, 0xc7, 0x2b, 0x34, 0xfd, 0xd4, 0xe4, 0x1e, 0x19, 0xa3, 0x7d, 0x00, 0xb7, 0x1e, 0x84,
	0x63, 0x90, 0xb8, 0x7a, 0xb0, 0xdc, 0xd5, 0x78, 0xd8, 0x89, 0x31, 0x62, 0x4e, 0x38, 0xdd, 0x06,
	0xd0, 0xfa, 0xaa, 0x2c, 0x39, 0x65, 0xb1, 0xbc, 0x41, 0x1c, 0x73, 0x76, 0x2a, 0xce, 0x06, 0x7a,
	0x0e, 0x97, 0x55, 0xac, 0x4a, 0x86, 0x13, 0xcd, 0x52, 0xde, 0x60, 0x26, 0x4c, 0xbe, 0x18, 0xab,
	0xdc, 0x7e, 0xac, 0x1e, 0xca, 0x5d, 0x5c, 0x53, 0xde, 0x60, 0x31, 0xae, 0x4e, 0x04, 0x74, 0x1f,
	0xae, 0x8c, 0x5d, 0x6a, 0x7d, 0xb5, 0x85, 0x4d, 0x26, 0x42, 0xc2, 0x5e, 0xf6, 0x50, 0x15, 0xb2,
	0x89, 0xf2, 0x10, 0x25, 0xcc, 0x54, 0xac, 0x32, 0x51, 0x92, 0xe3, 0x6f, 0x97, 0x47, 0xf5, 0x9a,
	0x41, 0x8c, 0x68, 0x5e, 0x57, 0x1c, 0xc1, 0xc6, 0x45, 0x18, 0xf9, 0xc8, 0x33, 0x31, 0x92, 0x4a,
	0x6a, 0xf5, 0xc3, 0x25, 0xb5, 0xbb, 0x31, 0x06, 0x4c, 0x6f, 0xa3, 0x17, 0xc0, 0x28, 0x9a, 0x8d,
	0x4d, 0x4d, 0xee, 0x49, 0xce, 0x63, 0xc0, 0xfb, 0x80, 0x99, 0xfd, 0x1e, 0x66, 0x80, 0xb0, 0x67,
	0xe7, 0x02, 0x4d, 0x9e, 0x0c, 0x29, 0xb1, 0xdf, 0xc3, 0xe2, 0x8d, 0x91, 0x7d, 0xc3, 0x6a, 0xb9,
	0xa7, 0xee, 0x6c, 0x27, 0xdf, 0x85, 0x20, 0x5e, 0xc0, 0xf6, 0xb7, 0x3e, 0xfd, 0xd6, 0xa7, 0xbf,
	0xe6, 0x3e, 0xfd, 0xc3, 0xd5, 0xff, 0xff, 0x69, 0x6e, 0xa4, 0x26, 0xff, 0x0c, 0x1b, 0xb9, 0x79,
	0x12, 0x35, 0x5b, 0xb6, 0xfb, 0x16, 0xba, 0x07, 0x6b, 0x3d, 0xd9, 0xc6, 0x96, 0x2d, 0x8d, 0x3e,
	0xa1, 0xee, 0x60, 0xbf, 0xec, 0xee, 0x36, 0xdd, 0xcd, 0xdd, 0x1f, 0x28, 0x40, 0x17, 0xdf, 0xb0,
	0xe8, 0x16, 0x6c, 0x14, 0x39, 0x31, 0xff, 0x82, 0x13, 0x79, 0x29, 0xcf, 0x37, 0x85, 0x1c, 0x2f,
	0x09, 0x95, 0x26, 0x57, 0x12, 0xf2, 0xb4, 0x0f, 0x6d, 0x01, 0x33, 0xaf, 0xe4, 0xeb, 0x45, 0x5e,
	0xac, 0xf0, 0x75, 0x9a, 0x42, 0x9b, 0xb0, 0x3e, 0xaf, 0x6d, 0x0a, 0x62, 0x5d, 0xa8, 0xd2, 0xfe,
	0x2f, 0xe9, 0xea, 0x8d, 0x4a, 0x9d, 0x3b, 0xa4, 0x03, 0x88, 0x81, 0xeb, 0xf3, 0xba, 0x6c, 0xb5,
	0x92, 0xa7, 0x83, 0xe8, 0x01, 0x6c, 0x5f, 0x88, 0xf7, 0x97, 0x3a, 0x2f, 0x56, 0xb8, 0x92, 0x24,
	0xd4, 0x72, 0x35, 0x41, 0xaa, 0xd5, 0xab, 0x62, 0x9d, 0x2b, 0xf0, 0x74, 0x08, 0xb1, 0xb0, 0x39,
	0x0f, 0xae, 0x34, 0x85, 0xbc, 0xc0, 0x49, 0x85, 0xc3, 0x06, 0x1d, 0xde, 0xfd, 0x57, 0x10, 0x6e,
	0x2f, 0x7c, 0x6b, 0xa3, 0x3b, 0x70, 0x6b, 0xde, 0x43, 0xa3, 0xc6, 0x4b, 0x22, 0x5f, 0x68, 0x94,
	0x38, 0x91, 0xf6, 0xa1, 0x04, 0x6c, 0x7d, 0x09, 0x20, 0x54, 0x5c, 0x4e, 0x34, 0x85, 0xb6, 0xe1,
	0x37, 0x63, 0x44, 0x85, 0xaf, 0xbf, 0xa8, 0x8a, 0x07, 0x5f, 0x72, 0xe5, 0x47, 0x3b, 0x70, 0x77,
	0x11, 0x70, 0xec, 0x32, 0x80, 0x76, 0xe1, 0xfe, 0x22, 0x64, 0x99, 0xab, 0x70, 0x05, 0xbe, 0xcc,
	0x57, 0xea, 0x74, 0x70, 0x59, 0xf8, 0x6a, 0xa3, 0x5e, 0x13, 0xf2, 0x4e, 0xb1, 0xee, 0x43, 0x72,
	0x71, 0x78, 0x82, 0x0b, 0xcf, 0x9c, 0xc0, 0xd7, 0x1d, 0x4a, 0x25, 0xae, 0x40, 0x47, 0x96, 0x31,
	0x75, 0x9d, 0x12, 0x6c, 0x74, 0x19, 0xb6, 0xc4, 0x15, 0xa4, 0x32, 0x5f, 0xce, 0xf2, 0x22, 0x1d,
	0x5b, 0x96, 0x95, 0xd3, 0x03, 0x4e, 0x0b, 0x00, 0x7a, 0x04, 0xe9, 0x45, 0xc0, 0x67, 0x5c, 0xa9,
	0x94, 0xe5, 0x72, 0x07, 0xd3, 0x35, 0x8b, 0xef, 0x0a, 0x70, 0x69, 0xe6, 0x1a, 0x5f, 0x82, 0x68,
	0xb3, 0x5a, 0xaa, 0x97, 0xf9, 0x5a, 0x91, 0xf6, 0xa1, 0x6b, 0x70, 0xc5, 0x91, 0x6a, 0x75, 0xc7,
	0x2e, 0x57, 0x2d, 0x67, 0xab, 0x34, 0x85, 0xd6, 0x01, 0xe5, 0x4a, 0xd5, 0x46, 0x5e, 0x2a, 0x73,
	0xe2, 0x01, 0x5f, 0x97, 0x0e, 0x4b, 0x5c, 0x8e, 0xa7, 0xfd, 0xbb, 0xff, 0x70, 0x9e, 0xbb, 0x53,
	0x73, 0x2e, 0x09, 0xec, 0x98, 0x4f, 0x99, 0x2f, 0x4b, 0x87, 0x5c, 0x81, 0x97, 0x6a, 0xc2, 0xcb,
	0xe9, 0x3b, 0x35, 0xdd, 0xb6, 0xb3, 0x98, 0xc7, 0x07, 0x59, 0x9a, 0x5a, 0xa0, 0xcf, 0x94, 0xb3,
	0xb4, 0x7f, 0x81, 0xfe, 0x77, 0x85, 0x2c, 0x1d, 0xc8, 0xfe, 0x9b, 0x3a, 0x3b, 0x67, 0x7d, 0x1f,
	0xcf, 0x59, 0xdf, 0xe7, 0x73, 0x96, 0xfa, 0xf1, 0x9c, 0xa5, 0xfe, 0x3a, 0x64, 0xa9, 0xb7, 0x43,
	0x96, 0x7a, 0x37, 0x64, 0xa9, 0x0f, 0x43, 0x96, 0xfa, 0xdf, 0x90, 0xa5, 0xce, 0x86, 0x2c, 0xf5,
	0x71, 0xc8, 0x52, 0xdf, 0x0d, 0x59, 0xea, 0xfb, 0x21, 0xeb, 0xfb, 0x3c, 0x64, 0xa9, 0xbf, 0x7f,
	0x62, 0x7d, 0x1f, 0x3e, 0xb1, 0xd4, 0xcb, 0x66, 0x57, 0x37, 0x5e, 0x75, 0x53, 0x03, 0xbd, 0x67,
	0x63, 0xd3, 0x74, 0xc6, 0x56, 0x9a, 0x2c, 0x8e, 0x74, 0x53, 0xdd, 0x1b, 0xfd, 0xca, 0xd9, 0x1b,
	0xa9, 0xd3, 0x46, 0xab, 0xab, 0xa7, 0xf1, 0x6b, 0xdb, 0xfb, 0xed, 0xfd, 0xd5, 0xbf, 0x35, 0x5a,
	0x61, 0xf2, 0x4b, 0xfc, 0xd1, 0x4f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf3, 0x03, 0xb5, 0x24, 0x01,
	0x11, 0x00, 0x00,
}

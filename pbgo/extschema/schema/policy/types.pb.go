// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/policy/types.proto

/*
	Package policy is a generated protocol buffer package.

	It is generated from these files:
		ves.io/schema/policy/types.proto

	It has these top-level messages:
		WafRuleControl
		WafInlineRuleControl
		WafAction
		PrefixMatchList
		AsnMatchList
		SimpleWafExclusionRule
		DenyInformation
		TlsFingerprintMatcherType
		PathMatcherType
		MatcherType
		MatcherTypeBasic
		CookieMatcherType
		ArgMatcherType
		HeaderMatcherType
		QueryParameterMatcherType
		HttpMethodMatcherType
		RoleMatcherType
		StringMatcherType
		IpMatcherType
		AsnMatcherType
		PortMatcherType
		URLItem
		URLMatcherType
		L4DestMatcherType
*/
package policy

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	google_protobuf1 "github.com/gogo/protobuf/types"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema_waf_rule_list "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/waf_rule_list"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// PolicySetType
//
// x-displayName: "Policy Set Type"
// The type a policy set indicates it's purpose.
// The primary use of the type is to determine the relative order of evaluation when there are multiple policy sets in a namespace. For example, a rate limiting
// policy set is evaluated before a network security policy set. The type is also used to enforce constraints on the action in rules that are part of the policy
// set. For example, a rate limiting policy set cannot contain a rule with an ALLOW or DENY action - the only valid actions are NEXT_POLICY and NEXT_POLICY_SET.
//
// - NETWORK_SECURITY Policy Set is used to apply L7 security to API requests
// - RATE_LIMITING Policy Set is used to rate limit API requests
type PolicySetType int32

const (
	// Network Security
	//
	// x-displayName: "Policy Set for Network Security"
	// Policy Set is used to apply L7 security to API requests
	NETWORK_SECURITY PolicySetType = 0
	// Rate Limiting
	//
	// x-displayName: "Policy Set for Rate Limiting"
	// Policy Set is used to rate limit API requests
	RATE_LIMITING PolicySetType = 1
	// Policy Based Routing
	//
	// x-displayName: "Policy Set for Policy Based Routing"
	// Policy Set is used to perform policy based routing
	POLICY_BASED_ROUTING PolicySetType = 2
	// WAF Exclusion
	//
	// x-displayName: "Policy Set for WAF Exclusion"
	// Policy Set is used to exclude WAF rules that result in false positives in the WAF module
	WAF_EXCLUSION PolicySetType = 3
)

var PolicySetType_name = map[int32]string{
	0: "NETWORK_SECURITY",
	1: "RATE_LIMITING",
	2: "POLICY_BASED_ROUTING",
	3: "WAF_EXCLUSION",
}
var PolicySetType_value = map[string]int32{
	"NETWORK_SECURITY":     0,
	"RATE_LIMITING":        1,
	"POLICY_BASED_ROUTING": 2,
	"WAF_EXCLUSION":        3,
}

func (PolicySetType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// PolicySetScope
//
// x-displayName: "Policy Set Scope"
// The scope of a policy set. This could be per namespace or per virtual host.
type PolicySetScope int32

const (
	// per namespace
	//
	// x-displayName: "Policy Set for Namespace"
	// Policy Set is used for the entire namespace.
	POLICY_SET_SCOPE_NAMESPACE PolicySetScope = 0
	// per virtual host
	//
	// x-displayName: "Policy Set for Namespace"
	// Policy Set is used for a specific virtual host.
	POLICY_SET_SCOPE_VIRTUAL_HOST PolicySetScope = 1
)

var PolicySetScope_name = map[int32]string{
	0: "POLICY_SET_SCOPE_NAMESPACE",
	1: "POLICY_SET_SCOPE_VIRTUAL_HOST",
}
var PolicySetScope_value = map[string]int32{
	"POLICY_SET_SCOPE_NAMESPACE":    0,
	"POLICY_SET_SCOPE_VIRTUAL_HOST": 1,
}

func (PolicySetScope) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// RuleCombiningAlgorithm
//
// x-displayName: "Rule Combining Algorithm"
// The rule combining algorithm for a policy determines how the list of rules in the policy is evaluated.
// If any of the rules is configured with a App Firewall action, the rule combining algorithm must be configured to be FIRST_MATCH.
//
// - FIRST_MATCH Rules are evaluated sequentially till a matching rule is identified
// - ALLOW_OVERRIDES Rules with an ALLOW action are evaluated prior to rules with a DENY action
// - DENY_OVERRIDES Rules with a DENY action are evaluated prior to rules with an ALLOW action
type RuleCombiningAlgorithm int32

const (
	// First Match
	//
	// x-displayName: "First Rule Match"
	// Rules are evaluated sequentially till a matching rule is identified
	FIRST_MATCH RuleCombiningAlgorithm = 0
	// Deny Overrides
	//
	// x-displayName: "Deny Rule Overrides"
	// Rules with a DENY action are evaluated prior to rules with an ALLOW action
	DENY_OVERRIDES RuleCombiningAlgorithm = 1
	// Allow Overrides
	//
	// x-displayName: "Allow Rule Overrides"
	// Rules with an ALLOW action are evaluated prior to rules with a DENY action
	ALLOW_OVERRIDES RuleCombiningAlgorithm = 2
)

var RuleCombiningAlgorithm_name = map[int32]string{
	0: "FIRST_MATCH",
	1: "DENY_OVERRIDES",
	2: "ALLOW_OVERRIDES",
}
var RuleCombiningAlgorithm_value = map[string]int32{
	"FIRST_MATCH":     0,
	"DENY_OVERRIDES":  1,
	"ALLOW_OVERRIDES": 2,
}

func (RuleCombiningAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// Transformer
//
// x-displayName: "Transformer"
// Transformers to be applied on the part of the request before matching.
type Transformer int32

const (
	// transformer none
	//
	// x-displayName: "Transformer None"
	// No transformers enabled
	TRANSFORMER_NONE Transformer = 0
	// lower case
	//
	// x-displayName: "Lower Case"
	// Convert string to lower case
	LOWER_CASE Transformer = 1
	// upper case
	//
	// x-displayName: "Upper Case"
	// Convert string to upper case
	UPPER_CASE Transformer = 2
	// base64 decode
	//
	// x-displayName: "Base64 Decode"
	// Decode string assuming base64 encoding
	BASE64_DECODE Transformer = 3
	// normalize path
	//
	// x-displayName: "Normalize Path"
	// Normalize URL path so that /a/b/../c will be transformed to /a/c
	NORMALIZE_PATH Transformer = 4
	// remove whitespace
	//
	// x-displayName: "Remove Whitespace"
	// Remove whitespaces
	REMOVE_WHITESPACE Transformer = 5
	// URL decode
	//
	// x-displayName: "URL Decode"
	// Decode string assuming URL encoding as per rfc1738
	URL_DECODE Transformer = 6
	// trim left
	//
	// x-displayName: "Trim Left"
	// Remove whitespace from the left side of the input string
	TRIM_LEFT Transformer = 7
	// trim right
	//
	// x-displayName: "Trim Right"
	// Remove whitespace from the right side of the input string
	TRIM_RIGHT Transformer = 8
	// trim
	//
	// x-displayName: "Trim"
	// Remove whitespace from the both sides of the input string
	TRIM Transformer = 9
)

var Transformer_name = map[int32]string{
	0: "TRANSFORMER_NONE",
	1: "LOWER_CASE",
	2: "UPPER_CASE",
	3: "BASE64_DECODE",
	4: "NORMALIZE_PATH",
	5: "REMOVE_WHITESPACE",
	6: "URL_DECODE",
	7: "TRIM_LEFT",
	8: "TRIM_RIGHT",
	9: "TRIM",
}
var Transformer_value = map[string]int32{
	"TRANSFORMER_NONE":  0,
	"LOWER_CASE":        1,
	"UPPER_CASE":        2,
	"BASE64_DECODE":     3,
	"NORMALIZE_PATH":    4,
	"REMOVE_WHITESPACE": 5,
	"URL_DECODE":        6,
	"TRIM_LEFT":         7,
	"TRIM_RIGHT":        8,
	"TRIM":              9,
}

func (Transformer) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// TLS known fingerprint class
//
// x-displayName: "TLS known fingerprint class"
// Specifies known TLS fingerprint classes
type KnownTlsFingerprintClass int32

const (
	// TLS_FINGERPRINT_NONE
	//
	// x-displayName: "TLS Fingerprint None"
	// No TLS fingerprint
	TLS_FINGERPRINT_NONE KnownTlsFingerprintClass = 0
	// ANY_MALICIOUS_FINGERPRINT
	//
	// x-displayName: "Any Known Malicious Fingerprint"
	// TLS fingerprints known to be associated with malicious clients
	ANY_MALICIOUS_FINGERPRINT KnownTlsFingerprintClass = 1
	// ADWARE
	//
	// x-displayName: "ADWARE"
	// TLS fingerprints known to be associated with adware
	ADWARE KnownTlsFingerprintClass = 2
	// ADWIND
	//
	// x-displayName: "ADWIND"
	// TLS fingerprints known to be associated with adwind
	ADWIND KnownTlsFingerprintClass = 3
	// DRIDEX
	//
	// x-displayName: "DRIDEX"
	// TLS fingerprints known to be associated with dridex
	DRIDEX KnownTlsFingerprintClass = 4
	// GOOTKIT
	//
	// x-displayName: "GOOTKIT"
	// TLS fingerprints known to be associated with gootkit
	GOOTKIT KnownTlsFingerprintClass = 5
	// GOZI
	//
	// x-displayName: "GOZI"
	// TLS fingerprints known to be associated with gozi
	GOZI KnownTlsFingerprintClass = 6
	// JBIFROST
	//
	// x-displayName: "JBIFROST"
	// TLS fingerprints known to be associated with jbifrost
	JBIFROST KnownTlsFingerprintClass = 7
	// QUAKBOT
	//
	// x-displayName: "QUAKBOT"
	// TLS fingerprints known to be associated with quakbot
	QUAKBOT KnownTlsFingerprintClass = 8
	// RANSOMWARE
	//
	// x-displayName: "RANSOMWARE"
	// TLS fingerprints known to be associated with ransomware
	RANSOMWARE KnownTlsFingerprintClass = 9
	// TROLDESH
	//
	// x-displayName: "TROLDESH"
	// TLS fingerprints known to be associated with troldesh
	TROLDESH KnownTlsFingerprintClass = 10
	// TOFSEE
	//
	// x-displayName: "TOFSEE"
	// TLS fingerprints known to be associated with tofsee
	TOFSEE KnownTlsFingerprintClass = 11
	// TORRENTLOCKER
	//
	// x-displayName: "TORRENTLOCKER"
	// TLS fingerprints known to be associated with torrentlocker
	TORRENTLOCKER KnownTlsFingerprintClass = 12
	// TRICKBOT
	//
	// x-displayName: "TRICKBOT"
	// TLS fingerprints known to be associated with trickbot
	TRICKBOT KnownTlsFingerprintClass = 13
)

var KnownTlsFingerprintClass_name = map[int32]string{
	0:  "TLS_FINGERPRINT_NONE",
	1:  "ANY_MALICIOUS_FINGERPRINT",
	2:  "ADWARE",
	3:  "ADWIND",
	4:  "DRIDEX",
	5:  "GOOTKIT",
	6:  "GOZI",
	7:  "JBIFROST",
	8:  "QUAKBOT",
	9:  "RANSOMWARE",
	10: "TROLDESH",
	11: "TOFSEE",
	12: "TORRENTLOCKER",
	13: "TRICKBOT",
}
var KnownTlsFingerprintClass_value = map[string]int32{
	"TLS_FINGERPRINT_NONE":      0,
	"ANY_MALICIOUS_FINGERPRINT": 1,
	"ADWARE":                    2,
	"ADWIND":                    3,
	"DRIDEX":                    4,
	"GOOTKIT":                   5,
	"GOZI":                      6,
	"JBIFROST":                  7,
	"QUAKBOT":                   8,
	"RANSOMWARE":                9,
	"TROLDESH":                  10,
	"TOFSEE":                    11,
	"TORRENTLOCKER":             12,
	"TRICKBOT":                  13,
}

func (KnownTlsFingerprintClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{4}
}

// CountryCode
//
// x-displayName: "Country Code"
// ISO 3166 Aplpha-2 country codes
// Note that we use the numeric code from ISO 3166 as the value
// TBD enumerate all country codes here
type CountryCode int32

const (
	// x-displayName: "NONE"
	// None
	COUNTRY_NONE CountryCode = 0
	// x-displayName: "AF"
	// Afghanistan
	COUNTRY_AF CountryCode = 4
	// x-displayName: "AL"
	// Albania
	COUNTRY_AL CountryCode = 8
)

var CountryCode_name = map[int32]string{
	0: "COUNTRY_NONE",
	4: "COUNTRY_AF",
	8: "COUNTRY_AL",
}
var CountryCode_value = map[string]int32{
	"COUNTRY_NONE": 0,
	"COUNTRY_AF":   4,
	"COUNTRY_AL":   8,
}

func (CountryCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

// Rule Action
//
// x-displayName: "Rule Action"
// The rule action determines the disposition of the input request API. If a policy matches a rule with an ALLOW action, the processing of the request proceeds
// forward. If it matches a rule with a DENY action, the processing of the request is terminated and an appropriate message/code returned to the originator. If
// it matches a rule with a NEXT_POLICY_SET action, evaluation of the current policy set terminates and evaluation of the next policy set in the chain begins.
type RuleAction int32

const (
	// DENY
	//
	// x-displayName: "Deny"
	// Deny the request.
	DENY RuleAction = 0
	// ALLOW
	//
	// x-displayName: "Allow"
	// Allow the request to proceed.
	ALLOW RuleAction = 1
	// NEXT_POLICY_SET
	//
	// x-displayName: "Next Policy Set"
	// Terminate evaluation of the current policy set and begin evaluating the next policy set in the chain. Note that the evaluation of any remaining policies
	// in the current policy set is skipped.
	NEXT_POLICY_SET RuleAction = 2
	// NEXT_POLICY
	//
	// x-displayName: "Next Policy"
	// Terminate evaluation of the current policy and begin evaluating the next policy in the policy set. Note that the evaluation of any remaining rules in the
	// current policy is skipped.
	NEXT_POLICY RuleAction = 3
)

var RuleAction_name = map[int32]string{
	0: "DENY",
	1: "ALLOW",
	2: "NEXT_POLICY_SET",
	3: "NEXT_POLICY",
}
var RuleAction_value = map[string]int32{
	"DENY":            0,
	"ALLOW":           1,
	"NEXT_POLICY_SET": 2,
	"NEXT_POLICY":     3,
}

func (RuleAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

// App Firewall Rule Control
//
// x-displayName: "App Firewall Rule Control"
// App Firewall rule changes to be applied for this request
type WafRuleControl struct {
	// Exclude Rule IDs
	//
	// x-displayName: "Exclude App Firewall Rule List"
	// App Firewall Rule List specifying the rule IDs to be excluded for this request
	ExcludeRuleIds []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1,rep,name=exclude_rule_ids,json=excludeRuleIds" json:"exclude_rule_ids,omitempty"`
}

func (m *WafRuleControl) Reset()                    { *m = WafRuleControl{} }
func (*WafRuleControl) ProtoMessage()               {}
func (*WafRuleControl) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *WafRuleControl) GetExcludeRuleIds() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ExcludeRuleIds
	}
	return nil
}

// App Firewall Rule Control with inline Rule IDs
//
// x-displayName: "App Firewall Rule Control with inline Rule IDs"
// App Firewall rule changes to be applied for this request
type WafInlineRuleControl struct {
	// Exclude Rule IDs
	//
	// x-displayName: "Exclude App Firewall Rule IDs"
	// App Firewall Rule IDs to be excluded for this request
	ExcludeRuleIds []ves_io_schema_waf_rule_list.WafRuleID `protobuf:"varint,1,rep,packed,name=exclude_rule_ids,json=excludeRuleIds,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"exclude_rule_ids,omitempty"`
}

func (m *WafInlineRuleControl) Reset()                    { *m = WafInlineRuleControl{} }
func (*WafInlineRuleControl) ProtoMessage()               {}
func (*WafInlineRuleControl) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *WafInlineRuleControl) GetExcludeRuleIds() []ves_io_schema_waf_rule_list.WafRuleID {
	if m != nil {
		return m.ExcludeRuleIds
	}
	return nil
}

// App Firewall Action
//
// x-displayName: "App Firewall Action"
// Modify App Firewall behavior for a matching request. The modification could either be to entirely skip firewall processing or to customize the firewall rules
// to be applied as defined by App Firewall Rule Control settings.
type WafAction struct {
	// Select Waf Action Type
	//
	// x-displayName: "Select App Firewall Action Type"
	// x-required
	// Select application firewall Action, skip waf processing or skip rules
	//
	// Types that are valid to be assigned to ActionType:
	//	*WafAction_None
	//	*WafAction_WafSkipProcessing
	//	*WafAction_WafRuleControl
	//	*WafAction_WafInlineRuleControl
	ActionType isWafAction_ActionType `protobuf_oneof:"action_type"`
}

func (m *WafAction) Reset()                    { *m = WafAction{} }
func (*WafAction) ProtoMessage()               {}
func (*WafAction) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isWafAction_ActionType interface {
	isWafAction_ActionType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WafAction_None struct {
	None *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=none,oneof"`
}
type WafAction_WafSkipProcessing struct {
	WafSkipProcessing *ves_io_schema4.Empty `protobuf:"bytes,1,opt,name=waf_skip_processing,json=wafSkipProcessing,oneof"`
}
type WafAction_WafRuleControl struct {
	WafRuleControl *WafRuleControl `protobuf:"bytes,2,opt,name=waf_rule_control,json=wafRuleControl,oneof"`
}
type WafAction_WafInlineRuleControl struct {
	WafInlineRuleControl *WafInlineRuleControl `protobuf:"bytes,4,opt,name=waf_inline_rule_control,json=wafInlineRuleControl,oneof"`
}

func (*WafAction_None) isWafAction_ActionType()                 {}
func (*WafAction_WafSkipProcessing) isWafAction_ActionType()    {}
func (*WafAction_WafRuleControl) isWafAction_ActionType()       {}
func (*WafAction_WafInlineRuleControl) isWafAction_ActionType() {}

func (m *WafAction) GetActionType() isWafAction_ActionType {
	if m != nil {
		return m.ActionType
	}
	return nil
}

func (m *WafAction) GetNone() *ves_io_schema4.Empty {
	if x, ok := m.GetActionType().(*WafAction_None); ok {
		return x.None
	}
	return nil
}

func (m *WafAction) GetWafSkipProcessing() *ves_io_schema4.Empty {
	if x, ok := m.GetActionType().(*WafAction_WafSkipProcessing); ok {
		return x.WafSkipProcessing
	}
	return nil
}

func (m *WafAction) GetWafRuleControl() *WafRuleControl {
	if x, ok := m.GetActionType().(*WafAction_WafRuleControl); ok {
		return x.WafRuleControl
	}
	return nil
}

func (m *WafAction) GetWafInlineRuleControl() *WafInlineRuleControl {
	if x, ok := m.GetActionType().(*WafAction_WafInlineRuleControl); ok {
		return x.WafInlineRuleControl
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WafAction) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WafAction_OneofMarshaler, _WafAction_OneofUnmarshaler, _WafAction_OneofSizer, []interface{}{
		(*WafAction_None)(nil),
		(*WafAction_WafSkipProcessing)(nil),
		(*WafAction_WafRuleControl)(nil),
		(*WafAction_WafInlineRuleControl)(nil),
	}
}

func _WafAction_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WafAction)
	// action_type
	switch x := m.ActionType.(type) {
	case *WafAction_None:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.None); err != nil {
			return err
		}
	case *WafAction_WafSkipProcessing:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WafSkipProcessing); err != nil {
			return err
		}
	case *WafAction_WafRuleControl:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WafRuleControl); err != nil {
			return err
		}
	case *WafAction_WafInlineRuleControl:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WafInlineRuleControl); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("WafAction.ActionType has unexpected type %T", x)
	}
	return nil
}

func _WafAction_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WafAction)
	switch tag {
	case 3: // action_type.none
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ActionType = &WafAction_None{msg}
		return true, err
	case 1: // action_type.waf_skip_processing
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ActionType = &WafAction_WafSkipProcessing{msg}
		return true, err
	case 2: // action_type.waf_rule_control
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WafRuleControl)
		err := b.DecodeMessage(msg)
		m.ActionType = &WafAction_WafRuleControl{msg}
		return true, err
	case 4: // action_type.waf_inline_rule_control
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WafInlineRuleControl)
		err := b.DecodeMessage(msg)
		m.ActionType = &WafAction_WafInlineRuleControl{msg}
		return true, err
	default:
		return false, nil
	}
}

func _WafAction_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WafAction)
	// action_type
	switch x := m.ActionType.(type) {
	case *WafAction_None:
		s := proto.Size(x.None)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WafAction_WafSkipProcessing:
		s := proto.Size(x.WafSkipProcessing)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WafAction_WafRuleControl:
		s := proto.Size(x.WafRuleControl)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WafAction_WafInlineRuleControl:
		s := proto.Size(x.WafInlineRuleControl)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Prefix Match List
//
// x-displayName: "IP Prefix Match List"
// List of IPv4 Prefix strings to match against.
type PrefixMatchList struct {
	// ip prefixes
	//
	// x-displayName: "IP Prefix List"
	// x-example: "192.168.20.0/24"
	// x-required
	// List of IPv4 prefix strings.
	IpPrefixes []string `protobuf:"bytes,1,rep,name=ip_prefixes,json=ipPrefixes" json:"ip_prefixes,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Match Result"
	// Invert the match result.
	InvertMatch bool `protobuf:"varint,2,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
}

func (m *PrefixMatchList) Reset()                    { *m = PrefixMatchList{} }
func (*PrefixMatchList) ProtoMessage()               {}
func (*PrefixMatchList) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *PrefixMatchList) GetIpPrefixes() []string {
	if m != nil {
		return m.IpPrefixes
	}
	return nil
}

func (m *PrefixMatchList) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// Asn Match List
//
// x-displayName: "ASN Match List"
// An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy.
type AsnMatchList struct {
	// as numbers
	//
	// x-displayName: "AS Numbers"
	// x-required
	// x-example: "[713, 7932, 847325, 4683, 15269, 1000001]"
	// An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy.
	AsNumbers []uint32 `protobuf:"varint,1,rep,packed,name=as_numbers,json=asNumbers" json:"as_numbers,omitempty"`
}

func (m *AsnMatchList) Reset()                    { *m = AsnMatchList{} }
func (*AsnMatchList) ProtoMessage()               {}
func (*AsnMatchList) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *AsnMatchList) GetAsNumbers() []uint32 {
	if m != nil {
		return m.AsNumbers
	}
	return nil
}

// SimpleWafExclusionRule
//
// x-displayName: "Simple WAF Exclusion Rule"
// Simple WAF exclusion rule specifies a simple set of match conditions to be matched to skip a list of WAF rule ids
type SimpleWafExclusionRule struct {
	// Name
	//
	// x-displayName: "Exclusion Rule Name"
	// x-example: "login-exclusions"
	// x-required
	// Exclusion rule name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Description
	//
	// x-displayName: "Description"
	// x-example: "exclusions for login API seen due to false positives on september 4 2020"
	// Description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Domain
	//
	// x-displayName: "Domain"
	// x-example: "mybloggingwebsite.org"
	// x-required
	// Domain to be matched
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*SimpleWafExclusionRule_AnyDomain
	//	*SimpleWafExclusionRule_DomainRegex
	DomainChoice isSimpleWafExclusionRule_DomainChoice `protobuf_oneof:"domain_choice"`
	// Path Regex
	//
	// x-displayName: "Path Regex"
	// x-example: "/blog_id/.*"
	// x-required
	// path regex to be matched
	PathRegex string `protobuf:"bytes,6,opt,name=path_regex,json=pathRegex,proto3" json:"path_regex,omitempty"`
	// Methods
	//
	// x-displayName: "Methods"
	// x-example: "GET"
	// methods to be matched
	Methods []ves_io_schema4.HttpMethod `protobuf:"varint,7,rep,packed,name=methods,enum=ves.io.schema.HttpMethod" json:"methods,omitempty"`
	// Exclude WAF Rules
	//
	// x-displayName: "Exclude WAF Rules"
	// x-example: "[942260, 942200]"
	// x-required
	// WAF Rules to be excluded when match conditions are met
	ExcludeRuleIds []ves_io_schema_waf_rule_list.WafRuleID `protobuf:"varint,8,rep,packed,name=exclude_rule_ids,json=excludeRuleIds,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"exclude_rule_ids,omitempty"`
	// expiration timestamp
	//
	// x-displayName: "Expiration Timestamp"
	// x-example: "2019-12-31:44:34.171543432Z"
	// The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in
	// the configuration but is not applied anymore.
	ExpirationTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,9,opt,name=expiration_timestamp,json=expirationTimestamp" json:"expiration_timestamp,omitempty"`
}

func (m *SimpleWafExclusionRule) Reset()                    { *m = SimpleWafExclusionRule{} }
func (*SimpleWafExclusionRule) ProtoMessage()               {}
func (*SimpleWafExclusionRule) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

type isSimpleWafExclusionRule_DomainChoice interface {
	isSimpleWafExclusionRule_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SimpleWafExclusionRule_AnyDomain struct {
	AnyDomain *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=any_domain,json=anyDomain,oneof"`
}
type SimpleWafExclusionRule_DomainRegex struct {
	DomainRegex string `protobuf:"bytes,5,opt,name=domain_regex,json=domainRegex,proto3,oneof"`
}

func (*SimpleWafExclusionRule_AnyDomain) isSimpleWafExclusionRule_DomainChoice()   {}
func (*SimpleWafExclusionRule_DomainRegex) isSimpleWafExclusionRule_DomainChoice() {}

func (m *SimpleWafExclusionRule) GetDomainChoice() isSimpleWafExclusionRule_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SimpleWafExclusionRule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SimpleWafExclusionRule) GetAnyDomain() *ves_io_schema4.Empty {
	if x, ok := m.GetDomainChoice().(*SimpleWafExclusionRule_AnyDomain); ok {
		return x.AnyDomain
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetDomainRegex() string {
	if x, ok := m.GetDomainChoice().(*SimpleWafExclusionRule_DomainRegex); ok {
		return x.DomainRegex
	}
	return ""
}

func (m *SimpleWafExclusionRule) GetPathRegex() string {
	if m != nil {
		return m.PathRegex
	}
	return ""
}

func (m *SimpleWafExclusionRule) GetMethods() []ves_io_schema4.HttpMethod {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetExcludeRuleIds() []ves_io_schema_waf_rule_list.WafRuleID {
	if m != nil {
		return m.ExcludeRuleIds
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetExpirationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SimpleWafExclusionRule) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SimpleWafExclusionRule_OneofMarshaler, _SimpleWafExclusionRule_OneofUnmarshaler, _SimpleWafExclusionRule_OneofSizer, []interface{}{
		(*SimpleWafExclusionRule_AnyDomain)(nil),
		(*SimpleWafExclusionRule_DomainRegex)(nil),
	}
}

func _SimpleWafExclusionRule_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SimpleWafExclusionRule)
	// domain_choice
	switch x := m.DomainChoice.(type) {
	case *SimpleWafExclusionRule_AnyDomain:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyDomain); err != nil {
			return err
		}
	case *SimpleWafExclusionRule_DomainRegex:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DomainRegex)
	case nil:
	default:
		return fmt.Errorf("SimpleWafExclusionRule.DomainChoice has unexpected type %T", x)
	}
	return nil
}

func _SimpleWafExclusionRule_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SimpleWafExclusionRule)
	switch tag {
	case 4: // domain_choice.any_domain
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DomainChoice = &SimpleWafExclusionRule_AnyDomain{msg}
		return true, err
	case 5: // domain_choice.domain_regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DomainChoice = &SimpleWafExclusionRule_DomainRegex{x}
		return true, err
	default:
		return false, nil
	}
}

func _SimpleWafExclusionRule_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SimpleWafExclusionRule)
	// domain_choice
	switch x := m.DomainChoice.(type) {
	case *SimpleWafExclusionRule_AnyDomain:
		s := proto.Size(x.AnyDomain)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SimpleWafExclusionRule_DomainRegex:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DomainRegex)))
		n += len(x.DomainRegex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Deny Information
//
// x-displayName: "Deny Information"
// Detailed information including HTTP response code and error message to be sent when the policy or policy set action is DENY.
type DenyInformation struct {
	// response_code
	//
	// x-displayName: "HTTP Response Code"
	// x-example: 400
	// The HTTP status code to use in the response. The default code is Forbidden (403).
	ResponseCode uint32 `protobuf:"varint,1,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	// error_message
	//
	// x-displayName: "Error Message"
	// x-example: "Denied because the URL path contains an unknown object type"
	// An error message associated with a DENY action in a policy or policy set, that is meaningful to the end user. Note that this error message is included
	// in the body but does not constitute the entire body.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *DenyInformation) Reset()                    { *m = DenyInformation{} }
func (*DenyInformation) ProtoMessage()               {}
func (*DenyInformation) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *DenyInformation) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *DenyInformation) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// TlsFingerprintMatcherType
//
// x-displayName: "TLS Fingerprint Matcher"
// A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known
// classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input
// fingerprint is not one of the excluded values.
type TlsFingerprintMatcherType struct {
	// classes
	//
	// x-displayName: "TLS fingerprint classes"
	// x-example: "['ADWARE', 'TRICKBOT']
	// A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.
	Classes []KnownTlsFingerprintClass `protobuf:"varint,1,rep,packed,name=classes,enum=ves.io.schema.policy.KnownTlsFingerprintClass" json:"classes,omitempty"`
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']
	// A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.
	ExactValues []string `protobuf:"bytes,2,rep,name=exact_values,json=exactValues" json:"exact_values,omitempty"`
	// excluded values
	//
	// x-displayName: "Excluded Values"
	// x-example: "['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']
	// A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one
	// or more known TLS fingerprint classes in the enclosing matcher.
	ExcludedValues []string `protobuf:"bytes,3,rep,name=excluded_values,json=excludedValues" json:"excluded_values,omitempty"`
}

func (m *TlsFingerprintMatcherType) Reset()                    { *m = TlsFingerprintMatcherType{} }
func (*TlsFingerprintMatcherType) ProtoMessage()               {}
func (*TlsFingerprintMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *TlsFingerprintMatcherType) GetClasses() []KnownTlsFingerprintClass {
	if m != nil {
		return m.Classes
	}
	return nil
}

func (m *TlsFingerprintMatcherType) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *TlsFingerprintMatcherType) GetExcludedValues() []string {
	if m != nil {
		return m.ExcludedValues
	}
	return nil
}

// PathMatcherType
//
// x-displayName: "Path Matcher"
// A path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set
// of supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.
type PathMatcherType struct {
	// prefix values
	//
	// x-displayName: "Prefix Values"
	// x-example: "['/api/web/namespaces/project179/users/', '/api/config/namespaces/', '/api/data/namespaces/']"
	// A list of path prefix values to match the input HTTP path against.
	PrefixValues []string `protobuf:"bytes,1,rep,name=prefix_values,json=prefixValues" json:"prefix_values,omitempty"`
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']"
	// A list of exact path values to match the input HTTP path against.
	ExactValues []string `protobuf:"bytes,2,rep,name=exact_values,json=exactValues" json:"exact_values,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$', '/api/data/namespaces/proj404/virtual_hosts/([a-z]([-a-z0-9]*[a-z0-9])?)$']"
	// A list of regular expressions to match the input HTTP path against.
	RegexValues []string `protobuf:"bytes,3,rep,name=regex_values,json=regexValues" json:"regex_values,omitempty"`
	// transformers
	//
	// x-displayName: "Transformers"
	// x-example: "[BASE64_DECODE, LOWER_CASE]
	// An ordered list of transformers (starting from index 0) to be applied to the path before matching.
	Transformers []Transformer `protobuf:"varint,4,rep,packed,name=transformers,enum=ves.io.schema.policy.Transformer" json:"transformers,omitempty"`
}

func (m *PathMatcherType) Reset()                    { *m = PathMatcherType{} }
func (*PathMatcherType) ProtoMessage()               {}
func (*PathMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *PathMatcherType) GetPrefixValues() []string {
	if m != nil {
		return m.PrefixValues
	}
	return nil
}

func (m *PathMatcherType) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *PathMatcherType) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

func (m *PathMatcherType) GetTransformers() []Transformer {
	if m != nil {
		return m.Transformers
	}
	return nil
}

// MatcherType
//
// x-displayName: "Matcher"
// A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set
// of supported match criteria includes a list of exact values and a list of regular expressions.
type MatcherType struct {
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
	// A list of exact values to match the input against.
	ExactValues []string `protobuf:"bytes,1,rep,name=exact_values,json=exactValues" json:"exact_values,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^new .*$', 'san f.*', '.* del .*']"
	// A list of regular expressions to match the input against.
	RegexValues []string `protobuf:"bytes,2,rep,name=regex_values,json=regexValues" json:"regex_values,omitempty"`
	// transformers
	//
	// x-displayName: "Transformers"
	// x-example: "[BASE64_DECODE, LOWER_CASE]
	// An ordered list of transformers (starting from index 0) to be applied to the path before matching.
	Transformers []Transformer `protobuf:"varint,3,rep,packed,name=transformers,enum=ves.io.schema.policy.Transformer" json:"transformers,omitempty"`
}

func (m *MatcherType) Reset()                    { *m = MatcherType{} }
func (*MatcherType) ProtoMessage()               {}
func (*MatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *MatcherType) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *MatcherType) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

func (m *MatcherType) GetTransformers() []Transformer {
	if m != nil {
		return m.Transformers
	}
	return nil
}

// MatcherTypeBasic
//
// x-displayName: "Matcher"
// A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set
// of supported match criteria includes a list of exact values and a list of regular expressions.
type MatcherTypeBasic struct {
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
	// A list of exact values to match the input against.
	ExactValues []string `protobuf:"bytes,1,rep,name=exact_values,json=exactValues" json:"exact_values,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^new .*$', 'san f.*', '.* del .*']"
	// A list of regular expressions to match the input against.
	RegexValues []string `protobuf:"bytes,2,rep,name=regex_values,json=regexValues" json:"regex_values,omitempty"`
}

func (m *MatcherTypeBasic) Reset()                    { *m = MatcherTypeBasic{} }
func (*MatcherTypeBasic) ProtoMessage()               {}
func (*MatcherTypeBasic) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *MatcherTypeBasic) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *MatcherTypeBasic) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

// CookieMatcherType
//
// x-displayName: "Cookie Matcher"
// A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each
// cookie in the request.
// A cookie matcher can check for one of the following:
// * Presence or absence of the cookie
// * At least one of the values for the cookie in the request satisfies the MatcherType item
type CookieMatcherType struct {
	// name
	//
	// x-displayName: "Cookie Name"
	// x-example: "Session"
	// x-required
	// A case-sensitive cookie name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*CookieMatcherType_Presence
	//	*CookieMatcherType_CheckPresent
	//	*CookieMatcherType_CheckNotPresent
	//	*CookieMatcherType_Item
	Match isCookieMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Matcher"
	// Invert Match of the expression defined
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *CookieMatcherType) Reset()                    { *m = CookieMatcherType{} }
func (*CookieMatcherType) ProtoMessage()               {}
func (*CookieMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

type isCookieMatcherType_Match interface {
	isCookieMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CookieMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof"`
}
type CookieMatcherType_CheckPresent struct {
	CheckPresent *ves_io_schema4.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,oneof"`
}
type CookieMatcherType_CheckNotPresent struct {
	CheckNotPresent *ves_io_schema4.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,oneof"`
}
type CookieMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,oneof"`
}

func (*CookieMatcherType_Presence) isCookieMatcherType_Match()        {}
func (*CookieMatcherType_CheckPresent) isCookieMatcherType_Match()    {}
func (*CookieMatcherType_CheckNotPresent) isCookieMatcherType_Match() {}
func (*CookieMatcherType_Item) isCookieMatcherType_Match()            {}

func (m *CookieMatcherType) GetMatch() isCookieMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *CookieMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CookieMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*CookieMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *CookieMatcherType) GetCheckPresent() *ves_io_schema4.Empty {
	if x, ok := m.GetMatch().(*CookieMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *CookieMatcherType) GetCheckNotPresent() *ves_io_schema4.Empty {
	if x, ok := m.GetMatch().(*CookieMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *CookieMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*CookieMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *CookieMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CookieMatcherType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CookieMatcherType_OneofMarshaler, _CookieMatcherType_OneofUnmarshaler, _CookieMatcherType_OneofSizer, []interface{}{
		(*CookieMatcherType_Presence)(nil),
		(*CookieMatcherType_CheckPresent)(nil),
		(*CookieMatcherType_CheckNotPresent)(nil),
		(*CookieMatcherType_Item)(nil),
	}
}

func _CookieMatcherType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CookieMatcherType)
	// match
	switch x := m.Match.(type) {
	case *CookieMatcherType_Presence:
		t := uint64(0)
		if x.Presence {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CookieMatcherType_CheckPresent:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CheckPresent); err != nil {
			return err
		}
	case *CookieMatcherType_CheckNotPresent:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CheckNotPresent); err != nil {
			return err
		}
	case *CookieMatcherType_Item:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Item); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CookieMatcherType.Match has unexpected type %T", x)
	}
	return nil
}

func _CookieMatcherType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CookieMatcherType)
	switch tag {
	case 2: // match.presence
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Match = &CookieMatcherType_Presence{x != 0}
		return true, err
	case 7: // match.check_present
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Match = &CookieMatcherType_CheckPresent{msg}
		return true, err
	case 8: // match.check_not_present
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Match = &CookieMatcherType_CheckNotPresent{msg}
		return true, err
	case 3: // match.item
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatcherType)
		err := b.DecodeMessage(msg)
		m.Match = &CookieMatcherType_Item{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CookieMatcherType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CookieMatcherType)
	// match
	switch x := m.Match.(type) {
	case *CookieMatcherType_Presence:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *CookieMatcherType_CheckPresent:
		s := proto.Size(x.CheckPresent)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CookieMatcherType_CheckNotPresent:
		s := proto.Size(x.CheckNotPresent)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CookieMatcherType_Item:
		s := proto.Size(x.Item)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ArgMatcherType
//
// x-displayName: "Argument Matcher"
// A argument matcher specifies the name of a single argument in the body and the criteria to match it.
// A argument matcher can check for one of the following:
// * Presence or absence of the argument
// * At least one of the values for the argument in the request satisfies the MatcherType item
type ArgMatcherType struct {
	// name
	//
	// x-displayName: "Argument Name"
	// x-example: "name"
	// x-example: "phones[_]"
	// x-example: "cars.make.toyota.models[1]"
	// x-example: "cars.make.honda.models[_]"
	// x-example: "cars.make[_].models[_]"
	// x-required
	// A case-sensitive JSON path in the HTTP request body.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*ArgMatcherType_Presence
	//	*ArgMatcherType_CheckPresent
	//	*ArgMatcherType_CheckNotPresent
	//	*ArgMatcherType_Item
	Match isArgMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Matcher"
	// Invert Match of the expression defined
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *ArgMatcherType) Reset()                    { *m = ArgMatcherType{} }
func (*ArgMatcherType) ProtoMessage()               {}
func (*ArgMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

type isArgMatcherType_Match interface {
	isArgMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ArgMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof"`
}
type ArgMatcherType_CheckPresent struct {
	CheckPresent *ves_io_schema4.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,oneof"`
}
type ArgMatcherType_CheckNotPresent struct {
	CheckNotPresent *ves_io_schema4.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,oneof"`
}
type ArgMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,oneof"`
}

func (*ArgMatcherType_Presence) isArgMatcherType_Match()        {}
func (*ArgMatcherType_CheckPresent) isArgMatcherType_Match()    {}
func (*ArgMatcherType_CheckNotPresent) isArgMatcherType_Match() {}
func (*ArgMatcherType_Item) isArgMatcherType_Match()            {}

func (m *ArgMatcherType) GetMatch() isArgMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ArgMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArgMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*ArgMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *ArgMatcherType) GetCheckPresent() *ves_io_schema4.Empty {
	if x, ok := m.GetMatch().(*ArgMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *ArgMatcherType) GetCheckNotPresent() *ves_io_schema4.Empty {
	if x, ok := m.GetMatch().(*ArgMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *ArgMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*ArgMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *ArgMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ArgMatcherType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ArgMatcherType_OneofMarshaler, _ArgMatcherType_OneofUnmarshaler, _ArgMatcherType_OneofSizer, []interface{}{
		(*ArgMatcherType_Presence)(nil),
		(*ArgMatcherType_CheckPresent)(nil),
		(*ArgMatcherType_CheckNotPresent)(nil),
		(*ArgMatcherType_Item)(nil),
	}
}

func _ArgMatcherType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ArgMatcherType)
	// match
	switch x := m.Match.(type) {
	case *ArgMatcherType_Presence:
		t := uint64(0)
		if x.Presence {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ArgMatcherType_CheckPresent:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CheckPresent); err != nil {
			return err
		}
	case *ArgMatcherType_CheckNotPresent:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CheckNotPresent); err != nil {
			return err
		}
	case *ArgMatcherType_Item:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Item); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ArgMatcherType.Match has unexpected type %T", x)
	}
	return nil
}

func _ArgMatcherType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ArgMatcherType)
	switch tag {
	case 2: // match.presence
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Match = &ArgMatcherType_Presence{x != 0}
		return true, err
	case 7: // match.check_present
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Match = &ArgMatcherType_CheckPresent{msg}
		return true, err
	case 8: // match.check_not_present
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Match = &ArgMatcherType_CheckNotPresent{msg}
		return true, err
	case 3: // match.item
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatcherType)
		err := b.DecodeMessage(msg)
		m.Match = &ArgMatcherType_Item{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ArgMatcherType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ArgMatcherType)
	// match
	switch x := m.Match.(type) {
	case *ArgMatcherType_Presence:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *ArgMatcherType_CheckPresent:
		s := proto.Size(x.CheckPresent)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ArgMatcherType_CheckNotPresent:
		s := proto.Size(x.CheckNotPresent)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ArgMatcherType_Item:
		s := proto.Size(x.Item)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// HeaderMatcherType
//
// x-displayName: "Header Matcher"
// A header matcher specifies the name of a single HTTP header and the criteria for the input request to match it. The input has a list of actual values for each
// header name in the original HTTP request.
// A header matcher can check for one of the following:
// * Presence or absence of the header in the input
// * At least one of the values for the header in the input satisfies the MatcherType item
type HeaderMatcherType struct {
	// name
	//
	// x-displayName: "Header Name"
	// x-example: "Accept-Encoding"
	// x-required
	// A case-insensitive HTTP header name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*HeaderMatcherType_Presence
	//	*HeaderMatcherType_CheckPresent
	//	*HeaderMatcherType_CheckNotPresent
	//	*HeaderMatcherType_Item
	Match isHeaderMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Header Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *HeaderMatcherType) Reset()                    { *m = HeaderMatcherType{} }
func (*HeaderMatcherType) ProtoMessage()               {}
func (*HeaderMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

type isHeaderMatcherType_Match interface {
	isHeaderMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof"`
}
type HeaderMatcherType_CheckPresent struct {
	CheckPresent *ves_io_schema4.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,oneof"`
}
type HeaderMatcherType_CheckNotPresent struct {
	CheckNotPresent *ves_io_schema4.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,oneof"`
}
type HeaderMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,oneof"`
}

func (*HeaderMatcherType_Presence) isHeaderMatcherType_Match()        {}
func (*HeaderMatcherType_CheckPresent) isHeaderMatcherType_Match()    {}
func (*HeaderMatcherType_CheckNotPresent) isHeaderMatcherType_Match() {}
func (*HeaderMatcherType_Item) isHeaderMatcherType_Match()            {}

func (m *HeaderMatcherType) GetMatch() isHeaderMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *HeaderMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*HeaderMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *HeaderMatcherType) GetCheckPresent() *ves_io_schema4.Empty {
	if x, ok := m.GetMatch().(*HeaderMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *HeaderMatcherType) GetCheckNotPresent() *ves_io_schema4.Empty {
	if x, ok := m.GetMatch().(*HeaderMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *HeaderMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*HeaderMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *HeaderMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HeaderMatcherType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HeaderMatcherType_OneofMarshaler, _HeaderMatcherType_OneofUnmarshaler, _HeaderMatcherType_OneofSizer, []interface{}{
		(*HeaderMatcherType_Presence)(nil),
		(*HeaderMatcherType_CheckPresent)(nil),
		(*HeaderMatcherType_CheckNotPresent)(nil),
		(*HeaderMatcherType_Item)(nil),
	}
}

func _HeaderMatcherType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HeaderMatcherType)
	// match
	switch x := m.Match.(type) {
	case *HeaderMatcherType_Presence:
		t := uint64(0)
		if x.Presence {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *HeaderMatcherType_CheckPresent:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CheckPresent); err != nil {
			return err
		}
	case *HeaderMatcherType_CheckNotPresent:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CheckNotPresent); err != nil {
			return err
		}
	case *HeaderMatcherType_Item:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Item); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HeaderMatcherType.Match has unexpected type %T", x)
	}
	return nil
}

func _HeaderMatcherType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HeaderMatcherType)
	switch tag {
	case 2: // match.presence
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Match = &HeaderMatcherType_Presence{x != 0}
		return true, err
	case 7: // match.check_present
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Match = &HeaderMatcherType_CheckPresent{msg}
		return true, err
	case 8: // match.check_not_present
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Match = &HeaderMatcherType_CheckNotPresent{msg}
		return true, err
	case 3: // match.item
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatcherType)
		err := b.DecodeMessage(msg)
		m.Match = &HeaderMatcherType_Item{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HeaderMatcherType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HeaderMatcherType)
	// match
	switch x := m.Match.(type) {
	case *HeaderMatcherType_Presence:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *HeaderMatcherType_CheckPresent:
		s := proto.Size(x.CheckPresent)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HeaderMatcherType_CheckNotPresent:
		s := proto.Size(x.CheckNotPresent)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HeaderMatcherType_Item:
		s := proto.Size(x.Item)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// QueryParameterMatcherType
//
// x-displayName: "Query Parameter Matcher"
// A query parameter matcher specifies the name of a single query parameter and the criteria for the input request to match it. The input has a list of actual
// values for each query parameter name in the original HTTP request.
// A query parameter matcher can check for one of the following:
// * Presence or absence of the query parameter in the input
// * At least one of the values for the query parameter in the input satisfies the MatcherType item
type QueryParameterMatcherType struct {
	// key
	//
	// x-displayName: "Query Parameter Name"
	// x-example: "sourceid"
	// x-required
	// A case-sensitive HTTP query parameter name.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*QueryParameterMatcherType_Presence
	//	*QueryParameterMatcherType_CheckPresent
	//	*QueryParameterMatcherType_CheckNotPresent
	//	*QueryParameterMatcherType_Item
	Match isQueryParameterMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Query Parameter Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *QueryParameterMatcherType) Reset()                    { *m = QueryParameterMatcherType{} }
func (*QueryParameterMatcherType) ProtoMessage()               {}
func (*QueryParameterMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

type isQueryParameterMatcherType_Match interface {
	isQueryParameterMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryParameterMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof"`
}
type QueryParameterMatcherType_CheckPresent struct {
	CheckPresent *ves_io_schema4.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,oneof"`
}
type QueryParameterMatcherType_CheckNotPresent struct {
	CheckNotPresent *ves_io_schema4.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,oneof"`
}
type QueryParameterMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,oneof"`
}

func (*QueryParameterMatcherType_Presence) isQueryParameterMatcherType_Match()        {}
func (*QueryParameterMatcherType_CheckPresent) isQueryParameterMatcherType_Match()    {}
func (*QueryParameterMatcherType_CheckNotPresent) isQueryParameterMatcherType_Match() {}
func (*QueryParameterMatcherType_Item) isQueryParameterMatcherType_Match()            {}

func (m *QueryParameterMatcherType) GetMatch() isQueryParameterMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *QueryParameterMatcherType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *QueryParameterMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *QueryParameterMatcherType) GetCheckPresent() *ves_io_schema4.Empty {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *QueryParameterMatcherType) GetCheckNotPresent() *ves_io_schema4.Empty {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *QueryParameterMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *QueryParameterMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueryParameterMatcherType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueryParameterMatcherType_OneofMarshaler, _QueryParameterMatcherType_OneofUnmarshaler, _QueryParameterMatcherType_OneofSizer, []interface{}{
		(*QueryParameterMatcherType_Presence)(nil),
		(*QueryParameterMatcherType_CheckPresent)(nil),
		(*QueryParameterMatcherType_CheckNotPresent)(nil),
		(*QueryParameterMatcherType_Item)(nil),
	}
}

func _QueryParameterMatcherType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueryParameterMatcherType)
	// match
	switch x := m.Match.(type) {
	case *QueryParameterMatcherType_Presence:
		t := uint64(0)
		if x.Presence {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *QueryParameterMatcherType_CheckPresent:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CheckPresent); err != nil {
			return err
		}
	case *QueryParameterMatcherType_CheckNotPresent:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CheckNotPresent); err != nil {
			return err
		}
	case *QueryParameterMatcherType_Item:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Item); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QueryParameterMatcherType.Match has unexpected type %T", x)
	}
	return nil
}

func _QueryParameterMatcherType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueryParameterMatcherType)
	switch tag {
	case 2: // match.presence
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Match = &QueryParameterMatcherType_Presence{x != 0}
		return true, err
	case 7: // match.check_present
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Match = &QueryParameterMatcherType_CheckPresent{msg}
		return true, err
	case 8: // match.check_not_present
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.Match = &QueryParameterMatcherType_CheckNotPresent{msg}
		return true, err
	case 3: // match.item
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatcherType)
		err := b.DecodeMessage(msg)
		m.Match = &QueryParameterMatcherType_Item{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QueryParameterMatcherType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueryParameterMatcherType)
	// match
	switch x := m.Match.(type) {
	case *QueryParameterMatcherType_Presence:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *QueryParameterMatcherType_CheckPresent:
		s := proto.Size(x.CheckPresent)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryParameterMatcherType_CheckNotPresent:
		s := proto.Size(x.CheckNotPresent)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryParameterMatcherType_Item:
		s := proto.Size(x.Item)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// HttpMethodMatcherType
//
// x-displayName: "HTTP Method Matcher"
// A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list.
// The result of the match based on the method list is inverted if invert_matcher is true.
type HttpMethodMatcherType struct {
	// methods
	//
	// x-displayName: "Method List"
	// List of methods values to match against.
	// x-example: "['GET', 'POST', 'DELETE']"
	Methods []ves_io_schema4.HttpMethod `protobuf:"varint,1,rep,packed,name=methods,enum=ves.io.schema.HttpMethod" json:"methods,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Method Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *HttpMethodMatcherType) Reset()                    { *m = HttpMethodMatcherType{} }
func (*HttpMethodMatcherType) ProtoMessage()               {}
func (*HttpMethodMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *HttpMethodMatcherType) GetMethods() []ves_io_schema4.HttpMethod {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *HttpMethodMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// RoleMatcherType
//
// x-displayName: "Role Matcher"
// A role matcher specifies a single value for matching an input list of roles. The match is considered successful if the specified value is present in the input
// list.
type RoleMatcherType struct {
	// match
	//
	// x-displayName: "Role"
	// x-required
	// x-example: "ves-io-monitor-role"
	// x-example: "ves-io-uam-role"
	// x-example: "custom-role-security-czar'"
	// Value of the expected role.
	Match string `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
}

func (m *RoleMatcherType) Reset()                    { *m = RoleMatcherType{} }
func (*RoleMatcherType) ProtoMessage()               {}
func (*RoleMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

func (m *RoleMatcherType) GetMatch() string {
	if m != nil {
		return m.Match
	}
	return ""
}

// StringMatcherType
//
// x-displayName: "String Matcher"
// A matcher specifies a list of values for matching an input string. The match is considered successful if the input value is present in the list. The result of
// the match is inverted if invert_matcher is true.
type StringMatcherType struct {
	// match
	//
	// x-displayName: "Exact Values"
	// x-required
	// x-example: "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
	// A list of exact values to match the input against.
	Match []string `protobuf:"bytes,1,rep,name=match" json:"match,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert String Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *StringMatcherType) Reset()                    { *m = StringMatcherType{} }
func (*StringMatcherType) ProtoMessage()               {}
func (*StringMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

func (m *StringMatcherType) GetMatch() []string {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *StringMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// ip matcher type
//
// x-displayName: "IP Prefix Matcher"
// Match any ip prefix contained in the list of ip_prefix_sets.
// The result of the match is inverted if invert_matcher is true.
type IpMatcherType struct {
	// prefix_sets
	//
	// x-displayName: "IP Prefix Sets"
	// x-required
	// A list of references to ip_prefix_set objects.
	PrefixSets []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1,rep,name=prefix_sets,json=prefixSets" json:"prefix_sets,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert IP Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *IpMatcherType) Reset()                    { *m = IpMatcherType{} }
func (*IpMatcherType) ProtoMessage()               {}
func (*IpMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

func (m *IpMatcherType) GetPrefixSets() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.PrefixSets
	}
	return nil
}

func (m *IpMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// asn matcher type
//
// x-displayName: "ASN Matcher"
// Match any AS number contained in the list of bgp_asn_sets.
type AsnMatcherType struct {
	// asn_sets
	//
	// x-displayName: "BGP ASN Sets"
	// x-required
	// A list of references to bgp_asn_set objects.
	AsnSets []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1,rep,name=asn_sets,json=asnSets" json:"asn_sets,omitempty"`
}

func (m *AsnMatcherType) Reset()                    { *m = AsnMatcherType{} }
func (*AsnMatcherType) ProtoMessage()               {}
func (*AsnMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

func (m *AsnMatcherType) GetAsnSets() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.AsnSets
	}
	return nil
}

// port matcher type
//
// x-displayName: "Port Matcher"
// A port matcher specifies a list of port ranges as match criteria. The match is considered successful if the input port falls within any of the port ranges.
// The result of the match is inverted if invert_matcher is true.
type PortMatcherType struct {
	// port ranges
	//
	// x-displayName: "Port Ranges"
	// x-required
	// x-example: "8000-8191"
	// A list of strings, each of which is a single port value or a tuple of start and end port values separated by "-". The start and end values are considered
	// to be part of the range.
	Ports []string `protobuf:"bytes,1,rep,name=ports" json:"ports,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Port Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *PortMatcherType) Reset()                    { *m = PortMatcherType{} }
func (*PortMatcherType) ProtoMessage()               {}
func (*PortMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20} }

func (m *PortMatcherType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *PortMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// url item
//
// x-displayName: "URL Item"
// A URL item specifies exact or regular expression match criteria for the domain and path.
type URLItem struct {
	// domain choice
	//
	// x-displayName: "Domain Match"
	// x-required
	// Select Domain Match.
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*URLItem_DomainValue
	//	*URLItem_DomainRegex
	DomainChoice isURLItem_DomainChoice `protobuf_oneof:"domain_choice"`
	// path choice
	//
	// x-displayName: "Path Match"
	// Select Path Match.
	//
	// Types that are valid to be assigned to PathChoice:
	//	*URLItem_PathValue
	//	*URLItem_PathPrefix
	//	*URLItem_PathRegex
	PathChoice isURLItem_PathChoice `protobuf_oneof:"path_choice"`
}

func (m *URLItem) Reset()                    { *m = URLItem{} }
func (*URLItem) ProtoMessage()               {}
func (*URLItem) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{21} }

type isURLItem_DomainChoice interface {
	isURLItem_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isURLItem_PathChoice interface {
	isURLItem_PathChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type URLItem_DomainValue struct {
	DomainValue string `protobuf:"bytes,2,opt,name=domain_value,json=domainValue,proto3,oneof"`
}
type URLItem_DomainRegex struct {
	DomainRegex string `protobuf:"bytes,3,opt,name=domain_regex,json=domainRegex,proto3,oneof"`
}
type URLItem_PathValue struct {
	PathValue string `protobuf:"bytes,5,opt,name=path_value,json=pathValue,proto3,oneof"`
}
type URLItem_PathPrefix struct {
	PathPrefix string `protobuf:"bytes,7,opt,name=path_prefix,json=pathPrefix,proto3,oneof"`
}
type URLItem_PathRegex struct {
	PathRegex string `protobuf:"bytes,6,opt,name=path_regex,json=pathRegex,proto3,oneof"`
}

func (*URLItem_DomainValue) isURLItem_DomainChoice() {}
func (*URLItem_DomainRegex) isURLItem_DomainChoice() {}
func (*URLItem_PathValue) isURLItem_PathChoice()     {}
func (*URLItem_PathPrefix) isURLItem_PathChoice()    {}
func (*URLItem_PathRegex) isURLItem_PathChoice()     {}

func (m *URLItem) GetDomainChoice() isURLItem_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}
func (m *URLItem) GetPathChoice() isURLItem_PathChoice {
	if m != nil {
		return m.PathChoice
	}
	return nil
}

func (m *URLItem) GetDomainValue() string {
	if x, ok := m.GetDomainChoice().(*URLItem_DomainValue); ok {
		return x.DomainValue
	}
	return ""
}

func (m *URLItem) GetDomainRegex() string {
	if x, ok := m.GetDomainChoice().(*URLItem_DomainRegex); ok {
		return x.DomainRegex
	}
	return ""
}

func (m *URLItem) GetPathValue() string {
	if x, ok := m.GetPathChoice().(*URLItem_PathValue); ok {
		return x.PathValue
	}
	return ""
}

func (m *URLItem) GetPathPrefix() string {
	if x, ok := m.GetPathChoice().(*URLItem_PathPrefix); ok {
		return x.PathPrefix
	}
	return ""
}

func (m *URLItem) GetPathRegex() string {
	if x, ok := m.GetPathChoice().(*URLItem_PathRegex); ok {
		return x.PathRegex
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*URLItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _URLItem_OneofMarshaler, _URLItem_OneofUnmarshaler, _URLItem_OneofSizer, []interface{}{
		(*URLItem_DomainValue)(nil),
		(*URLItem_DomainRegex)(nil),
		(*URLItem_PathValue)(nil),
		(*URLItem_PathPrefix)(nil),
		(*URLItem_PathRegex)(nil),
	}
}

func _URLItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*URLItem)
	// domain_choice
	switch x := m.DomainChoice.(type) {
	case *URLItem_DomainValue:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DomainValue)
	case *URLItem_DomainRegex:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DomainRegex)
	case nil:
	default:
		return fmt.Errorf("URLItem.DomainChoice has unexpected type %T", x)
	}
	// path_choice
	switch x := m.PathChoice.(type) {
	case *URLItem_PathValue:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PathValue)
	case *URLItem_PathPrefix:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PathPrefix)
	case *URLItem_PathRegex:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PathRegex)
	case nil:
	default:
		return fmt.Errorf("URLItem.PathChoice has unexpected type %T", x)
	}
	return nil
}

func _URLItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*URLItem)
	switch tag {
	case 2: // domain_choice.domain_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DomainChoice = &URLItem_DomainValue{x}
		return true, err
	case 3: // domain_choice.domain_regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DomainChoice = &URLItem_DomainRegex{x}
		return true, err
	case 5: // path_choice.path_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathChoice = &URLItem_PathValue{x}
		return true, err
	case 7: // path_choice.path_prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathChoice = &URLItem_PathPrefix{x}
		return true, err
	case 6: // path_choice.path_regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathChoice = &URLItem_PathRegex{x}
		return true, err
	default:
		return false, nil
	}
}

func _URLItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*URLItem)
	// domain_choice
	switch x := m.DomainChoice.(type) {
	case *URLItem_DomainValue:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DomainValue)))
		n += len(x.DomainValue)
	case *URLItem_DomainRegex:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DomainRegex)))
		n += len(x.DomainRegex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// path_choice
	switch x := m.PathChoice.(type) {
	case *URLItem_PathValue:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PathValue)))
		n += len(x.PathValue)
	case *URLItem_PathPrefix:
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PathPrefix)))
		n += len(x.PathPrefix)
	case *URLItem_PathRegex:
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PathRegex)))
		n += len(x.PathRegex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// url matcher type
//
// x-displayName: "URL Matcher"
// A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the input domain and path match any of the URL items.
// The result of the match is inverted if invert_matcher is true.
type URLMatcherType struct {
	// url items
	//
	// x-displayName: "URL Items"
	// x-required
	// A list of URL items used as match criteria. The match is considered successful if the domain and path match any of the URL items.
	UrlItems []*URLItem `protobuf:"bytes,1,rep,name=url_items,json=urlItems" json:"url_items,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert URL Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *URLMatcherType) Reset()                    { *m = URLMatcherType{} }
func (*URLMatcherType) ProtoMessage()               {}
func (*URLMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{22} }

func (m *URLMatcherType) GetUrlItems() []*URLItem {
	if m != nil {
		return m.UrlItems
	}
	return nil
}

func (m *URLMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// l4 dest matcher type
//
// x-displayName: "L4 Destination Matcher"
// A L4 Destination matcher specifies a list of L4 Destinations as match criteria. The match is considered successful if the destination IP and port match any
// of the L4 Destinations.
// The result of the match is inverted if invert_matcher is true.
type L4DestMatcherType struct {
	// prefixes
	//
	// x-displayName: "L4 Destinations"
	// x-required
	// A list of L4 destinations used as match criteria. The match is considered successful if the destination IP and path match any of the L4 destinations.
	L4Dests []*ves_io_schema4.L4DestType `protobuf:"bytes,4,rep,name=l4_dests,json=l4Dests" json:"l4_dests,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert L4 Destination Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,3,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *L4DestMatcherType) Reset()                    { *m = L4DestMatcherType{} }
func (*L4DestMatcherType) ProtoMessage()               {}
func (*L4DestMatcherType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{23} }

func (m *L4DestMatcherType) GetL4Dests() []*ves_io_schema4.L4DestType {
	if m != nil {
		return m.L4Dests
	}
	return nil
}

func (m *L4DestMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

func init() {
	proto.RegisterType((*WafRuleControl)(nil), "ves.io.schema.policy.WafRuleControl")
	golang_proto.RegisterType((*WafRuleControl)(nil), "ves.io.schema.policy.WafRuleControl")
	proto.RegisterType((*WafInlineRuleControl)(nil), "ves.io.schema.policy.WafInlineRuleControl")
	golang_proto.RegisterType((*WafInlineRuleControl)(nil), "ves.io.schema.policy.WafInlineRuleControl")
	proto.RegisterType((*WafAction)(nil), "ves.io.schema.policy.WafAction")
	golang_proto.RegisterType((*WafAction)(nil), "ves.io.schema.policy.WafAction")
	proto.RegisterType((*PrefixMatchList)(nil), "ves.io.schema.policy.PrefixMatchList")
	golang_proto.RegisterType((*PrefixMatchList)(nil), "ves.io.schema.policy.PrefixMatchList")
	proto.RegisterType((*AsnMatchList)(nil), "ves.io.schema.policy.AsnMatchList")
	golang_proto.RegisterType((*AsnMatchList)(nil), "ves.io.schema.policy.AsnMatchList")
	proto.RegisterType((*SimpleWafExclusionRule)(nil), "ves.io.schema.policy.SimpleWafExclusionRule")
	golang_proto.RegisterType((*SimpleWafExclusionRule)(nil), "ves.io.schema.policy.SimpleWafExclusionRule")
	proto.RegisterType((*DenyInformation)(nil), "ves.io.schema.policy.DenyInformation")
	golang_proto.RegisterType((*DenyInformation)(nil), "ves.io.schema.policy.DenyInformation")
	proto.RegisterType((*TlsFingerprintMatcherType)(nil), "ves.io.schema.policy.TlsFingerprintMatcherType")
	golang_proto.RegisterType((*TlsFingerprintMatcherType)(nil), "ves.io.schema.policy.TlsFingerprintMatcherType")
	proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.policy.PathMatcherType")
	golang_proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.policy.PathMatcherType")
	proto.RegisterType((*MatcherType)(nil), "ves.io.schema.policy.MatcherType")
	golang_proto.RegisterType((*MatcherType)(nil), "ves.io.schema.policy.MatcherType")
	proto.RegisterType((*MatcherTypeBasic)(nil), "ves.io.schema.policy.MatcherTypeBasic")
	golang_proto.RegisterType((*MatcherTypeBasic)(nil), "ves.io.schema.policy.MatcherTypeBasic")
	proto.RegisterType((*CookieMatcherType)(nil), "ves.io.schema.policy.CookieMatcherType")
	golang_proto.RegisterType((*CookieMatcherType)(nil), "ves.io.schema.policy.CookieMatcherType")
	proto.RegisterType((*ArgMatcherType)(nil), "ves.io.schema.policy.ArgMatcherType")
	golang_proto.RegisterType((*ArgMatcherType)(nil), "ves.io.schema.policy.ArgMatcherType")
	proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.policy.HeaderMatcherType")
	golang_proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.policy.HeaderMatcherType")
	proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.policy.QueryParameterMatcherType")
	golang_proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.policy.QueryParameterMatcherType")
	proto.RegisterType((*HttpMethodMatcherType)(nil), "ves.io.schema.policy.HttpMethodMatcherType")
	golang_proto.RegisterType((*HttpMethodMatcherType)(nil), "ves.io.schema.policy.HttpMethodMatcherType")
	proto.RegisterType((*RoleMatcherType)(nil), "ves.io.schema.policy.RoleMatcherType")
	golang_proto.RegisterType((*RoleMatcherType)(nil), "ves.io.schema.policy.RoleMatcherType")
	proto.RegisterType((*StringMatcherType)(nil), "ves.io.schema.policy.StringMatcherType")
	golang_proto.RegisterType((*StringMatcherType)(nil), "ves.io.schema.policy.StringMatcherType")
	proto.RegisterType((*IpMatcherType)(nil), "ves.io.schema.policy.IpMatcherType")
	golang_proto.RegisterType((*IpMatcherType)(nil), "ves.io.schema.policy.IpMatcherType")
	proto.RegisterType((*AsnMatcherType)(nil), "ves.io.schema.policy.AsnMatcherType")
	golang_proto.RegisterType((*AsnMatcherType)(nil), "ves.io.schema.policy.AsnMatcherType")
	proto.RegisterType((*PortMatcherType)(nil), "ves.io.schema.policy.PortMatcherType")
	golang_proto.RegisterType((*PortMatcherType)(nil), "ves.io.schema.policy.PortMatcherType")
	proto.RegisterType((*URLItem)(nil), "ves.io.schema.policy.URLItem")
	golang_proto.RegisterType((*URLItem)(nil), "ves.io.schema.policy.URLItem")
	proto.RegisterType((*URLMatcherType)(nil), "ves.io.schema.policy.URLMatcherType")
	golang_proto.RegisterType((*URLMatcherType)(nil), "ves.io.schema.policy.URLMatcherType")
	proto.RegisterType((*L4DestMatcherType)(nil), "ves.io.schema.policy.L4DestMatcherType")
	golang_proto.RegisterType((*L4DestMatcherType)(nil), "ves.io.schema.policy.L4DestMatcherType")
	proto.RegisterEnum("ves.io.schema.policy.PolicySetType", PolicySetType_name, PolicySetType_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.PolicySetType", PolicySetType_name, PolicySetType_value)
	proto.RegisterEnum("ves.io.schema.policy.PolicySetScope", PolicySetScope_name, PolicySetScope_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.PolicySetScope", PolicySetScope_name, PolicySetScope_value)
	proto.RegisterEnum("ves.io.schema.policy.RuleCombiningAlgorithm", RuleCombiningAlgorithm_name, RuleCombiningAlgorithm_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.RuleCombiningAlgorithm", RuleCombiningAlgorithm_name, RuleCombiningAlgorithm_value)
	proto.RegisterEnum("ves.io.schema.policy.Transformer", Transformer_name, Transformer_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.Transformer", Transformer_name, Transformer_value)
	proto.RegisterEnum("ves.io.schema.policy.KnownTlsFingerprintClass", KnownTlsFingerprintClass_name, KnownTlsFingerprintClass_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.KnownTlsFingerprintClass", KnownTlsFingerprintClass_name, KnownTlsFingerprintClass_value)
	proto.RegisterEnum("ves.io.schema.policy.CountryCode", CountryCode_name, CountryCode_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.CountryCode", CountryCode_name, CountryCode_value)
	proto.RegisterEnum("ves.io.schema.policy.RuleAction", RuleAction_name, RuleAction_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.RuleAction", RuleAction_name, RuleAction_value)
}
func (x PolicySetType) String() string {
	s, ok := PolicySetType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PolicySetScope) String() string {
	s, ok := PolicySetScope_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RuleCombiningAlgorithm) String() string {
	s, ok := RuleCombiningAlgorithm_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Transformer) String() string {
	s, ok := Transformer_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x KnownTlsFingerprintClass) String() string {
	s, ok := KnownTlsFingerprintClass_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CountryCode) String() string {
	s, ok := CountryCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RuleAction) String() string {
	s, ok := RuleAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *WafRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafRuleControl)
	if !ok {
		that2, ok := that.(WafRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExcludeRuleIds) != len(that1.ExcludeRuleIds) {
		return false
	}
	for i := range this.ExcludeRuleIds {
		if !this.ExcludeRuleIds[i].Equal(that1.ExcludeRuleIds[i]) {
			return false
		}
	}
	return true
}
func (this *WafInlineRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafInlineRuleControl)
	if !ok {
		that2, ok := that.(WafInlineRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExcludeRuleIds) != len(that1.ExcludeRuleIds) {
		return false
	}
	for i := range this.ExcludeRuleIds {
		if this.ExcludeRuleIds[i] != that1.ExcludeRuleIds[i] {
			return false
		}
	}
	return true
}
func (this *WafAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction)
	if !ok {
		that2, ok := that.(WafAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionType == nil {
		if this.ActionType != nil {
			return false
		}
	} else if this.ActionType == nil {
		return false
	} else if !this.ActionType.Equal(that1.ActionType) {
		return false
	}
	return true
}
func (this *WafAction_None) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_None)
	if !ok {
		that2, ok := that.(WafAction_None)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.None.Equal(that1.None) {
		return false
	}
	return true
}
func (this *WafAction_WafSkipProcessing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafSkipProcessing)
	if !ok {
		that2, ok := that.(WafAction_WafSkipProcessing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafSkipProcessing.Equal(that1.WafSkipProcessing) {
		return false
	}
	return true
}
func (this *WafAction_WafRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafRuleControl)
	if !ok {
		that2, ok := that.(WafAction_WafRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafRuleControl.Equal(that1.WafRuleControl) {
		return false
	}
	return true
}
func (this *WafAction_WafInlineRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafInlineRuleControl)
	if !ok {
		that2, ok := that.(WafAction_WafInlineRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafInlineRuleControl.Equal(that1.WafInlineRuleControl) {
		return false
	}
	return true
}
func (this *PrefixMatchList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrefixMatchList)
	if !ok {
		that2, ok := that.(PrefixMatchList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.IpPrefixes) != len(that1.IpPrefixes) {
		return false
	}
	for i := range this.IpPrefixes {
		if this.IpPrefixes[i] != that1.IpPrefixes[i] {
			return false
		}
	}
	if this.InvertMatch != that1.InvertMatch {
		return false
	}
	return true
}
func (this *AsnMatchList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AsnMatchList)
	if !ok {
		that2, ok := that.(AsnMatchList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AsNumbers) != len(that1.AsNumbers) {
		return false
	}
	for i := range this.AsNumbers {
		if this.AsNumbers[i] != that1.AsNumbers[i] {
			return false
		}
	}
	return true
}
func (this *SimpleWafExclusionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if this.PathRegex != that1.PathRegex {
		return false
	}
	if len(this.Methods) != len(that1.Methods) {
		return false
	}
	for i := range this.Methods {
		if this.Methods[i] != that1.Methods[i] {
			return false
		}
	}
	if len(this.ExcludeRuleIds) != len(that1.ExcludeRuleIds) {
		return false
	}
	for i := range this.ExcludeRuleIds {
		if this.ExcludeRuleIds[i] != that1.ExcludeRuleIds[i] {
			return false
		}
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	return true
}
func (this *SimpleWafExclusionRule_AnyDomain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule_AnyDomain)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule_AnyDomain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDomain.Equal(that1.AnyDomain) {
		return false
	}
	return true
}
func (this *SimpleWafExclusionRule_DomainRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule_DomainRegex)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule_DomainRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainRegex != that1.DomainRegex {
		return false
	}
	return true
}
func (this *DenyInformation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DenyInformation)
	if !ok {
		that2, ok := that.(DenyInformation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	return true
}
func (this *TlsFingerprintMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsFingerprintMatcherType)
	if !ok {
		that2, ok := that.(TlsFingerprintMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Classes) != len(that1.Classes) {
		return false
	}
	for i := range this.Classes {
		if this.Classes[i] != that1.Classes[i] {
			return false
		}
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.ExcludedValues) != len(that1.ExcludedValues) {
		return false
	}
	for i := range this.ExcludedValues {
		if this.ExcludedValues[i] != that1.ExcludedValues[i] {
			return false
		}
	}
	return true
}
func (this *PathMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType)
	if !ok {
		that2, ok := that.(PathMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PrefixValues) != len(that1.PrefixValues) {
		return false
	}
	for i := range this.PrefixValues {
		if this.PrefixValues[i] != that1.PrefixValues[i] {
			return false
		}
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	if len(this.Transformers) != len(that1.Transformers) {
		return false
	}
	for i := range this.Transformers {
		if this.Transformers[i] != that1.Transformers[i] {
			return false
		}
	}
	return true
}
func (this *MatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatcherType)
	if !ok {
		that2, ok := that.(MatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	if len(this.Transformers) != len(that1.Transformers) {
		return false
	}
	for i := range this.Transformers {
		if this.Transformers[i] != that1.Transformers[i] {
			return false
		}
	}
	return true
}
func (this *MatcherTypeBasic) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatcherTypeBasic)
	if !ok {
		that2, ok := that.(MatcherTypeBasic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	return true
}
func (this *CookieMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType)
	if !ok {
		that2, ok := that.(CookieMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *CookieMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_Presence)
	if !ok {
		that2, ok := that.(CookieMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *CookieMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(CookieMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *CookieMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(CookieMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *CookieMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_Item)
	if !ok {
		that2, ok := that.(CookieMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *ArgMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType)
	if !ok {
		that2, ok := that.(ArgMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *ArgMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_Presence)
	if !ok {
		that2, ok := that.(ArgMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *ArgMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(ArgMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *ArgMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(ArgMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *ArgMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_Item)
	if !ok {
		that2, ok := that.(ArgMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *HeaderMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType)
	if !ok {
		that2, ok := that.(HeaderMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Presence)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *HeaderMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(HeaderMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *HeaderMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(HeaderMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Item)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Presence)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Item)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *HttpMethodMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HttpMethodMatcherType)
	if !ok {
		that2, ok := that.(HttpMethodMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Methods) != len(that1.Methods) {
		return false
	}
	for i := range this.Methods {
		if this.Methods[i] != that1.Methods[i] {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *RoleMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleMatcherType)
	if !ok {
		that2, ok := that.(RoleMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Match != that1.Match {
		return false
	}
	return true
}
func (this *StringMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StringMatcherType)
	if !ok {
		that2, ok := that.(StringMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Match) != len(that1.Match) {
		return false
	}
	for i := range this.Match {
		if this.Match[i] != that1.Match[i] {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *IpMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpMatcherType)
	if !ok {
		that2, ok := that.(IpMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PrefixSets) != len(that1.PrefixSets) {
		return false
	}
	for i := range this.PrefixSets {
		if !this.PrefixSets[i].Equal(that1.PrefixSets[i]) {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *AsnMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AsnMatcherType)
	if !ok {
		that2, ok := that.(AsnMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AsnSets) != len(that1.AsnSets) {
		return false
	}
	for i := range this.AsnSets {
		if !this.AsnSets[i].Equal(that1.AsnSets[i]) {
			return false
		}
	}
	return true
}
func (this *PortMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortMatcherType)
	if !ok {
		that2, ok := that.(PortMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *URLItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem)
	if !ok {
		that2, ok := that.(URLItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if that1.PathChoice == nil {
		if this.PathChoice != nil {
			return false
		}
	} else if this.PathChoice == nil {
		return false
	} else if !this.PathChoice.Equal(that1.PathChoice) {
		return false
	}
	return true
}
func (this *URLItem_DomainValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_DomainValue)
	if !ok {
		that2, ok := that.(URLItem_DomainValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainValue != that1.DomainValue {
		return false
	}
	return true
}
func (this *URLItem_DomainRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_DomainRegex)
	if !ok {
		that2, ok := that.(URLItem_DomainRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainRegex != that1.DomainRegex {
		return false
	}
	return true
}
func (this *URLItem_PathValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_PathValue)
	if !ok {
		that2, ok := that.(URLItem_PathValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathValue != that1.PathValue {
		return false
	}
	return true
}
func (this *URLItem_PathPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_PathPrefix)
	if !ok {
		that2, ok := that.(URLItem_PathPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathPrefix != that1.PathPrefix {
		return false
	}
	return true
}
func (this *URLItem_PathRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_PathRegex)
	if !ok {
		that2, ok := that.(URLItem_PathRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathRegex != that1.PathRegex {
		return false
	}
	return true
}
func (this *URLMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLMatcherType)
	if !ok {
		that2, ok := that.(URLMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.UrlItems) != len(that1.UrlItems) {
		return false
	}
	for i := range this.UrlItems {
		if !this.UrlItems[i].Equal(that1.UrlItems[i]) {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *L4DestMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L4DestMatcherType)
	if !ok {
		that2, ok := that.(L4DestMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.L4Dests) != len(that1.L4Dests) {
		return false
	}
	for i := range this.L4Dests {
		if !this.L4Dests[i].Equal(that1.L4Dests[i]) {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *WafRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.WafRuleControl{")
	if this.ExcludeRuleIds != nil {
		s = append(s, "ExcludeRuleIds: "+fmt.Sprintf("%#v", this.ExcludeRuleIds)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafInlineRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.WafInlineRuleControl{")
	s = append(s, "ExcludeRuleIds: "+fmt.Sprintf("%#v", this.ExcludeRuleIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&policy.WafAction{")
	if this.ActionType != nil {
		s = append(s, "ActionType: "+fmt.Sprintf("%#v", this.ActionType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafAction_None) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_None{` +
		`None:` + fmt.Sprintf("%#v", this.None) + `}`}, ", ")
	return s
}
func (this *WafAction_WafSkipProcessing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafSkipProcessing{` +
		`WafSkipProcessing:` + fmt.Sprintf("%#v", this.WafSkipProcessing) + `}`}, ", ")
	return s
}
func (this *WafAction_WafRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafRuleControl{` +
		`WafRuleControl:` + fmt.Sprintf("%#v", this.WafRuleControl) + `}`}, ", ")
	return s
}
func (this *WafAction_WafInlineRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafInlineRuleControl{` +
		`WafInlineRuleControl:` + fmt.Sprintf("%#v", this.WafInlineRuleControl) + `}`}, ", ")
	return s
}
func (this *PrefixMatchList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.PrefixMatchList{")
	s = append(s, "IpPrefixes: "+fmt.Sprintf("%#v", this.IpPrefixes)+",\n")
	s = append(s, "InvertMatch: "+fmt.Sprintf("%#v", this.InvertMatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AsnMatchList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.AsnMatchList{")
	s = append(s, "AsNumbers: "+fmt.Sprintf("%#v", this.AsNumbers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimpleWafExclusionRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&policy.SimpleWafExclusionRule{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "PathRegex: "+fmt.Sprintf("%#v", this.PathRegex)+",\n")
	s = append(s, "Methods: "+fmt.Sprintf("%#v", this.Methods)+",\n")
	s = append(s, "ExcludeRuleIds: "+fmt.Sprintf("%#v", this.ExcludeRuleIds)+",\n")
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimpleWafExclusionRule_AnyDomain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleWafExclusionRule_AnyDomain{` +
		`AnyDomain:` + fmt.Sprintf("%#v", this.AnyDomain) + `}`}, ", ")
	return s
}
func (this *SimpleWafExclusionRule_DomainRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleWafExclusionRule_DomainRegex{` +
		`DomainRegex:` + fmt.Sprintf("%#v", this.DomainRegex) + `}`}, ", ")
	return s
}
func (this *DenyInformation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.DenyInformation{")
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "ErrorMessage: "+fmt.Sprintf("%#v", this.ErrorMessage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsFingerprintMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&policy.TlsFingerprintMatcherType{")
	s = append(s, "Classes: "+fmt.Sprintf("%#v", this.Classes)+",\n")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "ExcludedValues: "+fmt.Sprintf("%#v", this.ExcludedValues)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PathMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&policy.PathMatcherType{")
	s = append(s, "PrefixValues: "+fmt.Sprintf("%#v", this.PrefixValues)+",\n")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "Transformers: "+fmt.Sprintf("%#v", this.Transformers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&policy.MatcherType{")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "Transformers: "+fmt.Sprintf("%#v", this.Transformers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatcherTypeBasic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.MatcherTypeBasic{")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.CookieMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *CookieMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *CookieMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *CookieMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.ArgMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.HeaderMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.QueryParameterMatcherType{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryParameterMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *HttpMethodMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.HttpMethodMatcherType{")
	s = append(s, "Methods: "+fmt.Sprintf("%#v", this.Methods)+",\n")
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoleMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.RoleMatcherType{")
	s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StringMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.StringMatcherType{")
	s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.IpMatcherType{")
	if this.PrefixSets != nil {
		s = append(s, "PrefixSets: "+fmt.Sprintf("%#v", this.PrefixSets)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AsnMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.AsnMatcherType{")
	if this.AsnSets != nil {
		s = append(s, "AsnSets: "+fmt.Sprintf("%#v", this.AsnSets)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.PortMatcherType{")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *URLItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&policy.URLItem{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	if this.PathChoice != nil {
		s = append(s, "PathChoice: "+fmt.Sprintf("%#v", this.PathChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *URLItem_DomainValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_DomainValue{` +
		`DomainValue:` + fmt.Sprintf("%#v", this.DomainValue) + `}`}, ", ")
	return s
}
func (this *URLItem_DomainRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_DomainRegex{` +
		`DomainRegex:` + fmt.Sprintf("%#v", this.DomainRegex) + `}`}, ", ")
	return s
}
func (this *URLItem_PathValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_PathValue{` +
		`PathValue:` + fmt.Sprintf("%#v", this.PathValue) + `}`}, ", ")
	return s
}
func (this *URLItem_PathPrefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_PathPrefix{` +
		`PathPrefix:` + fmt.Sprintf("%#v", this.PathPrefix) + `}`}, ", ")
	return s
}
func (this *URLItem_PathRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_PathRegex{` +
		`PathRegex:` + fmt.Sprintf("%#v", this.PathRegex) + `}`}, ", ")
	return s
}
func (this *URLMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.URLMatcherType{")
	if this.UrlItems != nil {
		s = append(s, "UrlItems: "+fmt.Sprintf("%#v", this.UrlItems)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L4DestMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.L4DestMatcherType{")
	if this.L4Dests != nil {
		s = append(s, "L4Dests: "+fmt.Sprintf("%#v", this.L4Dests)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *WafRuleControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafRuleControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExcludeRuleIds) > 0 {
		for _, msg := range m.ExcludeRuleIds {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WafInlineRuleControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafInlineRuleControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExcludeRuleIds) > 0 {
		dAtA2 := make([]byte, len(m.ExcludeRuleIds)*10)
		var j1 int
		for _, num := range m.ExcludeRuleIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *WafAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActionType != nil {
		nn3, err := m.ActionType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *WafAction_WafSkipProcessing) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WafSkipProcessing != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafSkipProcessing.Size()))
		n4, err := m.WafSkipProcessing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *WafAction_WafRuleControl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WafRuleControl != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafRuleControl.Size()))
		n5, err := m.WafRuleControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *WafAction_None) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.None != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.None.Size()))
		n6, err := m.None.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *WafAction_WafInlineRuleControl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WafInlineRuleControl != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafInlineRuleControl.Size()))
		n7, err := m.WafInlineRuleControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *PrefixMatchList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrefixMatchList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpPrefixes) > 0 {
		for _, s := range m.IpPrefixes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.InvertMatch {
		dAtA[i] = 0x10
		i++
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AsnMatchList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsnMatchList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AsNumbers) > 0 {
		dAtA9 := make([]byte, len(m.AsNumbers)*10)
		var j8 int
		for _, num := range m.AsNumbers {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	return i, nil
}

func (m *SimpleWafExclusionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleWafExclusionRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.DomainChoice != nil {
		nn10, err := m.DomainChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	if len(m.PathRegex) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PathRegex)))
		i += copy(dAtA[i:], m.PathRegex)
	}
	if len(m.Methods) > 0 {
		dAtA12 := make([]byte, len(m.Methods)*10)
		var j11 int
		for _, num := range m.Methods {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if len(m.ExcludeRuleIds) > 0 {
		dAtA14 := make([]byte, len(m.ExcludeRuleIds)*10)
		var j13 int
		for _, num := range m.ExcludeRuleIds {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.ExpirationTimestamp != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTimestamp.Size()))
		n15, err := m.ExpirationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *SimpleWafExclusionRule_AnyDomain) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyDomain != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyDomain.Size()))
		n16, err := m.AnyDomain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *SimpleWafExclusionRule_DomainRegex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x2a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainRegex)))
	i += copy(dAtA[i:], m.DomainRegex)
	return i, nil
}
func (m *DenyInformation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenyInformation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ResponseCode))
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	return i, nil
}

func (m *TlsFingerprintMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsFingerprintMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Classes) > 0 {
		dAtA18 := make([]byte, len(m.Classes)*10)
		var j17 int
		for _, num := range m.Classes {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExcludedValues) > 0 {
		for _, s := range m.ExcludedValues {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PathMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PrefixValues) > 0 {
		for _, s := range m.PrefixValues {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Transformers) > 0 {
		dAtA20 := make([]byte, len(m.Transformers)*10)
		var j19 int
		for _, num := range m.Transformers {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	return i, nil
}

func (m *MatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Transformers) > 0 {
		dAtA22 := make([]byte, len(m.Transformers)*10)
		var j21 int
		for _, num := range m.Transformers {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	return i, nil
}

func (m *MatcherTypeBasic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatcherTypeBasic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CookieMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Match != nil {
		nn23, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	if m.InvertMatcher {
		dAtA[i] = 0x20
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CookieMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *CookieMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Item != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Item.Size()))
		n24, err := m.Item.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *CookieMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CheckPresent != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CheckPresent.Size()))
		n25, err := m.CheckPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *CookieMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CheckNotPresent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CheckNotPresent.Size()))
		n26, err := m.CheckNotPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *ArgMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Match != nil {
		nn27, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn27
	}
	if m.InvertMatcher {
		dAtA[i] = 0x20
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ArgMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ArgMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Item != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Item.Size()))
		n28, err := m.Item.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *ArgMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CheckPresent != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CheckPresent.Size()))
		n29, err := m.CheckPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *ArgMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CheckNotPresent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CheckNotPresent.Size()))
		n30, err := m.CheckNotPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *HeaderMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Match != nil {
		nn31, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn31
	}
	if m.InvertMatcher {
		dAtA[i] = 0x20
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HeaderMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *HeaderMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Item != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Item.Size()))
		n32, err := m.Item.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *HeaderMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CheckPresent != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CheckPresent.Size()))
		n33, err := m.CheckPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *HeaderMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CheckNotPresent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CheckNotPresent.Size()))
		n34, err := m.CheckNotPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *QueryParameterMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParameterMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Match != nil {
		nn35, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn35
	}
	if m.InvertMatcher {
		dAtA[i] = 0x20
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *QueryParameterMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *QueryParameterMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Item != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Item.Size()))
		n36, err := m.Item.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *QueryParameterMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CheckPresent != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CheckPresent.Size()))
		n37, err := m.CheckPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *QueryParameterMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CheckNotPresent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CheckNotPresent.Size()))
		n38, err := m.CheckNotPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *HttpMethodMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpMethodMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Methods) > 0 {
		dAtA40 := make([]byte, len(m.Methods)*10)
		var j39 int
		for _, num := range m.Methods {
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j39))
		i += copy(dAtA[i:], dAtA40[:j39])
	}
	if m.InvertMatcher {
		dAtA[i] = 0x10
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RoleMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Match) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Match)))
		i += copy(dAtA[i:], m.Match)
	}
	return i, nil
}

func (m *StringMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, s := range m.Match {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.InvertMatcher {
		dAtA[i] = 0x10
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *IpMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PrefixSets) > 0 {
		for _, msg := range m.PrefixSets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InvertMatcher {
		dAtA[i] = 0x10
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AsnMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsnMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AsnSets) > 0 {
		for _, msg := range m.AsnSets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PortMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.InvertMatcher {
		dAtA[i] = 0x10
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *URLItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DomainChoice != nil {
		nn41, err := m.DomainChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn41
	}
	if m.PathChoice != nil {
		nn42, err := m.PathChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn42
	}
	return i, nil
}

func (m *URLItem_DomainValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainValue)))
	i += copy(dAtA[i:], m.DomainValue)
	return i, nil
}
func (m *URLItem_DomainRegex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainRegex)))
	i += copy(dAtA[i:], m.DomainRegex)
	return i, nil
}
func (m *URLItem_PathValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x2a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathValue)))
	i += copy(dAtA[i:], m.PathValue)
	return i, nil
}
func (m *URLItem_PathRegex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x32
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathRegex)))
	i += copy(dAtA[i:], m.PathRegex)
	return i, nil
}
func (m *URLItem_PathPrefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x3a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathPrefix)))
	i += copy(dAtA[i:], m.PathPrefix)
	return i, nil
}
func (m *URLMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UrlItems) > 0 {
		for _, msg := range m.UrlItems {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InvertMatcher {
		dAtA[i] = 0x10
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *L4DestMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4DestMatcherType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		dAtA[i] = 0x18
		i++
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.L4Dests) > 0 {
		for _, msg := range m.L4Dests {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedWafRuleControl(r randyTypes, easy bool) *WafRuleControl {
	this := &WafRuleControl{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.ExcludeRuleIds = make([]*ves_io_schema4.ObjectRefType, v1)
		for i := 0; i < v1; i++ {
			this.ExcludeRuleIds[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWafInlineRuleControl(r randyTypes, easy bool) *WafInlineRuleControl {
	this := &WafInlineRuleControl{}
	v2 := r.Intn(10)
	this.ExcludeRuleIds = make([]ves_io_schema_waf_rule_list.WafRuleID, v2)
	for i := 0; i < v2; i++ {
		this.ExcludeRuleIds[i] = ves_io_schema_waf_rule_list.WafRuleID([]int32{0, 910000, 910100, 910150, 910160, 910170, 910180, 911100, 912120, 913100, 913101, 913102, 913110, 913120, 920100, 920120, 920121, 920130, 920140, 920160, 920170, 920171, 920180, 920190, 920200, 920201, 920202, 920210, 920220, 920230, 920240, 920250, 920260, 920270, 920271, 920272, 920273, 920274, 920341, 920350, 920360, 920370, 920380, 920390, 920400, 920410, 920420, 920430, 920440, 920450, 920460, 920470, 920480, 921110, 921120, 921130, 921140, 921150, 921151, 921160, 930100, 930110, 930120, 930130, 931100, 931110, 931120, 931130, 932100, 932105, 932106, 932110, 932115, 932120, 932130, 932140, 932150, 932160, 932170, 932171, 932180, 932190, 933100, 933110, 933111, 933120, 933130, 933131, 933140, 933150, 933151, 933160, 933161, 933170, 933180, 933190, 941100, 941101, 941110, 941120, 941130, 941140, 941150, 941160, 941170, 941180, 941190, 941200, 941210, 941220, 941230, 941240, 941250, 941260, 941270, 941280, 941290, 941300, 941310, 941320, 941330, 941340, 941350, 942100, 942110, 942120, 942130, 942140, 942150, 942160, 942170, 942180, 942190, 942200, 942210, 942220, 942230, 942240, 942250, 942251, 942260, 942270, 942280, 942290, 942300, 942310, 942320, 942330, 942340, 942350, 942360, 942361, 942370, 942380, 942390, 942400, 942410, 942420, 942421, 942430, 942431, 942432, 942440, 942450, 942460, 942470, 942480, 942490, 943100, 943110, 943120, 944100, 944110, 944120, 944130, 944200, 944210, 944240, 944250, 944300, 950100, 950130, 951110, 951120, 951130, 951140, 951150, 951160, 951170, 951180, 951190, 951200, 951210, 951220, 951230, 951240, 951250, 951260, 952100, 952110, 953100, 953110, 953120, 954100, 954110, 954120, 954130, 4295001, 4295002, 4295003, 4295004, 4295005, 4295006}[r.Intn(213)])
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWafAction(r randyTypes, easy bool) *WafAction {
	this := &WafAction{}
	oneofNumber_ActionType := []int32{1, 2, 3, 4}[r.Intn(4)]
	switch oneofNumber_ActionType {
	case 1:
		this.ActionType = NewPopulatedWafAction_WafSkipProcessing(r, easy)
	case 2:
		this.ActionType = NewPopulatedWafAction_WafRuleControl(r, easy)
	case 3:
		this.ActionType = NewPopulatedWafAction_None(r, easy)
	case 4:
		this.ActionType = NewPopulatedWafAction_WafInlineRuleControl(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWafAction_WafSkipProcessing(r randyTypes, easy bool) *WafAction_WafSkipProcessing {
	this := &WafAction_WafSkipProcessing{}
	this.WafSkipProcessing = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedWafAction_WafRuleControl(r randyTypes, easy bool) *WafAction_WafRuleControl {
	this := &WafAction_WafRuleControl{}
	this.WafRuleControl = NewPopulatedWafRuleControl(r, easy)
	return this
}
func NewPopulatedWafAction_None(r randyTypes, easy bool) *WafAction_None {
	this := &WafAction_None{}
	this.None = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedWafAction_WafInlineRuleControl(r randyTypes, easy bool) *WafAction_WafInlineRuleControl {
	this := &WafAction_WafInlineRuleControl{}
	this.WafInlineRuleControl = NewPopulatedWafInlineRuleControl(r, easy)
	return this
}
func NewPopulatedPrefixMatchList(r randyTypes, easy bool) *PrefixMatchList {
	this := &PrefixMatchList{}
	v3 := r.Intn(10)
	this.IpPrefixes = make([]string, v3)
	for i := 0; i < v3; i++ {
		this.IpPrefixes[i] = string(randStringTypes(r))
	}
	this.InvertMatch = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAsnMatchList(r randyTypes, easy bool) *AsnMatchList {
	this := &AsnMatchList{}
	v4 := r.Intn(10)
	this.AsNumbers = make([]uint32, v4)
	for i := 0; i < v4; i++ {
		this.AsNumbers[i] = uint32(r.Uint32())
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSimpleWafExclusionRule(r randyTypes, easy bool) *SimpleWafExclusionRule {
	this := &SimpleWafExclusionRule{}
	this.Name = string(randStringTypes(r))
	this.Description = string(randStringTypes(r))
	oneofNumber_DomainChoice := []int32{4, 5}[r.Intn(2)]
	switch oneofNumber_DomainChoice {
	case 4:
		this.DomainChoice = NewPopulatedSimpleWafExclusionRule_AnyDomain(r, easy)
	case 5:
		this.DomainChoice = NewPopulatedSimpleWafExclusionRule_DomainRegex(r, easy)
	}
	this.PathRegex = string(randStringTypes(r))
	v5 := r.Intn(10)
	this.Methods = make([]ves_io_schema4.HttpMethod, v5)
	for i := 0; i < v5; i++ {
		this.Methods[i] = ves_io_schema4.HttpMethod([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}[r.Intn(10)])
	}
	v6 := r.Intn(10)
	this.ExcludeRuleIds = make([]ves_io_schema_waf_rule_list.WafRuleID, v6)
	for i := 0; i < v6; i++ {
		this.ExcludeRuleIds[i] = ves_io_schema_waf_rule_list.WafRuleID([]int32{0, 910000, 910100, 910150, 910160, 910170, 910180, 911100, 912120, 913100, 913101, 913102, 913110, 913120, 920100, 920120, 920121, 920130, 920140, 920160, 920170, 920171, 920180, 920190, 920200, 920201, 920202, 920210, 920220, 920230, 920240, 920250, 920260, 920270, 920271, 920272, 920273, 920274, 920341, 920350, 920360, 920370, 920380, 920390, 920400, 920410, 920420, 920430, 920440, 920450, 920460, 920470, 920480, 921110, 921120, 921130, 921140, 921150, 921151, 921160, 930100, 930110, 930120, 930130, 931100, 931110, 931120, 931130, 932100, 932105, 932106, 932110, 932115, 932120, 932130, 932140, 932150, 932160, 932170, 932171, 932180, 932190, 933100, 933110, 933111, 933120, 933130, 933131, 933140, 933150, 933151, 933160, 933161, 933170, 933180, 933190, 941100, 941101, 941110, 941120, 941130, 941140, 941150, 941160, 941170, 941180, 941190, 941200, 941210, 941220, 941230, 941240, 941250, 941260, 941270, 941280, 941290, 941300, 941310, 941320, 941330, 941340, 941350, 942100, 942110, 942120, 942130, 942140, 942150, 942160, 942170, 942180, 942190, 942200, 942210, 942220, 942230, 942240, 942250, 942251, 942260, 942270, 942280, 942290, 942300, 942310, 942320, 942330, 942340, 942350, 942360, 942361, 942370, 942380, 942390, 942400, 942410, 942420, 942421, 942430, 942431, 942432, 942440, 942450, 942460, 942470, 942480, 942490, 943100, 943110, 943120, 944100, 944110, 944120, 944130, 944200, 944210, 944240, 944250, 944300, 950100, 950130, 951110, 951120, 951130, 951140, 951150, 951160, 951170, 951180, 951190, 951200, 951210, 951220, 951230, 951240, 951250, 951260, 952100, 952110, 953100, 953110, 953120, 954100, 954110, 954120, 954130, 4295001, 4295002, 4295003, 4295004, 4295005, 4295006}[r.Intn(213)])
	}
	if r.Intn(10) != 0 {
		this.ExpirationTimestamp = google_protobuf1.NewPopulatedTimestamp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSimpleWafExclusionRule_AnyDomain(r randyTypes, easy bool) *SimpleWafExclusionRule_AnyDomain {
	this := &SimpleWafExclusionRule_AnyDomain{}
	this.AnyDomain = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedSimpleWafExclusionRule_DomainRegex(r randyTypes, easy bool) *SimpleWafExclusionRule_DomainRegex {
	this := &SimpleWafExclusionRule_DomainRegex{}
	this.DomainRegex = string(randStringTypes(r))
	return this
}
func NewPopulatedDenyInformation(r randyTypes, easy bool) *DenyInformation {
	this := &DenyInformation{}
	this.ResponseCode = uint32(r.Uint32())
	this.ErrorMessage = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTlsFingerprintMatcherType(r randyTypes, easy bool) *TlsFingerprintMatcherType {
	this := &TlsFingerprintMatcherType{}
	v7 := r.Intn(10)
	this.Classes = make([]KnownTlsFingerprintClass, v7)
	for i := 0; i < v7; i++ {
		this.Classes[i] = KnownTlsFingerprintClass([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}[r.Intn(14)])
	}
	v8 := r.Intn(10)
	this.ExactValues = make([]string, v8)
	for i := 0; i < v8; i++ {
		this.ExactValues[i] = string(randStringTypes(r))
	}
	v9 := r.Intn(10)
	this.ExcludedValues = make([]string, v9)
	for i := 0; i < v9; i++ {
		this.ExcludedValues[i] = string(randStringTypes(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPathMatcherType(r randyTypes, easy bool) *PathMatcherType {
	this := &PathMatcherType{}
	v10 := r.Intn(10)
	this.PrefixValues = make([]string, v10)
	for i := 0; i < v10; i++ {
		this.PrefixValues[i] = string(randStringTypes(r))
	}
	v11 := r.Intn(10)
	this.ExactValues = make([]string, v11)
	for i := 0; i < v11; i++ {
		this.ExactValues[i] = string(randStringTypes(r))
	}
	v12 := r.Intn(10)
	this.RegexValues = make([]string, v12)
	for i := 0; i < v12; i++ {
		this.RegexValues[i] = string(randStringTypes(r))
	}
	v13 := r.Intn(10)
	this.Transformers = make([]Transformer, v13)
	for i := 0; i < v13; i++ {
		this.Transformers[i] = Transformer([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}[r.Intn(10)])
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMatcherType(r randyTypes, easy bool) *MatcherType {
	this := &MatcherType{}
	v14 := r.Intn(10)
	this.ExactValues = make([]string, v14)
	for i := 0; i < v14; i++ {
		this.ExactValues[i] = string(randStringTypes(r))
	}
	v15 := r.Intn(10)
	this.RegexValues = make([]string, v15)
	for i := 0; i < v15; i++ {
		this.RegexValues[i] = string(randStringTypes(r))
	}
	v16 := r.Intn(10)
	this.Transformers = make([]Transformer, v16)
	for i := 0; i < v16; i++ {
		this.Transformers[i] = Transformer([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}[r.Intn(10)])
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMatcherTypeBasic(r randyTypes, easy bool) *MatcherTypeBasic {
	this := &MatcherTypeBasic{}
	v17 := r.Intn(10)
	this.ExactValues = make([]string, v17)
	for i := 0; i < v17; i++ {
		this.ExactValues[i] = string(randStringTypes(r))
	}
	v18 := r.Intn(10)
	this.RegexValues = make([]string, v18)
	for i := 0; i < v18; i++ {
		this.RegexValues[i] = string(randStringTypes(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCookieMatcherType(r randyTypes, easy bool) *CookieMatcherType {
	this := &CookieMatcherType{}
	this.Name = string(randStringTypes(r))
	oneofNumber_Match := []int32{2, 3, 7, 8}[r.Intn(4)]
	switch oneofNumber_Match {
	case 2:
		this.Match = NewPopulatedCookieMatcherType_Presence(r, easy)
	case 3:
		this.Match = NewPopulatedCookieMatcherType_Item(r, easy)
	case 7:
		this.Match = NewPopulatedCookieMatcherType_CheckPresent(r, easy)
	case 8:
		this.Match = NewPopulatedCookieMatcherType_CheckNotPresent(r, easy)
	}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCookieMatcherType_Presence(r randyTypes, easy bool) *CookieMatcherType_Presence {
	this := &CookieMatcherType_Presence{}
	this.Presence = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedCookieMatcherType_Item(r randyTypes, easy bool) *CookieMatcherType_Item {
	this := &CookieMatcherType_Item{}
	this.Item = NewPopulatedMatcherType(r, easy)
	return this
}
func NewPopulatedCookieMatcherType_CheckPresent(r randyTypes, easy bool) *CookieMatcherType_CheckPresent {
	this := &CookieMatcherType_CheckPresent{}
	this.CheckPresent = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedCookieMatcherType_CheckNotPresent(r randyTypes, easy bool) *CookieMatcherType_CheckNotPresent {
	this := &CookieMatcherType_CheckNotPresent{}
	this.CheckNotPresent = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedArgMatcherType(r randyTypes, easy bool) *ArgMatcherType {
	this := &ArgMatcherType{}
	this.Name = string(randStringTypes(r))
	oneofNumber_Match := []int32{2, 3, 7, 8}[r.Intn(4)]
	switch oneofNumber_Match {
	case 2:
		this.Match = NewPopulatedArgMatcherType_Presence(r, easy)
	case 3:
		this.Match = NewPopulatedArgMatcherType_Item(r, easy)
	case 7:
		this.Match = NewPopulatedArgMatcherType_CheckPresent(r, easy)
	case 8:
		this.Match = NewPopulatedArgMatcherType_CheckNotPresent(r, easy)
	}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedArgMatcherType_Presence(r randyTypes, easy bool) *ArgMatcherType_Presence {
	this := &ArgMatcherType_Presence{}
	this.Presence = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedArgMatcherType_Item(r randyTypes, easy bool) *ArgMatcherType_Item {
	this := &ArgMatcherType_Item{}
	this.Item = NewPopulatedMatcherType(r, easy)
	return this
}
func NewPopulatedArgMatcherType_CheckPresent(r randyTypes, easy bool) *ArgMatcherType_CheckPresent {
	this := &ArgMatcherType_CheckPresent{}
	this.CheckPresent = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedArgMatcherType_CheckNotPresent(r randyTypes, easy bool) *ArgMatcherType_CheckNotPresent {
	this := &ArgMatcherType_CheckNotPresent{}
	this.CheckNotPresent = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedHeaderMatcherType(r randyTypes, easy bool) *HeaderMatcherType {
	this := &HeaderMatcherType{}
	this.Name = string(randStringTypes(r))
	oneofNumber_Match := []int32{2, 3, 7, 8}[r.Intn(4)]
	switch oneofNumber_Match {
	case 2:
		this.Match = NewPopulatedHeaderMatcherType_Presence(r, easy)
	case 3:
		this.Match = NewPopulatedHeaderMatcherType_Item(r, easy)
	case 7:
		this.Match = NewPopulatedHeaderMatcherType_CheckPresent(r, easy)
	case 8:
		this.Match = NewPopulatedHeaderMatcherType_CheckNotPresent(r, easy)
	}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHeaderMatcherType_Presence(r randyTypes, easy bool) *HeaderMatcherType_Presence {
	this := &HeaderMatcherType_Presence{}
	this.Presence = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedHeaderMatcherType_Item(r randyTypes, easy bool) *HeaderMatcherType_Item {
	this := &HeaderMatcherType_Item{}
	this.Item = NewPopulatedMatcherType(r, easy)
	return this
}
func NewPopulatedHeaderMatcherType_CheckPresent(r randyTypes, easy bool) *HeaderMatcherType_CheckPresent {
	this := &HeaderMatcherType_CheckPresent{}
	this.CheckPresent = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedHeaderMatcherType_CheckNotPresent(r randyTypes, easy bool) *HeaderMatcherType_CheckNotPresent {
	this := &HeaderMatcherType_CheckNotPresent{}
	this.CheckNotPresent = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedQueryParameterMatcherType(r randyTypes, easy bool) *QueryParameterMatcherType {
	this := &QueryParameterMatcherType{}
	this.Key = string(randStringTypes(r))
	oneofNumber_Match := []int32{2, 3, 7, 8}[r.Intn(4)]
	switch oneofNumber_Match {
	case 2:
		this.Match = NewPopulatedQueryParameterMatcherType_Presence(r, easy)
	case 3:
		this.Match = NewPopulatedQueryParameterMatcherType_Item(r, easy)
	case 7:
		this.Match = NewPopulatedQueryParameterMatcherType_CheckPresent(r, easy)
	case 8:
		this.Match = NewPopulatedQueryParameterMatcherType_CheckNotPresent(r, easy)
	}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedQueryParameterMatcherType_Presence(r randyTypes, easy bool) *QueryParameterMatcherType_Presence {
	this := &QueryParameterMatcherType_Presence{}
	this.Presence = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedQueryParameterMatcherType_Item(r randyTypes, easy bool) *QueryParameterMatcherType_Item {
	this := &QueryParameterMatcherType_Item{}
	this.Item = NewPopulatedMatcherType(r, easy)
	return this
}
func NewPopulatedQueryParameterMatcherType_CheckPresent(r randyTypes, easy bool) *QueryParameterMatcherType_CheckPresent {
	this := &QueryParameterMatcherType_CheckPresent{}
	this.CheckPresent = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedQueryParameterMatcherType_CheckNotPresent(r randyTypes, easy bool) *QueryParameterMatcherType_CheckNotPresent {
	this := &QueryParameterMatcherType_CheckNotPresent{}
	this.CheckNotPresent = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedHttpMethodMatcherType(r randyTypes, easy bool) *HttpMethodMatcherType {
	this := &HttpMethodMatcherType{}
	v19 := r.Intn(10)
	this.Methods = make([]ves_io_schema4.HttpMethod, v19)
	for i := 0; i < v19; i++ {
		this.Methods[i] = ves_io_schema4.HttpMethod([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}[r.Intn(10)])
	}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRoleMatcherType(r randyTypes, easy bool) *RoleMatcherType {
	this := &RoleMatcherType{}
	this.Match = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStringMatcherType(r randyTypes, easy bool) *StringMatcherType {
	this := &StringMatcherType{}
	v20 := r.Intn(10)
	this.Match = make([]string, v20)
	for i := 0; i < v20; i++ {
		this.Match[i] = string(randStringTypes(r))
	}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpMatcherType(r randyTypes, easy bool) *IpMatcherType {
	this := &IpMatcherType{}
	if r.Intn(10) != 0 {
		v21 := r.Intn(5)
		this.PrefixSets = make([]*ves_io_schema4.ObjectRefType, v21)
		for i := 0; i < v21; i++ {
			this.PrefixSets[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAsnMatcherType(r randyTypes, easy bool) *AsnMatcherType {
	this := &AsnMatcherType{}
	if r.Intn(10) != 0 {
		v22 := r.Intn(5)
		this.AsnSets = make([]*ves_io_schema4.ObjectRefType, v22)
		for i := 0; i < v22; i++ {
			this.AsnSets[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPortMatcherType(r randyTypes, easy bool) *PortMatcherType {
	this := &PortMatcherType{}
	v23 := r.Intn(10)
	this.Ports = make([]string, v23)
	for i := 0; i < v23; i++ {
		this.Ports[i] = string(randStringTypes(r))
	}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedURLItem(r randyTypes, easy bool) *URLItem {
	this := &URLItem{}
	oneofNumber_DomainChoice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_DomainChoice {
	case 2:
		this.DomainChoice = NewPopulatedURLItem_DomainValue(r, easy)
	case 3:
		this.DomainChoice = NewPopulatedURLItem_DomainRegex(r, easy)
	}
	oneofNumber_PathChoice := []int32{5, 6, 7}[r.Intn(3)]
	switch oneofNumber_PathChoice {
	case 5:
		this.PathChoice = NewPopulatedURLItem_PathValue(r, easy)
	case 6:
		this.PathChoice = NewPopulatedURLItem_PathRegex(r, easy)
	case 7:
		this.PathChoice = NewPopulatedURLItem_PathPrefix(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedURLItem_DomainValue(r randyTypes, easy bool) *URLItem_DomainValue {
	this := &URLItem_DomainValue{}
	this.DomainValue = string(randStringTypes(r))
	return this
}
func NewPopulatedURLItem_DomainRegex(r randyTypes, easy bool) *URLItem_DomainRegex {
	this := &URLItem_DomainRegex{}
	this.DomainRegex = string(randStringTypes(r))
	return this
}
func NewPopulatedURLItem_PathValue(r randyTypes, easy bool) *URLItem_PathValue {
	this := &URLItem_PathValue{}
	this.PathValue = string(randStringTypes(r))
	return this
}
func NewPopulatedURLItem_PathRegex(r randyTypes, easy bool) *URLItem_PathRegex {
	this := &URLItem_PathRegex{}
	this.PathRegex = string(randStringTypes(r))
	return this
}
func NewPopulatedURLItem_PathPrefix(r randyTypes, easy bool) *URLItem_PathPrefix {
	this := &URLItem_PathPrefix{}
	this.PathPrefix = string(randStringTypes(r))
	return this
}
func NewPopulatedURLMatcherType(r randyTypes, easy bool) *URLMatcherType {
	this := &URLMatcherType{}
	if r.Intn(10) != 0 {
		v24 := r.Intn(5)
		this.UrlItems = make([]*URLItem, v24)
		for i := 0; i < v24; i++ {
			this.UrlItems[i] = NewPopulatedURLItem(r, easy)
		}
	}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedL4DestMatcherType(r randyTypes, easy bool) *L4DestMatcherType {
	this := &L4DestMatcherType{}
	this.InvertMatcher = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v25 := r.Intn(5)
		this.L4Dests = make([]*ves_io_schema4.L4DestType, v25)
		for i := 0; i < v25; i++ {
			this.L4Dests[i] = ves_io_schema4.NewPopulatedL4DestType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v26 := r.Intn(100)
	tmps := make([]rune, v26)
	for i := 0; i < v26; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v27 := r.Int63()
		if r.Intn(2) == 0 {
			v27 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v27))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *WafRuleControl) Size() (n int) {
	var l int
	_ = l
	if len(m.ExcludeRuleIds) > 0 {
		for _, e := range m.ExcludeRuleIds {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *WafInlineRuleControl) Size() (n int) {
	var l int
	_ = l
	if len(m.ExcludeRuleIds) > 0 {
		l = 0
		for _, e := range m.ExcludeRuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *WafAction) Size() (n int) {
	var l int
	_ = l
	if m.ActionType != nil {
		n += m.ActionType.Size()
	}
	return n
}

func (m *WafAction_WafSkipProcessing) Size() (n int) {
	var l int
	_ = l
	if m.WafSkipProcessing != nil {
		l = m.WafSkipProcessing.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_WafRuleControl) Size() (n int) {
	var l int
	_ = l
	if m.WafRuleControl != nil {
		l = m.WafRuleControl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_None) Size() (n int) {
	var l int
	_ = l
	if m.None != nil {
		l = m.None.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_WafInlineRuleControl) Size() (n int) {
	var l int
	_ = l
	if m.WafInlineRuleControl != nil {
		l = m.WafInlineRuleControl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PrefixMatchList) Size() (n int) {
	var l int
	_ = l
	if len(m.IpPrefixes) > 0 {
		for _, s := range m.IpPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatch {
		n += 2
	}
	return n
}

func (m *AsnMatchList) Size() (n int) {
	var l int
	_ = l
	if len(m.AsNumbers) > 0 {
		l = 0
		for _, e := range m.AsNumbers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *SimpleWafExclusionRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	l = len(m.PathRegex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Methods) > 0 {
		l = 0
		for _, e := range m.Methods {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.ExcludeRuleIds) > 0 {
		l = 0
		for _, e := range m.ExcludeRuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SimpleWafExclusionRule_AnyDomain) Size() (n int) {
	var l int
	_ = l
	if m.AnyDomain != nil {
		l = m.AnyDomain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SimpleWafExclusionRule_DomainRegex) Size() (n int) {
	var l int
	_ = l
	l = len(m.DomainRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DenyInformation) Size() (n int) {
	var l int
	_ = l
	if m.ResponseCode != 0 {
		n += 1 + sovTypes(uint64(m.ResponseCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TlsFingerprintMatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.Classes) > 0 {
		l = 0
		for _, e := range m.Classes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExcludedValues) > 0 {
		for _, s := range m.ExcludedValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PathMatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.PrefixValues) > 0 {
		for _, s := range m.PrefixValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Transformers) > 0 {
		l = 0
		for _, e := range m.Transformers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *MatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Transformers) > 0 {
		l = 0
		for _, e := range m.Transformers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *MatcherTypeBasic) Size() (n int) {
	var l int
	_ = l
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CookieMatcherType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *CookieMatcherType_Presence) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *CookieMatcherType_Item) Size() (n int) {
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieMatcherType_CheckPresent) Size() (n int) {
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieMatcherType_CheckNotPresent) Size() (n int) {
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ArgMatcherType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *ArgMatcherType_Presence) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *ArgMatcherType_Item) Size() (n int) {
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ArgMatcherType_CheckPresent) Size() (n int) {
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ArgMatcherType_CheckNotPresent) Size() (n int) {
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *HeaderMatcherType_Presence) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *HeaderMatcherType_Item) Size() (n int) {
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType_CheckPresent) Size() (n int) {
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType_CheckNotPresent) Size() (n int) {
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcherType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *QueryParameterMatcherType_Presence) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *QueryParameterMatcherType_Item) Size() (n int) {
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcherType_CheckPresent) Size() (n int) {
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcherType_CheckNotPresent) Size() (n int) {
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HttpMethodMatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.Methods) > 0 {
		l = 0
		for _, e := range m.Methods {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *RoleMatcherType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Match)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StringMatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, s := range m.Match {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *IpMatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.PrefixSets) > 0 {
		for _, e := range m.PrefixSets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *AsnMatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.AsnSets) > 0 {
		for _, e := range m.AsnSets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PortMatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *URLItem) Size() (n int) {
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	if m.PathChoice != nil {
		n += m.PathChoice.Size()
	}
	return n
}

func (m *URLItem_DomainValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.DomainValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_DomainRegex) Size() (n int) {
	var l int
	_ = l
	l = len(m.DomainRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_PathValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.PathValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_PathRegex) Size() (n int) {
	var l int
	_ = l
	l = len(m.PathRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_PathPrefix) Size() (n int) {
	var l int
	_ = l
	l = len(m.PathPrefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLMatcherType) Size() (n int) {
	var l int
	_ = l
	if len(m.UrlItems) > 0 {
		for _, e := range m.UrlItems {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *L4DestMatcherType) Size() (n int) {
	var l int
	_ = l
	if m.InvertMatcher {
		n += 2
	}
	if len(m.L4Dests) > 0 {
		for _, e := range m.L4Dests {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WafRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafRuleControl{`,
		`ExcludeRuleIds:` + strings.Replace(fmt.Sprintf("%v", this.ExcludeRuleIds), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafInlineRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafInlineRuleControl{`,
		`ExcludeRuleIds:` + fmt.Sprintf("%v", this.ExcludeRuleIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction{`,
		`ActionType:` + fmt.Sprintf("%v", this.ActionType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafSkipProcessing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafSkipProcessing{`,
		`WafSkipProcessing:` + strings.Replace(fmt.Sprintf("%v", this.WafSkipProcessing), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafRuleControl{`,
		`WafRuleControl:` + strings.Replace(fmt.Sprintf("%v", this.WafRuleControl), "WafRuleControl", "WafRuleControl", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_None) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_None{`,
		`None:` + strings.Replace(fmt.Sprintf("%v", this.None), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafInlineRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafInlineRuleControl{`,
		`WafInlineRuleControl:` + strings.Replace(fmt.Sprintf("%v", this.WafInlineRuleControl), "WafInlineRuleControl", "WafInlineRuleControl", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrefixMatchList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrefixMatchList{`,
		`IpPrefixes:` + fmt.Sprintf("%v", this.IpPrefixes) + `,`,
		`InvertMatch:` + fmt.Sprintf("%v", this.InvertMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AsnMatchList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AsnMatchList{`,
		`AsNumbers:` + fmt.Sprintf("%v", this.AsNumbers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`PathRegex:` + fmt.Sprintf("%v", this.PathRegex) + `,`,
		`Methods:` + fmt.Sprintf("%v", this.Methods) + `,`,
		`ExcludeRuleIds:` + fmt.Sprintf("%v", this.ExcludeRuleIds) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule_AnyDomain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule_AnyDomain{`,
		`AnyDomain:` + strings.Replace(fmt.Sprintf("%v", this.AnyDomain), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule_DomainRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule_DomainRegex{`,
		`DomainRegex:` + fmt.Sprintf("%v", this.DomainRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DenyInformation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DenyInformation{`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`ErrorMessage:` + fmt.Sprintf("%v", this.ErrorMessage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsFingerprintMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsFingerprintMatcherType{`,
		`Classes:` + fmt.Sprintf("%v", this.Classes) + `,`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`ExcludedValues:` + fmt.Sprintf("%v", this.ExcludedValues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType{`,
		`PrefixValues:` + fmt.Sprintf("%v", this.PrefixValues) + `,`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`Transformers:` + fmt.Sprintf("%v", this.Transformers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatcherType{`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`Transformers:` + fmt.Sprintf("%v", this.Transformers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatcherTypeBasic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatcherTypeBasic{`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HttpMethodMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HttpMethodMatcherType{`,
		`Methods:` + fmt.Sprintf("%v", this.Methods) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoleMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoleMatcherType{`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StringMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StringMatcherType{`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpMatcherType{`,
		`PrefixSets:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSets), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AsnMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AsnMatcherType{`,
		`AsnSets:` + strings.Replace(fmt.Sprintf("%v", this.AsnSets), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortMatcherType{`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`PathChoice:` + fmt.Sprintf("%v", this.PathChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_DomainValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_DomainValue{`,
		`DomainValue:` + fmt.Sprintf("%v", this.DomainValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_DomainRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_DomainRegex{`,
		`DomainRegex:` + fmt.Sprintf("%v", this.DomainRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_PathValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_PathValue{`,
		`PathValue:` + fmt.Sprintf("%v", this.PathValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_PathRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_PathRegex{`,
		`PathRegex:` + fmt.Sprintf("%v", this.PathRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_PathPrefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_PathPrefix{`,
		`PathPrefix:` + fmt.Sprintf("%v", this.PathPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLMatcherType{`,
		`UrlItems:` + strings.Replace(fmt.Sprintf("%v", this.UrlItems), "URLItem", "URLItem", 1) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L4DestMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L4DestMatcherType{`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`L4Dests:` + strings.Replace(fmt.Sprintf("%v", this.L4Dests), "L4DestType", "ves_io_schema4.L4DestType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *WafRuleControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafRuleControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafRuleControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeRuleIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeRuleIds = append(m.ExcludeRuleIds, &ves_io_schema4.ObjectRefType{})
			if err := m.ExcludeRuleIds[len(m.ExcludeRuleIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafInlineRuleControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafInlineRuleControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafInlineRuleControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ves_io_schema_waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ves_io_schema_waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeRuleIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafSkipProcessing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafSkipProcessing{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafRuleControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafRuleControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafRuleControl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field None", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_None{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafInlineRuleControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafInlineRuleControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafInlineRuleControl{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrefixMatchList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrefixMatchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrefixMatchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefixes = append(m.IpPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsnMatchList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsnMatchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsnMatchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AsNumbers = append(m.AsNumbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AsNumbers = append(m.AsNumbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumbers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleWafExclusionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleWafExclusionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleWafExclusionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &SimpleWafExclusionRule_AnyDomain{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &SimpleWafExclusionRule_DomainRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v ves_io_schema4.HttpMethod
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ves_io_schema4.HttpMethod(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Methods = append(m.Methods, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ves_io_schema4.HttpMethod
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ves_io_schema4.HttpMethod(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Methods = append(m.Methods, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
		case 8:
			if wireType == 0 {
				var v ves_io_schema_waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ves_io_schema_waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeRuleIds", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenyInformation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenyInformation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenyInformation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsFingerprintMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsFingerprintMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsFingerprintMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v KnownTlsFingerprintClass
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (KnownTlsFingerprintClass(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Classes = append(m.Classes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v KnownTlsFingerprintClass
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (KnownTlsFingerprintClass(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Classes = append(m.Classes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Classes", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludedValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludedValues = append(m.ExcludedValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixValues = append(m.PrefixValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v Transformer
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Transformer(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Transformers = append(m.Transformers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Transformer
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Transformer(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Transformers = append(m.Transformers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Transformers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v Transformer
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Transformer(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Transformers = append(m.Transformers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Transformer
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Transformer(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Transformers = append(m.Transformers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Transformers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatcherTypeBasic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatcherTypeBasic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatcherTypeBasic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &CookieMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &CookieMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &CookieMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &CookieMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &ArgMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ArgMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ArgMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ArgMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &HeaderMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParameterMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParameterMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParameterMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &QueryParameterMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &QueryParameterMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &QueryParameterMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &QueryParameterMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpMethodMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpMethodMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpMethodMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ves_io_schema4.HttpMethod
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ves_io_schema4.HttpMethod(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Methods = append(m.Methods, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ves_io_schema4.HttpMethod
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ves_io_schema4.HttpMethod(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Methods = append(m.Methods, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixSets = append(m.PrefixSets, &ves_io_schema4.ObjectRefType{})
			if err := m.PrefixSets[len(m.PrefixSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsnMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsnMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsnMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsnSets = append(m.AsnSets, &ves_io_schema4.ObjectRefType{})
			if err := m.AsnSets[len(m.AsnSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &URLItem_DomainValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &URLItem_DomainRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathChoice = &URLItem_PathValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathChoice = &URLItem_PathRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathChoice = &URLItem_PathPrefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlItems = append(m.UrlItems, &URLItem{})
			if err := m.UrlItems[len(m.UrlItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4DestMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4DestMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4DestMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Dests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.L4Dests = append(m.L4Dests, &ves_io_schema4.L4DestType{})
			if err := m.L4Dests[len(m.L4Dests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/policy/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/policy/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 4165 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x4b, 0x6c, 0x5c, 0xe7,
	0x75, 0xe6, 0xe5, 0x43, 0x24, 0x7f, 0x3e, 0x34, 0x1a, 0x2b, 0x09, 0xad, 0xc6, 0xcc, 0x0d, 0x5b,
	0x34, 0x86, 0x22, 0x53, 0xff, 0xfb, 0x91, 0x02, 0x49, 0xf8, 0x18, 0x99, 0x63, 0x53, 0x1c, 0xfa,
	0x72, 0x64, 0xd9, 0xde, 0x0c, 0xfe, 0xc7, 0xf9, 0xa9, 0xa9, 0xc9, 0x19, 0x62, 0x66, 0x24, 0x4b,
	0x8b, 0x14, 0x46, 0x57, 0x5d, 0xf4, 0x85, 0x6c, 0x9a, 0x6e, 0xba, 0xe8, 0xaa, 0xc8, 0xaa, 0xab,
	0xa2, 0x28, 0x37, 0xea, 0x2e, 0x28, 0xba, 0xd0, 0xa6, 0x68, 0x80, 0x6e, 0x62, 0x66, 0x93, 0x6e,
	0x8a, 0x20, 0x48, 0x01, 0x77, 0x57, 0xdc, 0x3b, 0x33, 0xd2, 0x8c, 0x44, 0xb9, 0x76, 0xeb, 0x00,
	0x5d, 0x70, 0x77, 0xef, 0xfd, 0xcf, 0xeb, 0x7e, 0xe7, 0xfc, 0xe7, 0x9e, 0xfb, 0x9f, 0x83, 0xd2,
	0x07, 0xd0, 0x5d, 0x6f, 0xb6, 0x6f, 0x76, 0xfd, 0x3d, 0x38, 0xb6, 0x37, 0x4f, 0xda, 0x47, 0x4d,
	0xff, 0xe8, 0x66, 0xef, 0xd1, 0x09, 0x74, 0xd7, 0x4f, 0x3a, 0xed, 0x5e, 0xbb, 0x7c, 0xb5, 0x4f,
	0xb1, 0xde, 0xa7, 0x58, 0xef, 0x53, 0x5c, 0x7b, 0xe3, 0xb0, 0xd9, 0xbb, 0x77, 0xdf, 0xad, 0xfb,
	0xf6, 0xf1, 0xcd, 0xc3, 0xf6, 0x61, 0xfb, 0x66, 0x41, 0xec, 0xee, 0xc7, 0xe2, 0xae, 0xb8, 0x29,
	0xae, 0xfa, 0x42, 0xae, 0x7d, 0xe3, 0xb0, 0xdd, 0x3e, 0x3c, 0x82, 0x67, 0x54, 0xbd, 0xe6, 0x31,
	0x74, 0x7b, 0xf6, 0xf8, 0x64, 0x40, 0xf0, 0xb5, 0x71, 0x3b, 0x5a, 0xd0, 0x1b, 0x2c, 0xfc, 0xd6,
	0xf8, 0x42, 0xfb, 0xa4, 0xd7, 0x6c, 0xb7, 0x06, 0xb6, 0x5d, 0x7b, 0x75, 0x7c, 0x71, 0xc4, 0xec,
	0x6b, 0x5f, 0x1f, 0x5f, 0x7a, 0x60, 0x8f, 0x9a, 0xc1, 0xf6, 0x60, 0xb0, 0xfa, 0xdc, 0x6b, 0x3f,
	0x68, 0xc2, 0x47, 0x8d, 0x71, 0xd1, 0xdf, 0x1a, 0xa7, 0xf8, 0xc8, 0xc6, 0x46, 0xe7, 0xfe, 0x11,
	0x34, 0x8e, 0x9a, 0xdd, 0xde, 0xa8, 0xa2, 0xb5, 0x1e, 0x5a, 0xbe, 0x6b, 0x63, 0x76, 0xff, 0x08,
	0xb6, 0xda, 0xad, 0x5e, 0xa7, 0x7d, 0x54, 0x76, 0xa8, 0x04, 0x0f, 0xfd, 0xd1, 0xfd, 0x00, 0x7d,
	0x96, 0x66, 0xe8, 0xae, 0x24, 0xe9, 0xd4, 0xeb, 0x0b, 0xf4, 0xeb, 0xeb, 0xe3, 0x60, 0xd6, 0xdc,
	0xef, 0x83, 0xef, 0x65, 0x10, 0xeb, 0x8f, 0x4e, 0x60, 0xf3, 0xda, 0x8f, 0x7f, 0xb0, 0x34, 0xa6,
	0xe7, 0x1f, 0xfe, 0xfd, 0xf1, 0xd4, 0xcc, 0x0f, 0x93, 0xc9, 0xd2, 0x74, 0xb6, 0x3c, 0x90, 0x98,
	0xeb, 0xa9, 0x86, 0xee, 0xda, 0x1f, 0xa0, 0xab, 0x77, 0x6d, 0xac, 0xb6, 0x8e, 0x9a, 0x2d, 0x18,
	0xd5, 0x1d, 0x5f, 0xa2, 0x7b, 0x99, 0xfe, 0xee, 0x73, 0xba, 0xc7, 0x34, 0xad, 0x0f, 0x5e, 0xa1,
	0xba, 0xbd, 0x79, 0xf5, 0xa9, 0xd6, 0xef, 0x0f, 0xaf, 0x56, 0x92, 0x17, 0xf4, 0xff, 0x6c, 0x12,
	0xcd, 0xdf, 0xb5, 0x71, 0xc3, 0xe7, 0x98, 0x95, 0x6f, 0xa1, 0x57, 0x72, 0x71, 0xdd, 0x0f, 0x9b,
	0x27, 0x8d, 0x93, 0x4e, 0xdb, 0x43, 0xb7, 0xdb, 0x6c, 0x1d, 0xae, 0x24, 0x69, 0xf2, 0xfa, 0x02,
	0xbd, 0xfa, 0x9c, 0xe2, 0xca, 0xf1, 0x49, 0xef, 0xd1, 0xce, 0x44, 0x76, 0xe5, 0x23, 0x1b, 0x0f,
	0x3e, 0x6c, 0x9e, 0xec, 0x3f, 0x65, 0x28, 0xef, 0xa3, 0xd2, 0x53, 0xb3, 0x7c, 0xff, 0x8d, 0x56,
	0x26, 0x0b, 0x21, 0xbf, 0xb3, 0x7e, 0x5e, 0x18, 0xae, 0x8f, 0x23, 0xbf, 0x33, 0x91, 0x2d, 0x7f,
	0x34, 0xee, 0x8b, 0xeb, 0x68, 0xba, 0xd5, 0x6e, 0xc1, 0xca, 0xd4, 0x67, 0x9a, 0x52, 0xd0, 0x94,
	0x3d, 0xfa, 0x5a, 0xae, 0xbd, 0x59, 0x80, 0x3a, 0x6e, 0xc4, 0x74, 0xc1, 0x7e, 0xfd, 0xa5, 0x46,
	0xbc, 0xe0, 0x88, 0x9d, 0x89, 0xec, 0xea, 0x47, 0xe7, 0x3c, 0xdf, 0x5c, 0x43, 0x0b, 0xb6, 0x00,
	0xad, 0x91, 0x07, 0x51, 0xf9, 0x95, 0xc7, 0xa7, 0xc9, 0xd4, 0x93, 0xd3, 0x64, 0xe6, 0xec, 0x34,
	0x99, 0x65, 0x37, 0xc8, 0x0d, 0x7e, 0x83, 0xbe, 0x35, 0x3d, 0x37, 0x53, 0xba, 0xb4, 0xf6, 0xa7,
	0x09, 0xba, 0xbc, 0xdf, 0x81, 0xd8, 0x7c, 0x78, 0xdb, 0xf6, 0xfc, 0xbd, 0xdd, 0x66, 0xb7, 0x57,
	0xce, 0xd0, 0x42, 0x01, 0x71, 0xfe, 0x14, 0xfa, 0x9e, 0x9d, 0xdf, 0x24, 0x9f, 0x9e, 0x26, 0x13,
	0xb9, 0xaf, 0xd0, 0x0f, 0x93, 0xd9, 0xb5, 0x99, 0xce, 0xd4, 0xa7, 0x49, 0xf2, 0xd4, 0x89, 0xa5,
	0xe1, 0xd5, 0x5c, 0x32, 0xe2, 0x4e, 0x94, 0xc3, 0xde, 0x17, 0x52, 0xfe, 0x16, 0x5a, 0x6c, 0xb6,
	0x1e, 0x40, 0xa7, 0xd7, 0x38, 0xce, 0xf5, 0x14, 0x80, 0xcf, 0x6d, 0x4e, 0x3f, 0x3e, 0x4d, 0x92,
	0x6c, 0xa1, 0xbf, 0x52, 0x18, 0xb0, 0xf6, 0x0e, 0x5a, 0xdc, 0xe8, 0xb6, 0x9e, 0x19, 0xb3, 0x81,
	0x90, 0xed, 0x36, 0x5a, 0xf7, 0x8f, 0x1d, 0x74, 0xfa, 0xb6, 0x2c, 0x6d, 0xae, 0x0d, 0x6d, 0xf9,
	0x0c, 0xe5, 0xf3, 0xb6, 0xbb, 0xd7, 0x67, 0x5a, 0xfb, 0xbb, 0x69, 0xf4, 0xd5, 0x83, 0xe6, 0xf1,
	0xc9, 0x11, 0xdc, 0xb5, 0xb1, 0x92, 0x87, 0x58, 0xb7, 0xd9, 0x6e, 0xe5, 0x78, 0x95, 0x5f, 0x43,
	0xd3, 0x2d, 0x7b, 0x0c, 0x45, 0x10, 0xcd, 0x6f, 0xce, 0xe7, 0xfc, 0xd3, 0x9d, 0xc9, 0x95, 0xef,
	0x67, 0xc5, 0xe3, 0xf2, 0x0d, 0xb4, 0x10, 0xa0, 0xeb, 0x3b, 0xcd, 0x62, 0xd7, 0x16, 0x46, 0xcf,
	0x6f, 0xa2, 0x42, 0x4b, 0x67, 0x6a, 0xe5, 0xe3, 0xc9, 0x6c, 0x74, 0xb9, 0x2c, 0x10, 0xb2, 0xad,
	0x47, 0x8d, 0xd0, 0x3e, 0xb6, 0xcd, 0xd6, 0xc0, 0x9b, 0x2f, 0x0b, 0x86, 0x79, 0xdb, 0x7a, 0xb4,
	0x5d, 0x10, 0x96, 0x0d, 0x5a, 0xec, 0xb3, 0x34, 0x3a, 0x70, 0x08, 0x0f, 0x57, 0x66, 0x0a, 0x2d,
	0x57, 0x9f, 0x69, 0x19, 0x5c, 0xfd, 0xd1, 0x64, 0xb2, 0x33, 0x91, 0x2d, 0xf4, 0x69, 0xb3, 0x9c,
	0xb4, 0xcc, 0x10, 0x3a, 0xb1, 0xbd, 0x7b, 0x03, 0xc6, 0x4b, 0x63, 0x8c, 0xaf, 0x3f, 0x65, 0x7c,
	0x9c, 0x24, 0xd9, 0x7c, 0x4e, 0xd7, 0x67, 0xaa, 0xa2, 0xd9, 0x63, 0xe8, 0xdd, 0x6b, 0x87, 0xee,
	0xca, 0x6c, 0xb1, 0x69, 0x5f, 0x7d, 0xce, 0xc6, 0x9d, 0x5e, 0xef, 0xe4, 0x76, 0x41, 0x31, 0x10,
	0xf6, 0x87, 0xc9, 0x64, 0x69, 0x14, 0xdb, 0x21, 0xff, 0xb9, 0x89, 0x60, 0xee, 0xcb, 0x4f, 0x04,
	0xe5, 0xdb, 0xe8, 0x2a, 0x3c, 0x3c, 0x69, 0x76, 0x6c, 0x3f, 0xa6, 0x87, 0x69, 0x7d, 0x65, 0xbe,
	0xc0, 0xf8, 0xda, 0x7a, 0x3f, 0xf1, 0xaf, 0x0f, 0x13, 0xff, 0x7a, 0x7d, 0x48, 0x91, 0xbd, 0xf2,
	0x8c, 0xef, 0xe9, 0xc3, 0xcd, 0x14, 0x2d, 0x0d, 0x10, 0xf7, 0xf7, 0xda, 0x4d, 0x0f, 0xe5, 0xcb,
	0x8f, 0x4f, 0x93, 0xe9, 0x27, 0xa7, 0xc9, 0xd4, 0xd9, 0x69, 0x32, 0xc5, 0x6f, 0x88, 0xb7, 0xa6,
	0xe7, 0xa6, 0x4a, 0xd3, 0x6b, 0x5d, 0x74, 0x79, 0x1b, 0x5a, 0x8f, 0xaa, 0xad, 0xd8, 0xee, 0x1c,
	0x17, 0x32, 0xca, 0x37, 0xd1, 0x52, 0x07, 0xba, 0x27, 0xed, 0x56, 0x37, 0xdf, 0xb7, 0xa1, 0x1f,
	0x39, 0x4b, 0x83, 0x98, 0xb8, 0x3e, 0xb5, 0xf2, 0xaf, 0xd3, 0xd9, 0xe2, 0x90, 0x60, 0xab, 0x1d,
	0x20, 0x67, 0x80, 0x4e, 0xa7, 0xdd, 0x69, 0x1c, 0x43, 0xb7, 0x6b, 0x0f, 0xe1, 0xb9, 0x20, 0x7a,
	0xfd, 0xe3, 0xe9, 0x6c, 0xb1, 0x20, 0xb8, 0xdd, 0x5f, 0x5f, 0x3b, 0xfd, 0x16, 0x7a, 0xb5, 0x7e,
	0xd4, 0xbd, 0xd5, 0x6c, 0x1d, 0x42, 0xe7, 0xa4, 0xd3, 0x6c, 0xf5, 0x37, 0x06, 0x74, 0xf2, 0xf4,
	0x5d, 0x76, 0x68, 0xd6, 0x1f, 0xd9, 0x6e, 0x17, 0x86, 0x19, 0x77, 0xfd, 0xfc, 0x74, 0xf1, 0x76,
	0xab, 0xfd, 0x51, 0x6b, 0x5c, 0xcc, 0x56, 0xce, 0xb7, 0xb9, 0xf2, 0xe9, 0x69, 0x32, 0xf9, 0xe2,
	0xde, 0xc9, 0xbd, 0x3a, 0x10, 0x5c, 0xfe, 0xd1, 0x2b, 0x68, 0x11, 0x1e, 0x5a, 0xdf, 0x6b, 0x3c,
	0xb0, 0x47, 0xf7, 0xa1, 0xbb, 0x32, 0x59, 0x64, 0x80, 0x5f, 0x97, 0xcf, 0x4e, 0x93, 0x7f, 0x2e,
	0xa3, 0x94, 0x58, 0xab, 0x5c, 0xd4, 0xce, 0x28, 0x10, 0x1c, 0x7b, 0x2b, 0x20, 0x04, 0x25, 0xa2,
	0x72, 0x9a, 0x69, 0xee, 0xa2, 0x45, 0x29, 0xf3, 0xc1, 0x0a, 0x1a, 0x2c, 0xb7, 0x01, 0xb0, 0x89,
	0x24, 0x2a, 0x4d, 0x6c, 0xa0, 0xa0, 0x69, 0xf0, 0xd1, 0x52, 0x8c, 0x52, 0x15, 0x82, 0xc0, 0x40,
	0x08, 0xf5, 0x81, 0x32, 0xc5, 0xb8, 0x65, 0x04, 0x3b, 0x83, 0xa3, 0x8c, 0x9c, 0x5b, 0xe5, 0x03,
	0x4a, 0x89, 0x03, 0x06, 0x1e, 0x1c, 0x08, 0x6b, 0x4d, 0x60, 0x52, 0x70, 0x90, 0xa0, 0x30, 0x0b,
	0x9a, 0x44, 0x69, 0xa8, 0x46, 0xa9, 0x17, 0x94, 0x89, 0xc0, 0xac, 0x76, 0xc6, 0x30, 0xee, 0x54,
	0x74, 0x2e, 0x50, 0xcc, 0x83, 0xc0, 0xce, 0x63, 0xa1, 0x03, 0x4a, 0x41, 0x52, 0x2b, 0x22, 0x0f,
	0x82, 0x69, 0xef, 0x22, 0x91, 0xc6, 0x53, 0x1b, 0x15, 0x71, 0xe0, 0x29, 0x33, 0xc6, 0x71, 0x94,
	0x06, 0x6a, 0x98, 0xf0, 0x42, 0x47, 0x90, 0x4a, 0x2a, 0xce, 0x23, 0x78, 0xaf, 0x25, 0xe1, 0x00,
	0x82, 0x09, 0xe9, 0x15, 0x4a, 0x03, 0xf8, 0xe8, 0xb8, 0xb6, 0x82, 0x29, 0x6d, 0xc0, 0x01, 0xd6,
	0xc4, 0x69, 0x6d, 0xad, 0x73, 0x42, 0x03, 0x30, 0x8e, 0x52, 0x41, 0xbc, 0xe4, 0x5e, 0x29, 0x90,
	0x38, 0x32, 0xa3, 0x31, 0x80, 0x35, 0x58, 0x4b, 0xe3, 0xa4, 0xf6, 0x42, 0xdb, 0xdc, 0x52, 0x67,
	0xb4, 0xa5, 0x1c, 0x80, 0x3b, 0x43, 0x18, 0xe7, 0x5c, 0xc7, 0xe8, 0x84, 0x22, 0x3c, 0x06, 0xad,
	0xb0, 0xf5, 0x28, 0x65, 0x3c, 0x12, 0x6e, 0xa5, 0xb1, 0x41, 0x61, 0x6c, 0xbc, 0x15, 0x5a, 0x32,
	0xa6, 0x0c, 0x25, 0xda, 0x46, 0xa2, 0x22, 0x43, 0x69, 0x50, 0x12, 0x40, 0xf2, 0xe8, 0x14, 0x55,
	0x4c, 0x31, 0xe6, 0x1d, 0x70, 0x21, 0xac, 0xd7, 0xc4, 0x53, 0x43, 0x41, 0xa2, 0x54, 0x47, 0xe9,
	0x0d, 0xd1, 0xc1, 0x3b, 0xa1, 0x05, 0x38, 0x07, 0x16, 0x0b, 0xa0, 0xde, 0x1b, 0x2e, 0x18, 0x06,
	0x96, 0x63, 0x1a, 0xb0, 0x11, 0x20, 0x35, 0xd7, 0x26, 0x30, 0x2f, 0x98, 0xa0, 0x46, 0xf9, 0xa0,
	0x43, 0x8c, 0x0e, 0x4b, 0xef, 0x0c, 0x4a, 0x23, 0xa5, 0x2e, 0x04, 0xa1, 0x80, 0xe5, 0x0e, 0x04,
	0x2d, 0x7d, 0xb0, 0x1c, 0x07, 0x4b, 0x83, 0xe6, 0xa0, 0x99, 0x43, 0x69, 0x74, 0x42, 0x6b, 0x46,
	0xa2, 0x36, 0x94, 0x18, 0x2c, 0x73, 0xc8, 0x38, 0x07, 0x2a, 0x9c, 0xd7, 0x0c, 0x3b, 0x2e, 0x50,
	0x8a, 0xbd, 0x27, 0xa0, 0xb9, 0x90, 0x1a, 0xb8, 0x22, 0xd6, 0x92, 0x20, 0xa9, 0x0d, 0x9c, 0x08,
	0x6d, 0x03, 0x48, 0x27, 0x50, 0x4a, 0xb1, 0xa1, 0x40, 0x62, 0x8c, 0x8e, 0x8b, 0xa0, 0x80, 0x5b,
	0x62, 0xac, 0x50, 0xd1, 0x38, 0x2f, 0x80, 0x62, 0x66, 0x51, 0x1a, 0x88, 0xb6, 0x3c, 0x58, 0xcd,
	0x6d, 0x14, 0x06, 0x08, 0xc1, 0x5a, 0x4b, 0x6a, 0x99, 0x71, 0x16, 0x94, 0x37, 0x81, 0xa3, 0xd4,
	0x4a, 0x42, 0x8d, 0x89, 0xc6, 0x09, 0x4c, 0x6c, 0xf0, 0x51, 0x6a, 0xec, 0x0c, 0x55, 0x22, 0x28,
	0x13, 0xb8, 0xf5, 0x12, 0xa5, 0x8e, 0x69, 0x69, 0xb8, 0xb4, 0xc2, 0x72, 0x1e, 0x48, 0x08, 0xde,
	0x6b, 0xce, 0x9c, 0x57, 0x82, 0x31, 0x19, 0xa2, 0x07, 0x94, 0x6a, 0x6e, 0x74, 0x04, 0x4e, 0xa5,
	0x56, 0x92, 0x07, 0x17, 0x0d, 0x95, 0x96, 0x69, 0xaa, 0x19, 0x98, 0xc0, 0x82, 0x8e, 0xb9, 0xa5,
	0x21, 0x10, 0xed, 0x42, 0x60, 0x14, 0x1b, 0xb0, 0x8a, 0x68, 0xa3, 0x0d, 0x66, 0xd8, 0xca, 0x68,
	0x18, 0x93, 0x1c, 0xa5, 0xda, 0x18, 0x62, 0x99, 0x56, 0xc0, 0x73, 0xf9, 0x44, 0x71, 0x1c, 0xa9,
	0x08, 0x32, 0x0a, 0xc2, 0x4c, 0x34, 0x34, 0xa0, 0x94, 0x05, 0x6d, 0x3c, 0x0e, 0xd1, 0x91, 0x68,
	0x39, 0x37, 0x84, 0x38, 0x1d, 0xad, 0x12, 0x94, 0x41, 0xd4, 0x01, 0x82, 0x43, 0x29, 0x30, 0x86,
	0x9d, 0xb7, 0xc6, 0x78, 0x6d, 0x05, 0x15, 0xd2, 0x02, 0xa1, 0xd2, 0x0a, 0xe1, 0xb9, 0x57, 0x54,
	0x78, 0x81, 0x52, 0xcd, 0x00, 0x73, 0xe7, 0x85, 0x0e, 0x1c, 0xd3, 0x68, 0x24, 0x63, 0x46, 0x33,
	0xef, 0x22, 0xa5, 0x8a, 0x72, 0x87, 0x29, 0x4a, 0x9d, 0x8e, 0x9a, 0x48, 0xc5, 0x3c, 0x06, 0x12,
	0xa8, 0x31, 0x58, 0x33, 0x2e, 0x23, 0x73, 0xd6, 0x69, 0x43, 0x9d, 0x71, 0x28, 0x0d, 0x42, 0x90,
	0x68, 0xa3, 0xe7, 0x91, 0xe3, 0x48, 0x02, 0x78, 0xea, 0x1c, 0x17, 0x46, 0x63, 0x17, 0xad, 0xe1,
	0x86, 0xa2, 0x94, 0x1a, 0xac, 0x45, 0xc4, 0x2c, 0x6a, 0xd0, 0x16, 0xb3, 0x88, 0x1d, 0x33, 0xc6,
	0x0b, 0xaf, 0x7c, 0xc4, 0x0e, 0x3b, 0x9d, 0xc7, 0xba, 0x55, 0x36, 0x10, 0x2e, 0xb0, 0x89, 0x41,
	0x12, 0xee, 0x95, 0x73, 0xcc, 0x0a, 0xec, 0xb9, 0xd1, 0xd4, 0x69, 0x8f, 0x52, 0xe7, 0xa5, 0x67,
	0x5a, 0x46, 0x9e, 0x6f, 0x04, 0xa3, 0x9c, 0x09, 0x06, 0x04, 0x0d, 0x5c, 0x51, 0xa7, 0x14, 0x0d,
	0x1a, 0xa5, 0x8e, 0xb0, 0x80, 0x89, 0xe6, 0xd2, 0x06, 0x65, 0x09, 0xb7, 0x0a, 0xbb, 0x98, 0x43,
	0x4a, 0xa4, 0x52, 0xc2, 0x2b, 0x8d, 0x52, 0x69, 0x34, 0x30, 0x49, 0x89, 0x89, 0xcc, 0x28, 0xc3,
	0x29, 0x8e, 0x96, 0x0a, 0x4d, 0x1c, 0x25, 0xc1, 0x7a, 0x05, 0x1e, 0xa5, 0x44, 0x11, 0x4a, 0xb5,
	0xd2, 0x18, 0x5b, 0x6f, 0x88, 0x63, 0xdc, 0xdb, 0x10, 0x84, 0xd6, 0xdc, 0x83, 0x16, 0x42, 0xe6,
	0x96, 0x0a, 0x1c, 0x3c, 0x10, 0x1d, 0x80, 0x38, 0x47, 0x38, 0x03, 0x69, 0x82, 0x0c, 0xc1, 0x70,
	0xc2, 0x9c, 0x66, 0x42, 0xe4, 0x3b, 0x8a, 0x08, 0x6c, 0x23, 0x17, 0x84, 0x3b, 0x2d, 0x75, 0x80,
	0xe8, 0xb4, 0xe0, 0xc1, 0xe1, 0x28, 0xa9, 0xe5, 0x9c, 0xa0, 0x34, 0x44, 0xe1, 0x19, 0x06, 0xa9,
	0x70, 0x70, 0x36, 0x0f, 0x36, 0xaa, 0x30, 0x04, 0x26, 0xb1, 0xc4, 0x3e, 0x62, 0xc1, 0x51, 0xca,
	0x84, 0xc7, 0x96, 0x11, 0xcf, 0x35, 0x31, 0x54, 0x45, 0x4c, 0xa9, 0x65, 0x4e, 0x30, 0x4c, 0xf3,
	0xad, 0x89, 0x75, 0x91, 0xe9, 0xbc, 0x07, 0xe1, 0x94, 0xf4, 0xda, 0x11, 0xc5, 0x15, 0x0d, 0x98,
	0x72, 0x25, 0xb4, 0x51, 0xd8, 0x72, 0x2c, 0x1d, 0x4a, 0x0d, 0x21, 0x5c, 0x19, 0xeb, 0xb5, 0xc5,
	0x9a, 0x30, 0x08, 0x84, 0x72, 0xe2, 0x98, 0xd4, 0xd2, 0xfb, 0x60, 0x03, 0x18, 0x94, 0x62, 0x06,
	0x44, 0x4b, 0xab, 0xa2, 0x66, 0x54, 0x0b, 0x30, 0x8c, 0x71, 0x12, 0x80, 0x2b, 0xcd, 0x18, 0xc7,
	0x58, 0x42, 0x8e, 0x47, 0x0c, 0xdc, 0x28, 0x4a, 0xa3, 0x0e, 0x84, 0x44, 0x16, 0x94, 0x0c, 0x1e,
	0x34, 0x8f, 0x1a, 0xb0, 0x31, 0x56, 0xe5, 0xfb, 0x16, 0x63, 0x2c, 0x84, 0x25, 0xc4, 0x48, 0x0b,
	0x60, 0x75, 0x20, 0xce, 0x4b, 0x6c, 0xb4, 0x16, 0xce, 0x1a, 0xc1, 0x50, 0x8a, 0x8d, 0x8e, 0x42,
	0x00, 0x55, 0x41, 0x7b, 0xee, 0xb0, 0x15, 0x06, 0x13, 0x4c, 0xbd, 0x0b, 0xb9, 0x87, 0x63, 0xbe,
	0x2b, 0x81, 0x39, 0x6a, 0x1d, 0x89, 0xc6, 0x0a, 0x19, 0x69, 0x74, 0xdc, 0x1b, 0xca, 0x75, 0xa4,
	0x91, 0x13, 0xc9, 0x48, 0x9e, 0xf9, 0xb9, 0x84, 0xdc, 0x10, 0xeb, 0xbc, 0xb7, 0x1a, 0xac, 0x71,
	0xd6, 0x1a, 0x46, 0x83, 0x95, 0x3a, 0x06, 0x27, 0xa8, 0x41, 0x29, 0x0f, 0xca, 0x52, 0x1d, 0x64,
	0xa4, 0x54, 0x32, 0x08, 0x92, 0x04, 0xd0, 0xda, 0x5b, 0x29, 0xc1, 0x61, 0x42, 0x80, 0xa1, 0xd4,
	0x51, 0x27, 0x49, 0x70, 0xca, 0x19, 0x6e, 0xb0, 0x95, 0x38, 0x50, 0x85, 0xbd, 0x77, 0x14, 0x3b,
	0x2e, 0xa9, 0xa6, 0x12, 0xa5, 0x86, 0x0a, 0x65, 0x14, 0x26, 0x91, 0x70, 0x21, 0xb1, 0x00, 0x03,
	0xc1, 0x63, 0x87, 0x89, 0x35, 0x98, 0x78, 0x19, 0x04, 0x4a, 0x95, 0x34, 0x84, 0x1a, 0xe5, 0x72,
	0x36, 0xcb, 0x09, 0x65, 0x2c, 0x06, 0x6c, 0xb1, 0xb3, 0x16, 0x5b, 0x26, 0xf3, 0xaf, 0x07, 0x91,
	0x10, 0x7d, 0xc4, 0x80, 0xb1, 0xc0, 0x3c, 0x84, 0x08, 0x21, 0x00, 0x61, 0x2e, 0x82, 0x35, 0x46,
	0x19, 0x41, 0x51, 0x4a, 0x04, 0x67, 0x56, 0x79, 0x2e, 0x25, 0x63, 0xd6, 0x47, 0x95, 0x27, 0x35,
	0x4c, 0x9c, 0xf5, 0xde, 0x05, 0x5c, 0xc4, 0x58, 0x90, 0x11, 0x73, 0x27, 0xac, 0x21, 0x98, 0x10,
	0x11, 0xb9, 0x13, 0x18, 0x3c, 0x78, 0x6c, 0x02, 0xc7, 0x96, 0x84, 0x88, 0x52, 0xc3, 0x72, 0x52,
	0xa5, 0x69, 0x90, 0xdc, 0x04, 0x70, 0x82, 0xe4, 0x09, 0x95, 0x83, 0x77, 0x8a, 0x70, 0xe7, 0x30,
	0x4a, 0x05, 0x08, 0xc5, 0xbc, 0xf1, 0x26, 0x6a, 0x67, 0x15, 0xc5, 0x10, 0x8d, 0x23, 0x1a, 0x4c,
	0xf4, 0x40, 0x81, 0x46, 0x85, 0x52, 0x61, 0xb0, 0xa5, 0x8c, 0x86, 0xfc, 0xd3, 0x26, 0x39, 0x36,
	0xd1, 0x3a, 0x45, 0x41, 0x09, 0x6a, 0xb5, 0xa5, 0x32, 0xff, 0x02, 0x69, 0x6e, 0x1c, 0xe6, 0x2e,
	0xb8, 0x40, 0x02, 0x75, 0x46, 0xb3, 0x28, 0x41, 0x5b, 0x2e, 0x14, 0x60, 0xc9, 0x68, 0xfe, 0x05,
	0x32, 0x9e, 0x0a, 0x6d, 0x80, 0x78, 0x0c, 0x26, 0x0a, 0xc6, 0x2c, 0xa6, 0xd4, 0x4b, 0x8a, 0x45,
	0x34, 0x8a, 0x18, 0x20, 0x28, 0x35, 0x12, 0x9c, 0x95, 0x34, 0xff, 0x7c, 0x50, 0xc7, 0x95, 0xc4,
	0x8a, 0x18, 0xea, 0xac, 0xe2, 0x79, 0x40, 0x0b, 0x67, 0x51, 0xaa, 0x3c, 0x27, 0xd8, 0x83, 0x66,
	0x14, 0x34, 0xd7, 0x96, 0x31, 0x4a, 0x38, 0xa3, 0xde, 0x58, 0x4d, 0xc1, 0x28, 0x9a, 0x7f, 0x1b,
	0x64, 0x0c, 0x9a, 0x59, 0x4a, 0xa2, 0x89, 0xcc, 0x8b, 0x68, 0x62, 0x54, 0x4e, 0x78, 0xc9, 0x9c,
	0xf3, 0x44, 0x99, 0x80, 0x52, 0x1a, 0xb4, 0x32, 0xdc, 0x3b, 0xe5, 0x44, 0x9e, 0x0f, 0x94, 0x03,
	0xa0, 0xd2, 0x08, 0x50, 0xc6, 0x13, 0xa1, 0x24, 0x46, 0x69, 0x0c, 0x1a, 0x47, 0x6b, 0xbc, 0x24,
	0x14, 0xfb, 0x90, 0x07, 0xaa, 0xa0, 0x58, 0x10, 0x1c, 0x99, 0x97, 0x9c, 0xe7, 0xdf, 0x4a, 0xa1,
	0x22, 0x93, 0x9c, 0x3a, 0x0e, 0x4c, 0x01, 0xd5, 0x51, 0x78, 0x07, 0x0c, 0x53, 0xec, 0x0d, 0x63,
	0xc4, 0x71, 0x8f, 0x52, 0x83, 0x25, 0xc6, 0x9c, 0xf6, 0xf3, 0x9f, 0x00, 0x25, 0x84, 0xc3, 0x9c,
	0x79, 0x2c, 0x14, 0x15, 0xdc, 0xe6, 0x51, 0xe8, 0x05, 0x8e, 0x32, 0xaf, 0x1c, 0x88, 0x62, 0x52,
	0x49, 0xc7, 0x95, 0xb3, 0x12, 0x6b, 0xe1, 0x02, 0xf6, 0xd2, 0x03, 0xa0, 0xd4, 0x53, 0x4c, 0x9c,
	0xa1, 0x51, 0x3b, 0xae, 0x59, 0xb4, 0x4c, 0x6b, 0x07, 0x44, 0xf1, 0x20, 0xa5, 0xce, 0x11, 0xe4,
	0x28, 0x75, 0x06, 0xbb, 0xe0, 0xc0, 0x48, 0x62, 0x25, 0xd7, 0x11, 0x73, 0xaa, 0x82, 0xa3, 0xc4,
	0x5a, 0x2b, 0xbd, 0x77, 0xc2, 0xa0, 0xd4, 0x44, 0x49, 0x3d, 0x8f, 0x54, 0x3a, 0x83, 0x03, 0x0b,
	0x4a, 0x28, 0x07, 0x56, 0x62, 0x03, 0x9a, 0x46, 0x0a, 0x36, 0x8e, 0xfe, 0x4f, 0xfd, 0x28, 0x49,
	0xcf, 0x2d, 0xcb, 0x16, 0x8a, 0x52, 0xec, 0xdd, 0xa2, 0x12, 0x2b, 0xff, 0xd5, 0x2b, 0xe8, 0xf2,
	0xa0, 0x36, 0x0e, 0xc3, 0xea, 0x6c, 0xea, 0xa2, 0x3a, 0xbb, 0xa8, 0xce, 0x2e, 0xaa, 0xb3, 0x8b,
	0xea, 0xec, 0xa2, 0x3a, 0xbb, 0xa8, 0xce, 0x2e, 0xaa, 0xb3, 0x8b, 0xea, 0xec, 0xa2, 0x3a, 0xfb,
	0xcd, 0x56, 0x67, 0xe9, 0x39, 0x27, 0x95, 0xa1, 0x5f, 0xa0, 0xad, 0xfd, 0xdb, 0x24, 0xba, 0xbc,
	0x6f, 0x7b, 0xf7, 0x46, 0xcf, 0xec, 0x76, 0xd0, 0x52, 0xff, 0x30, 0x7d, 0x58, 0xb1, 0xf5, 0x4f,
	0xd4, 0x7f, 0x7b, 0x54, 0xfe, 0xf0, 0xb4, 0xf6, 0xf9, 0xea, 0x6f, 0xb1, 0xcf, 0x39, 0x28, 0xff,
	0x6e, 0x9d, 0x7b, 0x30, 0xf7, 0xb9, 0x04, 0x8d, 0x95, 0x91, 0x77, 0xd0, 0x62, 0x71, 0x64, 0x3c,
	0x5e, 0x42, 0xd2, 0x73, 0xe4, 0x0c, 0x6f, 0x1f, 0x9f, 0x77, 0xda, 0x9f, 0x8b, 0x2d, 0xe4, 0x0c,
	0xc4, 0x36, 0xd0, 0x62, 0xaf, 0x63, 0x5b, 0xdd, 0xd8, 0xee, 0x1c, 0x43, 0xa7, 0xbb, 0x32, 0x5d,
	0x9c, 0x50, 0x7e, 0xf3, 0xfc, 0x13, 0xca, 0xfa, 0x33, 0xca, 0xcd, 0x95, 0xc7, 0xa7, 0x23, 0xf2,
	0xe7, 0x47, 0xdf, 0x7f, 0x54, 0xe0, 0xda, 0x9f, 0x4c, 0xa2, 0x85, 0x51, 0x64, 0x9f, 0xc7, 0x23,
	0xf9, 0x92, 0xf0, 0x98, 0xfc, 0xcd, 0xe0, 0x31, 0xf5, 0x65, 0xe3, 0xf1, 0x8f, 0x09, 0x2a, 0x8d,
	0xe0, 0xb1, 0x69, 0xbb, 0x4d, 0xff, 0xff, 0x1c, 0x94, 0xef, 0x2c, 0xff, 0xd3, 0x77, 0x47, 0x7d,
	0xb8, 0xf6, 0x1f, 0x93, 0xe8, 0xca, 0x56, 0xbb, 0xfd, 0x61, 0x13, 0x46, 0x3d, 0xbb, 0x3a, 0xd6,
	0x98, 0x79, 0x76, 0x5a, 0x3e, 0x39, 0xe8, 0xcc, 0xac, 0xa1, 0xb9, 0x93, 0x0e, 0x74, 0xa1, 0xe5,
	0x61, 0xd8, 0x4b, 0xfa, 0xc5, 0x69, 0x92, 0xec, 0x4c, 0x64, 0x4f, 0x9f, 0x97, 0x15, 0x9a, 0x6e,
	0xf6, 0xe0, 0x78, 0xd0, 0x96, 0x7b, 0x09, 0xec, 0x23, 0x4a, 0x77, 0x26, 0xb2, 0x82, 0xa1, 0xfc,
	0x6d, 0xb4, 0x3c, 0xda, 0xac, 0x82, 0x4e, 0xd1, 0xcc, 0x19, 0xb6, 0xab, 0x96, 0x46, 0xda, 0x55,
	0xd0, 0x29, 0xff, 0x1e, 0x5a, 0xf2, 0xf7, 0xc0, 0x7f, 0xd8, 0xe8, 0xeb, 0xed, 0xad, 0xcc, 0x7e,
	0x66, 0xe3, 0x67, 0xb1, 0x20, 0xde, 0xef, 0xd3, 0x96, 0x37, 0xd1, 0x95, 0x3e, 0x73, 0xab, 0xdd,
	0x7b, 0x2a, 0x60, 0xee, 0x33, 0x05, 0x5c, 0x2e, 0x18, 0xf6, 0xda, 0xbd, 0x81, 0x8c, 0xef, 0xcc,
	0xfd, 0xea, 0xbb, 0x33, 0xe4, 0x86, 0xbc, 0xc1, 0x37, 0x57, 0xd0, 0x4c, 0x61, 0x70, 0xd1, 0xcf,
	0x98, 0x7a, 0x72, 0x9a, 0x5c, 0x3a, 0x3b, 0x4d, 0xa6, 0x58, 0xd1, 0xec, 0xbb, 0x54, 0x9a, 0x1d,
	0xb4, 0xfc, 0xfe, 0x73, 0x12, 0x2d, 0x6f, 0x74, 0x0e, 0x47, 0xd1, 0x7e, 0x7d, 0x0c, 0xed, 0x61,
	0x07, 0xe9, 0x17, 0x03, 0x77, 0x5e, 0xe0, 0xfe, 0xa5, 0xe0, 0xfe, 0xe9, 0x24, 0xba, 0xb2, 0x03,
	0x36, 0x40, 0xe7, 0x7f, 0x86, 0xfe, 0x27, 0x17, 0xd0, 0x7f, 0x99, 0xd0, 0xff, 0x7a, 0x12, 0xbd,
	0xfa, 0xce, 0x7d, 0xe8, 0x3c, 0xda, 0xb7, 0x1d, 0x7b, 0x0c, 0xbd, 0x71, 0x17, 0x7c, 0x1d, 0x4d,
	0x7d, 0x08, 0x8f, 0xce, 0x49, 0x35, 0xf9, 0xe3, 0x0b, 0xd8, 0xff, 0xf7, 0xb0, 0xff, 0x59, 0x82,
	0xbe, 0xf2, 0xac, 0x99, 0x3c, 0x0a, 0xf9, 0x48, 0x0f, 0x3a, 0xf9, 0x3f, 0xf6, 0xa0, 0x5f, 0x84,
	0x70, 0xf2, 0xa5, 0x10, 0xae, 0x51, 0x74, 0x39, 0x6b, 0x1f, 0x8d, 0x7d, 0x69, 0xbe, 0x31, 0x78,
	0x95, 0xe7, 0x66, 0x00, 0x5e, 0xff, 0x5e, 0xd6, 0x7f, 0xbe, 0xf6, 0x71, 0x82, 0xae, 0x1c, 0xf4,
	0x3a, 0xcd, 0xd6, 0x58, 0xca, 0xd4, 0xcf, 0xd8, 0xf2, 0xcf, 0xe2, 0x5a, 0xce, 0x36, 0xff, 0xc3,
	0xe4, 0xd2, 0x5a, 0xc1, 0x7b, 0x6e, 0x57, 0x7b, 0x00, 0xd9, 0x17, 0x31, 0x78, 0xd0, 0x88, 0xfe,
	0x8b, 0x04, 0x2d, 0x55, 0x4f, 0x46, 0xd5, 0xbf, 0x8f, 0x16, 0x06, 0x35, 0x65, 0x17, 0x7a, 0x9f,
	0x7f, 0xf2, 0xe7, 0xe9, 0x5c, 0x47, 0xce, 0x36, 0x32, 0xf9, 0x83, 0xfa, 0x4f, 0x0f, 0xa0, 0xf7,
	0x05, 0x01, 0xf5, 0x68, 0x79, 0x38, 0xae, 0x31, 0xb0, 0xec, 0x1d, 0x34, 0x67, 0xbb, 0xad, 0xcf,
	0x6f, 0xd6, 0xca, 0x8f, 0x7f, 0xb0, 0xe0, 0x0e, 0x4f, 0x1a, 0x03, 0xa6, 0x11, 0xa3, 0x66, 0x6d,
	0xb7, 0x95, 0x5b, 0xb4, 0xf6, 0x08, 0x5d, 0xde, 0x6f, 0x77, 0xc6, 0xfa, 0xe0, 0x06, 0xcd, 0x9c,
	0xb4, 0x3b, 0xbd, 0x73, 0xab, 0x9b, 0xbf, 0x7d, 0x49, 0x19, 0xd2, 0xe7, 0xf8, 0x62, 0xef, 0xf7,
	0x2f, 0x93, 0x68, 0xf6, 0x4e, 0xb6, 0x5b, 0xcd, 0x37, 0xeb, 0xfa, 0xd3, 0x41, 0x8d, 0xa2, 0x22,
	0x1a, 0x74, 0xf2, 0x87, 0x01, 0x73, 0x6f, 0x64, 0x3a, 0xa3, 0x28, 0x75, 0xca, 0x37, 0x9f, 0x1b,
	0xec, 0x98, 0x1a, 0x4b, 0x30, 0x8f, 0x93, 0x17, 0xc6, 0x39, 0xbe, 0x3d, 0x18, 0xe7, 0xe8, 0x8b,
	0x9f, 0x79, 0x7e, 0xda, 0x64, 0x67, 0x30, 0xc6, 0xd1, 0x97, 0x2e, 0x3e, 0x63, 0xf6, 0x63, 0x65,
	0x74, 0xf6, 0x63, 0x67, 0x6c, 0xfa, 0xe3, 0x0d, 0xb4, 0x50, 0xb0, 0xf5, 0x1d, 0x5e, 0xa4, 0x90,
	0xe7, 0x95, 0x14, 0x72, 0xfb, 0x93, 0x3b, 0xdf, 0xb9, 0xf4, 0xab, 0xef, 0x4e, 0x91, 0x1b, 0xfc,
	0xfc, 0x91, 0x89, 0xc9, 0x27, 0xa7, 0x49, 0x92, 0x6f, 0x7c, 0x7a, 0x83, 0x6d, 0xa6, 0x03, 0xc1,
	0x83, 0xf5, 0x2b, 0x8f, 0x4f, 0x93, 0x4b, 0x4f, 0x4e, 0x93, 0xe9, 0xb3, 0xd3, 0x64, 0x46, 0xdc,
	0x50, 0x37, 0xe4, 0x5b, 0xd3, 0x73, 0x49, 0x69, 0xf2, 0xad, 0xe9, 0xb9, 0xe9, 0xd2, 0xcc, 0xda,
	0x5f, 0x26, 0x68, 0xf9, 0x4e, 0xb6, 0x3b, 0xea, 0xd2, 0x0f, 0xd0, 0xfc, 0xfd, 0xce, 0x51, 0x23,
	0xcf, 0x8b, 0xc3, 0xc8, 0x79, 0xed, 0xfc, 0x4c, 0x3a, 0x70, 0xc8, 0xe6, 0xea, 0x8b, 0xdb, 0x6c,
	0x6c, 0x06, 0x68, 0xee, 0x7e, 0xe7, 0x28, 0x27, 0xfc, 0x82, 0x3e, 0xff, 0xeb, 0x04, 0x5d, 0xd9,
	0xe5, 0xdb, 0xd0, 0x1d, 0x8b, 0xb8, 0x17, 0x45, 0x4c, 0xbd, 0x3c, 0x55, 0xd7, 0xd1, 0xdc, 0x11,
	0x6f, 0x04, 0xe8, 0xf6, 0xfa, 0x7f, 0x41, 0x0b, 0x2f, 0x24, 0xb8, 0xbe, 0x82, 0x62, 0x07, 0xac,
	0xbe, 0xf8, 0x67, 0x39, 0xf6, 0x1a, 0xb3, 0x47, 0x05, 0x6d, 0xf7, 0x29, 0x80, 0x93, 0xa5, 0xa9,
	0xeb, 0x80, 0x96, 0xf6, 0x0b, 0x34, 0x0e, 0xa0, 0x90, 0x52, 0xbe, 0x8a, 0x4a, 0x7b, 0x95, 0xfa,
	0xdd, 0x5a, 0xf6, 0x76, 0xe3, 0xa0, 0xb2, 0x75, 0x27, 0xab, 0xd6, 0xdf, 0x2f, 0x4d, 0x94, 0xaf,
	0xa0, 0xa5, 0x6c, 0xa3, 0x5e, 0x69, 0xec, 0x56, 0x6f, 0x57, 0xeb, 0xd5, 0xbd, 0x37, 0x4b, 0x49,
	0x79, 0x05, 0x5d, 0xdd, 0xaf, 0xed, 0x56, 0xb7, 0xde, 0x6f, 0x6c, 0x6e, 0x1c, 0x54, 0xb6, 0x1b,
	0x59, 0xed, 0x4e, 0xb1, 0x32, 0x99, 0x13, 0xdf, 0xdd, 0xb8, 0xd5, 0xa8, 0xbc, 0xb7, 0xb5, 0x7b,
	0xe7, 0xa0, 0x5a, 0xdb, 0x2b, 0x4d, 0x5d, 0x3f, 0x40, 0xcb, 0x4f, 0xd5, 0x1c, 0xf8, 0x76, 0x51,
	0x99, 0x5f, 0x1b, 0xb0, 0x1f, 0x54, 0xea, 0x8d, 0x83, 0xad, 0xda, 0x7e, 0xa5, 0xb1, 0xb7, 0x71,
	0xbb, 0x72, 0xb0, 0xbf, 0xb1, 0x55, 0x29, 0x4d, 0x94, 0xbf, 0x89, 0x5e, 0x7b, 0x61, 0xfd, 0xdd,
	0x6a, 0x56, 0xbf, 0xb3, 0xb1, 0xdb, 0xd8, 0xa9, 0x1d, 0xd4, 0x4b, 0xc9, 0xf5, 0xf7, 0xd0, 0x57,
	0xfb, 0xd3, 0x6a, 0xc7, 0xae, 0xd9, 0x6a, 0xb6, 0x0e, 0x37, 0x8e, 0x0e, 0xdb, 0x9d, 0x66, 0xef,
	0xde, 0x71, 0xf9, 0x32, 0x5a, 0xb8, 0x55, 0xcd, 0x0e, 0xea, 0x8d, 0xdb, 0x1b, 0xf5, 0xad, 0x9d,
	0xd2, 0x44, 0xb9, 0x8c, 0x96, 0xb7, 0x2b, 0x7b, 0xef, 0x37, 0x6a, 0xef, 0x56, 0xb2, 0xac, 0xba,
	0x5d, 0x39, 0x28, 0x25, 0xe5, 0x57, 0xd0, 0xe5, 0x8d, 0xdd, 0xdd, 0xda, 0xdd, 0x91, 0x87, 0x93,
	0xd7, 0x72, 0x37, 0x4c, 0x5c, 0x7f, 0x9c, 0xa0, 0x85, 0x91, 0x1f, 0xa9, 0xf2, 0x35, 0x54, 0xaa,
	0x67, 0x1b, 0x7b, 0x07, 0xb7, 0x6a, 0xd9, 0xed, 0x4a, 0xd6, 0xd8, 0xab, 0xed, 0x55, 0x4a, 0x13,
	0x05, 0x6d, 0x52, 0x5e, 0x46, 0x68, 0xb7, 0x76, 0xb7, 0x92, 0x35, 0xb6, 0x36, 0x0e, 0x2a, 0xa5,
	0xe2, 0xfe, 0xce, 0xfe, 0xfe, 0xf0, 0xbe, 0x40, 0x23, 0x07, 0x48, 0xf2, 0xc6, 0x76, 0x65, 0xab,
	0xb6, 0x5d, 0x29, 0x4d, 0xe5, 0xd6, 0xec, 0xd5, 0xb2, 0xdb, 0x1b, 0xbb, 0xd5, 0x0f, 0x2a, 0x8d,
	0xfd, 0x8d, 0xfa, 0x4e, 0x69, 0xba, 0xfc, 0x15, 0x74, 0x25, 0xab, 0xdc, 0xae, 0xbd, 0x5b, 0x69,
	0xdc, 0xdd, 0xa9, 0xd6, 0x07, 0x30, 0xcc, 0x14, 0xd2, 0xb2, 0xdd, 0x21, 0xeb, 0xa5, 0xf2, 0x12,
	0x9a, 0xaf, 0x67, 0xd5, 0xdb, 0x8d, 0xdd, 0xca, 0xad, 0x7a, 0x69, 0x36, 0x5f, 0x2e, 0x6e, 0xb3,
	0xea, 0x9b, 0x3b, 0xf5, 0xd2, 0x5c, 0x79, 0x0e, 0x4d, 0xe7, 0xf7, 0xa5, 0xf9, 0xeb, 0xff, 0x95,
	0xa0, 0x95, 0x97, 0x4d, 0xef, 0x94, 0x5f, 0x43, 0x57, 0xeb, 0xbb, 0x07, 0x8d, 0x5b, 0xd5, 0xbd,
	0x37, 0x2b, 0xd9, 0x7e, 0x56, 0xdd, 0xab, 0x0f, 0xdf, 0x69, 0xea, 0xe3, 0x1f, 0x24, 0xe5, 0xd7,
	0xd0, 0xab, 0x1b, 0x7b, 0xef, 0x37, 0x72, 0x03, 0xb7, 0xaa, 0xb5, 0x3b, 0x63, 0x84, 0xa5, 0xa4,
	0x8c, 0xd0, 0xa5, 0x8d, 0xed, 0xbb, 0x1b, 0x59, 0xfe, 0x76, 0xfd, 0xeb, 0xea, 0xde, 0x76, 0x69,
	0x2a, 0xbf, 0xde, 0xce, 0x71, 0x7c, 0xaf, 0x34, 0x5d, 0x5e, 0x40, 0xb3, 0x6f, 0xd6, 0x6a, 0xf5,
	0xb7, 0xab, 0xf5, 0xd2, 0x4c, 0x6e, 0xd5, 0x9b, 0xb5, 0x0f, 0xaa, 0xa5, 0x4b, 0xe5, 0x45, 0x34,
	0xf7, 0xd6, 0x66, 0xf5, 0x56, 0x96, 0x3b, 0x70, 0x36, 0x27, 0x7a, 0xe7, 0xce, 0xc6, 0xdb, 0x9b,
	0xb5, 0xdc, 0xf4, 0x65, 0x84, 0x72, 0x88, 0x6b, 0xb7, 0x0b, 0xc9, 0xf3, 0x39, 0x69, 0x3d, 0xab,
	0xed, 0x6e, 0x57, 0x0e, 0x76, 0x4a, 0x28, 0x97, 0x5d, 0xaf, 0xdd, 0x3a, 0xa8, 0x54, 0x4a, 0x0b,
	0x39, 0xa2, 0xf5, 0x5a, 0x96, 0x55, 0xf6, 0xea, 0xbb, 0xb5, 0xad, 0xb7, 0x2b, 0x59, 0x69, 0xb1,
	0x4f, 0x5c, 0xdd, 0x2a, 0x44, 0x2d, 0x5d, 0xff, 0x1e, 0x5a, 0xd8, 0x6a, 0xdf, 0x6f, 0xf5, 0x3a,
	0x8f, 0x8a, 0xd9, 0xa9, 0x12, 0x5a, 0xdc, 0xaa, 0xdd, 0xd9, 0xab, 0x67, 0xef, 0x0f, 0xde, 0x32,
	0xd7, 0x35, 0x7c, 0xb2, 0x71, 0xab, 0x34, 0x3d, 0x76, 0xbf, 0x5b, 0x9a, 0xbb, 0x7e, 0x80, 0x50,
	0x1e, 0x59, 0x83, 0x89, 0xd1, 0x39, 0x34, 0x9d, 0x07, 0x4f, 0x69, 0xa2, 0x3c, 0x8f, 0x66, 0x8a,
	0x90, 0x29, 0x25, 0xe5, 0x57, 0xd1, 0xe5, 0xbd, 0xca, 0x7b, 0xf5, 0xc6, 0xb3, 0x20, 0x1d, 0x44,
	0x4f, 0x92, 0x47, 0xdf, 0xc8, 0x52, 0x69, 0xaa, 0x1f, 0x54, 0x9b, 0x7f, 0x9c, 0x3c, 0xf9, 0x64,
	0x75, 0xe2, 0xa7, 0x9f, 0xac, 0x4e, 0xfc, 0xf2, 0x93, 0xd5, 0xe4, 0xd3, 0x4f, 0x56, 0x93, 0x8f,
	0xcf, 0x56, 0x93, 0xbf, 0x39, 0x5b, 0x4d, 0xfe, 0xfe, 0x6c, 0x35, 0x79, 0x7c, 0xb6, 0x9a, 0xfc,
	0xe4, 0x6c, 0x35, 0x79, 0x72, 0xb6, 0x9a, 0xfc, 0xf4, 0x6c, 0x35, 0xf9, 0xd9, 0xd9, 0x6a, 0xf2,
	0x8b, 0xb3, 0xd5, 0x89, 0x5f, 0x9e, 0xad, 0x26, 0x7f, 0xfe, 0xf3, 0xd5, 0x89, 0xc7, 0x3f, 0x5f,
	0x4d, 0x3e, 0x78, 0xeb, 0xb0, 0x7d, 0xf2, 0xe1, 0xe1, 0xfa, 0x83, 0xf6, 0x51, 0x0f, 0x3a, 0x1d,
	0xbb, 0x7e, 0xbf, 0x7b, 0xb3, 0xb8, 0xc8, 0xc3, 0xf4, 0x8d, 0x93, 0x4e, 0xfb, 0x41, 0x33, 0x40,
	0xe7, 0x8d, 0xe1, 0xf2, 0xcd, 0x13, 0x77, 0xd8, 0xbe, 0x09, 0x0f, 0x7b, 0x83, 0xb9, 0xe0, 0xb1,
	0xb9, 0x69, 0x77, 0xa9, 0x18, 0x73, 0x63, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x19, 0x01, 0x8d,
	0x73, 0x56, 0x2d, 0x00, 0x00,
}

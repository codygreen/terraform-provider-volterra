// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/service_policy_rule/types.proto

package service_policy_rule

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/gogo/protobuf/types"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// GlobalSpecType
//
// x-displayName: "Specification"
// Shape of service_policy_rule in the storage backend.
type GlobalSpecType struct {
	// action
	//
	// x-displayName: "Action"
	// x-required
	// Action to be enforced if the input request matches the rule.
	Action ves_io_schema_policy.RuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// client choice
	//
	// x-displayName: "Client Selection"
	// x-required
	// Select clients for which the rule the will be applied. The actual names of the client are extracted from its TLS certificate.
	//
	// Types that are valid to be assigned to ClientChoice:
	//	*GlobalSpecType_AnyClient
	//	*GlobalSpecType_ClientName
	//	*GlobalSpecType_ClientSelector
	//	*GlobalSpecType_ClientNameMatcher
	ClientChoice isGlobalSpecType_ClientChoice `protobuf_oneof:"client_choice"`
	// client role
	//
	// x-displayName: "Client Role"
	// The expected role(s) of the client invoking the request API. The actual roles for the client are derived from the user and namespace information in the
	// API request.
	// The predicate evaluates to true if any of the client's roles match the value(s) specified in client role.
	ClientRole *ves_io_schema_policy.RoleMatcherType `protobuf:"bytes,9,opt,name=client_role,json=clientRole" json:"client_role,omitempty"`
	// server selector
	//
	// x-displayName: "Group of Servers by Label Selector"
	// A label selector that describes the expected set of servers.
	// The predicate evaluates to true if the expressions in the label selector are true for the server labels.
	ServerSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,45,opt,name=server_selector,json=serverSelector" json:"server_selector,omitempty"`
	// label matcher
	//
	// x-displayName: "Label Matcher"
	// x-example: "['environment', 'location', 'deployment']"
	// A list of label keys that identify the label values that need to be the same for the client and server. Note that the actual label values are not specified
	// here, just the label keys. This predicate facilitates reuse of rules and policies across multiple dimensions such as deployment, environment, and location.
	// The predicate evaluates to true if the values of the client and server labels for all the keys specified in the label matcher are equal. The values of any
	// other labels do not matter.
	LabelMatcher *ves_io_schema4.LabelMatcherType `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher" json:"label_matcher,omitempty"`
	// path
	//
	// x-displayName: "HTTP Path"
	// A list of exact values, prefixes and regular expressions for the expected value of the HTTP path. The actual value of the HTTP path is the unescaped path
	// value extracted from the HTTP URL Resource, excluding any query and fragment information.
	// The predicate evaluates to true if the actual path value matches any of the exact or prefix values or regular expressions in the path matcher.
	Path *ves_io_schema_policy.PathMatcherType `protobuf:"bytes,5,opt,name=path" json:"path,omitempty"`
	// headers
	//
	// x-displayName: "HTTP Headers"
	// A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType
	// instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.
	// Note that all specified header predicates must evaluate to true.
	Headers []*ves_io_schema_policy.HeaderMatcherType `protobuf:"bytes,6,rep,name=headers" json:"headers,omitempty"`
	// query params
	//
	// x-displayName: "HTTP Query Parameters"
	// A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances
	// of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.
	// Note that all specified query parameter predicates must evaluate to true.
	QueryParams []*ves_io_schema_policy.QueryParameterMatcherType `protobuf:"bytes,7,rep,name=query_params,json=queryParams" json:"query_params,omitempty"`
	// method
	//
	// x-displayName: "HTTP Method"
	// The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.
	// The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.
	HttpMethod *ves_io_schema_policy.HttpMethodMatcherType `protobuf:"bytes,8,opt,name=http_method,json=httpMethod" json:"http_method,omitempty"`
	// ip choice
	//
	// x-displayName: "Source IPv4 Match"
	// x-required
	// Match source IPv4 address of the request
	//
	// Types that are valid to be assigned to IpChoice:
	//	*GlobalSpecType_AnyIp
	//	*GlobalSpecType_IpPrefixList
	//	*GlobalSpecType_IpMatcher
	IpChoice isGlobalSpecType_IpChoice `protobuf_oneof:"ip_choice"`
	// dst ip choice
	//
	// x-displayName: "Destination IPv4 Match"
	// Match destination IPv4 address of the request
	//
	// Types that are valid to be assigned to DstIpChoice:
	//	*GlobalSpecType_AnyDstIp
	//	*GlobalSpecType_DstIpPrefixList
	//	*GlobalSpecType_DstIpMatcher
	DstIpChoice isGlobalSpecType_DstIpChoice `protobuf_oneof:"dst_ip_choice"`
	// asn choice
	//
	// x-displayName: "Source ASN Match"
	// x-required
	// Match the 4-byte origin Autonomous System Number for the source IPv4 address of the request. The origin ASN for the request is obtained by performing
	// a lookup for the source IPv4 Address in a GeoIP DB.
	//
	// Types that are valid to be assigned to AsnChoice:
	//	*GlobalSpecType_AnyAsn
	//	*GlobalSpecType_AsnList
	//	*GlobalSpecType_AsnMatcher
	AsnChoice isGlobalSpecType_AsnChoice `protobuf_oneof:"asn_choice"`
	// asn choice
	//
	// x-displayName: "Destination ASN Match"
	// Match the 4-byte origin Autonomous System Number for the destination ASN. The destination ASN is obtained by performing a lookup for the destination IPv4
	// Address in a GeoIP DB.
	//
	// Types that are valid to be assigned to DstAsnChoice:
	//	*GlobalSpecType_AnyDstAsn
	//	*GlobalSpecType_DstAsnList
	//	*GlobalSpecType_DstAsnMatcher
	DstAsnChoice isGlobalSpecType_DstAsnChoice `protobuf_oneof:"dst_asn_choice"`
	// api group matcher
	//
	// x-displayName: "API Group Matcher"
	// The list of expected API group names to which the request API belongs. The actual list of API group names for the request API is determined from the api
	// group and api group element configuration objects using the HTTP method and the HTTP path as inputs.
	// The predicate evaluates to true if any of the actual API group names for the request is equal to any of the values in the api group matcher.
	ApiGroupMatcher *ves_io_schema_policy.StringMatcherType `protobuf:"bytes,14,opt,name=api_group_matcher,json=apiGroupMatcher" json:"api_group_matcher,omitempty"`
	// port matcher
	//
	// x-displayName: "Port Matcher"
	// The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.
	PortMatcher *ves_io_schema_policy.PortMatcherType `protobuf:"bytes,15,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
	// expiration timestamp
	//
	// x-displayName: "Expiration Timestamp"
	// x-example: "2019-12-31:44:34.171543432Z"
	// The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in
	// the configuration but is not applied anymore.
	ExpirationTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,16,opt,name=expiration_timestamp,json=expirationTimestamp" json:"expiration_timestamp,omitempty"`
	// request body matcher
	//
	// x-displayName: "Request Body Matcher"
	// Predicate for matching the request body string. The criteria for matching the request body is described in MatcherType.
	// The actual request body value is extracted from the request API as a string.
	BodyMatcher *ves_io_schema_policy.MatcherType `protobuf:"bytes,21,opt,name=body_matcher,json=bodyMatcher" json:"body_matcher,omitempty"`
	// arg matchers
	//
	// x-displayName: "Argument Matchers"
	// A list of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances
	// of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name.
	// Note that all specified arg matcher predicates must evaluate to true.
	ArgMatchers []*ves_io_schema_policy.ArgMatcherType `protobuf:"bytes,18,rep,name=arg_matchers,json=argMatchers" json:"arg_matchers,omitempty"`
	// cookie matchers
	//
	// x-displayName: "Cookie Matchers"
	// A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances
	// of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.
	// Note that all specified cookie matcher predicates must evaluate to true.
	CookieMatchers []*ves_io_schema_policy.CookieMatcherType `protobuf:"bytes,19,rep,name=cookie_matchers,json=cookieMatchers" json:"cookie_matchers,omitempty"`
	// App Firewall Action
	//
	// x-displayName: "App Firewall Action"
	// x-required
	// App Firewall action to be enforced if the input request matches the rule.
	WafAction *ves_io_schema_policy.WafAction `protobuf:"bytes,20,opt,name=waf_action,json=wafAction" json:"waf_action,omitempty"`
	// domain matcher
	//
	// x-displayName: "Domain Matcher"
	// A list of exact values and/or regular expressions for the expected name of the domain. The actual value of domain is the host component
	// from the URL. The predicate evaluates to true if the domain value matches any of the exact values or regular expressions in the domain
	// matcher.
	DomainMatcher *ves_io_schema_policy.MatcherType `protobuf:"bytes,22,opt,name=domain_matcher,json=domainMatcher" json:"domain_matcher,omitempty"`
	// rate_limiter
	//
	// x-displayName: "Rate Limiter"
	// A reference to rate_limiter object.
	// Requests matching this the enclosing rule are subjected to the specified rate_limiter.
	RateLimiter []*ves_io_schema4.ObjectRefType `protobuf:"bytes,23,rep,name=rate_limiter,json=rateLimiter" json:"rate_limiter,omitempty"`
	// virtual_host matcher
	//
	// x-displayName: "Virtual Host Matcher"
	// A list of exact values and/or regular expressions for the expected name of the virtual_host. The name of the virtual_host is is part of the context in
	// which a service_policy_set is evaluated. The predicate evaluates to true if the virtual_host name matches any of the exact values or regular expressions
	// in the virtual_host matcher.
	// Hidden because this will be used only in system generated rate limiting service_policy_sets.
	VirtualHostMatcher *ves_io_schema_policy.MatcherType `protobuf:"bytes,24,opt,name=virtual_host_matcher,json=virtualHostMatcher" json:"virtual_host_matcher,omitempty"`
	// TLS JA3 fingerprint matcher
	//
	// x-displayName: "TLS Fingerprint Matcher"
	// TLS JA3 fingerprints to be matched.
	// The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.
	TlsFingerprintMatcher *ves_io_schema_policy.TlsFingerprintMatcherType `protobuf:"bytes,25,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher" json:"tls_fingerprint_matcher,omitempty"`
	// Forwarding Classes
	//
	// x-displayName: "Forwarding Classes"
	// Ordered list of forwarding class to use for traffic that match the enclosing rule
	// Action valid only when the policy is used PBR
	ForwardingClass []*ves_io_schema4.ObjectRefType `protobuf:"bytes,26,rep,name=forwarding_class,json=forwardingClass" json:"forwarding_class,omitempty"`
	// malicious user mitigation bypass
	//
	// x-displayName: "Malicious User Mitigation Bypass"
	// When user behavior analyses is enabled, all requests in the application namespace
	// are subjected to user behavior analyses and mitigation actions are taken as configured in MaliciousUserMitigationRule.
	// If required, the behavior checks can be disabled for certain requests by configuring
	// the appropriate match conditions in the enclosing policy rule and setting malicious user mitigation bypass flag.
	MaliciousUserMitigationBypass *ves_io_schema4.Empty `protobuf:"bytes,28,opt,name=malicious_user_mitigation_bypass,json=maliciousUserMitigationBypass" json:"malicious_user_mitigation_bypass,omitempty"`
	// scheme
	//
	// x-displayName: "Scheme"
	// x-example: "HTTPS"
	// The scheme in the request.
	Scheme []string `protobuf:"bytes,38,rep,name=scheme" json:"scheme,omitempty"`
	// url matcher
	//
	// x-displayName: "URL Matcher"
	// A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the domain and path match any of the URL items.
	UrlMatcher *ves_io_schema_policy.URLMatcherType `protobuf:"bytes,39,opt,name=url_matcher,json=urlMatcher" json:"url_matcher,omitempty"`
	// l4 dest matcher
	//
	// x-displayName: "L4 Destination Matcher"
	// A L4 Destination matcher specifies a list of IPv4 prefixes and a TCP port range as match criteria. The match is considered successful if the destination
	// IP matches one of the prefixes and the destination port belongs to the port range.
	L4DestMatcher *ves_io_schema_policy.L4DestMatcherType `protobuf:"bytes,44,opt,name=l4_dest_matcher,json=l4DestMatcher" json:"l4_dest_matcher,omitempty"`
	// Challenge Action
	//
	// x-displayName: "Select Challenge Action Type"
	// x-required
	// Select challenge action, enable javascript/captcha challenge or disable challenge
	ChallengeAction ves_io_schema_policy.ChallengeAction `protobuf:"varint,54,opt,name=challenge_action,json=challengeAction,proto3,enum=ves.io.schema.policy.ChallengeAction" json:"challenge_action,omitempty"`
	// goto_policy
	//
	// x-displayName: "Goto Policy"
	// A reference to a service_policy object.
	// Target of the GOTO_POLICY action.
	// The target policy must be part of the current policy set and must be after the current policy in the policy set.
	GotoPolicy []*ves_io_schema4.ObjectRefType `protobuf:"bytes,55,rep,name=goto_policy,json=gotoPolicy" json:"goto_policy,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

type isGlobalSpecType_ClientChoice interface {
	isGlobalSpecType_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_IpChoice interface {
	isGlobalSpecType_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_DstIpChoice interface {
	isGlobalSpecType_DstIpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_AsnChoice interface {
	isGlobalSpecType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_DstAsnChoice interface {
	isGlobalSpecType_DstAsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AnyClient struct {
	AnyClient *ves_io_schema4.Empty `protobuf:"bytes,37,opt,name=any_client,json=anyClient,oneof"`
}
type GlobalSpecType_ClientName struct {
	ClientName string `protobuf:"bytes,2,opt,name=client_name,json=clientName,proto3,oneof"`
}
type GlobalSpecType_ClientSelector struct {
	ClientSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,3,opt,name=client_selector,json=clientSelector,oneof"`
}
type GlobalSpecType_ClientNameMatcher struct {
	ClientNameMatcher *ves_io_schema_policy.MatcherType `protobuf:"bytes,10,opt,name=client_name_matcher,json=clientNameMatcher,oneof"`
}
type GlobalSpecType_AnyIp struct {
	AnyIp *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,oneof"`
}
type GlobalSpecType_IpPrefixList struct {
	IpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,oneof"`
}
type GlobalSpecType_IpMatcher struct {
	IpMatcher *ves_io_schema_policy.IpMatcherType `protobuf:"bytes,12,opt,name=ip_matcher,json=ipMatcher,oneof"`
}
type GlobalSpecType_AnyDstIp struct {
	AnyDstIp *ves_io_schema4.Empty `protobuf:"bytes,41,opt,name=any_dst_ip,json=anyDstIp,oneof"`
}
type GlobalSpecType_DstIpPrefixList struct {
	DstIpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,42,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,oneof"`
}
type GlobalSpecType_DstIpMatcher struct {
	DstIpMatcher *ves_io_schema_policy.IpMatcherType `protobuf:"bytes,43,opt,name=dst_ip_matcher,json=dstIpMatcher,oneof"`
}
type GlobalSpecType_AnyAsn struct {
	AnyAsn *ves_io_schema4.Empty `protobuf:"bytes,34,opt,name=any_asn,json=anyAsn,oneof"`
}
type GlobalSpecType_AsnList struct {
	AsnList *ves_io_schema_policy.AsnMatchList `protobuf:"bytes,35,opt,name=asn_list,json=asnList,oneof"`
}
type GlobalSpecType_AsnMatcher struct {
	AsnMatcher *ves_io_schema_policy.AsnMatcherType `protobuf:"bytes,13,opt,name=asn_matcher,json=asnMatcher,oneof"`
}
type GlobalSpecType_AnyDstAsn struct {
	AnyDstAsn *ves_io_schema4.Empty `protobuf:"bytes,51,opt,name=any_dst_asn,json=anyDstAsn,oneof"`
}
type GlobalSpecType_DstAsnList struct {
	DstAsnList *ves_io_schema_policy.AsnMatchList `protobuf:"bytes,52,opt,name=dst_asn_list,json=dstAsnList,oneof"`
}
type GlobalSpecType_DstAsnMatcher struct {
	DstAsnMatcher *ves_io_schema_policy.AsnMatcherType `protobuf:"bytes,53,opt,name=dst_asn_matcher,json=dstAsnMatcher,oneof"`
}

func (*GlobalSpecType_AnyClient) isGlobalSpecType_ClientChoice()         {}
func (*GlobalSpecType_ClientName) isGlobalSpecType_ClientChoice()        {}
func (*GlobalSpecType_ClientSelector) isGlobalSpecType_ClientChoice()    {}
func (*GlobalSpecType_ClientNameMatcher) isGlobalSpecType_ClientChoice() {}
func (*GlobalSpecType_AnyIp) isGlobalSpecType_IpChoice()                 {}
func (*GlobalSpecType_IpPrefixList) isGlobalSpecType_IpChoice()          {}
func (*GlobalSpecType_IpMatcher) isGlobalSpecType_IpChoice()             {}
func (*GlobalSpecType_AnyDstIp) isGlobalSpecType_DstIpChoice()           {}
func (*GlobalSpecType_DstIpPrefixList) isGlobalSpecType_DstIpChoice()    {}
func (*GlobalSpecType_DstIpMatcher) isGlobalSpecType_DstIpChoice()       {}
func (*GlobalSpecType_AnyAsn) isGlobalSpecType_AsnChoice()               {}
func (*GlobalSpecType_AsnList) isGlobalSpecType_AsnChoice()              {}
func (*GlobalSpecType_AsnMatcher) isGlobalSpecType_AsnChoice()           {}
func (*GlobalSpecType_AnyDstAsn) isGlobalSpecType_DstAsnChoice()         {}
func (*GlobalSpecType_DstAsnList) isGlobalSpecType_DstAsnChoice()        {}
func (*GlobalSpecType_DstAsnMatcher) isGlobalSpecType_DstAsnChoice()     {}

func (m *GlobalSpecType) GetClientChoice() isGlobalSpecType_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}
func (m *GlobalSpecType) GetIpChoice() isGlobalSpecType_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *GlobalSpecType) GetDstIpChoice() isGlobalSpecType_DstIpChoice {
	if m != nil {
		return m.DstIpChoice
	}
	return nil
}
func (m *GlobalSpecType) GetAsnChoice() isGlobalSpecType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *GlobalSpecType) GetDstAsnChoice() isGlobalSpecType_DstAsnChoice {
	if m != nil {
		return m.DstAsnChoice
	}
	return nil
}

func (m *GlobalSpecType) GetAction() ves_io_schema_policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return ves_io_schema_policy.DENY
}

func (m *GlobalSpecType) GetAnyClient() *ves_io_schema4.Empty {
	if x, ok := m.GetClientChoice().(*GlobalSpecType_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *GlobalSpecType) GetClientName() string {
	if x, ok := m.GetClientChoice().(*GlobalSpecType_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *GlobalSpecType) GetClientSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*GlobalSpecType_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *GlobalSpecType) GetClientNameMatcher() *ves_io_schema_policy.MatcherType {
	if x, ok := m.GetClientChoice().(*GlobalSpecType_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetClientRole() *ves_io_schema_policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *GlobalSpecType) GetServerSelector() *ves_io_schema4.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *GlobalSpecType) GetLabelMatcher() *ves_io_schema4.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetPath() *ves_io_schema_policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *GlobalSpecType) GetHeaders() []*ves_io_schema_policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GlobalSpecType) GetQueryParams() []*ves_io_schema_policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *GlobalSpecType) GetHttpMethod() *ves_io_schema_policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *GlobalSpecType) GetAnyIp() *ves_io_schema4.Empty {
	if x, ok := m.GetIpChoice().(*GlobalSpecType_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *GlobalSpecType) GetIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*GlobalSpecType_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *GlobalSpecType) GetIpMatcher() *ves_io_schema_policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*GlobalSpecType_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetAnyDstIp() *ves_io_schema4.Empty {
	if x, ok := m.GetDstIpChoice().(*GlobalSpecType_AnyDstIp); ok {
		return x.AnyDstIp
	}
	return nil
}

func (m *GlobalSpecType) GetDstIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if x, ok := m.GetDstIpChoice().(*GlobalSpecType_DstIpPrefixList); ok {
		return x.DstIpPrefixList
	}
	return nil
}

func (m *GlobalSpecType) GetDstIpMatcher() *ves_io_schema_policy.IpMatcherType {
	if x, ok := m.GetDstIpChoice().(*GlobalSpecType_DstIpMatcher); ok {
		return x.DstIpMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetAnyAsn() *ves_io_schema4.Empty {
	if x, ok := m.GetAsnChoice().(*GlobalSpecType_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *GlobalSpecType) GetAsnList() *ves_io_schema_policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*GlobalSpecType_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *GlobalSpecType) GetAsnMatcher() *ves_io_schema_policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*GlobalSpecType_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetAnyDstAsn() *ves_io_schema4.Empty {
	if x, ok := m.GetDstAsnChoice().(*GlobalSpecType_AnyDstAsn); ok {
		return x.AnyDstAsn
	}
	return nil
}

func (m *GlobalSpecType) GetDstAsnList() *ves_io_schema_policy.AsnMatchList {
	if x, ok := m.GetDstAsnChoice().(*GlobalSpecType_DstAsnList); ok {
		return x.DstAsnList
	}
	return nil
}

func (m *GlobalSpecType) GetDstAsnMatcher() *ves_io_schema_policy.AsnMatcherType {
	if x, ok := m.GetDstAsnChoice().(*GlobalSpecType_DstAsnMatcher); ok {
		return x.DstAsnMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetApiGroupMatcher() *ves_io_schema_policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetPortMatcher() *ves_io_schema_policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetExpirationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *GlobalSpecType) GetBodyMatcher() *ves_io_schema_policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetArgMatchers() []*ves_io_schema_policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *GlobalSpecType) GetCookieMatchers() []*ves_io_schema_policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *GlobalSpecType) GetWafAction() *ves_io_schema_policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *GlobalSpecType) GetDomainMatcher() *ves_io_schema_policy.MatcherType {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetRateLimiter() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *GlobalSpecType) GetVirtualHostMatcher() *ves_io_schema_policy.MatcherType {
	if m != nil {
		return m.VirtualHostMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetTlsFingerprintMatcher() *ves_io_schema_policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetForwardingClass() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ForwardingClass
	}
	return nil
}

func (m *GlobalSpecType) GetMaliciousUserMitigationBypass() *ves_io_schema4.Empty {
	if m != nil {
		return m.MaliciousUserMitigationBypass
	}
	return nil
}

func (m *GlobalSpecType) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *GlobalSpecType) GetUrlMatcher() *ves_io_schema_policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetL4DestMatcher() *ves_io_schema_policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetChallengeAction() ves_io_schema_policy.ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return ves_io_schema_policy.DEFAULT_CHALLENGE
}

func (m *GlobalSpecType) GetGotoPolicy() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_AnyClient)(nil),
		(*GlobalSpecType_ClientName)(nil),
		(*GlobalSpecType_ClientSelector)(nil),
		(*GlobalSpecType_ClientNameMatcher)(nil),
		(*GlobalSpecType_AnyIp)(nil),
		(*GlobalSpecType_IpPrefixList)(nil),
		(*GlobalSpecType_IpMatcher)(nil),
		(*GlobalSpecType_AnyDstIp)(nil),
		(*GlobalSpecType_DstIpPrefixList)(nil),
		(*GlobalSpecType_DstIpMatcher)(nil),
		(*GlobalSpecType_AnyAsn)(nil),
		(*GlobalSpecType_AsnList)(nil),
		(*GlobalSpecType_AsnMatcher)(nil),
		(*GlobalSpecType_AnyDstAsn)(nil),
		(*GlobalSpecType_DstAsnList)(nil),
		(*GlobalSpecType_DstAsnMatcher)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *GlobalSpecType_AnyClient:
		_ = b.EncodeVarint(37<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyClient); err != nil {
			return err
		}
	case *GlobalSpecType_ClientName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ClientName)
	case *GlobalSpecType_ClientSelector:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientSelector); err != nil {
			return err
		}
	case *GlobalSpecType_ClientNameMatcher:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientNameMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.ClientChoice has unexpected type %T", x)
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *GlobalSpecType_AnyIp:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyIp); err != nil {
			return err
		}
	case *GlobalSpecType_IpPrefixList:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpPrefixList); err != nil {
			return err
		}
	case *GlobalSpecType_IpMatcher:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.IpChoice has unexpected type %T", x)
	}
	// dst_ip_choice
	switch x := m.DstIpChoice.(type) {
	case *GlobalSpecType_AnyDstIp:
		_ = b.EncodeVarint(41<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyDstIp); err != nil {
			return err
		}
	case *GlobalSpecType_DstIpPrefixList:
		_ = b.EncodeVarint(42<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstIpPrefixList); err != nil {
			return err
		}
	case *GlobalSpecType_DstIpMatcher:
		_ = b.EncodeVarint(43<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstIpMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.DstIpChoice has unexpected type %T", x)
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *GlobalSpecType_AnyAsn:
		_ = b.EncodeVarint(34<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyAsn); err != nil {
			return err
		}
	case *GlobalSpecType_AsnList:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnList); err != nil {
			return err
		}
	case *GlobalSpecType_AsnMatcher:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.AsnChoice has unexpected type %T", x)
	}
	// dst_asn_choice
	switch x := m.DstAsnChoice.(type) {
	case *GlobalSpecType_AnyDstAsn:
		_ = b.EncodeVarint(51<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyDstAsn); err != nil {
			return err
		}
	case *GlobalSpecType_DstAsnList:
		_ = b.EncodeVarint(52<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstAsnList); err != nil {
			return err
		}
	case *GlobalSpecType_DstAsnMatcher:
		_ = b.EncodeVarint(53<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstAsnMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.DstAsnChoice has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 37: // client_choice.any_client
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &GlobalSpecType_AnyClient{msg}
		return true, err
	case 2: // client_choice.client_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ClientChoice = &GlobalSpecType_ClientName{x}
		return true, err
	case 3: // client_choice.client_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &GlobalSpecType_ClientSelector{msg}
		return true, err
	case 10: // client_choice.client_name_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.MatcherType)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &GlobalSpecType_ClientNameMatcher{msg}
		return true, err
	case 31: // ip_choice.any_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.IpChoice = &GlobalSpecType_AnyIp{msg}
		return true, err
	case 32: // ip_choice.ip_prefix_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.PrefixMatchList)
		err := b.DecodeMessage(msg)
		m.IpChoice = &GlobalSpecType_IpPrefixList{msg}
		return true, err
	case 12: // ip_choice.ip_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.IpMatcherType)
		err := b.DecodeMessage(msg)
		m.IpChoice = &GlobalSpecType_IpMatcher{msg}
		return true, err
	case 41: // dst_ip_choice.any_dst_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &GlobalSpecType_AnyDstIp{msg}
		return true, err
	case 42: // dst_ip_choice.dst_ip_prefix_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.PrefixMatchList)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &GlobalSpecType_DstIpPrefixList{msg}
		return true, err
	case 43: // dst_ip_choice.dst_ip_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.IpMatcherType)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &GlobalSpecType_DstIpMatcher{msg}
		return true, err
	case 34: // asn_choice.any_asn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &GlobalSpecType_AnyAsn{msg}
		return true, err
	case 35: // asn_choice.asn_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatchList)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &GlobalSpecType_AsnList{msg}
		return true, err
	case 13: // asn_choice.asn_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatcherType)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &GlobalSpecType_AsnMatcher{msg}
		return true, err
	case 51: // dst_asn_choice.any_dst_asn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &GlobalSpecType_AnyDstAsn{msg}
		return true, err
	case 52: // dst_asn_choice.dst_asn_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatchList)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &GlobalSpecType_DstAsnList{msg}
		return true, err
	case 53: // dst_asn_choice.dst_asn_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatcherType)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &GlobalSpecType_DstAsnMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *GlobalSpecType_AnyClient:
		s := proto.Size(x.AnyClient)
		n += proto.SizeVarint(37<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_ClientName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ClientName)))
		n += len(x.ClientName)
	case *GlobalSpecType_ClientSelector:
		s := proto.Size(x.ClientSelector)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_ClientNameMatcher:
		s := proto.Size(x.ClientNameMatcher)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *GlobalSpecType_AnyIp:
		s := proto.Size(x.AnyIp)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_IpPrefixList:
		s := proto.Size(x.IpPrefixList)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_IpMatcher:
		s := proto.Size(x.IpMatcher)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dst_ip_choice
	switch x := m.DstIpChoice.(type) {
	case *GlobalSpecType_AnyDstIp:
		s := proto.Size(x.AnyDstIp)
		n += proto.SizeVarint(41<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_DstIpPrefixList:
		s := proto.Size(x.DstIpPrefixList)
		n += proto.SizeVarint(42<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_DstIpMatcher:
		s := proto.Size(x.DstIpMatcher)
		n += proto.SizeVarint(43<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *GlobalSpecType_AnyAsn:
		s := proto.Size(x.AnyAsn)
		n += proto.SizeVarint(34<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_AsnList:
		s := proto.Size(x.AsnList)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_AsnMatcher:
		s := proto.Size(x.AsnMatcher)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dst_asn_choice
	switch x := m.DstAsnChoice.(type) {
	case *GlobalSpecType_AnyDstAsn:
		s := proto.Size(x.AnyDstAsn)
		n += proto.SizeVarint(51<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_DstAsnList:
		s := proto.Size(x.DstAsnList)
		n += proto.SizeVarint(52<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_DstAsnMatcher:
		s := proto.Size(x.DstAsnMatcher)
		n += proto.SizeVarint(53<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create service policy rule
//
// x-displayName: "Create Service Policy Rule"
// Create service_policy_rule creates a new object in the storage backend for metadata.namespace.
type CreateSpecType struct {
	Action ves_io_schema_policy.RuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// Types that are valid to be assigned to ClientChoice:
	//	*CreateSpecType_AnyClient
	//	*CreateSpecType_ClientName
	//	*CreateSpecType_ClientSelector
	//	*CreateSpecType_ClientNameMatcher
	ClientChoice   isCreateSpecType_ClientChoice                     `protobuf_oneof:"client_choice"`
	ClientRole     *ves_io_schema_policy.RoleMatcherType             `protobuf:"bytes,9,opt,name=client_role,json=clientRole" json:"client_role,omitempty"`
	ServerSelector *ves_io_schema4.LabelSelectorType                 `protobuf:"bytes,45,opt,name=server_selector,json=serverSelector" json:"server_selector,omitempty"`
	LabelMatcher   *ves_io_schema4.LabelMatcherType                  `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher" json:"label_matcher,omitempty"`
	Path           *ves_io_schema_policy.PathMatcherType             `protobuf:"bytes,5,opt,name=path" json:"path,omitempty"`
	Headers        []*ves_io_schema_policy.HeaderMatcherType         `protobuf:"bytes,6,rep,name=headers" json:"headers,omitempty"`
	QueryParams    []*ves_io_schema_policy.QueryParameterMatcherType `protobuf:"bytes,7,rep,name=query_params,json=queryParams" json:"query_params,omitempty"`
	HttpMethod     *ves_io_schema_policy.HttpMethodMatcherType       `protobuf:"bytes,8,opt,name=http_method,json=httpMethod" json:"http_method,omitempty"`
	// Types that are valid to be assigned to IpChoice:
	//	*CreateSpecType_AnyIp
	//	*CreateSpecType_IpPrefixList
	//	*CreateSpecType_IpMatcher
	IpChoice isCreateSpecType_IpChoice `protobuf_oneof:"ip_choice"`
	// Types that are valid to be assigned to DstIpChoice:
	//	*CreateSpecType_AnyDstIp
	//	*CreateSpecType_DstIpPrefixList
	//	*CreateSpecType_DstIpMatcher
	DstIpChoice isCreateSpecType_DstIpChoice `protobuf_oneof:"dst_ip_choice"`
	// Types that are valid to be assigned to AsnChoice:
	//	*CreateSpecType_AnyAsn
	//	*CreateSpecType_AsnList
	//	*CreateSpecType_AsnMatcher
	AsnChoice isCreateSpecType_AsnChoice `protobuf_oneof:"asn_choice"`
	// Types that are valid to be assigned to DstAsnChoice:
	//	*CreateSpecType_AnyDstAsn
	//	*CreateSpecType_DstAsnList
	//	*CreateSpecType_DstAsnMatcher
	DstAsnChoice                  isCreateSpecType_DstAsnChoice                   `protobuf_oneof:"dst_asn_choice"`
	ApiGroupMatcher               *ves_io_schema_policy.StringMatcherType         `protobuf:"bytes,14,opt,name=api_group_matcher,json=apiGroupMatcher" json:"api_group_matcher,omitempty"`
	PortMatcher                   *ves_io_schema_policy.PortMatcherType           `protobuf:"bytes,15,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
	ExpirationTimestamp           *google_protobuf1.Timestamp                     `protobuf:"bytes,16,opt,name=expiration_timestamp,json=expirationTimestamp" json:"expiration_timestamp,omitempty"`
	BodyMatcher                   *ves_io_schema_policy.MatcherType               `protobuf:"bytes,21,opt,name=body_matcher,json=bodyMatcher" json:"body_matcher,omitempty"`
	ArgMatchers                   []*ves_io_schema_policy.ArgMatcherType          `protobuf:"bytes,18,rep,name=arg_matchers,json=argMatchers" json:"arg_matchers,omitempty"`
	CookieMatchers                []*ves_io_schema_policy.CookieMatcherType       `protobuf:"bytes,19,rep,name=cookie_matchers,json=cookieMatchers" json:"cookie_matchers,omitempty"`
	WafAction                     *ves_io_schema_policy.WafAction                 `protobuf:"bytes,20,opt,name=waf_action,json=wafAction" json:"waf_action,omitempty"`
	DomainMatcher                 *ves_io_schema_policy.MatcherTypeBasic          `protobuf:"bytes,22,opt,name=domain_matcher,json=domainMatcher" json:"domain_matcher,omitempty"`
	RateLimiter                   []*ves_io_schema4.ObjectRefType                 `protobuf:"bytes,23,rep,name=rate_limiter,json=rateLimiter" json:"rate_limiter,omitempty"`
	VirtualHostMatcher            *ves_io_schema_policy.MatcherTypeBasic          `protobuf:"bytes,24,opt,name=virtual_host_matcher,json=virtualHostMatcher" json:"virtual_host_matcher,omitempty"`
	TlsFingerprintMatcher         *ves_io_schema_policy.TlsFingerprintMatcherType `protobuf:"bytes,25,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher" json:"tls_fingerprint_matcher,omitempty"`
	MaliciousUserMitigationBypass *ves_io_schema4.Empty                           `protobuf:"bytes,28,opt,name=malicious_user_mitigation_bypass,json=maliciousUserMitigationBypass" json:"malicious_user_mitigation_bypass,omitempty"`
	Scheme                        []string                                        `protobuf:"bytes,38,rep,name=scheme" json:"scheme,omitempty"`
	UrlMatcher                    *ves_io_schema_policy.URLMatcherType            `protobuf:"bytes,39,opt,name=url_matcher,json=urlMatcher" json:"url_matcher,omitempty"`
	L4DestMatcher                 *ves_io_schema_policy.L4DestMatcherType         `protobuf:"bytes,44,opt,name=l4_dest_matcher,json=l4DestMatcher" json:"l4_dest_matcher,omitempty"`
	ChallengeAction               ves_io_schema_policy.ChallengeAction            `protobuf:"varint,54,opt,name=challenge_action,json=challengeAction,proto3,enum=ves.io.schema.policy.ChallengeAction" json:"challenge_action,omitempty"`
	GotoPolicy                    []*ves_io_schema4.ObjectRefType                 `protobuf:"bytes,55,rep,name=goto_policy,json=gotoPolicy" json:"goto_policy,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

type isCreateSpecType_ClientChoice interface {
	isCreateSpecType_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_IpChoice interface {
	isCreateSpecType_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_DstIpChoice interface {
	isCreateSpecType_DstIpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_AsnChoice interface {
	isCreateSpecType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_DstAsnChoice interface {
	isCreateSpecType_DstAsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AnyClient struct {
	AnyClient *ves_io_schema4.Empty `protobuf:"bytes,37,opt,name=any_client,json=anyClient,oneof"`
}
type CreateSpecType_ClientName struct {
	ClientName string `protobuf:"bytes,2,opt,name=client_name,json=clientName,proto3,oneof"`
}
type CreateSpecType_ClientSelector struct {
	ClientSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,3,opt,name=client_selector,json=clientSelector,oneof"`
}
type CreateSpecType_ClientNameMatcher struct {
	ClientNameMatcher *ves_io_schema_policy.MatcherTypeBasic `protobuf:"bytes,10,opt,name=client_name_matcher,json=clientNameMatcher,oneof"`
}
type CreateSpecType_AnyIp struct {
	AnyIp *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,oneof"`
}
type CreateSpecType_IpPrefixList struct {
	IpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,oneof"`
}
type CreateSpecType_IpMatcher struct {
	IpMatcher *ves_io_schema_policy.IpMatcherType `protobuf:"bytes,12,opt,name=ip_matcher,json=ipMatcher,oneof"`
}
type CreateSpecType_AnyDstIp struct {
	AnyDstIp *ves_io_schema4.Empty `protobuf:"bytes,41,opt,name=any_dst_ip,json=anyDstIp,oneof"`
}
type CreateSpecType_DstIpPrefixList struct {
	DstIpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,42,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,oneof"`
}
type CreateSpecType_DstIpMatcher struct {
	DstIpMatcher *ves_io_schema_policy.IpMatcherType `protobuf:"bytes,43,opt,name=dst_ip_matcher,json=dstIpMatcher,oneof"`
}
type CreateSpecType_AnyAsn struct {
	AnyAsn *ves_io_schema4.Empty `protobuf:"bytes,34,opt,name=any_asn,json=anyAsn,oneof"`
}
type CreateSpecType_AsnList struct {
	AsnList *ves_io_schema_policy.AsnMatchList `protobuf:"bytes,35,opt,name=asn_list,json=asnList,oneof"`
}
type CreateSpecType_AsnMatcher struct {
	AsnMatcher *ves_io_schema_policy.AsnMatcherType `protobuf:"bytes,13,opt,name=asn_matcher,json=asnMatcher,oneof"`
}
type CreateSpecType_AnyDstAsn struct {
	AnyDstAsn *ves_io_schema4.Empty `protobuf:"bytes,51,opt,name=any_dst_asn,json=anyDstAsn,oneof"`
}
type CreateSpecType_DstAsnList struct {
	DstAsnList *ves_io_schema_policy.AsnMatchList `protobuf:"bytes,52,opt,name=dst_asn_list,json=dstAsnList,oneof"`
}
type CreateSpecType_DstAsnMatcher struct {
	DstAsnMatcher *ves_io_schema_policy.AsnMatcherType `protobuf:"bytes,53,opt,name=dst_asn_matcher,json=dstAsnMatcher,oneof"`
}

func (*CreateSpecType_AnyClient) isCreateSpecType_ClientChoice()         {}
func (*CreateSpecType_ClientName) isCreateSpecType_ClientChoice()        {}
func (*CreateSpecType_ClientSelector) isCreateSpecType_ClientChoice()    {}
func (*CreateSpecType_ClientNameMatcher) isCreateSpecType_ClientChoice() {}
func (*CreateSpecType_AnyIp) isCreateSpecType_IpChoice()                 {}
func (*CreateSpecType_IpPrefixList) isCreateSpecType_IpChoice()          {}
func (*CreateSpecType_IpMatcher) isCreateSpecType_IpChoice()             {}
func (*CreateSpecType_AnyDstIp) isCreateSpecType_DstIpChoice()           {}
func (*CreateSpecType_DstIpPrefixList) isCreateSpecType_DstIpChoice()    {}
func (*CreateSpecType_DstIpMatcher) isCreateSpecType_DstIpChoice()       {}
func (*CreateSpecType_AnyAsn) isCreateSpecType_AsnChoice()               {}
func (*CreateSpecType_AsnList) isCreateSpecType_AsnChoice()              {}
func (*CreateSpecType_AsnMatcher) isCreateSpecType_AsnChoice()           {}
func (*CreateSpecType_AnyDstAsn) isCreateSpecType_DstAsnChoice()         {}
func (*CreateSpecType_DstAsnList) isCreateSpecType_DstAsnChoice()        {}
func (*CreateSpecType_DstAsnMatcher) isCreateSpecType_DstAsnChoice()     {}

func (m *CreateSpecType) GetClientChoice() isCreateSpecType_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}
func (m *CreateSpecType) GetIpChoice() isCreateSpecType_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *CreateSpecType) GetDstIpChoice() isCreateSpecType_DstIpChoice {
	if m != nil {
		return m.DstIpChoice
	}
	return nil
}
func (m *CreateSpecType) GetAsnChoice() isCreateSpecType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *CreateSpecType) GetDstAsnChoice() isCreateSpecType_DstAsnChoice {
	if m != nil {
		return m.DstAsnChoice
	}
	return nil
}

func (m *CreateSpecType) GetAction() ves_io_schema_policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return ves_io_schema_policy.DENY
}

func (m *CreateSpecType) GetAnyClient() *ves_io_schema4.Empty {
	if x, ok := m.GetClientChoice().(*CreateSpecType_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *CreateSpecType) GetClientName() string {
	if x, ok := m.GetClientChoice().(*CreateSpecType_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *CreateSpecType) GetClientSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*CreateSpecType_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *CreateSpecType) GetClientNameMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if x, ok := m.GetClientChoice().(*CreateSpecType_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *CreateSpecType) GetClientRole() *ves_io_schema_policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *CreateSpecType) GetServerSelector() *ves_io_schema4.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *CreateSpecType) GetLabelMatcher() *ves_io_schema4.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *CreateSpecType) GetPath() *ves_io_schema_policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *CreateSpecType) GetHeaders() []*ves_io_schema_policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *CreateSpecType) GetQueryParams() []*ves_io_schema_policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *CreateSpecType) GetHttpMethod() *ves_io_schema_policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *CreateSpecType) GetAnyIp() *ves_io_schema4.Empty {
	if x, ok := m.GetIpChoice().(*CreateSpecType_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *CreateSpecType) GetIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*CreateSpecType_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *CreateSpecType) GetIpMatcher() *ves_io_schema_policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*CreateSpecType_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAnyDstIp() *ves_io_schema4.Empty {
	if x, ok := m.GetDstIpChoice().(*CreateSpecType_AnyDstIp); ok {
		return x.AnyDstIp
	}
	return nil
}

func (m *CreateSpecType) GetDstIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if x, ok := m.GetDstIpChoice().(*CreateSpecType_DstIpPrefixList); ok {
		return x.DstIpPrefixList
	}
	return nil
}

func (m *CreateSpecType) GetDstIpMatcher() *ves_io_schema_policy.IpMatcherType {
	if x, ok := m.GetDstIpChoice().(*CreateSpecType_DstIpMatcher); ok {
		return x.DstIpMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAnyAsn() *ves_io_schema4.Empty {
	if x, ok := m.GetAsnChoice().(*CreateSpecType_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *CreateSpecType) GetAsnList() *ves_io_schema_policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*CreateSpecType_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *CreateSpecType) GetAsnMatcher() *ves_io_schema_policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*CreateSpecType_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAnyDstAsn() *ves_io_schema4.Empty {
	if x, ok := m.GetDstAsnChoice().(*CreateSpecType_AnyDstAsn); ok {
		return x.AnyDstAsn
	}
	return nil
}

func (m *CreateSpecType) GetDstAsnList() *ves_io_schema_policy.AsnMatchList {
	if x, ok := m.GetDstAsnChoice().(*CreateSpecType_DstAsnList); ok {
		return x.DstAsnList
	}
	return nil
}

func (m *CreateSpecType) GetDstAsnMatcher() *ves_io_schema_policy.AsnMatcherType {
	if x, ok := m.GetDstAsnChoice().(*CreateSpecType_DstAsnMatcher); ok {
		return x.DstAsnMatcher
	}
	return nil
}

func (m *CreateSpecType) GetApiGroupMatcher() *ves_io_schema_policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *CreateSpecType) GetPortMatcher() *ves_io_schema_policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *CreateSpecType) GetExpirationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *CreateSpecType) GetBodyMatcher() *ves_io_schema_policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *CreateSpecType) GetArgMatchers() []*ves_io_schema_policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *CreateSpecType) GetCookieMatchers() []*ves_io_schema_policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *CreateSpecType) GetWafAction() *ves_io_schema_policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *CreateSpecType) GetDomainMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *CreateSpecType) GetRateLimiter() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *CreateSpecType) GetVirtualHostMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if m != nil {
		return m.VirtualHostMatcher
	}
	return nil
}

func (m *CreateSpecType) GetTlsFingerprintMatcher() *ves_io_schema_policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *CreateSpecType) GetMaliciousUserMitigationBypass() *ves_io_schema4.Empty {
	if m != nil {
		return m.MaliciousUserMitigationBypass
	}
	return nil
}

func (m *CreateSpecType) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *CreateSpecType) GetUrlMatcher() *ves_io_schema_policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *CreateSpecType) GetL4DestMatcher() *ves_io_schema_policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *CreateSpecType) GetChallengeAction() ves_io_schema_policy.ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return ves_io_schema_policy.DEFAULT_CHALLENGE
}

func (m *CreateSpecType) GetGotoPolicy() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_AnyClient)(nil),
		(*CreateSpecType_ClientName)(nil),
		(*CreateSpecType_ClientSelector)(nil),
		(*CreateSpecType_ClientNameMatcher)(nil),
		(*CreateSpecType_AnyIp)(nil),
		(*CreateSpecType_IpPrefixList)(nil),
		(*CreateSpecType_IpMatcher)(nil),
		(*CreateSpecType_AnyDstIp)(nil),
		(*CreateSpecType_DstIpPrefixList)(nil),
		(*CreateSpecType_DstIpMatcher)(nil),
		(*CreateSpecType_AnyAsn)(nil),
		(*CreateSpecType_AsnList)(nil),
		(*CreateSpecType_AsnMatcher)(nil),
		(*CreateSpecType_AnyDstAsn)(nil),
		(*CreateSpecType_DstAsnList)(nil),
		(*CreateSpecType_DstAsnMatcher)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *CreateSpecType_AnyClient:
		_ = b.EncodeVarint(37<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyClient); err != nil {
			return err
		}
	case *CreateSpecType_ClientName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ClientName)
	case *CreateSpecType_ClientSelector:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientSelector); err != nil {
			return err
		}
	case *CreateSpecType_ClientNameMatcher:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientNameMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.ClientChoice has unexpected type %T", x)
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *CreateSpecType_AnyIp:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyIp); err != nil {
			return err
		}
	case *CreateSpecType_IpPrefixList:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpPrefixList); err != nil {
			return err
		}
	case *CreateSpecType_IpMatcher:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.IpChoice has unexpected type %T", x)
	}
	// dst_ip_choice
	switch x := m.DstIpChoice.(type) {
	case *CreateSpecType_AnyDstIp:
		_ = b.EncodeVarint(41<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyDstIp); err != nil {
			return err
		}
	case *CreateSpecType_DstIpPrefixList:
		_ = b.EncodeVarint(42<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstIpPrefixList); err != nil {
			return err
		}
	case *CreateSpecType_DstIpMatcher:
		_ = b.EncodeVarint(43<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstIpMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.DstIpChoice has unexpected type %T", x)
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *CreateSpecType_AnyAsn:
		_ = b.EncodeVarint(34<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyAsn); err != nil {
			return err
		}
	case *CreateSpecType_AsnList:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnList); err != nil {
			return err
		}
	case *CreateSpecType_AsnMatcher:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.AsnChoice has unexpected type %T", x)
	}
	// dst_asn_choice
	switch x := m.DstAsnChoice.(type) {
	case *CreateSpecType_AnyDstAsn:
		_ = b.EncodeVarint(51<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyDstAsn); err != nil {
			return err
		}
	case *CreateSpecType_DstAsnList:
		_ = b.EncodeVarint(52<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstAsnList); err != nil {
			return err
		}
	case *CreateSpecType_DstAsnMatcher:
		_ = b.EncodeVarint(53<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstAsnMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.DstAsnChoice has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 37: // client_choice.any_client
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &CreateSpecType_AnyClient{msg}
		return true, err
	case 2: // client_choice.client_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ClientChoice = &CreateSpecType_ClientName{x}
		return true, err
	case 3: // client_choice.client_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &CreateSpecType_ClientSelector{msg}
		return true, err
	case 10: // client_choice.client_name_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.MatcherTypeBasic)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &CreateSpecType_ClientNameMatcher{msg}
		return true, err
	case 31: // ip_choice.any_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.IpChoice = &CreateSpecType_AnyIp{msg}
		return true, err
	case 32: // ip_choice.ip_prefix_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.PrefixMatchList)
		err := b.DecodeMessage(msg)
		m.IpChoice = &CreateSpecType_IpPrefixList{msg}
		return true, err
	case 12: // ip_choice.ip_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.IpMatcherType)
		err := b.DecodeMessage(msg)
		m.IpChoice = &CreateSpecType_IpMatcher{msg}
		return true, err
	case 41: // dst_ip_choice.any_dst_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &CreateSpecType_AnyDstIp{msg}
		return true, err
	case 42: // dst_ip_choice.dst_ip_prefix_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.PrefixMatchList)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &CreateSpecType_DstIpPrefixList{msg}
		return true, err
	case 43: // dst_ip_choice.dst_ip_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.IpMatcherType)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &CreateSpecType_DstIpMatcher{msg}
		return true, err
	case 34: // asn_choice.any_asn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &CreateSpecType_AnyAsn{msg}
		return true, err
	case 35: // asn_choice.asn_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatchList)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &CreateSpecType_AsnList{msg}
		return true, err
	case 13: // asn_choice.asn_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatcherType)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &CreateSpecType_AsnMatcher{msg}
		return true, err
	case 51: // dst_asn_choice.any_dst_asn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &CreateSpecType_AnyDstAsn{msg}
		return true, err
	case 52: // dst_asn_choice.dst_asn_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatchList)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &CreateSpecType_DstAsnList{msg}
		return true, err
	case 53: // dst_asn_choice.dst_asn_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatcherType)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &CreateSpecType_DstAsnMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *CreateSpecType_AnyClient:
		s := proto.Size(x.AnyClient)
		n += proto.SizeVarint(37<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_ClientName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ClientName)))
		n += len(x.ClientName)
	case *CreateSpecType_ClientSelector:
		s := proto.Size(x.ClientSelector)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_ClientNameMatcher:
		s := proto.Size(x.ClientNameMatcher)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *CreateSpecType_AnyIp:
		s := proto.Size(x.AnyIp)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_IpPrefixList:
		s := proto.Size(x.IpPrefixList)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_IpMatcher:
		s := proto.Size(x.IpMatcher)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dst_ip_choice
	switch x := m.DstIpChoice.(type) {
	case *CreateSpecType_AnyDstIp:
		s := proto.Size(x.AnyDstIp)
		n += proto.SizeVarint(41<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DstIpPrefixList:
		s := proto.Size(x.DstIpPrefixList)
		n += proto.SizeVarint(42<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DstIpMatcher:
		s := proto.Size(x.DstIpMatcher)
		n += proto.SizeVarint(43<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *CreateSpecType_AnyAsn:
		s := proto.Size(x.AnyAsn)
		n += proto.SizeVarint(34<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_AsnList:
		s := proto.Size(x.AsnList)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_AsnMatcher:
		s := proto.Size(x.AsnMatcher)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dst_asn_choice
	switch x := m.DstAsnChoice.(type) {
	case *CreateSpecType_AnyDstAsn:
		s := proto.Size(x.AnyDstAsn)
		n += proto.SizeVarint(51<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DstAsnList:
		s := proto.Size(x.DstAsnList)
		n += proto.SizeVarint(52<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DstAsnMatcher:
		s := proto.Size(x.DstAsnMatcher)
		n += proto.SizeVarint(53<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace service policy rule
//
// x-displayName: "Replace Service Policy Rule"
// Replace service_policy_rule replaces an existing object in the storage backend for metadata.namespace.
type ReplaceSpecType struct {
	Action ves_io_schema_policy.RuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// Types that are valid to be assigned to ClientChoice:
	//	*ReplaceSpecType_AnyClient
	//	*ReplaceSpecType_ClientName
	//	*ReplaceSpecType_ClientSelector
	//	*ReplaceSpecType_ClientNameMatcher
	ClientChoice   isReplaceSpecType_ClientChoice                    `protobuf_oneof:"client_choice"`
	ClientRole     *ves_io_schema_policy.RoleMatcherType             `protobuf:"bytes,9,opt,name=client_role,json=clientRole" json:"client_role,omitempty"`
	ServerSelector *ves_io_schema4.LabelSelectorType                 `protobuf:"bytes,45,opt,name=server_selector,json=serverSelector" json:"server_selector,omitempty"`
	LabelMatcher   *ves_io_schema4.LabelMatcherType                  `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher" json:"label_matcher,omitempty"`
	Path           *ves_io_schema_policy.PathMatcherType             `protobuf:"bytes,5,opt,name=path" json:"path,omitempty"`
	Headers        []*ves_io_schema_policy.HeaderMatcherType         `protobuf:"bytes,6,rep,name=headers" json:"headers,omitempty"`
	QueryParams    []*ves_io_schema_policy.QueryParameterMatcherType `protobuf:"bytes,7,rep,name=query_params,json=queryParams" json:"query_params,omitempty"`
	HttpMethod     *ves_io_schema_policy.HttpMethodMatcherType       `protobuf:"bytes,8,opt,name=http_method,json=httpMethod" json:"http_method,omitempty"`
	// Types that are valid to be assigned to IpChoice:
	//	*ReplaceSpecType_AnyIp
	//	*ReplaceSpecType_IpPrefixList
	//	*ReplaceSpecType_IpMatcher
	IpChoice isReplaceSpecType_IpChoice `protobuf_oneof:"ip_choice"`
	// Types that are valid to be assigned to DstIpChoice:
	//	*ReplaceSpecType_AnyDstIp
	//	*ReplaceSpecType_DstIpPrefixList
	//	*ReplaceSpecType_DstIpMatcher
	DstIpChoice isReplaceSpecType_DstIpChoice `protobuf_oneof:"dst_ip_choice"`
	// Types that are valid to be assigned to AsnChoice:
	//	*ReplaceSpecType_AnyAsn
	//	*ReplaceSpecType_AsnList
	//	*ReplaceSpecType_AsnMatcher
	AsnChoice isReplaceSpecType_AsnChoice `protobuf_oneof:"asn_choice"`
	// Types that are valid to be assigned to DstAsnChoice:
	//	*ReplaceSpecType_AnyDstAsn
	//	*ReplaceSpecType_DstAsnList
	//	*ReplaceSpecType_DstAsnMatcher
	DstAsnChoice                  isReplaceSpecType_DstAsnChoice                  `protobuf_oneof:"dst_asn_choice"`
	ApiGroupMatcher               *ves_io_schema_policy.StringMatcherType         `protobuf:"bytes,14,opt,name=api_group_matcher,json=apiGroupMatcher" json:"api_group_matcher,omitempty"`
	PortMatcher                   *ves_io_schema_policy.PortMatcherType           `protobuf:"bytes,15,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
	ExpirationTimestamp           *google_protobuf1.Timestamp                     `protobuf:"bytes,16,opt,name=expiration_timestamp,json=expirationTimestamp" json:"expiration_timestamp,omitempty"`
	BodyMatcher                   *ves_io_schema_policy.MatcherType               `protobuf:"bytes,21,opt,name=body_matcher,json=bodyMatcher" json:"body_matcher,omitempty"`
	ArgMatchers                   []*ves_io_schema_policy.ArgMatcherType          `protobuf:"bytes,18,rep,name=arg_matchers,json=argMatchers" json:"arg_matchers,omitempty"`
	CookieMatchers                []*ves_io_schema_policy.CookieMatcherType       `protobuf:"bytes,19,rep,name=cookie_matchers,json=cookieMatchers" json:"cookie_matchers,omitempty"`
	WafAction                     *ves_io_schema_policy.WafAction                 `protobuf:"bytes,20,opt,name=waf_action,json=wafAction" json:"waf_action,omitempty"`
	DomainMatcher                 *ves_io_schema_policy.MatcherTypeBasic          `protobuf:"bytes,22,opt,name=domain_matcher,json=domainMatcher" json:"domain_matcher,omitempty"`
	RateLimiter                   []*ves_io_schema4.ObjectRefType                 `protobuf:"bytes,23,rep,name=rate_limiter,json=rateLimiter" json:"rate_limiter,omitempty"`
	VirtualHostMatcher            *ves_io_schema_policy.MatcherTypeBasic          `protobuf:"bytes,24,opt,name=virtual_host_matcher,json=virtualHostMatcher" json:"virtual_host_matcher,omitempty"`
	TlsFingerprintMatcher         *ves_io_schema_policy.TlsFingerprintMatcherType `protobuf:"bytes,25,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher" json:"tls_fingerprint_matcher,omitempty"`
	MaliciousUserMitigationBypass *ves_io_schema4.Empty                           `protobuf:"bytes,28,opt,name=malicious_user_mitigation_bypass,json=maliciousUserMitigationBypass" json:"malicious_user_mitigation_bypass,omitempty"`
	Scheme                        []string                                        `protobuf:"bytes,38,rep,name=scheme" json:"scheme,omitempty"`
	UrlMatcher                    *ves_io_schema_policy.URLMatcherType            `protobuf:"bytes,39,opt,name=url_matcher,json=urlMatcher" json:"url_matcher,omitempty"`
	L4DestMatcher                 *ves_io_schema_policy.L4DestMatcherType         `protobuf:"bytes,44,opt,name=l4_dest_matcher,json=l4DestMatcher" json:"l4_dest_matcher,omitempty"`
	ChallengeAction               ves_io_schema_policy.ChallengeAction            `protobuf:"varint,54,opt,name=challenge_action,json=challengeAction,proto3,enum=ves.io.schema.policy.ChallengeAction" json:"challenge_action,omitempty"`
	GotoPolicy                    []*ves_io_schema4.ObjectRefType                 `protobuf:"bytes,55,rep,name=goto_policy,json=gotoPolicy" json:"goto_policy,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isReplaceSpecType_ClientChoice interface {
	isReplaceSpecType_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_IpChoice interface {
	isReplaceSpecType_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_DstIpChoice interface {
	isReplaceSpecType_DstIpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_AsnChoice interface {
	isReplaceSpecType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_DstAsnChoice interface {
	isReplaceSpecType_DstAsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AnyClient struct {
	AnyClient *ves_io_schema4.Empty `protobuf:"bytes,37,opt,name=any_client,json=anyClient,oneof"`
}
type ReplaceSpecType_ClientName struct {
	ClientName string `protobuf:"bytes,2,opt,name=client_name,json=clientName,proto3,oneof"`
}
type ReplaceSpecType_ClientSelector struct {
	ClientSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,3,opt,name=client_selector,json=clientSelector,oneof"`
}
type ReplaceSpecType_ClientNameMatcher struct {
	ClientNameMatcher *ves_io_schema_policy.MatcherTypeBasic `protobuf:"bytes,10,opt,name=client_name_matcher,json=clientNameMatcher,oneof"`
}
type ReplaceSpecType_AnyIp struct {
	AnyIp *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,oneof"`
}
type ReplaceSpecType_IpPrefixList struct {
	IpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,oneof"`
}
type ReplaceSpecType_IpMatcher struct {
	IpMatcher *ves_io_schema_policy.IpMatcherType `protobuf:"bytes,12,opt,name=ip_matcher,json=ipMatcher,oneof"`
}
type ReplaceSpecType_AnyDstIp struct {
	AnyDstIp *ves_io_schema4.Empty `protobuf:"bytes,41,opt,name=any_dst_ip,json=anyDstIp,oneof"`
}
type ReplaceSpecType_DstIpPrefixList struct {
	DstIpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,42,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,oneof"`
}
type ReplaceSpecType_DstIpMatcher struct {
	DstIpMatcher *ves_io_schema_policy.IpMatcherType `protobuf:"bytes,43,opt,name=dst_ip_matcher,json=dstIpMatcher,oneof"`
}
type ReplaceSpecType_AnyAsn struct {
	AnyAsn *ves_io_schema4.Empty `protobuf:"bytes,34,opt,name=any_asn,json=anyAsn,oneof"`
}
type ReplaceSpecType_AsnList struct {
	AsnList *ves_io_schema_policy.AsnMatchList `protobuf:"bytes,35,opt,name=asn_list,json=asnList,oneof"`
}
type ReplaceSpecType_AsnMatcher struct {
	AsnMatcher *ves_io_schema_policy.AsnMatcherType `protobuf:"bytes,13,opt,name=asn_matcher,json=asnMatcher,oneof"`
}
type ReplaceSpecType_AnyDstAsn struct {
	AnyDstAsn *ves_io_schema4.Empty `protobuf:"bytes,51,opt,name=any_dst_asn,json=anyDstAsn,oneof"`
}
type ReplaceSpecType_DstAsnList struct {
	DstAsnList *ves_io_schema_policy.AsnMatchList `protobuf:"bytes,52,opt,name=dst_asn_list,json=dstAsnList,oneof"`
}
type ReplaceSpecType_DstAsnMatcher struct {
	DstAsnMatcher *ves_io_schema_policy.AsnMatcherType `protobuf:"bytes,53,opt,name=dst_asn_matcher,json=dstAsnMatcher,oneof"`
}

func (*ReplaceSpecType_AnyClient) isReplaceSpecType_ClientChoice()         {}
func (*ReplaceSpecType_ClientName) isReplaceSpecType_ClientChoice()        {}
func (*ReplaceSpecType_ClientSelector) isReplaceSpecType_ClientChoice()    {}
func (*ReplaceSpecType_ClientNameMatcher) isReplaceSpecType_ClientChoice() {}
func (*ReplaceSpecType_AnyIp) isReplaceSpecType_IpChoice()                 {}
func (*ReplaceSpecType_IpPrefixList) isReplaceSpecType_IpChoice()          {}
func (*ReplaceSpecType_IpMatcher) isReplaceSpecType_IpChoice()             {}
func (*ReplaceSpecType_AnyDstIp) isReplaceSpecType_DstIpChoice()           {}
func (*ReplaceSpecType_DstIpPrefixList) isReplaceSpecType_DstIpChoice()    {}
func (*ReplaceSpecType_DstIpMatcher) isReplaceSpecType_DstIpChoice()       {}
func (*ReplaceSpecType_AnyAsn) isReplaceSpecType_AsnChoice()               {}
func (*ReplaceSpecType_AsnList) isReplaceSpecType_AsnChoice()              {}
func (*ReplaceSpecType_AsnMatcher) isReplaceSpecType_AsnChoice()           {}
func (*ReplaceSpecType_AnyDstAsn) isReplaceSpecType_DstAsnChoice()         {}
func (*ReplaceSpecType_DstAsnList) isReplaceSpecType_DstAsnChoice()        {}
func (*ReplaceSpecType_DstAsnMatcher) isReplaceSpecType_DstAsnChoice()     {}

func (m *ReplaceSpecType) GetClientChoice() isReplaceSpecType_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetIpChoice() isReplaceSpecType_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetDstIpChoice() isReplaceSpecType_DstIpChoice {
	if m != nil {
		return m.DstIpChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetAsnChoice() isReplaceSpecType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetDstAsnChoice() isReplaceSpecType_DstAsnChoice {
	if m != nil {
		return m.DstAsnChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetAction() ves_io_schema_policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return ves_io_schema_policy.DENY
}

func (m *ReplaceSpecType) GetAnyClient() *ves_io_schema4.Empty {
	if x, ok := m.GetClientChoice().(*ReplaceSpecType_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *ReplaceSpecType) GetClientName() string {
	if x, ok := m.GetClientChoice().(*ReplaceSpecType_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *ReplaceSpecType) GetClientSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*ReplaceSpecType_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetClientNameMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if x, ok := m.GetClientChoice().(*ReplaceSpecType_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetClientRole() *ves_io_schema_policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *ReplaceSpecType) GetServerSelector() *ves_io_schema4.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetLabelMatcher() *ves_io_schema4.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetPath() *ves_io_schema_policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *ReplaceSpecType) GetHeaders() []*ves_io_schema_policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *ReplaceSpecType) GetQueryParams() []*ves_io_schema_policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *ReplaceSpecType) GetHttpMethod() *ves_io_schema_policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *ReplaceSpecType) GetAnyIp() *ves_io_schema4.Empty {
	if x, ok := m.GetIpChoice().(*ReplaceSpecType_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *ReplaceSpecType) GetIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*ReplaceSpecType_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *ReplaceSpecType) GetIpMatcher() *ves_io_schema_policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*ReplaceSpecType_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAnyDstIp() *ves_io_schema4.Empty {
	if x, ok := m.GetDstIpChoice().(*ReplaceSpecType_AnyDstIp); ok {
		return x.AnyDstIp
	}
	return nil
}

func (m *ReplaceSpecType) GetDstIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if x, ok := m.GetDstIpChoice().(*ReplaceSpecType_DstIpPrefixList); ok {
		return x.DstIpPrefixList
	}
	return nil
}

func (m *ReplaceSpecType) GetDstIpMatcher() *ves_io_schema_policy.IpMatcherType {
	if x, ok := m.GetDstIpChoice().(*ReplaceSpecType_DstIpMatcher); ok {
		return x.DstIpMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAnyAsn() *ves_io_schema4.Empty {
	if x, ok := m.GetAsnChoice().(*ReplaceSpecType_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *ReplaceSpecType) GetAsnList() *ves_io_schema_policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*ReplaceSpecType_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *ReplaceSpecType) GetAsnMatcher() *ves_io_schema_policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*ReplaceSpecType_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAnyDstAsn() *ves_io_schema4.Empty {
	if x, ok := m.GetDstAsnChoice().(*ReplaceSpecType_AnyDstAsn); ok {
		return x.AnyDstAsn
	}
	return nil
}

func (m *ReplaceSpecType) GetDstAsnList() *ves_io_schema_policy.AsnMatchList {
	if x, ok := m.GetDstAsnChoice().(*ReplaceSpecType_DstAsnList); ok {
		return x.DstAsnList
	}
	return nil
}

func (m *ReplaceSpecType) GetDstAsnMatcher() *ves_io_schema_policy.AsnMatcherType {
	if x, ok := m.GetDstAsnChoice().(*ReplaceSpecType_DstAsnMatcher); ok {
		return x.DstAsnMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetApiGroupMatcher() *ves_io_schema_policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetPortMatcher() *ves_io_schema_policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetExpirationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *ReplaceSpecType) GetBodyMatcher() *ves_io_schema_policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetArgMatchers() []*ves_io_schema_policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *ReplaceSpecType) GetCookieMatchers() []*ves_io_schema_policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *ReplaceSpecType) GetWafAction() *ves_io_schema_policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *ReplaceSpecType) GetDomainMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetRateLimiter() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *ReplaceSpecType) GetVirtualHostMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if m != nil {
		return m.VirtualHostMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetTlsFingerprintMatcher() *ves_io_schema_policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetMaliciousUserMitigationBypass() *ves_io_schema4.Empty {
	if m != nil {
		return m.MaliciousUserMitigationBypass
	}
	return nil
}

func (m *ReplaceSpecType) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *ReplaceSpecType) GetUrlMatcher() *ves_io_schema_policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetL4DestMatcher() *ves_io_schema_policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetChallengeAction() ves_io_schema_policy.ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return ves_io_schema_policy.DEFAULT_CHALLENGE
}

func (m *ReplaceSpecType) GetGotoPolicy() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_AnyClient)(nil),
		(*ReplaceSpecType_ClientName)(nil),
		(*ReplaceSpecType_ClientSelector)(nil),
		(*ReplaceSpecType_ClientNameMatcher)(nil),
		(*ReplaceSpecType_AnyIp)(nil),
		(*ReplaceSpecType_IpPrefixList)(nil),
		(*ReplaceSpecType_IpMatcher)(nil),
		(*ReplaceSpecType_AnyDstIp)(nil),
		(*ReplaceSpecType_DstIpPrefixList)(nil),
		(*ReplaceSpecType_DstIpMatcher)(nil),
		(*ReplaceSpecType_AnyAsn)(nil),
		(*ReplaceSpecType_AsnList)(nil),
		(*ReplaceSpecType_AsnMatcher)(nil),
		(*ReplaceSpecType_AnyDstAsn)(nil),
		(*ReplaceSpecType_DstAsnList)(nil),
		(*ReplaceSpecType_DstAsnMatcher)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *ReplaceSpecType_AnyClient:
		_ = b.EncodeVarint(37<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyClient); err != nil {
			return err
		}
	case *ReplaceSpecType_ClientName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ClientName)
	case *ReplaceSpecType_ClientSelector:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientSelector); err != nil {
			return err
		}
	case *ReplaceSpecType_ClientNameMatcher:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientNameMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.ClientChoice has unexpected type %T", x)
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *ReplaceSpecType_AnyIp:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyIp); err != nil {
			return err
		}
	case *ReplaceSpecType_IpPrefixList:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpPrefixList); err != nil {
			return err
		}
	case *ReplaceSpecType_IpMatcher:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.IpChoice has unexpected type %T", x)
	}
	// dst_ip_choice
	switch x := m.DstIpChoice.(type) {
	case *ReplaceSpecType_AnyDstIp:
		_ = b.EncodeVarint(41<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyDstIp); err != nil {
			return err
		}
	case *ReplaceSpecType_DstIpPrefixList:
		_ = b.EncodeVarint(42<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstIpPrefixList); err != nil {
			return err
		}
	case *ReplaceSpecType_DstIpMatcher:
		_ = b.EncodeVarint(43<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstIpMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.DstIpChoice has unexpected type %T", x)
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *ReplaceSpecType_AnyAsn:
		_ = b.EncodeVarint(34<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyAsn); err != nil {
			return err
		}
	case *ReplaceSpecType_AsnList:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnList); err != nil {
			return err
		}
	case *ReplaceSpecType_AsnMatcher:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.AsnChoice has unexpected type %T", x)
	}
	// dst_asn_choice
	switch x := m.DstAsnChoice.(type) {
	case *ReplaceSpecType_AnyDstAsn:
		_ = b.EncodeVarint(51<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyDstAsn); err != nil {
			return err
		}
	case *ReplaceSpecType_DstAsnList:
		_ = b.EncodeVarint(52<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstAsnList); err != nil {
			return err
		}
	case *ReplaceSpecType_DstAsnMatcher:
		_ = b.EncodeVarint(53<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstAsnMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.DstAsnChoice has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 37: // client_choice.any_client
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &ReplaceSpecType_AnyClient{msg}
		return true, err
	case 2: // client_choice.client_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ClientChoice = &ReplaceSpecType_ClientName{x}
		return true, err
	case 3: // client_choice.client_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &ReplaceSpecType_ClientSelector{msg}
		return true, err
	case 10: // client_choice.client_name_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.MatcherTypeBasic)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &ReplaceSpecType_ClientNameMatcher{msg}
		return true, err
	case 31: // ip_choice.any_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.IpChoice = &ReplaceSpecType_AnyIp{msg}
		return true, err
	case 32: // ip_choice.ip_prefix_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.PrefixMatchList)
		err := b.DecodeMessage(msg)
		m.IpChoice = &ReplaceSpecType_IpPrefixList{msg}
		return true, err
	case 12: // ip_choice.ip_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.IpMatcherType)
		err := b.DecodeMessage(msg)
		m.IpChoice = &ReplaceSpecType_IpMatcher{msg}
		return true, err
	case 41: // dst_ip_choice.any_dst_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &ReplaceSpecType_AnyDstIp{msg}
		return true, err
	case 42: // dst_ip_choice.dst_ip_prefix_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.PrefixMatchList)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &ReplaceSpecType_DstIpPrefixList{msg}
		return true, err
	case 43: // dst_ip_choice.dst_ip_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.IpMatcherType)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &ReplaceSpecType_DstIpMatcher{msg}
		return true, err
	case 34: // asn_choice.any_asn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &ReplaceSpecType_AnyAsn{msg}
		return true, err
	case 35: // asn_choice.asn_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatchList)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &ReplaceSpecType_AsnList{msg}
		return true, err
	case 13: // asn_choice.asn_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatcherType)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &ReplaceSpecType_AsnMatcher{msg}
		return true, err
	case 51: // dst_asn_choice.any_dst_asn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &ReplaceSpecType_AnyDstAsn{msg}
		return true, err
	case 52: // dst_asn_choice.dst_asn_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatchList)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &ReplaceSpecType_DstAsnList{msg}
		return true, err
	case 53: // dst_asn_choice.dst_asn_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatcherType)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &ReplaceSpecType_DstAsnMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *ReplaceSpecType_AnyClient:
		s := proto.Size(x.AnyClient)
		n += proto.SizeVarint(37<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_ClientName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ClientName)))
		n += len(x.ClientName)
	case *ReplaceSpecType_ClientSelector:
		s := proto.Size(x.ClientSelector)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_ClientNameMatcher:
		s := proto.Size(x.ClientNameMatcher)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *ReplaceSpecType_AnyIp:
		s := proto.Size(x.AnyIp)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_IpPrefixList:
		s := proto.Size(x.IpPrefixList)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_IpMatcher:
		s := proto.Size(x.IpMatcher)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dst_ip_choice
	switch x := m.DstIpChoice.(type) {
	case *ReplaceSpecType_AnyDstIp:
		s := proto.Size(x.AnyDstIp)
		n += proto.SizeVarint(41<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DstIpPrefixList:
		s := proto.Size(x.DstIpPrefixList)
		n += proto.SizeVarint(42<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DstIpMatcher:
		s := proto.Size(x.DstIpMatcher)
		n += proto.SizeVarint(43<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *ReplaceSpecType_AnyAsn:
		s := proto.Size(x.AnyAsn)
		n += proto.SizeVarint(34<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_AsnList:
		s := proto.Size(x.AsnList)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_AsnMatcher:
		s := proto.Size(x.AsnMatcher)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dst_asn_choice
	switch x := m.DstAsnChoice.(type) {
	case *ReplaceSpecType_AnyDstAsn:
		s := proto.Size(x.AnyDstAsn)
		n += proto.SizeVarint(51<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DstAsnList:
		s := proto.Size(x.DstAsnList)
		n += proto.SizeVarint(52<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DstAsnMatcher:
		s := proto.Size(x.DstAsnMatcher)
		n += proto.SizeVarint(53<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get service policy rule
//
// x-displayName: "Get Service Policy Rule"
// Get service_policy_rule reads a given object from storage backend for metadata.namespace.
type GetSpecType struct {
	Action ves_io_schema_policy.RuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// Types that are valid to be assigned to ClientChoice:
	//	*GetSpecType_AnyClient
	//	*GetSpecType_ClientName
	//	*GetSpecType_ClientSelector
	//	*GetSpecType_ClientNameMatcher
	ClientChoice   isGetSpecType_ClientChoice                        `protobuf_oneof:"client_choice"`
	ClientRole     *ves_io_schema_policy.RoleMatcherType             `protobuf:"bytes,9,opt,name=client_role,json=clientRole" json:"client_role,omitempty"`
	ServerSelector *ves_io_schema4.LabelSelectorType                 `protobuf:"bytes,45,opt,name=server_selector,json=serverSelector" json:"server_selector,omitempty"`
	LabelMatcher   *ves_io_schema4.LabelMatcherType                  `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher" json:"label_matcher,omitempty"`
	Path           *ves_io_schema_policy.PathMatcherType             `protobuf:"bytes,5,opt,name=path" json:"path,omitempty"`
	Headers        []*ves_io_schema_policy.HeaderMatcherType         `protobuf:"bytes,6,rep,name=headers" json:"headers,omitempty"`
	QueryParams    []*ves_io_schema_policy.QueryParameterMatcherType `protobuf:"bytes,7,rep,name=query_params,json=queryParams" json:"query_params,omitempty"`
	HttpMethod     *ves_io_schema_policy.HttpMethodMatcherType       `protobuf:"bytes,8,opt,name=http_method,json=httpMethod" json:"http_method,omitempty"`
	// Types that are valid to be assigned to IpChoice:
	//	*GetSpecType_AnyIp
	//	*GetSpecType_IpPrefixList
	//	*GetSpecType_IpMatcher
	IpChoice isGetSpecType_IpChoice `protobuf_oneof:"ip_choice"`
	// Types that are valid to be assigned to DstIpChoice:
	//	*GetSpecType_AnyDstIp
	//	*GetSpecType_DstIpPrefixList
	//	*GetSpecType_DstIpMatcher
	DstIpChoice isGetSpecType_DstIpChoice `protobuf_oneof:"dst_ip_choice"`
	// Types that are valid to be assigned to AsnChoice:
	//	*GetSpecType_AnyAsn
	//	*GetSpecType_AsnList
	//	*GetSpecType_AsnMatcher
	AsnChoice isGetSpecType_AsnChoice `protobuf_oneof:"asn_choice"`
	// Types that are valid to be assigned to DstAsnChoice:
	//	*GetSpecType_AnyDstAsn
	//	*GetSpecType_DstAsnList
	//	*GetSpecType_DstAsnMatcher
	DstAsnChoice                  isGetSpecType_DstAsnChoice                      `protobuf_oneof:"dst_asn_choice"`
	ApiGroupMatcher               *ves_io_schema_policy.StringMatcherType         `protobuf:"bytes,14,opt,name=api_group_matcher,json=apiGroupMatcher" json:"api_group_matcher,omitempty"`
	PortMatcher                   *ves_io_schema_policy.PortMatcherType           `protobuf:"bytes,15,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
	ExpirationTimestamp           *google_protobuf1.Timestamp                     `protobuf:"bytes,16,opt,name=expiration_timestamp,json=expirationTimestamp" json:"expiration_timestamp,omitempty"`
	BodyMatcher                   *ves_io_schema_policy.MatcherType               `protobuf:"bytes,21,opt,name=body_matcher,json=bodyMatcher" json:"body_matcher,omitempty"`
	ArgMatchers                   []*ves_io_schema_policy.ArgMatcherType          `protobuf:"bytes,18,rep,name=arg_matchers,json=argMatchers" json:"arg_matchers,omitempty"`
	CookieMatchers                []*ves_io_schema_policy.CookieMatcherType       `protobuf:"bytes,19,rep,name=cookie_matchers,json=cookieMatchers" json:"cookie_matchers,omitempty"`
	WafAction                     *ves_io_schema_policy.WafAction                 `protobuf:"bytes,20,opt,name=waf_action,json=wafAction" json:"waf_action,omitempty"`
	DomainMatcher                 *ves_io_schema_policy.MatcherTypeBasic          `protobuf:"bytes,22,opt,name=domain_matcher,json=domainMatcher" json:"domain_matcher,omitempty"`
	RateLimiter                   []*ves_io_schema4.ObjectRefType                 `protobuf:"bytes,23,rep,name=rate_limiter,json=rateLimiter" json:"rate_limiter,omitempty"`
	VirtualHostMatcher            *ves_io_schema_policy.MatcherTypeBasic          `protobuf:"bytes,24,opt,name=virtual_host_matcher,json=virtualHostMatcher" json:"virtual_host_matcher,omitempty"`
	TlsFingerprintMatcher         *ves_io_schema_policy.TlsFingerprintMatcherType `protobuf:"bytes,25,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher" json:"tls_fingerprint_matcher,omitempty"`
	MaliciousUserMitigationBypass *ves_io_schema4.Empty                           `protobuf:"bytes,28,opt,name=malicious_user_mitigation_bypass,json=maliciousUserMitigationBypass" json:"malicious_user_mitigation_bypass,omitempty"`
	Scheme                        []string                                        `protobuf:"bytes,38,rep,name=scheme" json:"scheme,omitempty"`
	UrlMatcher                    *ves_io_schema_policy.URLMatcherType            `protobuf:"bytes,39,opt,name=url_matcher,json=urlMatcher" json:"url_matcher,omitempty"`
	L4DestMatcher                 *ves_io_schema_policy.L4DestMatcherType         `protobuf:"bytes,44,opt,name=l4_dest_matcher,json=l4DestMatcher" json:"l4_dest_matcher,omitempty"`
	ChallengeAction               ves_io_schema_policy.ChallengeAction            `protobuf:"varint,54,opt,name=challenge_action,json=challengeAction,proto3,enum=ves.io.schema.policy.ChallengeAction" json:"challenge_action,omitempty"`
	GotoPolicy                    []*ves_io_schema4.ObjectRefType                 `protobuf:"bytes,55,rep,name=goto_policy,json=gotoPolicy" json:"goto_policy,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

type isGetSpecType_ClientChoice interface {
	isGetSpecType_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_IpChoice interface {
	isGetSpecType_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_DstIpChoice interface {
	isGetSpecType_DstIpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_AsnChoice interface {
	isGetSpecType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_DstAsnChoice interface {
	isGetSpecType_DstAsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AnyClient struct {
	AnyClient *ves_io_schema4.Empty `protobuf:"bytes,37,opt,name=any_client,json=anyClient,oneof"`
}
type GetSpecType_ClientName struct {
	ClientName string `protobuf:"bytes,2,opt,name=client_name,json=clientName,proto3,oneof"`
}
type GetSpecType_ClientSelector struct {
	ClientSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,3,opt,name=client_selector,json=clientSelector,oneof"`
}
type GetSpecType_ClientNameMatcher struct {
	ClientNameMatcher *ves_io_schema_policy.MatcherTypeBasic `protobuf:"bytes,10,opt,name=client_name_matcher,json=clientNameMatcher,oneof"`
}
type GetSpecType_AnyIp struct {
	AnyIp *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,oneof"`
}
type GetSpecType_IpPrefixList struct {
	IpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,oneof"`
}
type GetSpecType_IpMatcher struct {
	IpMatcher *ves_io_schema_policy.IpMatcherType `protobuf:"bytes,12,opt,name=ip_matcher,json=ipMatcher,oneof"`
}
type GetSpecType_AnyDstIp struct {
	AnyDstIp *ves_io_schema4.Empty `protobuf:"bytes,41,opt,name=any_dst_ip,json=anyDstIp,oneof"`
}
type GetSpecType_DstIpPrefixList struct {
	DstIpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,42,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,oneof"`
}
type GetSpecType_DstIpMatcher struct {
	DstIpMatcher *ves_io_schema_policy.IpMatcherType `protobuf:"bytes,43,opt,name=dst_ip_matcher,json=dstIpMatcher,oneof"`
}
type GetSpecType_AnyAsn struct {
	AnyAsn *ves_io_schema4.Empty `protobuf:"bytes,34,opt,name=any_asn,json=anyAsn,oneof"`
}
type GetSpecType_AsnList struct {
	AsnList *ves_io_schema_policy.AsnMatchList `protobuf:"bytes,35,opt,name=asn_list,json=asnList,oneof"`
}
type GetSpecType_AsnMatcher struct {
	AsnMatcher *ves_io_schema_policy.AsnMatcherType `protobuf:"bytes,13,opt,name=asn_matcher,json=asnMatcher,oneof"`
}
type GetSpecType_AnyDstAsn struct {
	AnyDstAsn *ves_io_schema4.Empty `protobuf:"bytes,51,opt,name=any_dst_asn,json=anyDstAsn,oneof"`
}
type GetSpecType_DstAsnList struct {
	DstAsnList *ves_io_schema_policy.AsnMatchList `protobuf:"bytes,52,opt,name=dst_asn_list,json=dstAsnList,oneof"`
}
type GetSpecType_DstAsnMatcher struct {
	DstAsnMatcher *ves_io_schema_policy.AsnMatcherType `protobuf:"bytes,53,opt,name=dst_asn_matcher,json=dstAsnMatcher,oneof"`
}

func (*GetSpecType_AnyClient) isGetSpecType_ClientChoice()         {}
func (*GetSpecType_ClientName) isGetSpecType_ClientChoice()        {}
func (*GetSpecType_ClientSelector) isGetSpecType_ClientChoice()    {}
func (*GetSpecType_ClientNameMatcher) isGetSpecType_ClientChoice() {}
func (*GetSpecType_AnyIp) isGetSpecType_IpChoice()                 {}
func (*GetSpecType_IpPrefixList) isGetSpecType_IpChoice()          {}
func (*GetSpecType_IpMatcher) isGetSpecType_IpChoice()             {}
func (*GetSpecType_AnyDstIp) isGetSpecType_DstIpChoice()           {}
func (*GetSpecType_DstIpPrefixList) isGetSpecType_DstIpChoice()    {}
func (*GetSpecType_DstIpMatcher) isGetSpecType_DstIpChoice()       {}
func (*GetSpecType_AnyAsn) isGetSpecType_AsnChoice()               {}
func (*GetSpecType_AsnList) isGetSpecType_AsnChoice()              {}
func (*GetSpecType_AsnMatcher) isGetSpecType_AsnChoice()           {}
func (*GetSpecType_AnyDstAsn) isGetSpecType_DstAsnChoice()         {}
func (*GetSpecType_DstAsnList) isGetSpecType_DstAsnChoice()        {}
func (*GetSpecType_DstAsnMatcher) isGetSpecType_DstAsnChoice()     {}

func (m *GetSpecType) GetClientChoice() isGetSpecType_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}
func (m *GetSpecType) GetIpChoice() isGetSpecType_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *GetSpecType) GetDstIpChoice() isGetSpecType_DstIpChoice {
	if m != nil {
		return m.DstIpChoice
	}
	return nil
}
func (m *GetSpecType) GetAsnChoice() isGetSpecType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *GetSpecType) GetDstAsnChoice() isGetSpecType_DstAsnChoice {
	if m != nil {
		return m.DstAsnChoice
	}
	return nil
}

func (m *GetSpecType) GetAction() ves_io_schema_policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return ves_io_schema_policy.DENY
}

func (m *GetSpecType) GetAnyClient() *ves_io_schema4.Empty {
	if x, ok := m.GetClientChoice().(*GetSpecType_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *GetSpecType) GetClientName() string {
	if x, ok := m.GetClientChoice().(*GetSpecType_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *GetSpecType) GetClientSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*GetSpecType_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *GetSpecType) GetClientNameMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if x, ok := m.GetClientChoice().(*GetSpecType_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *GetSpecType) GetClientRole() *ves_io_schema_policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *GetSpecType) GetServerSelector() *ves_io_schema4.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *GetSpecType) GetLabelMatcher() *ves_io_schema4.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *GetSpecType) GetPath() *ves_io_schema_policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *GetSpecType) GetHeaders() []*ves_io_schema_policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GetSpecType) GetQueryParams() []*ves_io_schema_policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *GetSpecType) GetHttpMethod() *ves_io_schema_policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *GetSpecType) GetAnyIp() *ves_io_schema4.Empty {
	if x, ok := m.GetIpChoice().(*GetSpecType_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *GetSpecType) GetIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*GetSpecType_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *GetSpecType) GetIpMatcher() *ves_io_schema_policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*GetSpecType_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *GetSpecType) GetAnyDstIp() *ves_io_schema4.Empty {
	if x, ok := m.GetDstIpChoice().(*GetSpecType_AnyDstIp); ok {
		return x.AnyDstIp
	}
	return nil
}

func (m *GetSpecType) GetDstIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if x, ok := m.GetDstIpChoice().(*GetSpecType_DstIpPrefixList); ok {
		return x.DstIpPrefixList
	}
	return nil
}

func (m *GetSpecType) GetDstIpMatcher() *ves_io_schema_policy.IpMatcherType {
	if x, ok := m.GetDstIpChoice().(*GetSpecType_DstIpMatcher); ok {
		return x.DstIpMatcher
	}
	return nil
}

func (m *GetSpecType) GetAnyAsn() *ves_io_schema4.Empty {
	if x, ok := m.GetAsnChoice().(*GetSpecType_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *GetSpecType) GetAsnList() *ves_io_schema_policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*GetSpecType_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *GetSpecType) GetAsnMatcher() *ves_io_schema_policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*GetSpecType_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *GetSpecType) GetAnyDstAsn() *ves_io_schema4.Empty {
	if x, ok := m.GetDstAsnChoice().(*GetSpecType_AnyDstAsn); ok {
		return x.AnyDstAsn
	}
	return nil
}

func (m *GetSpecType) GetDstAsnList() *ves_io_schema_policy.AsnMatchList {
	if x, ok := m.GetDstAsnChoice().(*GetSpecType_DstAsnList); ok {
		return x.DstAsnList
	}
	return nil
}

func (m *GetSpecType) GetDstAsnMatcher() *ves_io_schema_policy.AsnMatcherType {
	if x, ok := m.GetDstAsnChoice().(*GetSpecType_DstAsnMatcher); ok {
		return x.DstAsnMatcher
	}
	return nil
}

func (m *GetSpecType) GetApiGroupMatcher() *ves_io_schema_policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *GetSpecType) GetPortMatcher() *ves_io_schema_policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GetSpecType) GetExpirationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *GetSpecType) GetBodyMatcher() *ves_io_schema_policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *GetSpecType) GetArgMatchers() []*ves_io_schema_policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *GetSpecType) GetCookieMatchers() []*ves_io_schema_policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *GetSpecType) GetWafAction() *ves_io_schema_policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *GetSpecType) GetDomainMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *GetSpecType) GetRateLimiter() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *GetSpecType) GetVirtualHostMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if m != nil {
		return m.VirtualHostMatcher
	}
	return nil
}

func (m *GetSpecType) GetTlsFingerprintMatcher() *ves_io_schema_policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *GetSpecType) GetMaliciousUserMitigationBypass() *ves_io_schema4.Empty {
	if m != nil {
		return m.MaliciousUserMitigationBypass
	}
	return nil
}

func (m *GetSpecType) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *GetSpecType) GetUrlMatcher() *ves_io_schema_policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *GetSpecType) GetL4DestMatcher() *ves_io_schema_policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *GetSpecType) GetChallengeAction() ves_io_schema_policy.ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return ves_io_schema_policy.DEFAULT_CHALLENGE
}

func (m *GetSpecType) GetGotoPolicy() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_AnyClient)(nil),
		(*GetSpecType_ClientName)(nil),
		(*GetSpecType_ClientSelector)(nil),
		(*GetSpecType_ClientNameMatcher)(nil),
		(*GetSpecType_AnyIp)(nil),
		(*GetSpecType_IpPrefixList)(nil),
		(*GetSpecType_IpMatcher)(nil),
		(*GetSpecType_AnyDstIp)(nil),
		(*GetSpecType_DstIpPrefixList)(nil),
		(*GetSpecType_DstIpMatcher)(nil),
		(*GetSpecType_AnyAsn)(nil),
		(*GetSpecType_AsnList)(nil),
		(*GetSpecType_AsnMatcher)(nil),
		(*GetSpecType_AnyDstAsn)(nil),
		(*GetSpecType_DstAsnList)(nil),
		(*GetSpecType_DstAsnMatcher)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *GetSpecType_AnyClient:
		_ = b.EncodeVarint(37<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyClient); err != nil {
			return err
		}
	case *GetSpecType_ClientName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ClientName)
	case *GetSpecType_ClientSelector:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientSelector); err != nil {
			return err
		}
	case *GetSpecType_ClientNameMatcher:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientNameMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.ClientChoice has unexpected type %T", x)
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *GetSpecType_AnyIp:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyIp); err != nil {
			return err
		}
	case *GetSpecType_IpPrefixList:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpPrefixList); err != nil {
			return err
		}
	case *GetSpecType_IpMatcher:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.IpChoice has unexpected type %T", x)
	}
	// dst_ip_choice
	switch x := m.DstIpChoice.(type) {
	case *GetSpecType_AnyDstIp:
		_ = b.EncodeVarint(41<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyDstIp); err != nil {
			return err
		}
	case *GetSpecType_DstIpPrefixList:
		_ = b.EncodeVarint(42<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstIpPrefixList); err != nil {
			return err
		}
	case *GetSpecType_DstIpMatcher:
		_ = b.EncodeVarint(43<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstIpMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.DstIpChoice has unexpected type %T", x)
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *GetSpecType_AnyAsn:
		_ = b.EncodeVarint(34<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyAsn); err != nil {
			return err
		}
	case *GetSpecType_AsnList:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnList); err != nil {
			return err
		}
	case *GetSpecType_AsnMatcher:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.AsnChoice has unexpected type %T", x)
	}
	// dst_asn_choice
	switch x := m.DstAsnChoice.(type) {
	case *GetSpecType_AnyDstAsn:
		_ = b.EncodeVarint(51<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyDstAsn); err != nil {
			return err
		}
	case *GetSpecType_DstAsnList:
		_ = b.EncodeVarint(52<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstAsnList); err != nil {
			return err
		}
	case *GetSpecType_DstAsnMatcher:
		_ = b.EncodeVarint(53<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstAsnMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.DstAsnChoice has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 37: // client_choice.any_client
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &GetSpecType_AnyClient{msg}
		return true, err
	case 2: // client_choice.client_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ClientChoice = &GetSpecType_ClientName{x}
		return true, err
	case 3: // client_choice.client_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &GetSpecType_ClientSelector{msg}
		return true, err
	case 10: // client_choice.client_name_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.MatcherTypeBasic)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &GetSpecType_ClientNameMatcher{msg}
		return true, err
	case 31: // ip_choice.any_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.IpChoice = &GetSpecType_AnyIp{msg}
		return true, err
	case 32: // ip_choice.ip_prefix_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.PrefixMatchList)
		err := b.DecodeMessage(msg)
		m.IpChoice = &GetSpecType_IpPrefixList{msg}
		return true, err
	case 12: // ip_choice.ip_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.IpMatcherType)
		err := b.DecodeMessage(msg)
		m.IpChoice = &GetSpecType_IpMatcher{msg}
		return true, err
	case 41: // dst_ip_choice.any_dst_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &GetSpecType_AnyDstIp{msg}
		return true, err
	case 42: // dst_ip_choice.dst_ip_prefix_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.PrefixMatchList)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &GetSpecType_DstIpPrefixList{msg}
		return true, err
	case 43: // dst_ip_choice.dst_ip_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.IpMatcherType)
		err := b.DecodeMessage(msg)
		m.DstIpChoice = &GetSpecType_DstIpMatcher{msg}
		return true, err
	case 34: // asn_choice.any_asn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &GetSpecType_AnyAsn{msg}
		return true, err
	case 35: // asn_choice.asn_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatchList)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &GetSpecType_AsnList{msg}
		return true, err
	case 13: // asn_choice.asn_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatcherType)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &GetSpecType_AsnMatcher{msg}
		return true, err
	case 51: // dst_asn_choice.any_dst_asn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &GetSpecType_AnyDstAsn{msg}
		return true, err
	case 52: // dst_asn_choice.dst_asn_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatchList)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &GetSpecType_DstAsnList{msg}
		return true, err
	case 53: // dst_asn_choice.dst_asn_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatcherType)
		err := b.DecodeMessage(msg)
		m.DstAsnChoice = &GetSpecType_DstAsnMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *GetSpecType_AnyClient:
		s := proto.Size(x.AnyClient)
		n += proto.SizeVarint(37<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_ClientName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ClientName)))
		n += len(x.ClientName)
	case *GetSpecType_ClientSelector:
		s := proto.Size(x.ClientSelector)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_ClientNameMatcher:
		s := proto.Size(x.ClientNameMatcher)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *GetSpecType_AnyIp:
		s := proto.Size(x.AnyIp)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_IpPrefixList:
		s := proto.Size(x.IpPrefixList)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_IpMatcher:
		s := proto.Size(x.IpMatcher)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dst_ip_choice
	switch x := m.DstIpChoice.(type) {
	case *GetSpecType_AnyDstIp:
		s := proto.Size(x.AnyDstIp)
		n += proto.SizeVarint(41<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DstIpPrefixList:
		s := proto.Size(x.DstIpPrefixList)
		n += proto.SizeVarint(42<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DstIpMatcher:
		s := proto.Size(x.DstIpMatcher)
		n += proto.SizeVarint(43<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *GetSpecType_AnyAsn:
		s := proto.Size(x.AnyAsn)
		n += proto.SizeVarint(34<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_AsnList:
		s := proto.Size(x.AsnList)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_AsnMatcher:
		s := proto.Size(x.AsnMatcher)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dst_asn_choice
	switch x := m.DstAsnChoice.(type) {
	case *GetSpecType_AnyDstAsn:
		s := proto.Size(x.AnyDstAsn)
		n += proto.SizeVarint(51<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DstAsnList:
		s := proto.Size(x.DstAsnList)
		n += proto.SizeVarint(52<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DstAsnMatcher:
		s := proto.Size(x.DstAsnMatcher)
		n += proto.SizeVarint(53<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Challenge Rule Spec
//
// x-displayName: "Challenge Rule Specification"
// A Challenge Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from
// or derived from an L7 request API. A request API is considered to match the rule if all predicates in the rule evaluate to true for that request. Any
// predicates that are not specified in a rule are implicitly considered to be true. If a request API matches a challenge rule, the configured challenge is
// enforced.
type ChallengeRuleSpec struct {
	// Select Action Type
	//
	// x-displayName: "Select Challenge Action Type"
	// x-required
	// Select challenge action, enable or disable challenge
	// When enabled, the challenge type selected in PolicyBasedChallenge
	// will be launched when match conditions in this challenge rule are met
	// When the challenge type selected in PolicyBasedChallenge is always enable JS/Captcha challenge,
	// the challenge can be disabled for certain requests which match the predicates defined in this rule
	// by setting the action to disable_challenge
	//
	// Types that are valid to be assigned to ChallengeAction:
	//	*ChallengeRuleSpec_DisableChallenge
	//	*ChallengeRuleSpec_EnableJavascriptChallenge
	//	*ChallengeRuleSpec_EnableCaptchaChallenge
	ChallengeAction isChallengeRuleSpec_ChallengeAction `protobuf_oneof:"challenge_action"`
	// Types that are valid to be assigned to IpChoice:
	//	*ChallengeRuleSpec_AnyIp
	//	*ChallengeRuleSpec_IpPrefixList
	//	*ChallengeRuleSpec_IpMatcher
	IpChoice isChallengeRuleSpec_IpChoice `protobuf_oneof:"ip_choice"`
	// Types that are valid to be assigned to AsnChoice:
	//	*ChallengeRuleSpec_AnyAsn
	//	*ChallengeRuleSpec_AsnList
	//	*ChallengeRuleSpec_AsnMatcher
	AsnChoice             isChallengeRuleSpec_AsnChoice                     `protobuf_oneof:"asn_choice"`
	DomainMatcher         *ves_io_schema_policy.MatcherTypeBasic            `protobuf:"bytes,5,opt,name=domain_matcher,json=domainMatcher" json:"domain_matcher,omitempty"`
	Path                  *ves_io_schema_policy.PathMatcherType             `protobuf:"bytes,6,opt,name=path" json:"path,omitempty"`
	Headers               []*ves_io_schema_policy.HeaderMatcherType         `protobuf:"bytes,7,rep,name=headers" json:"headers,omitempty"`
	HttpMethod            *ves_io_schema_policy.HttpMethodMatcherType       `protobuf:"bytes,8,opt,name=http_method,json=httpMethod" json:"http_method,omitempty"`
	TlsFingerprintMatcher *ves_io_schema_policy.TlsFingerprintMatcherType   `protobuf:"bytes,10,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher" json:"tls_fingerprint_matcher,omitempty"`
	QueryParams           []*ves_io_schema_policy.QueryParameterMatcherType `protobuf:"bytes,11,rep,name=query_params,json=queryParams" json:"query_params,omitempty"`
	BodyMatcher           *ves_io_schema_policy.MatcherType                 `protobuf:"bytes,12,opt,name=body_matcher,json=bodyMatcher" json:"body_matcher,omitempty"`
	ArgMatchers           []*ves_io_schema_policy.ArgMatcherType            `protobuf:"bytes,13,rep,name=arg_matchers,json=argMatchers" json:"arg_matchers,omitempty"`
	CookieMatchers        []*ves_io_schema_policy.CookieMatcherType         `protobuf:"bytes,14,rep,name=cookie_matchers,json=cookieMatchers" json:"cookie_matchers,omitempty"`
	// Types that are valid to be assigned to ClientChoice:
	//	*ChallengeRuleSpec_AnyClient
	//	*ChallengeRuleSpec_ClientName
	//	*ChallengeRuleSpec_ClientSelector
	//	*ChallengeRuleSpec_ClientNameMatcher
	ClientChoice        isChallengeRuleSpec_ClientChoice `protobuf_oneof:"client_choice"`
	ExpirationTimestamp *google_protobuf1.Timestamp      `protobuf:"bytes,20,opt,name=expiration_timestamp,json=expirationTimestamp" json:"expiration_timestamp,omitempty"`
}

func (m *ChallengeRuleSpec) Reset()                    { *m = ChallengeRuleSpec{} }
func (*ChallengeRuleSpec) ProtoMessage()               {}
func (*ChallengeRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isChallengeRuleSpec_ChallengeAction interface {
	isChallengeRuleSpec_ChallengeAction()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isChallengeRuleSpec_IpChoice interface {
	isChallengeRuleSpec_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isChallengeRuleSpec_AsnChoice interface {
	isChallengeRuleSpec_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isChallengeRuleSpec_ClientChoice interface {
	isChallengeRuleSpec_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ChallengeRuleSpec_DisableChallenge struct {
	DisableChallenge *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=disable_challenge,json=disableChallenge,oneof"`
}
type ChallengeRuleSpec_EnableJavascriptChallenge struct {
	EnableJavascriptChallenge *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=enable_javascript_challenge,json=enableJavascriptChallenge,oneof"`
}
type ChallengeRuleSpec_EnableCaptchaChallenge struct {
	EnableCaptchaChallenge *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=enable_captcha_challenge,json=enableCaptchaChallenge,oneof"`
}
type ChallengeRuleSpec_AnyIp struct {
	AnyIp *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,oneof"`
}
type ChallengeRuleSpec_IpPrefixList struct {
	IpPrefixList *ves_io_schema_policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,oneof"`
}
type ChallengeRuleSpec_IpMatcher struct {
	IpMatcher *ves_io_schema_policy.IpMatcherType `protobuf:"bytes,33,opt,name=ip_matcher,json=ipMatcher,oneof"`
}
type ChallengeRuleSpec_AnyAsn struct {
	AnyAsn *ves_io_schema4.Empty `protobuf:"bytes,41,opt,name=any_asn,json=anyAsn,oneof"`
}
type ChallengeRuleSpec_AsnList struct {
	AsnList *ves_io_schema_policy.AsnMatchList `protobuf:"bytes,42,opt,name=asn_list,json=asnList,oneof"`
}
type ChallengeRuleSpec_AsnMatcher struct {
	AsnMatcher *ves_io_schema_policy.AsnMatcherType `protobuf:"bytes,43,opt,name=asn_matcher,json=asnMatcher,oneof"`
}
type ChallengeRuleSpec_AnyClient struct {
	AnyClient *ves_io_schema4.Empty `protobuf:"bytes,16,opt,name=any_client,json=anyClient,oneof"`
}
type ChallengeRuleSpec_ClientName struct {
	ClientName string `protobuf:"bytes,17,opt,name=client_name,json=clientName,proto3,oneof"`
}
type ChallengeRuleSpec_ClientSelector struct {
	ClientSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,18,opt,name=client_selector,json=clientSelector,oneof"`
}
type ChallengeRuleSpec_ClientNameMatcher struct {
	ClientNameMatcher *ves_io_schema_policy.MatcherType `protobuf:"bytes,19,opt,name=client_name_matcher,json=clientNameMatcher,oneof"`
}

func (*ChallengeRuleSpec_DisableChallenge) isChallengeRuleSpec_ChallengeAction()          {}
func (*ChallengeRuleSpec_EnableJavascriptChallenge) isChallengeRuleSpec_ChallengeAction() {}
func (*ChallengeRuleSpec_EnableCaptchaChallenge) isChallengeRuleSpec_ChallengeAction()    {}
func (*ChallengeRuleSpec_AnyIp) isChallengeRuleSpec_IpChoice()                            {}
func (*ChallengeRuleSpec_IpPrefixList) isChallengeRuleSpec_IpChoice()                     {}
func (*ChallengeRuleSpec_IpMatcher) isChallengeRuleSpec_IpChoice()                        {}
func (*ChallengeRuleSpec_AnyAsn) isChallengeRuleSpec_AsnChoice()                          {}
func (*ChallengeRuleSpec_AsnList) isChallengeRuleSpec_AsnChoice()                         {}
func (*ChallengeRuleSpec_AsnMatcher) isChallengeRuleSpec_AsnChoice()                      {}
func (*ChallengeRuleSpec_AnyClient) isChallengeRuleSpec_ClientChoice()                    {}
func (*ChallengeRuleSpec_ClientName) isChallengeRuleSpec_ClientChoice()                   {}
func (*ChallengeRuleSpec_ClientSelector) isChallengeRuleSpec_ClientChoice()               {}
func (*ChallengeRuleSpec_ClientNameMatcher) isChallengeRuleSpec_ClientChoice()            {}

func (m *ChallengeRuleSpec) GetChallengeAction() isChallengeRuleSpec_ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return nil
}
func (m *ChallengeRuleSpec) GetIpChoice() isChallengeRuleSpec_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *ChallengeRuleSpec) GetAsnChoice() isChallengeRuleSpec_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *ChallengeRuleSpec) GetClientChoice() isChallengeRuleSpec_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}

func (m *ChallengeRuleSpec) GetDisableChallenge() *ves_io_schema4.Empty {
	if x, ok := m.GetChallengeAction().(*ChallengeRuleSpec_DisableChallenge); ok {
		return x.DisableChallenge
	}
	return nil
}

func (m *ChallengeRuleSpec) GetEnableJavascriptChallenge() *ves_io_schema4.Empty {
	if x, ok := m.GetChallengeAction().(*ChallengeRuleSpec_EnableJavascriptChallenge); ok {
		return x.EnableJavascriptChallenge
	}
	return nil
}

func (m *ChallengeRuleSpec) GetEnableCaptchaChallenge() *ves_io_schema4.Empty {
	if x, ok := m.GetChallengeAction().(*ChallengeRuleSpec_EnableCaptchaChallenge); ok {
		return x.EnableCaptchaChallenge
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAnyIp() *ves_io_schema4.Empty {
	if x, ok := m.GetIpChoice().(*ChallengeRuleSpec_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *ChallengeRuleSpec) GetIpPrefixList() *ves_io_schema_policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*ChallengeRuleSpec_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *ChallengeRuleSpec) GetIpMatcher() *ves_io_schema_policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*ChallengeRuleSpec_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAnyAsn() *ves_io_schema4.Empty {
	if x, ok := m.GetAsnChoice().(*ChallengeRuleSpec_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAsnList() *ves_io_schema_policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*ChallengeRuleSpec_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAsnMatcher() *ves_io_schema_policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*ChallengeRuleSpec_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetDomainMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetPath() *ves_io_schema_policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *ChallengeRuleSpec) GetHeaders() []*ves_io_schema_policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *ChallengeRuleSpec) GetHttpMethod() *ves_io_schema_policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *ChallengeRuleSpec) GetTlsFingerprintMatcher() *ves_io_schema_policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetQueryParams() []*ves_io_schema_policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *ChallengeRuleSpec) GetBodyMatcher() *ves_io_schema_policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetArgMatchers() []*ves_io_schema_policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *ChallengeRuleSpec) GetCookieMatchers() []*ves_io_schema_policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAnyClient() *ves_io_schema4.Empty {
	if x, ok := m.GetClientChoice().(*ChallengeRuleSpec_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *ChallengeRuleSpec) GetClientName() string {
	if x, ok := m.GetClientChoice().(*ChallengeRuleSpec_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *ChallengeRuleSpec) GetClientSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*ChallengeRuleSpec_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *ChallengeRuleSpec) GetClientNameMatcher() *ves_io_schema_policy.MatcherType {
	if x, ok := m.GetClientChoice().(*ChallengeRuleSpec_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetExpirationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ChallengeRuleSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ChallengeRuleSpec_OneofMarshaler, _ChallengeRuleSpec_OneofUnmarshaler, _ChallengeRuleSpec_OneofSizer, []interface{}{
		(*ChallengeRuleSpec_DisableChallenge)(nil),
		(*ChallengeRuleSpec_EnableJavascriptChallenge)(nil),
		(*ChallengeRuleSpec_EnableCaptchaChallenge)(nil),
		(*ChallengeRuleSpec_AnyIp)(nil),
		(*ChallengeRuleSpec_IpPrefixList)(nil),
		(*ChallengeRuleSpec_IpMatcher)(nil),
		(*ChallengeRuleSpec_AnyAsn)(nil),
		(*ChallengeRuleSpec_AsnList)(nil),
		(*ChallengeRuleSpec_AsnMatcher)(nil),
		(*ChallengeRuleSpec_AnyClient)(nil),
		(*ChallengeRuleSpec_ClientName)(nil),
		(*ChallengeRuleSpec_ClientSelector)(nil),
		(*ChallengeRuleSpec_ClientNameMatcher)(nil),
	}
}

func _ChallengeRuleSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ChallengeRuleSpec)
	// challenge_action
	switch x := m.ChallengeAction.(type) {
	case *ChallengeRuleSpec_DisableChallenge:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DisableChallenge); err != nil {
			return err
		}
	case *ChallengeRuleSpec_EnableJavascriptChallenge:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableJavascriptChallenge); err != nil {
			return err
		}
	case *ChallengeRuleSpec_EnableCaptchaChallenge:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableCaptchaChallenge); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ChallengeRuleSpec.ChallengeAction has unexpected type %T", x)
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *ChallengeRuleSpec_AnyIp:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyIp); err != nil {
			return err
		}
	case *ChallengeRuleSpec_IpPrefixList:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpPrefixList); err != nil {
			return err
		}
	case *ChallengeRuleSpec_IpMatcher:
		_ = b.EncodeVarint(33<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ChallengeRuleSpec.IpChoice has unexpected type %T", x)
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *ChallengeRuleSpec_AnyAsn:
		_ = b.EncodeVarint(41<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyAsn); err != nil {
			return err
		}
	case *ChallengeRuleSpec_AsnList:
		_ = b.EncodeVarint(42<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnList); err != nil {
			return err
		}
	case *ChallengeRuleSpec_AsnMatcher:
		_ = b.EncodeVarint(43<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AsnMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ChallengeRuleSpec.AsnChoice has unexpected type %T", x)
	}
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *ChallengeRuleSpec_AnyClient:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyClient); err != nil {
			return err
		}
	case *ChallengeRuleSpec_ClientName:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ClientName)
	case *ChallengeRuleSpec_ClientSelector:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientSelector); err != nil {
			return err
		}
	case *ChallengeRuleSpec_ClientNameMatcher:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClientNameMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ChallengeRuleSpec.ClientChoice has unexpected type %T", x)
	}
	return nil
}

func _ChallengeRuleSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ChallengeRuleSpec)
	switch tag {
	case 2: // challenge_action.disable_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ChallengeAction = &ChallengeRuleSpec_DisableChallenge{msg}
		return true, err
	case 3: // challenge_action.enable_javascript_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ChallengeAction = &ChallengeRuleSpec_EnableJavascriptChallenge{msg}
		return true, err
	case 4: // challenge_action.enable_captcha_challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ChallengeAction = &ChallengeRuleSpec_EnableCaptchaChallenge{msg}
		return true, err
	case 31: // ip_choice.any_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.IpChoice = &ChallengeRuleSpec_AnyIp{msg}
		return true, err
	case 32: // ip_choice.ip_prefix_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.PrefixMatchList)
		err := b.DecodeMessage(msg)
		m.IpChoice = &ChallengeRuleSpec_IpPrefixList{msg}
		return true, err
	case 33: // ip_choice.ip_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.IpMatcherType)
		err := b.DecodeMessage(msg)
		m.IpChoice = &ChallengeRuleSpec_IpMatcher{msg}
		return true, err
	case 41: // asn_choice.any_asn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &ChallengeRuleSpec_AnyAsn{msg}
		return true, err
	case 42: // asn_choice.asn_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatchList)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &ChallengeRuleSpec_AsnList{msg}
		return true, err
	case 43: // asn_choice.asn_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.AsnMatcherType)
		err := b.DecodeMessage(msg)
		m.AsnChoice = &ChallengeRuleSpec_AsnMatcher{msg}
		return true, err
	case 16: // client_choice.any_client
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &ChallengeRuleSpec_AnyClient{msg}
		return true, err
	case 17: // client_choice.client_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ClientChoice = &ChallengeRuleSpec_ClientName{x}
		return true, err
	case 18: // client_choice.client_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &ChallengeRuleSpec_ClientSelector{msg}
		return true, err
	case 19: // client_choice.client_name_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_policy.MatcherType)
		err := b.DecodeMessage(msg)
		m.ClientChoice = &ChallengeRuleSpec_ClientNameMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ChallengeRuleSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ChallengeRuleSpec)
	// challenge_action
	switch x := m.ChallengeAction.(type) {
	case *ChallengeRuleSpec_DisableChallenge:
		s := proto.Size(x.DisableChallenge)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ChallengeRuleSpec_EnableJavascriptChallenge:
		s := proto.Size(x.EnableJavascriptChallenge)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ChallengeRuleSpec_EnableCaptchaChallenge:
		s := proto.Size(x.EnableCaptchaChallenge)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// ip_choice
	switch x := m.IpChoice.(type) {
	case *ChallengeRuleSpec_AnyIp:
		s := proto.Size(x.AnyIp)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ChallengeRuleSpec_IpPrefixList:
		s := proto.Size(x.IpPrefixList)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ChallengeRuleSpec_IpMatcher:
		s := proto.Size(x.IpMatcher)
		n += proto.SizeVarint(33<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// asn_choice
	switch x := m.AsnChoice.(type) {
	case *ChallengeRuleSpec_AnyAsn:
		s := proto.Size(x.AnyAsn)
		n += proto.SizeVarint(41<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ChallengeRuleSpec_AsnList:
		s := proto.Size(x.AsnList)
		n += proto.SizeVarint(42<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ChallengeRuleSpec_AsnMatcher:
		s := proto.Size(x.AsnMatcher)
		n += proto.SizeVarint(43<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// client_choice
	switch x := m.ClientChoice.(type) {
	case *ChallengeRuleSpec_AnyClient:
		s := proto.Size(x.AnyClient)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ChallengeRuleSpec_ClientName:
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ClientName)))
		n += len(x.ClientName)
	case *ChallengeRuleSpec_ClientSelector:
		s := proto.Size(x.ClientSelector)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ChallengeRuleSpec_ClientNameMatcher:
		s := proto.Size(x.ClientNameMatcher)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Rate Limiter Rule Spec
//
// x-displayName: "Rate Limiter Rule Specification"
// Shape of Rate Limiter Rule
type RateLimiterRuleSpec struct {
	// action choice
	//
	// x-displayName: "Action"
	// x-required
	// Specify action for the rule.
	//
	// Types that are valid to be assigned to ActionChoice:
	//	*RateLimiterRuleSpec_BypassRateLimiter
	//	*RateLimiterRuleSpec_ApplyRateLimiter
	//	*RateLimiterRuleSpec_CustomRateLimiter
	ActionChoice  isRateLimiterRuleSpec_ActionChoice          `protobuf_oneof:"action_choice"`
	HttpMethod    *ves_io_schema_policy.HttpMethodMatcherType `protobuf:"bytes,6,opt,name=http_method,json=httpMethod" json:"http_method,omitempty"`
	DomainMatcher *ves_io_schema_policy.MatcherTypeBasic      `protobuf:"bytes,10,opt,name=domain_matcher,json=domainMatcher" json:"domain_matcher,omitempty"`
	Path          *ves_io_schema_policy.PathMatcherType       `protobuf:"bytes,8,opt,name=path" json:"path,omitempty"`
	Headers       []*ves_io_schema_policy.HeaderMatcherType   `protobuf:"bytes,9,rep,name=headers" json:"headers,omitempty"`
}

func (m *RateLimiterRuleSpec) Reset()                    { *m = RateLimiterRuleSpec{} }
func (*RateLimiterRuleSpec) ProtoMessage()               {}
func (*RateLimiterRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

type isRateLimiterRuleSpec_ActionChoice interface {
	isRateLimiterRuleSpec_ActionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RateLimiterRuleSpec_BypassRateLimiter struct {
	BypassRateLimiter *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=bypass_rate_limiter,json=bypassRateLimiter,oneof"`
}
type RateLimiterRuleSpec_ApplyRateLimiter struct {
	ApplyRateLimiter *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=apply_rate_limiter,json=applyRateLimiter,oneof"`
}
type RateLimiterRuleSpec_CustomRateLimiter struct {
	CustomRateLimiter *ves_io_schema_views.ObjectRefType `protobuf:"bytes,5,opt,name=custom_rate_limiter,json=customRateLimiter,oneof"`
}

func (*RateLimiterRuleSpec_BypassRateLimiter) isRateLimiterRuleSpec_ActionChoice() {}
func (*RateLimiterRuleSpec_ApplyRateLimiter) isRateLimiterRuleSpec_ActionChoice()  {}
func (*RateLimiterRuleSpec_CustomRateLimiter) isRateLimiterRuleSpec_ActionChoice() {}

func (m *RateLimiterRuleSpec) GetActionChoice() isRateLimiterRuleSpec_ActionChoice {
	if m != nil {
		return m.ActionChoice
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetBypassRateLimiter() *ves_io_schema4.Empty {
	if x, ok := m.GetActionChoice().(*RateLimiterRuleSpec_BypassRateLimiter); ok {
		return x.BypassRateLimiter
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetApplyRateLimiter() *ves_io_schema4.Empty {
	if x, ok := m.GetActionChoice().(*RateLimiterRuleSpec_ApplyRateLimiter); ok {
		return x.ApplyRateLimiter
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetCustomRateLimiter() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetActionChoice().(*RateLimiterRuleSpec_CustomRateLimiter); ok {
		return x.CustomRateLimiter
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetHttpMethod() *ves_io_schema_policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetDomainMatcher() *ves_io_schema_policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetPath() *ves_io_schema_policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetHeaders() []*ves_io_schema_policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RateLimiterRuleSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RateLimiterRuleSpec_OneofMarshaler, _RateLimiterRuleSpec_OneofUnmarshaler, _RateLimiterRuleSpec_OneofSizer, []interface{}{
		(*RateLimiterRuleSpec_BypassRateLimiter)(nil),
		(*RateLimiterRuleSpec_ApplyRateLimiter)(nil),
		(*RateLimiterRuleSpec_CustomRateLimiter)(nil),
	}
}

func _RateLimiterRuleSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RateLimiterRuleSpec)
	// action_choice
	switch x := m.ActionChoice.(type) {
	case *RateLimiterRuleSpec_BypassRateLimiter:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BypassRateLimiter); err != nil {
			return err
		}
	case *RateLimiterRuleSpec_ApplyRateLimiter:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApplyRateLimiter); err != nil {
			return err
		}
	case *RateLimiterRuleSpec_CustomRateLimiter:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomRateLimiter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RateLimiterRuleSpec.ActionChoice has unexpected type %T", x)
	}
	return nil
}

func _RateLimiterRuleSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RateLimiterRuleSpec)
	switch tag {
	case 3: // action_choice.bypass_rate_limiter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ActionChoice = &RateLimiterRuleSpec_BypassRateLimiter{msg}
		return true, err
	case 4: // action_choice.apply_rate_limiter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ActionChoice = &RateLimiterRuleSpec_ApplyRateLimiter{msg}
		return true, err
	case 5: // action_choice.custom_rate_limiter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.ActionChoice = &RateLimiterRuleSpec_CustomRateLimiter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RateLimiterRuleSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RateLimiterRuleSpec)
	// action_choice
	switch x := m.ActionChoice.(type) {
	case *RateLimiterRuleSpec_BypassRateLimiter:
		s := proto.Size(x.BypassRateLimiter)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimiterRuleSpec_ApplyRateLimiter:
		s := proto.Size(x.ApplyRateLimiter)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimiterRuleSpec_CustomRateLimiter:
		s := proto.Size(x.CustomRateLimiter)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy_rule.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy_rule.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy_rule.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy_rule.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy_rule.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy_rule.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy_rule.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy_rule.GetSpecType")
	proto.RegisterType((*ChallengeRuleSpec)(nil), "ves.io.schema.service_policy_rule.ChallengeRuleSpec")
	golang_proto.RegisterType((*ChallengeRuleSpec)(nil), "ves.io.schema.service_policy_rule.ChallengeRuleSpec")
	proto.RegisterType((*RateLimiterRuleSpec)(nil), "ves.io.schema.service_policy_rule.RateLimiterRuleSpec")
	golang_proto.RegisterType((*RateLimiterRuleSpec)(nil), "ves.io.schema.service_policy_rule.RateLimiterRuleSpec")
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.DstIpChoice == nil {
		if this.DstIpChoice != nil {
			return false
		}
	} else if this.DstIpChoice == nil {
		return false
	} else if !this.DstIpChoice.Equal(that1.DstIpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if that1.DstAsnChoice == nil {
		if this.DstAsnChoice != nil {
			return false
		}
	} else if this.DstAsnChoice == nil {
		return false
	} else if !this.DstAsnChoice.Equal(that1.DstAsnChoice) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if !this.VirtualHostMatcher.Equal(that1.VirtualHostMatcher) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if len(this.ForwardingClass) != len(that1.ForwardingClass) {
		return false
	}
	for i := range this.ForwardingClass {
		if !this.ForwardingClass[i].Equal(that1.ForwardingClass[i]) {
			return false
		}
	}
	if !this.MaliciousUserMitigationBypass.Equal(that1.MaliciousUserMitigationBypass) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if this.ChallengeAction != that1.ChallengeAction {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyClient)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ClientName)
	if !ok {
		that2, ok := that.(GlobalSpecType_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *GlobalSpecType_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ClientSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ClientNameMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyIp)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IpPrefixList)
	if !ok {
		that2, ok := that.(GlobalSpecType_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IpMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AnyDstIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyDstIp)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyDstIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstIp.Equal(that1.AnyDstIp) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DstIpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DstIpPrefixList)
	if !ok {
		that2, ok := that.(GlobalSpecType_DstIpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DstIpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DstIpMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_DstIpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpMatcher.Equal(that1.DstIpMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyAsn)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AsnList)
	if !ok {
		that2, ok := that.(GlobalSpecType_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AsnMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AnyDstAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyDstAsn)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyDstAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstAsn.Equal(that1.AnyDstAsn) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DstAsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DstAsnList)
	if !ok {
		that2, ok := that.(GlobalSpecType_DstAsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnList.Equal(that1.DstAsnList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DstAsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DstAsnMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_DstAsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnMatcher.Equal(that1.DstAsnMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.DstIpChoice == nil {
		if this.DstIpChoice != nil {
			return false
		}
	} else if this.DstIpChoice == nil {
		return false
	} else if !this.DstIpChoice.Equal(that1.DstIpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if that1.DstAsnChoice == nil {
		if this.DstAsnChoice != nil {
			return false
		}
	} else if this.DstAsnChoice == nil {
		return false
	} else if !this.DstAsnChoice.Equal(that1.DstAsnChoice) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if !this.VirtualHostMatcher.Equal(that1.VirtualHostMatcher) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if !this.MaliciousUserMitigationBypass.Equal(that1.MaliciousUserMitigationBypass) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if this.ChallengeAction != that1.ChallengeAction {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyClient)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *CreateSpecType_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ClientName)
	if !ok {
		that2, ok := that.(CreateSpecType_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *CreateSpecType_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ClientSelector)
	if !ok {
		that2, ok := that.(CreateSpecType_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *CreateSpecType_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ClientNameMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyIp)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *CreateSpecType_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IpPrefixList)
	if !ok {
		that2, ok := that.(CreateSpecType_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *CreateSpecType_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IpMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyDstIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyDstIp)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyDstIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstIp.Equal(that1.AnyDstIp) {
		return false
	}
	return true
}
func (this *CreateSpecType_DstIpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DstIpPrefixList)
	if !ok {
		that2, ok := that.(CreateSpecType_DstIpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DstIpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DstIpMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_DstIpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpMatcher.Equal(that1.DstIpMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyAsn)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *CreateSpecType_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AsnList)
	if !ok {
		that2, ok := that.(CreateSpecType_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *CreateSpecType_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AsnMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyDstAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyDstAsn)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyDstAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstAsn.Equal(that1.AnyDstAsn) {
		return false
	}
	return true
}
func (this *CreateSpecType_DstAsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DstAsnList)
	if !ok {
		that2, ok := that.(CreateSpecType_DstAsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnList.Equal(that1.DstAsnList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DstAsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DstAsnMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_DstAsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnMatcher.Equal(that1.DstAsnMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.DstIpChoice == nil {
		if this.DstIpChoice != nil {
			return false
		}
	} else if this.DstIpChoice == nil {
		return false
	} else if !this.DstIpChoice.Equal(that1.DstIpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if that1.DstAsnChoice == nil {
		if this.DstAsnChoice != nil {
			return false
		}
	} else if this.DstAsnChoice == nil {
		return false
	} else if !this.DstAsnChoice.Equal(that1.DstAsnChoice) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if !this.VirtualHostMatcher.Equal(that1.VirtualHostMatcher) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if !this.MaliciousUserMitigationBypass.Equal(that1.MaliciousUserMitigationBypass) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if this.ChallengeAction != that1.ChallengeAction {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyClient)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ClientName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ClientSelector)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ClientNameMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyIp)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IpPrefixList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IpMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyDstIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyDstIp)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyDstIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstIp.Equal(that1.AnyDstIp) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DstIpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DstIpPrefixList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DstIpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DstIpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DstIpMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DstIpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpMatcher.Equal(that1.DstIpMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyAsn)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AsnList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AsnMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyDstAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyDstAsn)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyDstAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstAsn.Equal(that1.AnyDstAsn) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DstAsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DstAsnList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DstAsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnList.Equal(that1.DstAsnList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DstAsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DstAsnMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DstAsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnMatcher.Equal(that1.DstAsnMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.DstIpChoice == nil {
		if this.DstIpChoice != nil {
			return false
		}
	} else if this.DstIpChoice == nil {
		return false
	} else if !this.DstIpChoice.Equal(that1.DstIpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if that1.DstAsnChoice == nil {
		if this.DstAsnChoice != nil {
			return false
		}
	} else if this.DstAsnChoice == nil {
		return false
	} else if !this.DstAsnChoice.Equal(that1.DstAsnChoice) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if !this.VirtualHostMatcher.Equal(that1.VirtualHostMatcher) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if !this.MaliciousUserMitigationBypass.Equal(that1.MaliciousUserMitigationBypass) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if this.ChallengeAction != that1.ChallengeAction {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyClient)
	if !ok {
		that2, ok := that.(GetSpecType_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *GetSpecType_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ClientName)
	if !ok {
		that2, ok := that.(GetSpecType_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *GetSpecType_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ClientSelector)
	if !ok {
		that2, ok := that.(GetSpecType_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *GetSpecType_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ClientNameMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyIp)
	if !ok {
		that2, ok := that.(GetSpecType_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *GetSpecType_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IpPrefixList)
	if !ok {
		that2, ok := that.(GetSpecType_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *GetSpecType_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IpMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AnyDstIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyDstIp)
	if !ok {
		that2, ok := that.(GetSpecType_AnyDstIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstIp.Equal(that1.AnyDstIp) {
		return false
	}
	return true
}
func (this *GetSpecType_DstIpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DstIpPrefixList)
	if !ok {
		that2, ok := that.(GetSpecType_DstIpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	return true
}
func (this *GetSpecType_DstIpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DstIpMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_DstIpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpMatcher.Equal(that1.DstIpMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyAsn)
	if !ok {
		that2, ok := that.(GetSpecType_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *GetSpecType_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AsnList)
	if !ok {
		that2, ok := that.(GetSpecType_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *GetSpecType_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AsnMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AnyDstAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyDstAsn)
	if !ok {
		that2, ok := that.(GetSpecType_AnyDstAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstAsn.Equal(that1.AnyDstAsn) {
		return false
	}
	return true
}
func (this *GetSpecType_DstAsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DstAsnList)
	if !ok {
		that2, ok := that.(GetSpecType_DstAsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnList.Equal(that1.DstAsnList) {
		return false
	}
	return true
}
func (this *GetSpecType_DstAsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DstAsnMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_DstAsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnMatcher.Equal(that1.DstAsnMatcher) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ChallengeAction == nil {
		if this.ChallengeAction != nil {
			return false
		}
	} else if this.ChallengeAction == nil {
		return false
	} else if !this.ChallengeAction.Equal(that1.ChallengeAction) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_DisableChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_DisableChallenge)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_DisableChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableChallenge.Equal(that1.DisableChallenge) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_EnableJavascriptChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_EnableJavascriptChallenge)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_EnableJavascriptChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableJavascriptChallenge.Equal(that1.EnableJavascriptChallenge) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_EnableCaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_EnableCaptchaChallenge)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_EnableCaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableCaptchaChallenge.Equal(that1.EnableCaptchaChallenge) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AnyIp)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_IpPrefixList)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_IpMatcher)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AnyAsn)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AsnList)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AsnMatcher)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AnyClient)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_ClientName)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_ClientSelector)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_ClientNameMatcher)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *RateLimiterRuleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimiterRuleSpec)
	if !ok {
		that2, ok := that.(RateLimiterRuleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionChoice == nil {
		if this.ActionChoice != nil {
			return false
		}
	} else if this.ActionChoice == nil {
		return false
	} else if !this.ActionChoice.Equal(that1.ActionChoice) {
		return false
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	return true
}
func (this *RateLimiterRuleSpec_BypassRateLimiter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimiterRuleSpec_BypassRateLimiter)
	if !ok {
		that2, ok := that.(RateLimiterRuleSpec_BypassRateLimiter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BypassRateLimiter.Equal(that1.BypassRateLimiter) {
		return false
	}
	return true
}
func (this *RateLimiterRuleSpec_ApplyRateLimiter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimiterRuleSpec_ApplyRateLimiter)
	if !ok {
		that2, ok := that.(RateLimiterRuleSpec_ApplyRateLimiter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ApplyRateLimiter.Equal(that1.ApplyRateLimiter) {
		return false
	}
	return true
}
func (this *RateLimiterRuleSpec_CustomRateLimiter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimiterRuleSpec_CustomRateLimiter)
	if !ok {
		that2, ok := that.(RateLimiterRuleSpec_CustomRateLimiter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomRateLimiter.Equal(that1.CustomRateLimiter) {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 46)
	s = append(s, "&service_policy_rule.GlobalSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.DstIpChoice != nil {
		s = append(s, "DstIpChoice: "+fmt.Sprintf("%#v", this.DstIpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DstAsnChoice != nil {
		s = append(s, "DstAsnChoice: "+fmt.Sprintf("%#v", this.DstAsnChoice)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.VirtualHostMatcher != nil {
		s = append(s, "VirtualHostMatcher: "+fmt.Sprintf("%#v", this.VirtualHostMatcher)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.ForwardingClass != nil {
		s = append(s, "ForwardingClass: "+fmt.Sprintf("%#v", this.ForwardingClass)+",\n")
	}
	if this.MaliciousUserMitigationBypass != nil {
		s = append(s, "MaliciousUserMitigationBypass: "+fmt.Sprintf("%#v", this.MaliciousUserMitigationBypass)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AnyDstIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyDstIp{` +
		`AnyDstIp:` + fmt.Sprintf("%#v", this.AnyDstIp) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DstIpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_DstIpPrefixList{` +
		`DstIpPrefixList:` + fmt.Sprintf("%#v", this.DstIpPrefixList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DstIpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_DstIpMatcher{` +
		`DstIpMatcher:` + fmt.Sprintf("%#v", this.DstIpMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AnyDstAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyDstAsn{` +
		`AnyDstAsn:` + fmt.Sprintf("%#v", this.AnyDstAsn) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DstAsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_DstAsnList{` +
		`DstAsnList:` + fmt.Sprintf("%#v", this.DstAsnList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DstAsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_DstAsnMatcher{` +
		`DstAsnMatcher:` + fmt.Sprintf("%#v", this.DstAsnMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 45)
	s = append(s, "&service_policy_rule.CreateSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.DstIpChoice != nil {
		s = append(s, "DstIpChoice: "+fmt.Sprintf("%#v", this.DstIpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DstAsnChoice != nil {
		s = append(s, "DstAsnChoice: "+fmt.Sprintf("%#v", this.DstAsnChoice)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.VirtualHostMatcher != nil {
		s = append(s, "VirtualHostMatcher: "+fmt.Sprintf("%#v", this.VirtualHostMatcher)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.MaliciousUserMitigationBypass != nil {
		s = append(s, "MaliciousUserMitigationBypass: "+fmt.Sprintf("%#v", this.MaliciousUserMitigationBypass)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AnyDstIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyDstIp{` +
		`AnyDstIp:` + fmt.Sprintf("%#v", this.AnyDstIp) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DstIpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_DstIpPrefixList{` +
		`DstIpPrefixList:` + fmt.Sprintf("%#v", this.DstIpPrefixList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DstIpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_DstIpMatcher{` +
		`DstIpMatcher:` + fmt.Sprintf("%#v", this.DstIpMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AnyDstAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyDstAsn{` +
		`AnyDstAsn:` + fmt.Sprintf("%#v", this.AnyDstAsn) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DstAsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_DstAsnList{` +
		`DstAsnList:` + fmt.Sprintf("%#v", this.DstAsnList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DstAsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_DstAsnMatcher{` +
		`DstAsnMatcher:` + fmt.Sprintf("%#v", this.DstAsnMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 45)
	s = append(s, "&service_policy_rule.ReplaceSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.DstIpChoice != nil {
		s = append(s, "DstIpChoice: "+fmt.Sprintf("%#v", this.DstIpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DstAsnChoice != nil {
		s = append(s, "DstAsnChoice: "+fmt.Sprintf("%#v", this.DstAsnChoice)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.VirtualHostMatcher != nil {
		s = append(s, "VirtualHostMatcher: "+fmt.Sprintf("%#v", this.VirtualHostMatcher)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.MaliciousUserMitigationBypass != nil {
		s = append(s, "MaliciousUserMitigationBypass: "+fmt.Sprintf("%#v", this.MaliciousUserMitigationBypass)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AnyDstIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyDstIp{` +
		`AnyDstIp:` + fmt.Sprintf("%#v", this.AnyDstIp) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DstIpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_DstIpPrefixList{` +
		`DstIpPrefixList:` + fmt.Sprintf("%#v", this.DstIpPrefixList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DstIpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_DstIpMatcher{` +
		`DstIpMatcher:` + fmt.Sprintf("%#v", this.DstIpMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AnyDstAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyDstAsn{` +
		`AnyDstAsn:` + fmt.Sprintf("%#v", this.AnyDstAsn) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DstAsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_DstAsnList{` +
		`DstAsnList:` + fmt.Sprintf("%#v", this.DstAsnList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DstAsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_DstAsnMatcher{` +
		`DstAsnMatcher:` + fmt.Sprintf("%#v", this.DstAsnMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 45)
	s = append(s, "&service_policy_rule.GetSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.DstIpChoice != nil {
		s = append(s, "DstIpChoice: "+fmt.Sprintf("%#v", this.DstIpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DstAsnChoice != nil {
		s = append(s, "DstAsnChoice: "+fmt.Sprintf("%#v", this.DstAsnChoice)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.VirtualHostMatcher != nil {
		s = append(s, "VirtualHostMatcher: "+fmt.Sprintf("%#v", this.VirtualHostMatcher)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.MaliciousUserMitigationBypass != nil {
		s = append(s, "MaliciousUserMitigationBypass: "+fmt.Sprintf("%#v", this.MaliciousUserMitigationBypass)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AnyDstIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyDstIp{` +
		`AnyDstIp:` + fmt.Sprintf("%#v", this.AnyDstIp) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DstIpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_DstIpPrefixList{` +
		`DstIpPrefixList:` + fmt.Sprintf("%#v", this.DstIpPrefixList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DstIpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_DstIpMatcher{` +
		`DstIpMatcher:` + fmt.Sprintf("%#v", this.DstIpMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AnyDstAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyDstAsn{` +
		`AnyDstAsn:` + fmt.Sprintf("%#v", this.AnyDstAsn) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DstAsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_DstAsnList{` +
		`DstAsnList:` + fmt.Sprintf("%#v", this.DstAsnList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DstAsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_DstAsnMatcher{` +
		`DstAsnMatcher:` + fmt.Sprintf("%#v", this.DstAsnMatcher) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 27)
	s = append(s, "&service_policy_rule.ChallengeRuleSpec{")
	if this.ChallengeAction != nil {
		s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChallengeRuleSpec_DisableChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_DisableChallenge{` +
		`DisableChallenge:` + fmt.Sprintf("%#v", this.DisableChallenge) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_EnableJavascriptChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_EnableJavascriptChallenge{` +
		`EnableJavascriptChallenge:` + fmt.Sprintf("%#v", this.EnableJavascriptChallenge) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_EnableCaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_EnableCaptchaChallenge{` +
		`EnableCaptchaChallenge:` + fmt.Sprintf("%#v", this.EnableCaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *RateLimiterRuleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&service_policy_rule.RateLimiterRuleSpec{")
	if this.ActionChoice != nil {
		s = append(s, "ActionChoice: "+fmt.Sprintf("%#v", this.ActionChoice)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RateLimiterRuleSpec_BypassRateLimiter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.RateLimiterRuleSpec_BypassRateLimiter{` +
		`BypassRateLimiter:` + fmt.Sprintf("%#v", this.BypassRateLimiter) + `}`}, ", ")
	return s
}
func (this *RateLimiterRuleSpec_ApplyRateLimiter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.RateLimiterRuleSpec_ApplyRateLimiter{` +
		`ApplyRateLimiter:` + fmt.Sprintf("%#v", this.ApplyRateLimiter) + `}`}, ", ")
	return s
}
func (this *RateLimiterRuleSpec_CustomRateLimiter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.RateLimiterRuleSpec_CustomRateLimiter{` +
		`CustomRateLimiter:` + fmt.Sprintf("%#v", this.CustomRateLimiter) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	if m.ClientChoice != nil {
		nn1, err := m.ClientChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.LabelMatcher != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LabelMatcher.Size()))
		n2, err := m.LabelMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Path != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Path.Size()))
		n3, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QueryParams) > 0 {
		for _, msg := range m.QueryParams {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HttpMethod != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod.Size()))
		n4, err := m.HttpMethod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ClientRole != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientRole.Size()))
		n5, err := m.ClientRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.IpChoice != nil {
		nn6, err := m.IpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if m.AsnChoice != nil {
		nn7, err := m.AsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if m.ApiGroupMatcher != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiGroupMatcher.Size()))
		n8, err := m.ApiGroupMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.PortMatcher != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortMatcher.Size()))
		n9, err := m.PortMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ExpirationTimestamp != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTimestamp.Size()))
		n10, err := m.ExpirationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.ArgMatchers) > 0 {
		for _, msg := range m.ArgMatchers {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, msg := range m.CookieMatchers {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WafAction != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafAction.Size()))
		n11, err := m.WafAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.BodyMatcher != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BodyMatcher.Size()))
		n12, err := m.BodyMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.DomainMatcher != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DomainMatcher.Size()))
		n13, err := m.DomainMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.RateLimiter) > 0 {
		for _, msg := range m.RateLimiter {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.VirtualHostMatcher != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VirtualHostMatcher.Size()))
		n14, err := m.VirtualHostMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.TlsFingerprintMatcher != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsFingerprintMatcher.Size()))
		n15, err := m.TlsFingerprintMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.ForwardingClass) > 0 {
		for _, msg := range m.ForwardingClass {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MaliciousUserMitigationBypass != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaliciousUserMitigationBypass.Size()))
		n16, err := m.MaliciousUserMitigationBypass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.UrlMatcher != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UrlMatcher.Size()))
		n17, err := m.UrlMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.DstIpChoice != nil {
		nn18, err := m.DstIpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn18
	}
	if m.L4DestMatcher != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.L4DestMatcher.Size()))
		n19, err := m.L4DestMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.ServerSelector != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerSelector.Size()))
		n20, err := m.ServerSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.DstAsnChoice != nil {
		nn21, err := m.DstAsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	if m.ChallengeAction != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, msg := range m.GotoPolicy {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GlobalSpecType_ClientName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i += copy(dAtA[i:], m.ClientName)
	return i, nil
}
func (m *GlobalSpecType_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientSelector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientSelector.Size()))
		n22, err := m.ClientSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *GlobalSpecType_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientNameMatcher != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientNameMatcher.Size()))
		n23, err := m.ClientNameMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *GlobalSpecType_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpMatcher != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpMatcher.Size()))
		n24, err := m.IpMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *GlobalSpecType_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnMatcher != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnMatcher.Size()))
		n25, err := m.AsnMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *GlobalSpecType_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyIp != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyIp.Size()))
		n26, err := m.AnyIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *GlobalSpecType_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpPrefixList != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixList.Size()))
		n27, err := m.IpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *GlobalSpecType_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyAsn != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyAsn.Size()))
		n28, err := m.AnyAsn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *GlobalSpecType_AsnList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnList != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnList.Size()))
		n29, err := m.AsnList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *GlobalSpecType_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyClient != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyClient.Size()))
		n30, err := m.AnyClient.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *GlobalSpecType_AnyDstIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyDstIp != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyDstIp.Size()))
		n31, err := m.AnyDstIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *GlobalSpecType_DstIpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstIpPrefixList != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIpPrefixList.Size()))
		n32, err := m.DstIpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *GlobalSpecType_DstIpMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstIpMatcher != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIpMatcher.Size()))
		n33, err := m.DstIpMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *GlobalSpecType_AnyDstAsn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyDstAsn != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyDstAsn.Size()))
		n34, err := m.AnyDstAsn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *GlobalSpecType_DstAsnList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstAsnList != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstAsnList.Size()))
		n35, err := m.DstAsnList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *GlobalSpecType_DstAsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstAsnMatcher != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstAsnMatcher.Size()))
		n36, err := m.DstAsnMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	if m.ClientChoice != nil {
		nn37, err := m.ClientChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn37
	}
	if m.LabelMatcher != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LabelMatcher.Size()))
		n38, err := m.LabelMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Path != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Path.Size()))
		n39, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QueryParams) > 0 {
		for _, msg := range m.QueryParams {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HttpMethod != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod.Size()))
		n40, err := m.HttpMethod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.ClientRole != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientRole.Size()))
		n41, err := m.ClientRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.IpChoice != nil {
		nn42, err := m.IpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn42
	}
	if m.AsnChoice != nil {
		nn43, err := m.AsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn43
	}
	if m.ApiGroupMatcher != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiGroupMatcher.Size()))
		n44, err := m.ApiGroupMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.PortMatcher != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortMatcher.Size()))
		n45, err := m.PortMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.ExpirationTimestamp != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTimestamp.Size()))
		n46, err := m.ExpirationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.ArgMatchers) > 0 {
		for _, msg := range m.ArgMatchers {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, msg := range m.CookieMatchers {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WafAction != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafAction.Size()))
		n47, err := m.WafAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.BodyMatcher != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BodyMatcher.Size()))
		n48, err := m.BodyMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.DomainMatcher != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DomainMatcher.Size()))
		n49, err := m.DomainMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if len(m.RateLimiter) > 0 {
		for _, msg := range m.RateLimiter {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.VirtualHostMatcher != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VirtualHostMatcher.Size()))
		n50, err := m.VirtualHostMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.TlsFingerprintMatcher != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsFingerprintMatcher.Size()))
		n51, err := m.TlsFingerprintMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.MaliciousUserMitigationBypass != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaliciousUserMitigationBypass.Size()))
		n52, err := m.MaliciousUserMitigationBypass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.UrlMatcher != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UrlMatcher.Size()))
		n53, err := m.UrlMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.DstIpChoice != nil {
		nn54, err := m.DstIpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn54
	}
	if m.L4DestMatcher != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.L4DestMatcher.Size()))
		n55, err := m.L4DestMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.ServerSelector != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerSelector.Size()))
		n56, err := m.ServerSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.DstAsnChoice != nil {
		nn57, err := m.DstAsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn57
	}
	if m.ChallengeAction != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, msg := range m.GotoPolicy {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateSpecType_ClientName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i += copy(dAtA[i:], m.ClientName)
	return i, nil
}
func (m *CreateSpecType_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientSelector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientSelector.Size()))
		n58, err := m.ClientSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}
func (m *CreateSpecType_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientNameMatcher != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientNameMatcher.Size()))
		n59, err := m.ClientNameMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}
func (m *CreateSpecType_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpMatcher != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpMatcher.Size()))
		n60, err := m.IpMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}
func (m *CreateSpecType_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnMatcher != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnMatcher.Size()))
		n61, err := m.AsnMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}
func (m *CreateSpecType_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyIp != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyIp.Size()))
		n62, err := m.AnyIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}
func (m *CreateSpecType_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpPrefixList != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixList.Size()))
		n63, err := m.IpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}
func (m *CreateSpecType_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyAsn != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyAsn.Size()))
		n64, err := m.AnyAsn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}
func (m *CreateSpecType_AsnList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnList != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnList.Size()))
		n65, err := m.AsnList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}
func (m *CreateSpecType_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyClient != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyClient.Size()))
		n66, err := m.AnyClient.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	return i, nil
}
func (m *CreateSpecType_AnyDstIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyDstIp != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyDstIp.Size()))
		n67, err := m.AnyDstIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}
func (m *CreateSpecType_DstIpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstIpPrefixList != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIpPrefixList.Size()))
		n68, err := m.DstIpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}
func (m *CreateSpecType_DstIpMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstIpMatcher != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIpMatcher.Size()))
		n69, err := m.DstIpMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}
func (m *CreateSpecType_AnyDstAsn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyDstAsn != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyDstAsn.Size()))
		n70, err := m.AnyDstAsn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}
func (m *CreateSpecType_DstAsnList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstAsnList != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstAsnList.Size()))
		n71, err := m.DstAsnList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}
func (m *CreateSpecType_DstAsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstAsnMatcher != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstAsnMatcher.Size()))
		n72, err := m.DstAsnMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	if m.ClientChoice != nil {
		nn73, err := m.ClientChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn73
	}
	if m.LabelMatcher != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LabelMatcher.Size()))
		n74, err := m.LabelMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.Path != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Path.Size()))
		n75, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QueryParams) > 0 {
		for _, msg := range m.QueryParams {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HttpMethod != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod.Size()))
		n76, err := m.HttpMethod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if m.ClientRole != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientRole.Size()))
		n77, err := m.ClientRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if m.IpChoice != nil {
		nn78, err := m.IpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn78
	}
	if m.AsnChoice != nil {
		nn79, err := m.AsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn79
	}
	if m.ApiGroupMatcher != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiGroupMatcher.Size()))
		n80, err := m.ApiGroupMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.PortMatcher != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortMatcher.Size()))
		n81, err := m.PortMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.ExpirationTimestamp != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTimestamp.Size()))
		n82, err := m.ExpirationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if len(m.ArgMatchers) > 0 {
		for _, msg := range m.ArgMatchers {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, msg := range m.CookieMatchers {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WafAction != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafAction.Size()))
		n83, err := m.WafAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	if m.BodyMatcher != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BodyMatcher.Size()))
		n84, err := m.BodyMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if m.DomainMatcher != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DomainMatcher.Size()))
		n85, err := m.DomainMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if len(m.RateLimiter) > 0 {
		for _, msg := range m.RateLimiter {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.VirtualHostMatcher != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VirtualHostMatcher.Size()))
		n86, err := m.VirtualHostMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if m.TlsFingerprintMatcher != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsFingerprintMatcher.Size()))
		n87, err := m.TlsFingerprintMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.MaliciousUserMitigationBypass != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaliciousUserMitigationBypass.Size()))
		n88, err := m.MaliciousUserMitigationBypass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.UrlMatcher != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UrlMatcher.Size()))
		n89, err := m.UrlMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if m.DstIpChoice != nil {
		nn90, err := m.DstIpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn90
	}
	if m.L4DestMatcher != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.L4DestMatcher.Size()))
		n91, err := m.L4DestMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if m.ServerSelector != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerSelector.Size()))
		n92, err := m.ServerSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.DstAsnChoice != nil {
		nn93, err := m.DstAsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn93
	}
	if m.ChallengeAction != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, msg := range m.GotoPolicy {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplaceSpecType_ClientName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i += copy(dAtA[i:], m.ClientName)
	return i, nil
}
func (m *ReplaceSpecType_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientSelector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientSelector.Size()))
		n94, err := m.ClientSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	return i, nil
}
func (m *ReplaceSpecType_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientNameMatcher != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientNameMatcher.Size()))
		n95, err := m.ClientNameMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	return i, nil
}
func (m *ReplaceSpecType_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpMatcher != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpMatcher.Size()))
		n96, err := m.IpMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	return i, nil
}
func (m *ReplaceSpecType_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnMatcher != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnMatcher.Size()))
		n97, err := m.AsnMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	return i, nil
}
func (m *ReplaceSpecType_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyIp != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyIp.Size()))
		n98, err := m.AnyIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	return i, nil
}
func (m *ReplaceSpecType_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpPrefixList != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixList.Size()))
		n99, err := m.IpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	return i, nil
}
func (m *ReplaceSpecType_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyAsn != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyAsn.Size()))
		n100, err := m.AnyAsn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n100
	}
	return i, nil
}
func (m *ReplaceSpecType_AsnList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnList != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnList.Size()))
		n101, err := m.AsnList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	return i, nil
}
func (m *ReplaceSpecType_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyClient != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyClient.Size()))
		n102, err := m.AnyClient.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n102
	}
	return i, nil
}
func (m *ReplaceSpecType_AnyDstIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyDstIp != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyDstIp.Size()))
		n103, err := m.AnyDstIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	return i, nil
}
func (m *ReplaceSpecType_DstIpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstIpPrefixList != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIpPrefixList.Size()))
		n104, err := m.DstIpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	return i, nil
}
func (m *ReplaceSpecType_DstIpMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstIpMatcher != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIpMatcher.Size()))
		n105, err := m.DstIpMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	return i, nil
}
func (m *ReplaceSpecType_AnyDstAsn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyDstAsn != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyDstAsn.Size()))
		n106, err := m.AnyDstAsn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	return i, nil
}
func (m *ReplaceSpecType_DstAsnList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstAsnList != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstAsnList.Size()))
		n107, err := m.DstAsnList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n107
	}
	return i, nil
}
func (m *ReplaceSpecType_DstAsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstAsnMatcher != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstAsnMatcher.Size()))
		n108, err := m.DstAsnMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n108
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
	}
	if m.ClientChoice != nil {
		nn109, err := m.ClientChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn109
	}
	if m.LabelMatcher != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LabelMatcher.Size()))
		n110, err := m.LabelMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	if m.Path != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Path.Size()))
		n111, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QueryParams) > 0 {
		for _, msg := range m.QueryParams {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HttpMethod != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod.Size()))
		n112, err := m.HttpMethod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n112
	}
	if m.ClientRole != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientRole.Size()))
		n113, err := m.ClientRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n113
	}
	if m.IpChoice != nil {
		nn114, err := m.IpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn114
	}
	if m.AsnChoice != nil {
		nn115, err := m.AsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn115
	}
	if m.ApiGroupMatcher != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiGroupMatcher.Size()))
		n116, err := m.ApiGroupMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	if m.PortMatcher != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortMatcher.Size()))
		n117, err := m.PortMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n117
	}
	if m.ExpirationTimestamp != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTimestamp.Size()))
		n118, err := m.ExpirationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n118
	}
	if len(m.ArgMatchers) > 0 {
		for _, msg := range m.ArgMatchers {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, msg := range m.CookieMatchers {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WafAction != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WafAction.Size()))
		n119, err := m.WafAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n119
	}
	if m.BodyMatcher != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BodyMatcher.Size()))
		n120, err := m.BodyMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n120
	}
	if m.DomainMatcher != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DomainMatcher.Size()))
		n121, err := m.DomainMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n121
	}
	if len(m.RateLimiter) > 0 {
		for _, msg := range m.RateLimiter {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.VirtualHostMatcher != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VirtualHostMatcher.Size()))
		n122, err := m.VirtualHostMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n122
	}
	if m.TlsFingerprintMatcher != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsFingerprintMatcher.Size()))
		n123, err := m.TlsFingerprintMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n123
	}
	if m.MaliciousUserMitigationBypass != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MaliciousUserMitigationBypass.Size()))
		n124, err := m.MaliciousUserMitigationBypass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n124
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.UrlMatcher != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UrlMatcher.Size()))
		n125, err := m.UrlMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n125
	}
	if m.DstIpChoice != nil {
		nn126, err := m.DstIpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn126
	}
	if m.L4DestMatcher != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.L4DestMatcher.Size()))
		n127, err := m.L4DestMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n127
	}
	if m.ServerSelector != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerSelector.Size()))
		n128, err := m.ServerSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n128
	}
	if m.DstAsnChoice != nil {
		nn129, err := m.DstAsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn129
	}
	if m.ChallengeAction != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, msg := range m.GotoPolicy {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSpecType_ClientName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i += copy(dAtA[i:], m.ClientName)
	return i, nil
}
func (m *GetSpecType_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientSelector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientSelector.Size()))
		n130, err := m.ClientSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n130
	}
	return i, nil
}
func (m *GetSpecType_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientNameMatcher != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientNameMatcher.Size()))
		n131, err := m.ClientNameMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n131
	}
	return i, nil
}
func (m *GetSpecType_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpMatcher != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpMatcher.Size()))
		n132, err := m.IpMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n132
	}
	return i, nil
}
func (m *GetSpecType_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnMatcher != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnMatcher.Size()))
		n133, err := m.AsnMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n133
	}
	return i, nil
}
func (m *GetSpecType_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyIp != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyIp.Size()))
		n134, err := m.AnyIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n134
	}
	return i, nil
}
func (m *GetSpecType_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpPrefixList != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixList.Size()))
		n135, err := m.IpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n135
	}
	return i, nil
}
func (m *GetSpecType_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyAsn != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyAsn.Size()))
		n136, err := m.AnyAsn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n136
	}
	return i, nil
}
func (m *GetSpecType_AsnList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnList != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnList.Size()))
		n137, err := m.AsnList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n137
	}
	return i, nil
}
func (m *GetSpecType_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyClient != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyClient.Size()))
		n138, err := m.AnyClient.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n138
	}
	return i, nil
}
func (m *GetSpecType_AnyDstIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyDstIp != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyDstIp.Size()))
		n139, err := m.AnyDstIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n139
	}
	return i, nil
}
func (m *GetSpecType_DstIpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstIpPrefixList != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIpPrefixList.Size()))
		n140, err := m.DstIpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n140
	}
	return i, nil
}
func (m *GetSpecType_DstIpMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstIpMatcher != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIpMatcher.Size()))
		n141, err := m.DstIpMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n141
	}
	return i, nil
}
func (m *GetSpecType_AnyDstAsn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyDstAsn != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyDstAsn.Size()))
		n142, err := m.AnyDstAsn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n142
	}
	return i, nil
}
func (m *GetSpecType_DstAsnList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstAsnList != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstAsnList.Size()))
		n143, err := m.DstAsnList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n143
	}
	return i, nil
}
func (m *GetSpecType_DstAsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstAsnMatcher != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstAsnMatcher.Size()))
		n144, err := m.DstAsnMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n144
	}
	return i, nil
}
func (m *ChallengeRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChallengeAction != nil {
		nn145, err := m.ChallengeAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn145
	}
	if m.DomainMatcher != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DomainMatcher.Size()))
		n146, err := m.DomainMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n146
	}
	if m.Path != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Path.Size()))
		n147, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n147
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HttpMethod != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod.Size()))
		n148, err := m.HttpMethod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n148
	}
	if m.TlsFingerprintMatcher != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TlsFingerprintMatcher.Size()))
		n149, err := m.TlsFingerprintMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n149
	}
	if len(m.QueryParams) > 0 {
		for _, msg := range m.QueryParams {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BodyMatcher != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BodyMatcher.Size()))
		n150, err := m.BodyMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n150
	}
	if len(m.ArgMatchers) > 0 {
		for _, msg := range m.ArgMatchers {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, msg := range m.CookieMatchers {
			dAtA[i] = 0x72
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ClientChoice != nil {
		nn151, err := m.ClientChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn151
	}
	if m.ExpirationTimestamp != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTimestamp.Size()))
		n152, err := m.ExpirationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n152
	}
	if m.IpChoice != nil {
		nn153, err := m.IpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn153
	}
	if m.AsnChoice != nil {
		nn154, err := m.AsnChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn154
	}
	return i, nil
}

func (m *ChallengeRuleSpec_DisableChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DisableChallenge != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DisableChallenge.Size()))
		n155, err := m.DisableChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n155
	}
	return i, nil
}
func (m *ChallengeRuleSpec_EnableJavascriptChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableJavascriptChallenge != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EnableJavascriptChallenge.Size()))
		n156, err := m.EnableJavascriptChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n156
	}
	return i, nil
}
func (m *ChallengeRuleSpec_EnableCaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableCaptchaChallenge != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EnableCaptchaChallenge.Size()))
		n157, err := m.EnableCaptchaChallenge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n157
	}
	return i, nil
}
func (m *ChallengeRuleSpec_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyClient != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyClient.Size()))
		n158, err := m.AnyClient.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n158
	}
	return i, nil
}
func (m *ChallengeRuleSpec_ClientName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i += copy(dAtA[i:], m.ClientName)
	return i, nil
}
func (m *ChallengeRuleSpec_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientSelector != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientSelector.Size()))
		n159, err := m.ClientSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n159
	}
	return i, nil
}
func (m *ChallengeRuleSpec_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClientNameMatcher != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientNameMatcher.Size()))
		n160, err := m.ClientNameMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n160
	}
	return i, nil
}
func (m *ChallengeRuleSpec_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyIp != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyIp.Size()))
		n161, err := m.AnyIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n161
	}
	return i, nil
}
func (m *ChallengeRuleSpec_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpPrefixList != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpPrefixList.Size()))
		n162, err := m.IpPrefixList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n162
	}
	return i, nil
}
func (m *ChallengeRuleSpec_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpMatcher != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpMatcher.Size()))
		n163, err := m.IpMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n163
	}
	return i, nil
}
func (m *ChallengeRuleSpec_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyAsn != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnyAsn.Size()))
		n164, err := m.AnyAsn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n164
	}
	return i, nil
}
func (m *ChallengeRuleSpec_AsnList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnList != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnList.Size()))
		n165, err := m.AsnList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n165
	}
	return i, nil
}
func (m *ChallengeRuleSpec_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AsnMatcher != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AsnMatcher.Size()))
		n166, err := m.AsnMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n166
	}
	return i, nil
}
func (m *RateLimiterRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimiterRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActionChoice != nil {
		nn167, err := m.ActionChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn167
	}
	if m.HttpMethod != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod.Size()))
		n168, err := m.HttpMethod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n168
	}
	if m.Path != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Path.Size()))
		n169, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n169
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DomainMatcher != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DomainMatcher.Size()))
		n170, err := m.DomainMatcher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n170
	}
	return i, nil
}

func (m *RateLimiterRuleSpec_BypassRateLimiter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BypassRateLimiter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BypassRateLimiter.Size()))
		n171, err := m.BypassRateLimiter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n171
	}
	return i, nil
}
func (m *RateLimiterRuleSpec_ApplyRateLimiter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ApplyRateLimiter != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApplyRateLimiter.Size()))
		n172, err := m.ApplyRateLimiter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n172
	}
	return i, nil
}
func (m *RateLimiterRuleSpec_CustomRateLimiter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CustomRateLimiter != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CustomRateLimiter.Size()))
		n173, err := m.CustomRateLimiter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n173
	}
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.VirtualHostMatcher != nil {
		l = m.VirtualHostMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ForwardingClass) > 0 {
		for _, e := range m.ForwardingClass {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.MaliciousUserMitigationBypass != nil {
		l = m.MaliciousUserMitigationBypass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstIpChoice != nil {
		n += m.DstIpChoice.Size()
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnChoice != nil {
		n += m.DstAsnChoice.Size()
	}
	if m.ChallengeAction != 0 {
		n += 2 + sovTypes(uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_ClientName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ClientSelector) Size() (n int) {
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ClientNameMatcher) Size() (n int) {
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IpMatcher) Size() (n int) {
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AsnMatcher) Size() (n int) {
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyIp) Size() (n int) {
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IpPrefixList) Size() (n int) {
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyAsn) Size() (n int) {
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AsnList) Size() (n int) {
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyClient) Size() (n int) {
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyDstIp) Size() (n int) {
	var l int
	_ = l
	if m.AnyDstIp != nil {
		l = m.AnyDstIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DstIpPrefixList) Size() (n int) {
	var l int
	_ = l
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DstIpMatcher) Size() (n int) {
	var l int
	_ = l
	if m.DstIpMatcher != nil {
		l = m.DstIpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyDstAsn) Size() (n int) {
	var l int
	_ = l
	if m.AnyDstAsn != nil {
		l = m.AnyDstAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DstAsnList) Size() (n int) {
	var l int
	_ = l
	if m.DstAsnList != nil {
		l = m.DstAsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DstAsnMatcher) Size() (n int) {
	var l int
	_ = l
	if m.DstAsnMatcher != nil {
		l = m.DstAsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.VirtualHostMatcher != nil {
		l = m.VirtualHostMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.MaliciousUserMitigationBypass != nil {
		l = m.MaliciousUserMitigationBypass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstIpChoice != nil {
		n += m.DstIpChoice.Size()
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnChoice != nil {
		n += m.DstAsnChoice.Size()
	}
	if m.ChallengeAction != 0 {
		n += 2 + sovTypes(uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType_ClientName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_ClientSelector) Size() (n int) {
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ClientNameMatcher) Size() (n int) {
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IpMatcher) Size() (n int) {
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AsnMatcher) Size() (n int) {
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyIp) Size() (n int) {
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IpPrefixList) Size() (n int) {
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyAsn) Size() (n int) {
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AsnList) Size() (n int) {
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyClient) Size() (n int) {
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyDstIp) Size() (n int) {
	var l int
	_ = l
	if m.AnyDstIp != nil {
		l = m.AnyDstIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DstIpPrefixList) Size() (n int) {
	var l int
	_ = l
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DstIpMatcher) Size() (n int) {
	var l int
	_ = l
	if m.DstIpMatcher != nil {
		l = m.DstIpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyDstAsn) Size() (n int) {
	var l int
	_ = l
	if m.AnyDstAsn != nil {
		l = m.AnyDstAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DstAsnList) Size() (n int) {
	var l int
	_ = l
	if m.DstAsnList != nil {
		l = m.DstAsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DstAsnMatcher) Size() (n int) {
	var l int
	_ = l
	if m.DstAsnMatcher != nil {
		l = m.DstAsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.VirtualHostMatcher != nil {
		l = m.VirtualHostMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.MaliciousUserMitigationBypass != nil {
		l = m.MaliciousUserMitigationBypass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstIpChoice != nil {
		n += m.DstIpChoice.Size()
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnChoice != nil {
		n += m.DstAsnChoice.Size()
	}
	if m.ChallengeAction != 0 {
		n += 2 + sovTypes(uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType_ClientName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_ClientSelector) Size() (n int) {
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ClientNameMatcher) Size() (n int) {
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IpMatcher) Size() (n int) {
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AsnMatcher) Size() (n int) {
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyIp) Size() (n int) {
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IpPrefixList) Size() (n int) {
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyAsn) Size() (n int) {
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AsnList) Size() (n int) {
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyClient) Size() (n int) {
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyDstIp) Size() (n int) {
	var l int
	_ = l
	if m.AnyDstIp != nil {
		l = m.AnyDstIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DstIpPrefixList) Size() (n int) {
	var l int
	_ = l
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DstIpMatcher) Size() (n int) {
	var l int
	_ = l
	if m.DstIpMatcher != nil {
		l = m.DstIpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyDstAsn) Size() (n int) {
	var l int
	_ = l
	if m.AnyDstAsn != nil {
		l = m.AnyDstAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DstAsnList) Size() (n int) {
	var l int
	_ = l
	if m.DstAsnList != nil {
		l = m.DstAsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DstAsnMatcher) Size() (n int) {
	var l int
	_ = l
	if m.DstAsnMatcher != nil {
		l = m.DstAsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.VirtualHostMatcher != nil {
		l = m.VirtualHostMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.MaliciousUserMitigationBypass != nil {
		l = m.MaliciousUserMitigationBypass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstIpChoice != nil {
		n += m.DstIpChoice.Size()
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnChoice != nil {
		n += m.DstAsnChoice.Size()
	}
	if m.ChallengeAction != 0 {
		n += 2 + sovTypes(uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_ClientName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_ClientSelector) Size() (n int) {
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ClientNameMatcher) Size() (n int) {
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IpMatcher) Size() (n int) {
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AsnMatcher) Size() (n int) {
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyIp) Size() (n int) {
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IpPrefixList) Size() (n int) {
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyAsn) Size() (n int) {
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AsnList) Size() (n int) {
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyClient) Size() (n int) {
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyDstIp) Size() (n int) {
	var l int
	_ = l
	if m.AnyDstIp != nil {
		l = m.AnyDstIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DstIpPrefixList) Size() (n int) {
	var l int
	_ = l
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DstIpMatcher) Size() (n int) {
	var l int
	_ = l
	if m.DstIpMatcher != nil {
		l = m.DstIpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyDstAsn) Size() (n int) {
	var l int
	_ = l
	if m.AnyDstAsn != nil {
		l = m.AnyDstAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DstAsnList) Size() (n int) {
	var l int
	_ = l
	if m.DstAsnList != nil {
		l = m.DstAsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DstAsnMatcher) Size() (n int) {
	var l int
	_ = l
	if m.DstAsnMatcher != nil {
		l = m.DstAsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.ChallengeAction != nil {
		n += m.ChallengeAction.Size()
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	return n
}

func (m *ChallengeRuleSpec_DisableChallenge) Size() (n int) {
	var l int
	_ = l
	if m.DisableChallenge != nil {
		l = m.DisableChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_EnableJavascriptChallenge) Size() (n int) {
	var l int
	_ = l
	if m.EnableJavascriptChallenge != nil {
		l = m.EnableJavascriptChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_EnableCaptchaChallenge) Size() (n int) {
	var l int
	_ = l
	if m.EnableCaptchaChallenge != nil {
		l = m.EnableCaptchaChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AnyClient) Size() (n int) {
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_ClientName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *ChallengeRuleSpec_ClientSelector) Size() (n int) {
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_ClientNameMatcher) Size() (n int) {
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AnyIp) Size() (n int) {
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_IpPrefixList) Size() (n int) {
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_IpMatcher) Size() (n int) {
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AnyAsn) Size() (n int) {
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AsnList) Size() (n int) {
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AsnMatcher) Size() (n int) {
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RateLimiterRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.ActionChoice != nil {
		n += m.ActionChoice.Size()
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RateLimiterRuleSpec_BypassRateLimiter) Size() (n int) {
	var l int
	_ = l
	if m.BypassRateLimiter != nil {
		l = m.BypassRateLimiter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RateLimiterRuleSpec_ApplyRateLimiter) Size() (n int) {
	var l int
	_ = l
	if m.ApplyRateLimiter != nil {
		l = m.ApplyRateLimiter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RateLimiterRuleSpec_CustomRateLimiter) Size() (n int) {
	var l int
	_ = l
	if m.CustomRateLimiter != nil {
		l = m.CustomRateLimiter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "ves_io_schema4.LabelMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "ves_io_schema_policy.PathMatcherType", 1) + `,`,
		`Headers:` + strings.Replace(fmt.Sprintf("%v", this.Headers), "HeaderMatcherType", "ves_io_schema_policy.HeaderMatcherType", 1) + `,`,
		`QueryParams:` + strings.Replace(fmt.Sprintf("%v", this.QueryParams), "QueryParameterMatcherType", "ves_io_schema_policy.QueryParameterMatcherType", 1) + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "ves_io_schema_policy.HttpMethodMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "ves_io_schema_policy.RoleMatcherType", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "ves_io_schema_policy.StringMatcherType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "ves_io_schema_policy.PortMatcherType", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`ArgMatchers:` + strings.Replace(fmt.Sprintf("%v", this.ArgMatchers), "ArgMatcherType", "ves_io_schema_policy.ArgMatcherType", 1) + `,`,
		`CookieMatchers:` + strings.Replace(fmt.Sprintf("%v", this.CookieMatchers), "CookieMatcherType", "ves_io_schema_policy.CookieMatcherType", 1) + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "ves_io_schema_policy.WafAction", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`RateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiter), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`VirtualHostMatcher:` + strings.Replace(fmt.Sprintf("%v", this.VirtualHostMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "ves_io_schema_policy.TlsFingerprintMatcherType", 1) + `,`,
		`ForwardingClass:` + strings.Replace(fmt.Sprintf("%v", this.ForwardingClass), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`MaliciousUserMitigationBypass:` + strings.Replace(fmt.Sprintf("%v", this.MaliciousUserMitigationBypass), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "ves_io_schema_policy.URLMatcherType", 1) + `,`,
		`DstIpChoice:` + fmt.Sprintf("%v", this.DstIpChoice) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "ves_io_schema_policy.L4DestMatcherType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`DstAsnChoice:` + fmt.Sprintf("%v", this.DstAsnChoice) + `,`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`GotoPolicy:` + strings.Replace(fmt.Sprintf("%v", this.GotoPolicy), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "ves_io_schema_policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "ves_io_schema_policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "ves_io_schema_policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyDstIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyDstIp{`,
		`AnyDstIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstIp), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DstIpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DstIpPrefixList{`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DstIpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DstIpMatcher{`,
		`DstIpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstIpMatcher), "IpMatcherType", "ves_io_schema_policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyDstAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyDstAsn{`,
		`AnyDstAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstAsn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DstAsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DstAsnList{`,
		`DstAsnList:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnList), "AsnMatchList", "ves_io_schema_policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DstAsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DstAsnMatcher{`,
		`DstAsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnMatcher), "AsnMatcherType", "ves_io_schema_policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "ves_io_schema4.LabelMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "ves_io_schema_policy.PathMatcherType", 1) + `,`,
		`Headers:` + strings.Replace(fmt.Sprintf("%v", this.Headers), "HeaderMatcherType", "ves_io_schema_policy.HeaderMatcherType", 1) + `,`,
		`QueryParams:` + strings.Replace(fmt.Sprintf("%v", this.QueryParams), "QueryParameterMatcherType", "ves_io_schema_policy.QueryParameterMatcherType", 1) + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "ves_io_schema_policy.HttpMethodMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "ves_io_schema_policy.RoleMatcherType", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "ves_io_schema_policy.StringMatcherType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "ves_io_schema_policy.PortMatcherType", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`ArgMatchers:` + strings.Replace(fmt.Sprintf("%v", this.ArgMatchers), "ArgMatcherType", "ves_io_schema_policy.ArgMatcherType", 1) + `,`,
		`CookieMatchers:` + strings.Replace(fmt.Sprintf("%v", this.CookieMatchers), "CookieMatcherType", "ves_io_schema_policy.CookieMatcherType", 1) + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "ves_io_schema_policy.WafAction", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`RateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiter), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`VirtualHostMatcher:` + strings.Replace(fmt.Sprintf("%v", this.VirtualHostMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "ves_io_schema_policy.TlsFingerprintMatcherType", 1) + `,`,
		`MaliciousUserMitigationBypass:` + strings.Replace(fmt.Sprintf("%v", this.MaliciousUserMitigationBypass), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "ves_io_schema_policy.URLMatcherType", 1) + `,`,
		`DstIpChoice:` + fmt.Sprintf("%v", this.DstIpChoice) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "ves_io_schema_policy.L4DestMatcherType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`DstAsnChoice:` + fmt.Sprintf("%v", this.DstAsnChoice) + `,`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`GotoPolicy:` + strings.Replace(fmt.Sprintf("%v", this.GotoPolicy), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "ves_io_schema_policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "ves_io_schema_policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "ves_io_schema_policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyDstIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyDstIp{`,
		`AnyDstIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstIp), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DstIpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DstIpPrefixList{`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DstIpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DstIpMatcher{`,
		`DstIpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstIpMatcher), "IpMatcherType", "ves_io_schema_policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyDstAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyDstAsn{`,
		`AnyDstAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstAsn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DstAsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DstAsnList{`,
		`DstAsnList:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnList), "AsnMatchList", "ves_io_schema_policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DstAsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DstAsnMatcher{`,
		`DstAsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnMatcher), "AsnMatcherType", "ves_io_schema_policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "ves_io_schema4.LabelMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "ves_io_schema_policy.PathMatcherType", 1) + `,`,
		`Headers:` + strings.Replace(fmt.Sprintf("%v", this.Headers), "HeaderMatcherType", "ves_io_schema_policy.HeaderMatcherType", 1) + `,`,
		`QueryParams:` + strings.Replace(fmt.Sprintf("%v", this.QueryParams), "QueryParameterMatcherType", "ves_io_schema_policy.QueryParameterMatcherType", 1) + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "ves_io_schema_policy.HttpMethodMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "ves_io_schema_policy.RoleMatcherType", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "ves_io_schema_policy.StringMatcherType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "ves_io_schema_policy.PortMatcherType", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`ArgMatchers:` + strings.Replace(fmt.Sprintf("%v", this.ArgMatchers), "ArgMatcherType", "ves_io_schema_policy.ArgMatcherType", 1) + `,`,
		`CookieMatchers:` + strings.Replace(fmt.Sprintf("%v", this.CookieMatchers), "CookieMatcherType", "ves_io_schema_policy.CookieMatcherType", 1) + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "ves_io_schema_policy.WafAction", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`RateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiter), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`VirtualHostMatcher:` + strings.Replace(fmt.Sprintf("%v", this.VirtualHostMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "ves_io_schema_policy.TlsFingerprintMatcherType", 1) + `,`,
		`MaliciousUserMitigationBypass:` + strings.Replace(fmt.Sprintf("%v", this.MaliciousUserMitigationBypass), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "ves_io_schema_policy.URLMatcherType", 1) + `,`,
		`DstIpChoice:` + fmt.Sprintf("%v", this.DstIpChoice) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "ves_io_schema_policy.L4DestMatcherType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`DstAsnChoice:` + fmt.Sprintf("%v", this.DstAsnChoice) + `,`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`GotoPolicy:` + strings.Replace(fmt.Sprintf("%v", this.GotoPolicy), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "ves_io_schema_policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "ves_io_schema_policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "ves_io_schema_policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyDstIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyDstIp{`,
		`AnyDstIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstIp), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DstIpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DstIpPrefixList{`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DstIpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DstIpMatcher{`,
		`DstIpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstIpMatcher), "IpMatcherType", "ves_io_schema_policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyDstAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyDstAsn{`,
		`AnyDstAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstAsn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DstAsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DstAsnList{`,
		`DstAsnList:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnList), "AsnMatchList", "ves_io_schema_policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DstAsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DstAsnMatcher{`,
		`DstAsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnMatcher), "AsnMatcherType", "ves_io_schema_policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "ves_io_schema4.LabelMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "ves_io_schema_policy.PathMatcherType", 1) + `,`,
		`Headers:` + strings.Replace(fmt.Sprintf("%v", this.Headers), "HeaderMatcherType", "ves_io_schema_policy.HeaderMatcherType", 1) + `,`,
		`QueryParams:` + strings.Replace(fmt.Sprintf("%v", this.QueryParams), "QueryParameterMatcherType", "ves_io_schema_policy.QueryParameterMatcherType", 1) + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "ves_io_schema_policy.HttpMethodMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "ves_io_schema_policy.RoleMatcherType", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "ves_io_schema_policy.StringMatcherType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "ves_io_schema_policy.PortMatcherType", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`ArgMatchers:` + strings.Replace(fmt.Sprintf("%v", this.ArgMatchers), "ArgMatcherType", "ves_io_schema_policy.ArgMatcherType", 1) + `,`,
		`CookieMatchers:` + strings.Replace(fmt.Sprintf("%v", this.CookieMatchers), "CookieMatcherType", "ves_io_schema_policy.CookieMatcherType", 1) + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "ves_io_schema_policy.WafAction", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`RateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.RateLimiter), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`VirtualHostMatcher:` + strings.Replace(fmt.Sprintf("%v", this.VirtualHostMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "ves_io_schema_policy.TlsFingerprintMatcherType", 1) + `,`,
		`MaliciousUserMitigationBypass:` + strings.Replace(fmt.Sprintf("%v", this.MaliciousUserMitigationBypass), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "ves_io_schema_policy.URLMatcherType", 1) + `,`,
		`DstIpChoice:` + fmt.Sprintf("%v", this.DstIpChoice) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "ves_io_schema_policy.L4DestMatcherType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`DstAsnChoice:` + fmt.Sprintf("%v", this.DstAsnChoice) + `,`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`GotoPolicy:` + strings.Replace(fmt.Sprintf("%v", this.GotoPolicy), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "ves_io_schema_policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "ves_io_schema_policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "ves_io_schema_policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyDstIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyDstIp{`,
		`AnyDstIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstIp), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DstIpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DstIpPrefixList{`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DstIpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DstIpMatcher{`,
		`DstIpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstIpMatcher), "IpMatcherType", "ves_io_schema_policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyDstAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyDstAsn{`,
		`AnyDstAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstAsn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DstAsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DstAsnList{`,
		`DstAsnList:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnList), "AsnMatchList", "ves_io_schema_policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DstAsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DstAsnMatcher{`,
		`DstAsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnMatcher), "AsnMatcherType", "ves_io_schema_policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec{`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "ves_io_schema_policy.PathMatcherType", 1) + `,`,
		`Headers:` + strings.Replace(fmt.Sprintf("%v", this.Headers), "HeaderMatcherType", "ves_io_schema_policy.HeaderMatcherType", 1) + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "ves_io_schema_policy.HttpMethodMatcherType", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "ves_io_schema_policy.TlsFingerprintMatcherType", 1) + `,`,
		`QueryParams:` + strings.Replace(fmt.Sprintf("%v", this.QueryParams), "QueryParameterMatcherType", "ves_io_schema_policy.QueryParameterMatcherType", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`ArgMatchers:` + strings.Replace(fmt.Sprintf("%v", this.ArgMatchers), "ArgMatcherType", "ves_io_schema_policy.ArgMatcherType", 1) + `,`,
		`CookieMatchers:` + strings.Replace(fmt.Sprintf("%v", this.CookieMatchers), "CookieMatcherType", "ves_io_schema_policy.CookieMatcherType", 1) + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_DisableChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_DisableChallenge{`,
		`DisableChallenge:` + strings.Replace(fmt.Sprintf("%v", this.DisableChallenge), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_EnableJavascriptChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_EnableJavascriptChallenge{`,
		`EnableJavascriptChallenge:` + strings.Replace(fmt.Sprintf("%v", this.EnableJavascriptChallenge), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_EnableCaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_EnableCaptchaChallenge{`,
		`EnableCaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.EnableCaptchaChallenge), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherType", "ves_io_schema_policy.MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "ves_io_schema_policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "ves_io_schema_policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "ves_io_schema_policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "ves_io_schema_policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimiterRuleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimiterRuleSpec{`,
		`ActionChoice:` + fmt.Sprintf("%v", this.ActionChoice) + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "ves_io_schema_policy.HttpMethodMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "ves_io_schema_policy.PathMatcherType", 1) + `,`,
		`Headers:` + strings.Replace(fmt.Sprintf("%v", this.Headers), "HeaderMatcherType", "ves_io_schema_policy.HeaderMatcherType", 1) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "ves_io_schema_policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimiterRuleSpec_BypassRateLimiter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimiterRuleSpec_BypassRateLimiter{`,
		`BypassRateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.BypassRateLimiter), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimiterRuleSpec_ApplyRateLimiter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimiterRuleSpec_ApplyRateLimiter{`,
		`ApplyRateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.ApplyRateLimiter), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimiterRuleSpec_CustomRateLimiter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimiterRuleSpec_CustomRateLimiter{`,
		`CustomRateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.CustomRateLimiter), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (ves_io_schema_policy.RuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &GlobalSpecType_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GlobalSpecType_ClientSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &ves_io_schema4.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &ves_io_schema_policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &ves_io_schema_policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &ves_io_schema_policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &ves_io_schema_policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &ves_io_schema_policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GlobalSpecType_ClientNameMatcher{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GlobalSpecType_IpMatcher{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GlobalSpecType_AsnMatcher{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &ves_io_schema_policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &ves_io_schema_policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &ves_io_schema_policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &ves_io_schema_policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &ves_io_schema_policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &ves_io_schema_policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &ves_io_schema_policy.MatcherType{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHostMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualHostMatcher == nil {
				m.VirtualHostMatcher = &ves_io_schema_policy.MatcherType{}
			}
			if err := m.VirtualHostMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &ves_io_schema_policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingClass = append(m.ForwardingClass, &ves_io_schema4.ObjectRefType{})
			if err := m.ForwardingClass[len(m.ForwardingClass)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigationBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaliciousUserMitigationBypass == nil {
				m.MaliciousUserMitigationBypass = &ves_io_schema4.Empty{}
			}
			if err := m.MaliciousUserMitigationBypass.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GlobalSpecType_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GlobalSpecType_IpPrefixList{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GlobalSpecType_AnyAsn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GlobalSpecType_AsnList{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GlobalSpecType_AnyClient{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &ves_io_schema_policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GlobalSpecType_AnyDstIp{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GlobalSpecType_DstIpPrefixList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GlobalSpecType_DstIpMatcher{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &ves_io_schema_policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &ves_io_schema4.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GlobalSpecType_AnyDstAsn{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GlobalSpecType_DstAsnList{v}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GlobalSpecType_DstAsnMatcher{v}
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAction", wireType)
			}
			m.ChallengeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAction |= (ves_io_schema_policy.ChallengeAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &ves_io_schema4.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (ves_io_schema_policy.RuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &CreateSpecType_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &CreateSpecType_ClientSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &ves_io_schema4.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &ves_io_schema_policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &ves_io_schema_policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &ves_io_schema_policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &ves_io_schema_policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &ves_io_schema_policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &CreateSpecType_ClientNameMatcher{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &CreateSpecType_IpMatcher{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &CreateSpecType_AsnMatcher{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &ves_io_schema_policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &ves_io_schema_policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &ves_io_schema_policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &ves_io_schema_policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &ves_io_schema_policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &ves_io_schema_policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHostMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualHostMatcher == nil {
				m.VirtualHostMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
			}
			if err := m.VirtualHostMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &ves_io_schema_policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigationBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaliciousUserMitigationBypass == nil {
				m.MaliciousUserMitigationBypass = &ves_io_schema4.Empty{}
			}
			if err := m.MaliciousUserMitigationBypass.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &CreateSpecType_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &CreateSpecType_IpPrefixList{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &CreateSpecType_AnyAsn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &CreateSpecType_AsnList{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &CreateSpecType_AnyClient{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &ves_io_schema_policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &CreateSpecType_AnyDstIp{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &CreateSpecType_DstIpPrefixList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &CreateSpecType_DstIpMatcher{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &ves_io_schema_policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &ves_io_schema4.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &CreateSpecType_AnyDstAsn{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &CreateSpecType_DstAsnList{v}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &CreateSpecType_DstAsnMatcher{v}
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAction", wireType)
			}
			m.ChallengeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAction |= (ves_io_schema_policy.ChallengeAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &ves_io_schema4.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (ves_io_schema_policy.RuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &ReplaceSpecType_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ReplaceSpecType_ClientSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &ves_io_schema4.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &ves_io_schema_policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &ves_io_schema_policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &ves_io_schema_policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &ves_io_schema_policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &ves_io_schema_policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ReplaceSpecType_ClientNameMatcher{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ReplaceSpecType_IpMatcher{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ReplaceSpecType_AsnMatcher{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &ves_io_schema_policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &ves_io_schema_policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &ves_io_schema_policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &ves_io_schema_policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &ves_io_schema_policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &ves_io_schema_policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHostMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualHostMatcher == nil {
				m.VirtualHostMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
			}
			if err := m.VirtualHostMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &ves_io_schema_policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigationBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaliciousUserMitigationBypass == nil {
				m.MaliciousUserMitigationBypass = &ves_io_schema4.Empty{}
			}
			if err := m.MaliciousUserMitigationBypass.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ReplaceSpecType_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ReplaceSpecType_IpPrefixList{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ReplaceSpecType_AnyAsn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ReplaceSpecType_AsnList{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ReplaceSpecType_AnyClient{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &ves_io_schema_policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &ReplaceSpecType_AnyDstIp{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &ReplaceSpecType_DstIpPrefixList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &ReplaceSpecType_DstIpMatcher{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &ves_io_schema_policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &ves_io_schema4.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &ReplaceSpecType_AnyDstAsn{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &ReplaceSpecType_DstAsnList{v}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &ReplaceSpecType_DstAsnMatcher{v}
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAction", wireType)
			}
			m.ChallengeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAction |= (ves_io_schema_policy.ChallengeAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &ves_io_schema4.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (ves_io_schema_policy.RuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &GetSpecType_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GetSpecType_ClientSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &ves_io_schema4.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &ves_io_schema_policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &ves_io_schema_policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &ves_io_schema_policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &ves_io_schema_policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &ves_io_schema_policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GetSpecType_ClientNameMatcher{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GetSpecType_IpMatcher{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GetSpecType_AsnMatcher{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &ves_io_schema_policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &ves_io_schema_policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &ves_io_schema_policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &ves_io_schema_policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &ves_io_schema_policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &ves_io_schema_policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &ves_io_schema4.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHostMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualHostMatcher == nil {
				m.VirtualHostMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
			}
			if err := m.VirtualHostMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &ves_io_schema_policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigationBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaliciousUserMitigationBypass == nil {
				m.MaliciousUserMitigationBypass = &ves_io_schema4.Empty{}
			}
			if err := m.MaliciousUserMitigationBypass.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GetSpecType_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GetSpecType_IpPrefixList{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GetSpecType_AnyAsn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GetSpecType_AsnList{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GetSpecType_AnyClient{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &ves_io_schema_policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GetSpecType_AnyDstIp{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GetSpecType_DstIpPrefixList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GetSpecType_DstIpMatcher{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &ves_io_schema_policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &ves_io_schema4.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GetSpecType_AnyDstAsn{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GetSpecType_DstAsnList{v}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GetSpecType_DstAsnMatcher{v}
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAction", wireType)
			}
			m.ChallengeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAction |= (ves_io_schema_policy.ChallengeAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &ves_io_schema4.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeAction = &ChallengeRuleSpec_DisableChallenge{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableJavascriptChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeAction = &ChallengeRuleSpec_EnableJavascriptChallenge{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeAction = &ChallengeRuleSpec_EnableCaptchaChallenge{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &ves_io_schema_policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &ves_io_schema_policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &ves_io_schema_policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &ves_io_schema_policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &ves_io_schema_policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &ves_io_schema_policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &ves_io_schema_policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &ves_io_schema_policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ChallengeRuleSpec_AnyClient{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &ChallengeRuleSpec_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ChallengeRuleSpec_ClientSelector{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ChallengeRuleSpec_ClientNameMatcher{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ChallengeRuleSpec_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ChallengeRuleSpec_IpPrefixList{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ChallengeRuleSpec_IpMatcher{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ChallengeRuleSpec_AnyAsn{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ChallengeRuleSpec_AsnList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ChallengeRuleSpec_AsnMatcher{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimiterRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimiterRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimiterRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BypassRateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &RateLimiterRuleSpec_BypassRateLimiter{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyRateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &RateLimiterRuleSpec_ApplyRateLimiter{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomRateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &RateLimiterRuleSpec_CustomRateLimiter{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &ves_io_schema_policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &ves_io_schema_policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &ves_io_schema_policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/service_policy_rule/types.proto", fileDescriptorTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/service_policy_rule/types.proto", fileDescriptorTypes)
}

var fileDescriptorTypes = []byte{
	// 2799 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x9c, 0xcf, 0x6f, 0x1b, 0xc7,
	0x15, 0xc7, 0x35, 0x24, 0x25, 0x51, 0x43, 0x8a, 0x5c, 0xad, 0x64, 0x67, 0xad, 0x28, 0x34, 0xcd,
	0x58, 0x8e, 0x12, 0xaf, 0x28, 0xf1, 0x87, 0x64, 0x27, 0x45, 0x92, 0x9a, 0x52, 0x6c, 0x9a, 0x91,
	0x6c, 0x65, 0xa5, 0xc4, 0x4e, 0x9a, 0x94, 0x1d, 0x2d, 0x47, 0xe4, 0x26, 0x4b, 0xee, 0x7a, 0x77,
	0x29, 0x47, 0x28, 0x8c, 0x06, 0x3e, 0xf4, 0x56, 0xa0, 0xc8, 0x31, 0x7f, 0x41, 0x11, 0xa0, 0x28,
	0x50, 0xa0, 0x3d, 0x94, 0x39, 0x08, 0x01, 0x0a, 0x04, 0x3d, 0xf9, 0x18, 0x14, 0x3d, 0x24, 0xca,
	0x25, 0xbd, 0xf9, 0xec, 0x53, 0xb1, 0xb3, 0x3f, 0xb8, 0x4b, 0x2e, 0x59, 0x8a, 0x54, 0x50, 0x14,
	0xd8, 0x93, 0xb9, 0x3b, 0xef, 0x7d, 0x67, 0x76, 0xe6, 0xed, 0xcc, 0xfb, 0xac, 0x67, 0x04, 0x97,
	0x0f, 0xb1, 0x9a, 0x16, 0xa4, 0x15, 0x95, 0xaf, 0xe1, 0x3a, 0x5a, 0x51, 0xb1, 0x72, 0x28, 0xf0,
	0xb8, 0x2c, 0x4b, 0xa2, 0xc0, 0x1f, 0x95, 0x95, 0xa6, 0x88, 0x57, 0xb4, 0x23, 0x19, 0xab, 0x69,
	0x59, 0x91, 0x34, 0x89, 0xbe, 0x64, 0x98, 0xa7, 0x0d, 0xf3, 0xb4, 0x87, 0xf9, 0xfc, 0x72, 0x55,
	0xd0, 0x6a, 0xcd, 0xfd, 0x34, 0x2f, 0xd5, 0x57, 0xaa, 0x52, 0x55, 0x5a, 0x21, 0x9e, 0xfb, 0xcd,
	0x03, 0x72, 0x45, 0x2e, 0xc8, 0x2f, 0x43, 0x71, 0xfe, 0x62, 0x55, 0x92, 0xaa, 0x22, 0x6e, 0x5b,
	0x69, 0x42, 0x1d, 0xab, 0x1a, 0xaa, 0xcb, 0xa6, 0xc1, 0xf3, 0xee, 0x16, 0x4a, 0xb2, 0x26, 0x48,
	0x0d, 0xb3, 0x3d, 0xf3, 0x49, 0x77, 0xa1, 0xd1, 0x0e, 0x67, 0x8b, 0xe7, 0x2f, 0xb8, 0x2d, 0x9c,
	0x45, 0x0b, 0xee, 0xa2, 0x43, 0x24, 0x0a, 0x15, 0xa4, 0x61, 0x6f, 0xe9, 0x43, 0x01, 0x3f, 0x2c,
	0xbb, 0x2b, 0xbf, 0xd8, 0x6d, 0xa1, 0x3a, 0x2b, 0x48, 0xfd, 0x29, 0x01, 0x63, 0xb7, 0x44, 0x69,
	0x1f, 0x89, 0xbb, 0x32, 0xe6, 0xf7, 0x8e, 0x64, 0x4c, 0x17, 0xe0, 0x04, 0xe2, 0x75, 0x11, 0x06,
	0x24, 0xc1, 0x52, 0x2c, 0x9b, 0x4c, 0xbb, 0x7b, 0xd4, 0x78, 0x82, 0x34, 0xd7, 0x14, 0xf1, 0x0d,
	0x62, 0x57, 0x08, 0xff, 0xb3, 0x05, 0x42, 0x9b, 0x6f, 0xdd, 0x79, 0x9f, 0x33, 0x3d, 0xe9, 0x65,
	0x18, 0xe1, 0x45, 0x01, 0x37, 0xb4, 0x72, 0x03, 0xd5, 0x31, 0x13, 0x48, 0x82, 0xa5, 0xa9, 0x02,
	0xfc, 0xdb, 0xbf, 0x8f, 0x83, 0xe3, 0x4a, 0x70, 0xe9, 0xb3, 0x40, 0x71, 0x8c, 0x83, 0x86, 0xc1,
	0x1d, 0x54, 0xc7, 0xf4, 0x7b, 0x30, 0x6e, 0x9a, 0xab, 0x58, 0xc4, 0xbc, 0x26, 0x29, 0x4c, 0x30,
	0x09, 0x96, 0x22, 0x5d, 0x75, 0x6f, 0xa1, 0x7d, 0x2c, 0xee, 0x9a, 0x36, 0x7a, 0x6b, 0x0b, 0x53,
	0x5f, 0x7c, 0x05, 0xc6, 0x61, 0x10, 0x04, 0x82, 0xc5, 0x31, 0x2e, 0x66, 0xa8, 0x58, 0x06, 0xf4,
	0x2e, 0x9c, 0x16, 0x75, 0x8f, 0x72, 0x1d, 0x69, 0x7c, 0x0d, 0x2b, 0x4c, 0x88, 0xa8, 0x5e, 0xf4,
	0x52, 0xdd, 0x36, 0x4c, 0x88, 0xe8, 0xf4, 0xd3, 0x16, 0x00, 0xb6, 0x30, 0x17, 0x15, 0x1d, 0x06,
	0xf4, 0xab, 0x30, 0x24, 0x23, 0xad, 0xc6, 0x8c, 0x13, 0xad, 0x45, 0xef, 0xde, 0xd9, 0x41, 0x5a,
	0xcd, 0xa1, 0xc8, 0x11, 0x17, 0x7a, 0x1b, 0x4e, 0xd6, 0x30, 0xaa, 0x60, 0x45, 0x65, 0x26, 0x92,
	0xc1, 0xa5, 0x48, 0xf6, 0x25, 0x6f, 0xef, 0x22, 0x31, 0x72, 0xb6, 0xc8, 0xe8, 0xbb, 0xcf, 0x41,
	0x80, 0xa2, 0x38, 0x4b, 0x83, 0xfe, 0x25, 0x8c, 0x3e, 0x68, 0x62, 0xe5, 0xa8, 0x2c, 0x23, 0x05,
	0xd5, 0x55, 0x66, 0x92, 0x68, 0xae, 0x78, 0x6b, 0xbe, 0xa3, 0x5b, 0xee, 0xe8, 0x86, 0x58, 0xeb,
	0xad, 0x1d, 0x79, 0x60, 0x9b, 0xa9, 0xf4, 0x16, 0x8c, 0xd4, 0x34, 0x4d, 0x2e, 0xd7, 0xb1, 0x56,
	0x93, 0x2a, 0x4c, 0x98, 0x3c, 0xf0, 0xd5, 0x1e, 0x4d, 0xd6, 0x34, 0x79, 0x9b, 0xd8, 0x39, 0x1f,
	0x1b, 0xd6, 0xec, 0xdb, 0xf4, 0x5d, 0x3b, 0x26, 0x14, 0x49, 0xc4, 0xcc, 0x54, 0xbf, 0xee, 0xe3,
	0x24, 0x11, 0x3b, 0x9b, 0x38, 0xf9, 0xed, 0x23, 0xf0, 0x63, 0x0b, 0x00, 0x2b, 0x6a, 0xf4, 0x72,
	0x7a, 0x17, 0xce, 0x3a, 0x82, 0xcc, 0x1e, 0x63, 0x48, 0x84, 0x2f, 0x79, 0x0b, 0x3b, 0x44, 0x8b,
	0x63, 0xdc, 0x4c, 0x3b, 0x06, 0xad, 0xd1, 0xdd, 0x84, 0x50, 0x90, 0x6d, 0xad, 0x28, 0xd1, 0x7a,
	0xd1, 0x5b, 0xeb, 0xb6, 0xec, 0x54, 0x03, 0xdc, 0x94, 0x60, 0xdd, 0xa0, 0x6f, 0xc1, 0x08, 0x52,
	0x1b, 0xb6, 0xcc, 0x34, 0x91, 0xb9, 0xec, 0x2d, 0x73, 0x43, 0x6d, 0x38, 0x75, 0x82, 0x1c, 0x44,
	0xf6, 0x1d, 0xfa, 0x43, 0x38, 0x83, 0x64, 0xa1, 0x5c, 0x55, 0xa4, 0x66, 0xbb, 0x55, 0x31, 0x22,
	0xd7, 0x23, 0x76, 0x76, 0x35, 0x45, 0x68, 0x54, 0x3d, 0x3b, 0x2f, 0x8e, 0x64, 0xe1, 0x96, 0xae,
	0x64, 0xa9, 0xbf, 0x03, 0xa3, 0xb2, 0xa4, 0x68, 0xb6, 0x70, 0xbc, 0x6f, 0x48, 0x4b, 0x8a, 0xe6,
	0x29, 0x1b, 0x91, 0xdb, 0x25, 0xf4, 0x2e, 0x9c, 0xc3, 0x9f, 0xca, 0x82, 0x82, 0xf4, 0x79, 0xa0,
	0x6c, 0xcf, 0x94, 0x0c, 0x45, 0xa4, 0xe7, 0xd3, 0xc6, 0x5c, 0x9a, 0xb6, 0xe6, 0xd2, 0xf4, 0x9e,
	0x65, 0x51, 0x08, 0x1d, 0xeb, 0x62, 0xb3, 0x6d, 0x6f, 0xbb, 0x88, 0xbe, 0x07, 0xa3, 0x48, 0xa9,
	0x5a, 0xcd, 0x54, 0x19, 0x9a, 0x04, 0x7a, 0xaf, 0xfe, 0x54, 0x5c, 0x4f, 0x1f, 0xd3, 0x65, 0x9d,
	0x11, 0x8e, 0xec, 0x72, 0x95, 0xfe, 0x15, 0x8c, 0xf3, 0x92, 0xf4, 0x89, 0x80, 0xdb, 0xda, 0xb3,
	0xfd, 0x5e, 0xcc, 0x0d, 0x62, 0xdc, 0x4f, 0x3e, 0xc6, 0x3b, 0x4d, 0x54, 0xba, 0x08, 0xe1, 0x43,
	0x74, 0x50, 0x36, 0x67, 0xd4, 0x39, 0xcf, 0xf9, 0xc7, 0x14, 0xbf, 0x87, 0x0e, 0xac, 0x09, 0x55,
	0x17, 0xd5, 0xe7, 0x20, 0x6e, 0xea, 0xa1, 0x75, 0x93, 0x2e, 0xc1, 0xe8, 0xbe, 0x54, 0x39, 0xb2,
	0x07, 0xeb, 0xdc, 0x80, 0x71, 0x6e, 0x76, 0x6c, 0x44, 0x77, 0xb6, 0x46, 0xa9, 0x08, 0x63, 0x15,
	0xa9, 0x8e, 0x84, 0x76, 0x88, 0x9e, 0x1f, 0x50, 0x8d, 0x9b, 0x36, 0x1c, 0x2d, 0x25, 0x04, 0xa3,
	0x0a, 0xd2, 0x70, 0x59, 0x14, 0xea, 0x82, 0x86, 0x15, 0xe6, 0x39, 0xd2, 0x7d, 0x0b, 0x1d, 0x3a,
	0x77, 0xf7, 0x3f, 0xc6, 0xbc, 0xc6, 0xe1, 0x03, 0xd2, 0xa0, 0xe4, 0x97, 0x8f, 0x5c, 0x4e, 0x66,
	0x20, 0xd9, 0xbd, 0x18, 0xe0, 0x22, 0x7a, 0xf1, 0x96, 0x51, 0x4a, 0x7f, 0x08, 0xe7, 0x0e, 0x05,
	0x45, 0x6b, 0x22, 0xb1, 0x5c, 0x93, 0xd4, 0x76, 0xb4, 0x32, 0x83, 0x76, 0x80, 0x1d, 0xa9, 0xb4,
	0xa9, 0x53, 0x94, 0x54, 0x3b, 0x60, 0x7f, 0x0b, 0xe0, 0x73, 0x9a, 0xa8, 0x96, 0x0f, 0x84, 0x46,
	0x15, 0x2b, 0xb2, 0x22, 0x34, 0xda, 0x35, 0x5c, 0x20, 0x35, 0xf4, 0x98, 0x50, 0xf7, 0x44, 0xf5,
	0x66, 0xdb, 0xc7, 0x59, 0xdf, 0x0b, 0x7a, 0x87, 0x3f, 0x69, 0x01, 0x70, 0xf2, 0xdd, 0xdf, 0x83,
	0xd4, 0x17, 0x5f, 0x81, 0xa8, 0x5a, 0x43, 0x0a, 0xae, 0xb0, 0xc9, 0xa6, 0x8a, 0x15, 0xee, 0x9c,
	0xe6, 0xe5, 0x49, 0xd7, 0x21, 0x75, 0x20, 0x29, 0x0f, 0x91, 0x52, 0x11, 0x1a, 0xd5, 0x32, 0x2f,
	0x22, 0x55, 0x65, 0xe6, 0x07, 0xe8, 0xcd, 0xcb, 0x5f, 0x3e, 0xea, 0x72, 0xec, 0xec, 0xd1, 0x20,
	0x17, 0x6f, 0x9b, 0x6c, 0xe8, 0x16, 0xf4, 0x01, 0x4c, 0xd6, 0x91, 0x28, 0xf0, 0x82, 0xd4, 0x54,
	0xcb, 0x7a, 0xbb, 0xca, 0x75, 0x41, 0x13, 0xaa, 0xc6, 0x7b, 0xbb, 0x7f, 0x24, 0xeb, 0xd5, 0x2f,
	0x90, 0xe7, 0x9f, 0xeb, 0xa8, 0xfe, 0xad, 0xba, 0xac, 0x1d, 0xb5, 0x3b, 0xf5, 0x05, 0x5b, 0xe6,
	0x5d, 0x15, 0x2b, 0xdb, 0xb6, 0x48, 0x81, 0x68, 0xd0, 0xcb, 0x70, 0x02, 0x35, 0x8e, 0xca, 0x82,
	0xcc, 0x5c, 0xec, 0xad, 0x56, 0x04, 0xdc, 0x38, 0x6a, 0x1c, 0xdd, 0x96, 0xe9, 0x6d, 0x18, 0x13,
	0xe4, 0xb2, 0xac, 0xe0, 0x03, 0xe1, 0xd3, 0xb2, 0x28, 0xa8, 0x1a, 0x93, 0xec, 0x3b, 0x29, 0x11,
	0x43, 0xd2, 0x85, 0x5b, 0x82, 0xaa, 0x15, 0x01, 0x17, 0x15, 0x64, 0xe3, 0xa6, 0x7e, 0x4d, 0xaf,
	0xc0, 0x49, 0xbd, 0x76, 0xa4, 0x36, 0x98, 0x54, 0x9f, 0xea, 0x83, 0x9c, 0xde, 0xc8, 0x1b, 0x6a,
	0x83, 0x7e, 0x13, 0x86, 0xf5, 0x99, 0x9b, 0xd4, 0xfc, 0x22, 0xf1, 0x48, 0xf5, 0x9f, 0xb6, 0x49,
	0xb5, 0x41, 0x6e, 0x12, 0xa9, 0x0d, 0x52, 0xe3, 0x1a, 0x84, 0x7a, 0x8d, 0xc6, 0xca, 0xc2, 0x2c,
	0xf6, 0xa9, 0x74, 0x8c, 0x9b, 0x42, 0x8d, 0xa3, 0x0d, 0x62, 0x48, 0x57, 0xe1, 0x04, 0x29, 0xc4,
	0xcc, 0x95, 0x64, 0x70, 0x69, 0xaa, 0x70, 0xd7, 0x31, 0x84, 0x2b, 0x9f, 0x03, 0x36, 0xf5, 0x8a,
	0xb2, 0xc4, 0x5d, 0xf9, 0x45, 0xea, 0xc6, 0x9d, 0xf7, 0x53, 0x6c, 0x32, 0x55, 0xdc, 0xdb, 0xdb,
	0xb1, 0xfe, 0xdd, 0xd5, 0x7f, 0xec, 0x6d, 0x90, 0xeb, 0xbd, 0xad, 0xdd, 0xd4, 0x47, 0xf6, 0xb0,
	0x87, 0xac, 0x5f, 0x0c, 0xe0, 0x4c, 0x79, 0xfa, 0x0e, 0x8c, 0x34, 0x95, 0x76, 0x46, 0xf4, 0x52,
	0xbf, 0xa5, 0xe9, 0x5d, 0x6e, 0xcb, 0x7b, 0x15, 0x6e, 0x2a, 0x76, 0x3a, 0xf4, 0xba, 0xf1, 0xbc,
	0x15, 0x55, 0xd3, 0xc7, 0xf8, 0xe5, 0x01, 0x22, 0xa6, 0x18, 0xe0, 0xc2, 0xa8, 0x71, 0xb4, 0xa9,
	0x6a, 0xb7, 0x65, 0xfa, 0x23, 0x48, 0x1b, 0xae, 0xae, 0x31, 0x7f, 0xe5, 0x14, 0x63, 0xee, 0xd4,
	0x8d, 0x57, 0x74, 0x51, 0xc7, 0xf8, 0xef, 0xc1, 0x98, 0x29, 0x6f, 0x3d, 0xf0, 0xd5, 0x81, 0x97,
	0x74, 0xa7, 0x70, 0x94, 0x08, 0x5b, 0xcf, 0x7c, 0x1f, 0xc6, 0xc5, 0x7c, 0xb9, 0x82, 0x1d, 0x93,
	0x11, 0xdb, 0x6f, 0x4d, 0xde, 0xca, 0x6f, 0x62, 0xd5, 0x7b, 0xf1, 0x9c, 0x16, 0x9d, 0x65, 0xf4,
	0x07, 0x30, 0xae, 0x13, 0x0b, 0x56, 0xda, 0x99, 0xf0, 0xf2, 0x80, 0x99, 0x70, 0xdc, 0x94, 0xfc,
	0xe2, 0x2b, 0x10, 0x82, 0x01, 0x10, 0xe0, 0x62, 0x86, 0x92, 0x9d, 0x0d, 0xbf, 0x09, 0x23, 0xd6,
	0x48, 0xe9, 0xef, 0x43, 0x6e, 0x90, 0xa1, 0x0a, 0x91, 0x18, 0xdd, 0x54, 0x35, 0xfd, 0xdd, 0xb8,
	0x0b, 0xa3, 0xa6, 0xb3, 0x31, 0x4a, 0xf9, 0x41, 0xdf, 0x0f, 0xa7, 0x1e, 0xac, 0x10, 0x31, 0x32,
	0x3a, 0xf7, 0x60, 0xdc, 0x12, 0xb4, 0xfa, 0x71, 0x6d, 0xf0, 0x54, 0xc9, 0xa9, 0x3a, 0x6d, 0xa8,
	0x5a, 0xdd, 0xf8, 0x3e, 0xa4, 0xf8, 0x1a, 0x12, 0x45, 0xdc, 0xa8, 0x62, 0x6b, 0xed, 0x5d, 0x27,
	0x34, 0xd3, 0x23, 0xa6, 0x36, 0x2c, 0x6b, 0x73, 0x05, 0x6e, 0xe7, 0x4c, 0xbc, 0xbb, 0x84, 0x46,
	0x30, 0x52, 0x95, 0x34, 0xc9, 0x04, 0x4a, 0xe6, 0xda, 0x00, 0x33, 0x74, 0xea, 0xcb, 0x47, 0x31,
	0x37, 0x87, 0x76, 0xce, 0xcf, 0x80, 0x83, 0xba, 0xe8, 0x0e, 0x29, 0x7c, 0xed, 0x37, 0x5f, 0xb7,
	0xc0, 0xaf, 0x61, 0x1c, 0x4e, 0x98, 0x55, 0x8e, 0x67, 0xd8, 0x64, 0x76, 0x15, 0x5e, 0x80, 0x93,
	0xc6, 0x64, 0xa1, 0xd2, 0xb1, 0xdc, 0x3a, 0x9b, 0xcc, 0xad, 0xb2, 0xc9, 0x5c, 0x8e, 0x4d, 0x66,
	0xd7, 0xe0, 0x34, 0x9c, 0xdc, 0x25, 0x83, 0xad, 0xd2, 0x81, 0x6c, 0x16, 0x5e, 0x81, 0xd3, 0x1c,
	0x7e, 0xd0, 0xc4, 0xaa, 0x96, 0x24, 0x3d, 0x42, 0x9f, 0xbb, 0xce, 0x26, 0xd7, 0xd8, 0xe4, 0x35,
	0x36, 0xb9, 0xce, 0x26, 0x33, 0xaf, 0xb2, 0x99, 0xeb, 0x6c, 0x32, 0x9b, 0x81, 0xe7, 0x61, 0xec,
	0x46, 0xe5, 0x10, 0x35, 0x78, 0x5c, 0x31, 0x0d, 0x43, 0x79, 0x36, 0xb3, 0x5e, 0xb8, 0x02, 0xa7,
	0xcd, 0xcc, 0x9a, 0xaf, 0x49, 0x02, 0x8f, 0xe9, 0x73, 0xc7, 0x2d, 0xb0, 0xf8, 0xa4, 0x05, 0x2e,
	0x9f, 0xb4, 0xc0, 0x54, 0xee, 0x1a, 0x9b, 0x65, 0x33, 0xab, 0x6c, 0xae, 0xb0, 0x08, 0xa7, 0x04,
	0xd9, 0xb2, 0x61, 0x8e, 0x5b, 0xe0, 0xe2, 0x37, 0xc6, 0xca, 0x97, 0x38, 0x69, 0x81, 0x70, 0x2e,
	0xc3, 0xe6, 0xb2, 0x6c, 0x26, 0x5b, 0x58, 0x86, 0xd3, 0xe6, 0x4b, 0x68, 0x9a, 0x2e, 0x1c, 0xb7,
	0xc0, 0xcb, 0xa6, 0xe9, 0x92, 0x6e, 0x9a, 0xcf, 0xb0, 0xf9, 0x2c, 0x9b, 0xcf, 0xe9, 0x39, 0x4f,
	0x61, 0x1d, 0xea, 0x19, 0xb0, 0x65, 0xbb, 0x74, 0xdc, 0x02, 0x29, 0xd3, 0xf6, 0x12, 0x91, 0xcd,
	0xb3, 0xb9, 0x35, 0x36, 0x93, 0x7b, 0xdc, 0xb1, 0xae, 0x16, 0xd2, 0xc6, 0xbb, 0xee, 0xf0, 0xd5,
	0xeb, 0xc9, 0x99, 0xbe, 0x59, 0xdd, 0x77, 0x2d, 0xc3, 0xae, 0x65, 0xd9, 0x35, 0x52, 0x4f, 0x29,
	0x14, 0xbe, 0x4c, 0x2d, 0x96, 0x42, 0xe1, 0x08, 0x15, 0x2d, 0x85, 0xc2, 0x09, 0xea, 0x62, 0x29,
	0x14, 0x5e, 0xa2, 0x5e, 0x2e, 0x85, 0xc2, 0x97, 0xa8, 0x54, 0x29, 0x14, 0xce, 0x52, 0xb9, 0x52,
	0x28, 0x3c, 0x43, 0xd1, 0xa5, 0x50, 0xf8, 0x79, 0x6a, 0xa1, 0x14, 0x0a, 0xbf, 0x40, 0x25, 0x52,
	0x7f, 0x61, 0x60, 0x6c, 0x43, 0xc1, 0x48, 0xc3, 0x36, 0x31, 0x5f, 0x3f, 0x2d, 0x31, 0xdb, 0x9c,
	0x7c, 0xc9, 0x83, 0x93, 0x3b, 0xd8, 0xf8, 0xed, 0xa1, 0xd9, 0xd8, 0x03, 0x88, 0x37, 0x87, 0x03,
	0xe2, 0xb3, 0x23, 0xe0, 0x1b, 0xc3, 0x12, 0x70, 0x9b, 0x7a, 0xb9, 0x33, 0xa1, 0xde, 0x9f, 0x92,
	0x74, 0x6f, 0x0e, 0x4f, 0xba, 0x2e, 0xc0, 0xbd, 0xdf, 0x0f, 0x70, 0xaf, 0xfc, 0xf7, 0xbc, 0x17,
	0xa9, 0x02, 0xff, 0x7f, 0x41, 0xb9, 0xbb, 0xa3, 0x53, 0x6e, 0x37, 0xdc, 0x16, 0x47, 0x80, 0x5b,
	0x37, 0xd3, 0x6e, 0x0f, 0xcb, 0xb4, 0xde, 0x34, 0x7b, 0x6b, 0x78, 0x9a, 0x75, 0xd3, 0xeb, 0xce,
	0xa8, 0xf4, 0xda, 0x45, 0xab, 0x6f, 0x0c, 0x41, 0xab, 0x4e, 0x46, 0xdd, 0x1c, 0x92, 0x51, 0xdd,
	0x74, 0xba, 0xdd, 0x83, 0x4e, 0x07, 0x0c, 0xf9, 0x4e, 0x44, 0x7d, 0xf3, 0xf4, 0x88, 0xea, 0x06,
	0xd0, 0xfb, 0x7d, 0x01, 0x74, 0xd0, 0x56, 0x79, 0xc1, 0x67, 0xf5, 0xac, 0xd9, 0xb3, 0x17, 0x5c,
	0x7e, 0x34, 0x1a, 0xed, 0xf9, 0x90, 0x77, 0x26, 0x90, 0x77, 0xde, 0x0d, 0x79, 0x36, 0x93, 0xbd,
	0x35, 0x34, 0x93, 0xb9, 0x50, 0x2c, 0x3f, 0x28, 0x8a, 0xb9, 0x08, 0x6c, 0x6f, 0x64, 0x02, 0xf3,
	0x02, 0xaf, 0xb7, 0x47, 0x00, 0xaf, 0x2e, 0xde, 0xba, 0x3b, 0x2a, 0x6f, 0x75, 0x62, 0xd6, 0xed,
	0xa1, 0x31, 0xab, 0x8b, 0xaa, 0xd6, 0x07, 0xa6, 0x2a, 0x37, 0x4c, 0xdd, 0x1c, 0x16, 0xa6, 0x3a,
	0x18, 0xea, 0xce, 0x48, 0x0c, 0xd5, 0x8d, 0x4e, 0x3b, 0x23, 0xa2, 0x53, 0x37, 0x31, 0xbd, 0x7e,
	0x6a, 0x62, 0x72, 0xd1, 0xd0, 0xcc, 0x3f, 0xde, 0xe8, 0xf8, 0x2f, 0xaa, 0x42, 0xaa, 0x93, 0x4f,
	0x66, 0x1e, 0x3f, 0x03, 0xee, 0x5b, 0x85, 0x79, 0x27, 0x9b, 0x4c, 0x3f, 0x7e, 0x06, 0xda, 0x97,
	0xba, 0xbf, 0x1b, 0x48, 0x88, 0xbf, 0xeb, 0x56, 0x61, 0xc1, 0x45, 0x21, 0xb1, 0xc7, 0xcf, 0x80,
	0xe3, 0xba, 0x70, 0xb9, 0x8b, 0x35, 0xe8, 0xc7, 0xcf, 0x40, 0xc7, 0x3d, 0x9b, 0x2d, 0x66, 0x28,
	0x3a, 0xf5, 0x57, 0x06, 0xc6, 0x39, 0x2c, 0x8b, 0x88, 0xf7, 0xc1, 0xc1, 0x07, 0x07, 0x1f, 0x1c,
	0x7c, 0x70, 0xf0, 0xc1, 0xc1, 0x07, 0x07, 0x1f, 0x1c, 0x7c, 0x70, 0xf0, 0xc1, 0xc1, 0x07, 0x07,
	0x1f, 0x1c, 0x7c, 0x70, 0xe8, 0x01, 0x0e, 0x7f, 0x66, 0x60, 0xe4, 0x16, 0xd6, 0x7c, 0x68, 0xf0,
	0xa1, 0xc1, 0x87, 0x06, 0x1f, 0x1a, 0x7c, 0x68, 0xf0, 0xa1, 0xc1, 0x87, 0x06, 0x1f, 0x1a, 0x7c,
	0x68, 0xf0, 0xa1, 0xc1, 0x87, 0x06, 0x1f, 0x1a, 0xbc, 0xa1, 0xe1, 0x5f, 0x14, 0x9c, 0xb1, 0xbb,
	0x4a, 0x47, 0x01, 0xfd, 0x69, 0xe8, 0x0d, 0x38, 0x53, 0x11, 0x54, 0xb4, 0x2f, 0xe2, 0xb2, 0xdd,
	0x6d, 0x04, 0x03, 0x7a, 0xcf, 0x27, 0x94, 0xe9, 0x60, 0x8b, 0xd1, 0xef, 0xc1, 0xe7, 0x71, 0x83,
	0x68, 0x7c, 0x8c, 0x0e, 0x91, 0xca, 0x2b, 0x82, 0xac, 0x39, 0xe4, 0x82, 0x7d, 0xe5, 0x2e, 0x18,
	0xae, 0x25, 0xdb, 0xb3, 0xad, 0xbb, 0x03, 0x19, 0x53, 0x97, 0x47, 0xb2, 0xc6, 0xd7, 0x90, 0x43,
	0x34, 0xd4, 0x57, 0xf4, 0xbc, 0xe1, 0xb7, 0x61, 0xb8, 0xb5, 0x15, 0xbb, 0x57, 0xf6, 0xf1, 0x51,
	0x56, 0x76, 0x0b, 0x44, 0x26, 0x46, 0x3a, 0xf8, 0x33, 0x79, 0x06, 0x07, 0x7f, 0xce, 0x16, 0x20,
	0x1e, 0xf4, 0x4e, 0x0b, 0xe0, 0x70, 0x1b, 0xe0, 0xc3, 0xd6, 0x06, 0xf8, 0x5e, 0x09, 0x42, 0xe7,
	0xc9, 0xa5, 0xc8, 0x19, 0x9f, 0x5c, 0xea, 0x3c, 0x2b, 0x11, 0x1d, 0xe1, 0xac, 0x44, 0xe7, 0xe1,
	0x93, 0xe9, 0x9f, 0xf0, 0xf0, 0x49, 0xec, 0x6c, 0x0f, 0x9f, 0xfc, 0xcc, 0x95, 0x38, 0x50, 0x7d,
	0x36, 0xfc, 0x92, 0xe7, 0x2e, 0x06, 0x9d, 0xe9, 0x43, 0xde, 0xfd, 0xb5, 0x60, 0x86, 0x9c, 0xe1,
	0x9b, 0x71, 0xee, 0x5c, 0x35, 0x8e, 0xf2, 0x05, 0x5d, 0x1f, 0x10, 0xee, 0x77, 0x7f, 0x40, 0xa0,
	0x07, 0xdc, 0xc0, 0x1c, 0x39, 0x36, 0x76, 0x2f, 0x07, 0x21, 0xd0, 0x55, 0x3b, 0xbf, 0x26, 0x7c,
	0xe8, 0xcd, 0xa7, 0xb3, 0xa7, 0x3d, 0x05, 0x52, 0x0c, 0x7a, 0x31, 0x6a, 0x2f, 0xea, 0x9a, 0x1b,
	0x8e, 0xba, 0xfe, 0xb7, 0x29, 0xaa, 0x1b, 0xb8, 0x2f, 0x0d, 0x09, 0xdc, 0x8e, 0x44, 0xb7, 0x7f,
	0x76, 0xe7, 0x95, 0xe8, 0xbe, 0x32, 0x70, 0x82, 0x11, 0x68, 0x27, 0xba, 0x1d, 0x88, 0x7f, 0xf5,
	0x14, 0x99, 0x45, 0xc0, 0x89, 0xf8, 0xaf, 0x1d, 0x76, 0xad, 0xe2, 0x5f, 0xb7, 0x00, 0x82, 0x11,
	0x7b, 0x4b, 0x35, 0xc8, 0xc0, 0xf3, 0xed, 0xed, 0xd4, 0x91, 0xdc, 0x2a, 0x9b, 0x5f, 0x65, 0x33,
	0x6b, 0x6c, 0x66, 0x15, 0x5e, 0xee, 0xdc, 0x3c, 0x3d, 0xbb, 0xc6, 0xae, 0xb3, 0xd7, 0xd8, 0xeb,
	0x6c, 0x26, 0xc3, 0x66, 0xb2, 0x6c, 0x26, 0xc7, 0x66, 0xf2, 0x70, 0xae, 0x6b, 0xeb, 0x74, 0x20,
	0xbb, 0x5a, 0x58, 0xec, 0x4e, 0x67, 0xe8, 0x99, 0xe3, 0x16, 0x08, 0x90, 0xd3, 0x40, 0x2d, 0x30,
	0x9e, 0x65, 0x73, 0x6c, 0xbe, 0x90, 0x75, 0x66, 0x0b, 0x8b, 0xde, 0xfb, 0xa6, 0x73, 0x39, 0x77,
	0x16, 0x91, 0x77, 0x65, 0x08, 0x57, 0x7a, 0xed, 0xa0, 0xee, 0xc8, 0x1c, 0xae, 0x75, 0xe6, 0x2e,
	0xba, 0x23, 0x65, 0x3a, 0xc6, 0xf5, 0x16, 0x65, 0xd6, 0xd9, 0xcc, 0xf5, 0xae, 0x84, 0xa6, 0x14,
	0x0a, 0x03, 0x2a, 0xd0, 0xb1, 0x2d, 0x7a, 0x8a, 0x82, 0xa5, 0x50, 0x38, 0x4e, 0x51, 0xa9, 0x3f,
	0x8e, 0xc3, 0x59, 0xae, 0xcd, 0xac, 0x76, 0x82, 0x71, 0x13, 0xce, 0x1a, 0x78, 0x57, 0x76, 0x31,
	0x70, 0xff, 0x9c, 0x60, 0xc6, 0x70, 0x71, 0xe8, 0xd1, 0x9b, 0x90, 0x46, 0xb2, 0x2c, 0x1e, 0xb9,
	0x65, 0xfa, 0x67, 0x01, 0x14, 0xf1, 0x70, 0xaa, 0x60, 0x38, 0xcb, 0x37, 0x55, 0x4d, 0xaa, 0xbb,
	0x65, 0xc6, 0x3d, 0x43, 0x93, 0x9c, 0x8d, 0xee, 0xd8, 0xb8, 0x1f, 0xef, 0x38, 0xa8, 0x46, 0x3e,
	0x6f, 0x11, 0x45, 0x67, 0x35, 0x1d, 0xab, 0xf1, 0xc4, 0x68, 0xab, 0xb1, 0x95, 0x65, 0x84, 0x4f,
	0x9f, 0x65, 0xdc, 0x6b, 0x67, 0x19, 0x53, 0xa7, 0xcb, 0x32, 0xe6, 0x3c, 0x8f, 0x0c, 0xd9, 0xf9,
	0x46, 0x77, 0x22, 0x05, 0x47, 0x48, 0xa4, 0x5e, 0xfb, 0xb9, 0xd7, 0xdb, 0x79, 0xd5, 0xf9, 0x76,
	0x66, 0xe1, 0x02, 0xa4, 0x88, 0x79, 0x72, 0x47, 0xc1, 0x15, 0x81, 0x47, 0x1a, 0x56, 0xe9, 0xf0,
	0x3a, 0x9b, 0x59, 0x65, 0xaf, 0xb3, 0xaf, 0xea, 0x29, 0xb5, 0xf1, 0x76, 0xd9, 0x29, 0xf5, 0x71,
	0x0b, 0x04, 0x9f, 0xb4, 0x40, 0x40, 0x0f, 0xe9, 0x1c, 0x9b, 0x67, 0xd7, 0x4a, 0xa1, 0x70, 0x80,
	0x0a, 0x96, 0x42, 0xe1, 0x49, 0x2a, 0x5c, 0xf8, 0x1d, 0x78, 0xf2, 0x7d, 0x62, 0xec, 0xdb, 0xef,
	0x13, 0x63, 0x4f, 0xbf, 0x4f, 0x80, 0xcf, 0x4e, 0x12, 0xe0, 0x0f, 0x27, 0x09, 0xf0, 0xcd, 0x49,
	0x02, 0x3c, 0x39, 0x49, 0x80, 0x6f, 0x4f, 0x12, 0xe0, 0xbb, 0x93, 0x04, 0xf8, 0xf1, 0x24, 0x31,
	0xf6, 0xf4, 0x24, 0x01, 0x7e, 0xff, 0x43, 0x62, 0xec, 0xf8, 0x87, 0x04, 0xf8, 0xe0, 0x5e, 0x55,
	0x92, 0x3f, 0xa9, 0xa6, 0x0f, 0x25, 0x51, 0xc3, 0x8a, 0x82, 0xd2, 0x4d, 0x75, 0x85, 0xfc, 0x38,
	0x90, 0x94, 0xfa, 0xb2, 0xac, 0x48, 0x87, 0x42, 0x05, 0x2b, 0xcb, 0x56, 0xf1, 0x8a, 0xbc, 0x5f,
	0x95, 0x56, 0xf0, 0xa7, 0x9a, 0xf5, 0x97, 0x0a, 0x7a, 0xfe, 0xc1, 0x82, 0xfd, 0x09, 0xb2, 0x8e,
	0xe4, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0x77, 0x1c, 0x4d, 0xa1, 0xdc, 0x40, 0x00, 0x00,
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/waf_rules/types.proto

package waf_rules

import (
	fmt "fmt"

	proto "github.com/gogo/protobuf/proto"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	_ "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	_ "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	_ "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema_waf_rule_list "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema/waf_rule_list"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// SeverityType
//
// x-displayName: "Severity"
// Rule severity as defined in the rule
type SeverityType int32

const (
	// x-displayName: "Emergency"
	// Emergency Level
	EMERGENCY SeverityType = 0
	// x-displayName: "Alert"
	// Alert Level
	ALERT SeverityType = 1
	// x-displayName: "Critical"
	// Critical Level
	CRITICAL SeverityType = 2
	// x-displayName: "Error"
	// Error Level
	ERROR SeverityType = 3
	// x-displayName: "Warning"
	// Warning Level
	WARNING SeverityType = 4
	// x-displayName: "Notice"
	// Notice Level
	NOTICE SeverityType = 5
	// x-displayName: "Info"
	// Info Level
	INFO SeverityType = 6
	// x-displayName: "Debug"
	// Debug Level
	DEBUG SeverityType = 7
)

var SeverityType_name = map[int32]string{
	0: "EMERGENCY",
	1: "ALERT",
	2: "CRITICAL",
	3: "ERROR",
	4: "WARNING",
	5: "NOTICE",
	6: "INFO",
	7: "DEBUG",
}
var SeverityType_value = map[string]int32{
	"EMERGENCY": 0,
	"ALERT":     1,
	"CRITICAL":  2,
	"ERROR":     3,
	"WARNING":   4,
	"NOTICE":    5,
	"INFO":      6,
	"DEBUG":     7,
}

func (SeverityType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// RuleModeType
//
// x-displayName: "Rule Mode"
// Specify whether rule is to be included or excluded.
type RuleModeType int32

const (
	// x-displayName: "Exclude"
	// Exclude
	EXCLUDE RuleModeType = 0
	// x-displayName: "Include"
	// Include
	INCLUDE RuleModeType = 1
)

var RuleModeType_name = map[int32]string{
	0: "EXCLUDE",
	1: "INCLUDE",
}
var RuleModeType_value = map[string]int32{
	"EXCLUDE": 0,
	"INCLUDE": 1,
}

func (RuleModeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// Rule
//
// x-displayName: "Rule"
// Every WAF rule will have these properties associated
type Rules struct {
	// mode
	//
	// x-displayName: "Mode"
	// Whether the Rule is excluded or included
	Mode RuleModeType `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"mode,omitempty"`
	// id
	//
	// x-displayName: "ID"
	// x-example: "941210"
	// WAF rule ID which is a unique ID with in waf_rules object.
	// Generated alerts will have the id displayed in alert.
	Id uint32 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "IE XSS Filters - Attack Detected."
	// This is the brief description of the rule.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// tags
	//
	// x-displayName: "Tags"
	// x-example: "["attack-sqli", "attack-protocol"]"
	// Tags are a set of string labels associated with a rule. For eg a particular rule may be under
	// "attack-sqli" and "attack-protocol" tags. This is used by user to find out Tags associated with a
	// Rule.
	Tags []string `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
	// severity
	//
	// x-displayName: "Severity"
	// Severity of the rule.
	Severity SeverityType `protobuf:"varint,5,opt,name=severity,proto3,enum=ves.io.schema.waf_rules.SeverityType" json:"severity,omitempty"`
}

func (m *Rules) Reset()                    { *m = Rules{} }
func (*Rules) ProtoMessage()               {}
func (*Rules) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *Rules) GetMode() RuleModeType {
	if m != nil {
		return m.Mode
	}
	return EXCLUDE
}

func (m *Rules) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Rules) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Rules) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Rules) GetSeverity() SeverityType {
	if m != nil {
		return m.Severity
	}
	return EMERGENCY
}

// GlobalSpecType
//
// x-displayName: "Specification"
type GlobalSpecType struct {
	// mode
	//
	// x-displayName: "Mode"
	// x-required
	// WAF Mode is blocking or Alert
	Mode ves_io_schema4.WafModeType `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	// anomaly_score_threshold
	//
	// x-displayName: "Anomaly Score Threshold"
	// x-example: "4"
	// x-required
	// If anomaly score is same or above threshold , the req/resp will be blocked/alerted (depending
	// on non_blocking_mode configuration)
	AnomalyScoreThreshold uint32 `protobuf:"varint,2,opt,name=anomaly_score_threshold,json=anomalyScoreThreshold,proto3" json:"anomaly_score_threshold,omitempty"`
	// paranoia_level
	//
	// x-displayName: "Paranoia Level"
	// x-required
	// x-example: "2"
	// Paranoia level
	ParanoiaLevel uint32 `protobuf:"varint,3,opt,name=paranoia_level,json=paranoiaLevel,proto3" json:"paranoia_level,omitempty"`
	// rule_ids
	//
	// x-displayName: "Rule IDs"
	// x-example: "[941210, 941310]"
	// rule IDs to be included or excluded in this WAF instance
	RuleIds []ves_io_schema_waf_rule_list.WafRuleID `protobuf:"varint,4,rep,packed,name=rule_ids,json=ruleIds,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"rule_ids,omitempty"`
	// rule_list_type
	//
	// x-displayName: "Rule List Type"
	// x-required
	// Specify whether the defined rule_ids list is to be included or excluded from associated WAF instance
	RuleListType RuleModeType `protobuf:"varint,5,opt,name=rule_list_type,json=ruleListType,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"rule_list_type,omitempty"`
	// waf
	//
	// x-displayName: "WAF"
	// A reference to WAF object
	Waf []*ves_io_schema4.ObjectRefType `protobuf:"bytes,6,rep,name=waf" json:"waf,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *GlobalSpecType) GetMode() ves_io_schema4.WafModeType {
	if m != nil {
		return m.Mode
	}
	return ves_io_schema4.BLOCK
}

func (m *GlobalSpecType) GetAnomalyScoreThreshold() uint32 {
	if m != nil {
		return m.AnomalyScoreThreshold
	}
	return 0
}

func (m *GlobalSpecType) GetParanoiaLevel() uint32 {
	if m != nil {
		return m.ParanoiaLevel
	}
	return 0
}

func (m *GlobalSpecType) GetRuleIds() []ves_io_schema_waf_rule_list.WafRuleID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *GlobalSpecType) GetRuleListType() RuleModeType {
	if m != nil {
		return m.RuleListType
	}
	return EXCLUDE
}

func (m *GlobalSpecType) GetWaf() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Waf
	}
	return nil
}

// Create WAF Rules
//
// x-displayName: "Create WAF Rules Object"
// Create App type will create the configuration in namespace metadata.namespace
type CreateSpecType struct {
	Mode                  ves_io_schema4.WafModeType              `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	AnomalyScoreThreshold uint32                                  `protobuf:"varint,2,opt,name=anomaly_score_threshold,json=anomalyScoreThreshold,proto3" json:"anomaly_score_threshold,omitempty"`
	ParanoiaLevel         uint32                                  `protobuf:"varint,3,opt,name=paranoia_level,json=paranoiaLevel,proto3" json:"paranoia_level,omitempty"`
	RuleIds               []ves_io_schema_waf_rule_list.WafRuleID `protobuf:"varint,4,rep,packed,name=rule_ids,json=ruleIds,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"rule_ids,omitempty"`
	RuleListType          RuleModeType                            `protobuf:"varint,5,opt,name=rule_list_type,json=ruleListType,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"rule_list_type,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *CreateSpecType) GetMode() ves_io_schema4.WafModeType {
	if m != nil {
		return m.Mode
	}
	return ves_io_schema4.BLOCK
}

func (m *CreateSpecType) GetAnomalyScoreThreshold() uint32 {
	if m != nil {
		return m.AnomalyScoreThreshold
	}
	return 0
}

func (m *CreateSpecType) GetParanoiaLevel() uint32 {
	if m != nil {
		return m.ParanoiaLevel
	}
	return 0
}

func (m *CreateSpecType) GetRuleIds() []ves_io_schema_waf_rule_list.WafRuleID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *CreateSpecType) GetRuleListType() RuleModeType {
	if m != nil {
		return m.RuleListType
	}
	return EXCLUDE
}

// Replace WAF Rules
//
// x-displayName: "Replace WAF Rules Object"
// Update the configuration by replacing the existing spec with the provided one.
// For read-then-write operations a resourceVersion mismatch will occur if the object was modified between the read and write.
type ReplaceSpecType struct {
	Mode                  ves_io_schema4.WafModeType              `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	AnomalyScoreThreshold uint32                                  `protobuf:"varint,2,opt,name=anomaly_score_threshold,json=anomalyScoreThreshold,proto3" json:"anomaly_score_threshold,omitempty"`
	ParanoiaLevel         uint32                                  `protobuf:"varint,3,opt,name=paranoia_level,json=paranoiaLevel,proto3" json:"paranoia_level,omitempty"`
	RuleIds               []ves_io_schema_waf_rule_list.WafRuleID `protobuf:"varint,4,rep,packed,name=rule_ids,json=ruleIds,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"rule_ids,omitempty"`
	RuleListType          RuleModeType                            `protobuf:"varint,5,opt,name=rule_list_type,json=ruleListType,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"rule_list_type,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *ReplaceSpecType) GetMode() ves_io_schema4.WafModeType {
	if m != nil {
		return m.Mode
	}
	return ves_io_schema4.BLOCK
}

func (m *ReplaceSpecType) GetAnomalyScoreThreshold() uint32 {
	if m != nil {
		return m.AnomalyScoreThreshold
	}
	return 0
}

func (m *ReplaceSpecType) GetParanoiaLevel() uint32 {
	if m != nil {
		return m.ParanoiaLevel
	}
	return 0
}

func (m *ReplaceSpecType) GetRuleIds() []ves_io_schema_waf_rule_list.WafRuleID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *ReplaceSpecType) GetRuleListType() RuleModeType {
	if m != nil {
		return m.RuleListType
	}
	return EXCLUDE
}

// Get WAF Rules
//
// x-displayName: "Get WAF Rules"
// Get App type will read the configuration from namespace metadata.namespace
type GetSpecType struct {
	Mode                  ves_io_schema4.WafModeType              `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	AnomalyScoreThreshold uint32                                  `protobuf:"varint,2,opt,name=anomaly_score_threshold,json=anomalyScoreThreshold,proto3" json:"anomaly_score_threshold,omitempty"`
	ParanoiaLevel         uint32                                  `protobuf:"varint,3,opt,name=paranoia_level,json=paranoiaLevel,proto3" json:"paranoia_level,omitempty"`
	RuleIds               []ves_io_schema_waf_rule_list.WafRuleID `protobuf:"varint,4,rep,packed,name=rule_ids,json=ruleIds,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"rule_ids,omitempty"`
	RuleListType          RuleModeType                            `protobuf:"varint,5,opt,name=rule_list_type,json=ruleListType,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"rule_list_type,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *GetSpecType) GetMode() ves_io_schema4.WafModeType {
	if m != nil {
		return m.Mode
	}
	return ves_io_schema4.BLOCK
}

func (m *GetSpecType) GetAnomalyScoreThreshold() uint32 {
	if m != nil {
		return m.AnomalyScoreThreshold
	}
	return 0
}

func (m *GetSpecType) GetParanoiaLevel() uint32 {
	if m != nil {
		return m.ParanoiaLevel
	}
	return 0
}

func (m *GetSpecType) GetRuleIds() []ves_io_schema_waf_rule_list.WafRuleID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *GetSpecType) GetRuleListType() RuleModeType {
	if m != nil {
		return m.RuleListType
	}
	return EXCLUDE
}

func init() {
	proto.RegisterType((*Rules)(nil), "ves.io.schema.waf_rules.Rules")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.waf_rules.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.waf_rules.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.waf_rules.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.waf_rules.GetSpecType")
	proto.RegisterEnum("ves.io.schema.waf_rules.SeverityType", SeverityType_name, SeverityType_value)
	proto.RegisterEnum("ves.io.schema.waf_rules.RuleModeType", RuleModeType_name, RuleModeType_value)
}
func (x SeverityType) String() string {
	s, ok := SeverityType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RuleModeType) String() string {
	s, ok := RuleModeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Rules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rules)
	if !ok {
		that2, ok := that.(Rules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.Severity != that1.Severity {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.AnomalyScoreThreshold != that1.AnomalyScoreThreshold {
		return false
	}
	if this.ParanoiaLevel != that1.ParanoiaLevel {
		return false
	}
	if len(this.RuleIds) != len(that1.RuleIds) {
		return false
	}
	for i := range this.RuleIds {
		if this.RuleIds[i] != that1.RuleIds[i] {
			return false
		}
	}
	if this.RuleListType != that1.RuleListType {
		return false
	}
	if len(this.Waf) != len(that1.Waf) {
		return false
	}
	for i := range this.Waf {
		if !this.Waf[i].Equal(that1.Waf[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.AnomalyScoreThreshold != that1.AnomalyScoreThreshold {
		return false
	}
	if this.ParanoiaLevel != that1.ParanoiaLevel {
		return false
	}
	if len(this.RuleIds) != len(that1.RuleIds) {
		return false
	}
	for i := range this.RuleIds {
		if this.RuleIds[i] != that1.RuleIds[i] {
			return false
		}
	}
	if this.RuleListType != that1.RuleListType {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.AnomalyScoreThreshold != that1.AnomalyScoreThreshold {
		return false
	}
	if this.ParanoiaLevel != that1.ParanoiaLevel {
		return false
	}
	if len(this.RuleIds) != len(that1.RuleIds) {
		return false
	}
	for i := range this.RuleIds {
		if this.RuleIds[i] != that1.RuleIds[i] {
			return false
		}
	}
	if this.RuleListType != that1.RuleListType {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.AnomalyScoreThreshold != that1.AnomalyScoreThreshold {
		return false
	}
	if this.ParanoiaLevel != that1.ParanoiaLevel {
		return false
	}
	if len(this.RuleIds) != len(that1.RuleIds) {
		return false
	}
	for i := range this.RuleIds {
		if this.RuleIds[i] != that1.RuleIds[i] {
			return false
		}
	}
	if this.RuleListType != that1.RuleListType {
		return false
	}
	return true
}
func (this *Rules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&waf_rules.Rules{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	s = append(s, "Severity: "+fmt.Sprintf("%#v", this.Severity)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&waf_rules.GlobalSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AnomalyScoreThreshold: "+fmt.Sprintf("%#v", this.AnomalyScoreThreshold)+",\n")
	s = append(s, "ParanoiaLevel: "+fmt.Sprintf("%#v", this.ParanoiaLevel)+",\n")
	s = append(s, "RuleIds: "+fmt.Sprintf("%#v", this.RuleIds)+",\n")
	s = append(s, "RuleListType: "+fmt.Sprintf("%#v", this.RuleListType)+",\n")
	if this.Waf != nil {
		s = append(s, "Waf: "+fmt.Sprintf("%#v", this.Waf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&waf_rules.CreateSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AnomalyScoreThreshold: "+fmt.Sprintf("%#v", this.AnomalyScoreThreshold)+",\n")
	s = append(s, "ParanoiaLevel: "+fmt.Sprintf("%#v", this.ParanoiaLevel)+",\n")
	s = append(s, "RuleIds: "+fmt.Sprintf("%#v", this.RuleIds)+",\n")
	s = append(s, "RuleListType: "+fmt.Sprintf("%#v", this.RuleListType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&waf_rules.ReplaceSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AnomalyScoreThreshold: "+fmt.Sprintf("%#v", this.AnomalyScoreThreshold)+",\n")
	s = append(s, "ParanoiaLevel: "+fmt.Sprintf("%#v", this.ParanoiaLevel)+",\n")
	s = append(s, "RuleIds: "+fmt.Sprintf("%#v", this.RuleIds)+",\n")
	s = append(s, "RuleListType: "+fmt.Sprintf("%#v", this.RuleListType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&waf_rules.GetSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AnomalyScoreThreshold: "+fmt.Sprintf("%#v", this.AnomalyScoreThreshold)+",\n")
	s = append(s, "ParanoiaLevel: "+fmt.Sprintf("%#v", this.ParanoiaLevel)+",\n")
	s = append(s, "RuleIds: "+fmt.Sprintf("%#v", this.RuleIds)+",\n")
	s = append(s, "RuleListType: "+fmt.Sprintf("%#v", this.RuleListType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Rules) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rules) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Severity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Severity))
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		dAtA2 := make([]byte, len(m.RuleIds)*10)
		var j1 int
		for _, num := range m.RuleIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.RuleListType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RuleListType))
	}
	if len(m.Waf) > 0 {
		for _, msg := range m.Waf {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		dAtA4 := make([]byte, len(m.RuleIds)*10)
		var j3 int
		for _, num := range m.RuleIds {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.RuleListType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RuleListType))
	}
	return i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		dAtA6 := make([]byte, len(m.RuleIds)*10)
		var j5 int
		for _, num := range m.RuleIds {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.RuleListType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RuleListType))
	}
	return i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		dAtA8 := make([]byte, len(m.RuleIds)*10)
		var j7 int
		for _, num := range m.RuleIds {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.RuleListType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.RuleListType))
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedRules(r randyTypes, easy bool) *Rules {
	this := &Rules{}
	this.Mode = RuleModeType([]int32{0, 1}[r.Intn(2)])
	this.Id = uint32(r.Uint32())
	this.Description = string(randStringTypes(r))
	v1 := r.Intn(10)
	this.Tags = make([]string, v1)
	for i := 0; i < v1; i++ {
		this.Tags[i] = string(randStringTypes(r))
	}
	this.Severity = SeverityType([]int32{0, 1, 2, 3, 4, 5, 6, 7}[r.Intn(8)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	this.Mode = ves_io_schema4.WafModeType([]int32{0, 1}[r.Intn(2)])
	this.AnomalyScoreThreshold = uint32(r.Uint32())
	this.ParanoiaLevel = uint32(r.Uint32())
	v2 := r.Intn(10)
	this.RuleIds = make([]ves_io_schema_waf_rule_list.WafRuleID, v2)
	for i := 0; i < v2; i++ {
		this.RuleIds[i] = ves_io_schema_waf_rule_list.WafRuleID([]int32{0, 910000, 910100, 910150, 910160, 910170, 910180, 911100, 912120, 913100, 913101, 913102, 913110, 913120, 920100, 920120, 920121, 920130, 920140, 920160, 920170, 920171, 920180, 920190, 920200, 920201, 920202, 920210, 920220, 920230, 920240, 920250, 920260, 920270, 920271, 920272, 920273, 920274, 920341, 920350, 920360, 920370, 920380, 920390, 920400, 920410, 920420, 920430, 920440, 920450, 920460, 920470, 920480, 921110, 921120, 921130, 921140, 921150, 921151, 921160, 930100, 930110, 930120, 930130, 931100, 931110, 931120, 931130, 932100, 932105, 932106, 932110, 932115, 932120, 932130, 932140, 932150, 932160, 932170, 932171, 932180, 932190, 933100, 933110, 933111, 933120, 933130, 933131, 933140, 933150, 933151, 933160, 933161, 933170, 933180, 933190, 941100, 941101, 941110, 941120, 941130, 941140, 941150, 941160, 941170, 941180, 941190, 941200, 941210, 941220, 941230, 941240, 941250, 941260, 941270, 941280, 941290, 941300, 941310, 941320, 941330, 941340, 941350, 942100, 942110, 942120, 942130, 942140, 942150, 942160, 942170, 942180, 942190, 942200, 942210, 942220, 942230, 942240, 942250, 942251, 942260, 942270, 942280, 942290, 942300, 942310, 942320, 942330, 942340, 942350, 942360, 942361, 942370, 942380, 942390, 942400, 942410, 942420, 942421, 942430, 942431, 942432, 942440, 942450, 942460, 942470, 942480, 942490, 943100, 943110, 943120, 944100, 944110, 944120, 944130, 944200, 944210, 944240, 944250, 944300, 950100, 950130, 951110, 951120, 951130, 951140, 951150, 951160, 951170, 951180, 951190, 951200, 951210, 951220, 951230, 951240, 951250, 951260, 952100, 952110, 953100, 953110, 953120, 954100, 954110, 954120, 954130, 4295001, 4295002, 4295003, 4295004, 4295005, 4295006}[r.Intn(213)])
	}
	this.RuleListType = RuleModeType([]int32{0, 1}[r.Intn(2)])
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Waf = make([]*ves_io_schema4.ObjectRefType, v3)
		for i := 0; i < v3; i++ {
			this.Waf[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	this.Mode = ves_io_schema4.WafModeType([]int32{0, 1}[r.Intn(2)])
	this.AnomalyScoreThreshold = uint32(r.Uint32())
	this.ParanoiaLevel = uint32(r.Uint32())
	v4 := r.Intn(10)
	this.RuleIds = make([]ves_io_schema_waf_rule_list.WafRuleID, v4)
	for i := 0; i < v4; i++ {
		this.RuleIds[i] = ves_io_schema_waf_rule_list.WafRuleID([]int32{0, 910000, 910100, 910150, 910160, 910170, 910180, 911100, 912120, 913100, 913101, 913102, 913110, 913120, 920100, 920120, 920121, 920130, 920140, 920160, 920170, 920171, 920180, 920190, 920200, 920201, 920202, 920210, 920220, 920230, 920240, 920250, 920260, 920270, 920271, 920272, 920273, 920274, 920341, 920350, 920360, 920370, 920380, 920390, 920400, 920410, 920420, 920430, 920440, 920450, 920460, 920470, 920480, 921110, 921120, 921130, 921140, 921150, 921151, 921160, 930100, 930110, 930120, 930130, 931100, 931110, 931120, 931130, 932100, 932105, 932106, 932110, 932115, 932120, 932130, 932140, 932150, 932160, 932170, 932171, 932180, 932190, 933100, 933110, 933111, 933120, 933130, 933131, 933140, 933150, 933151, 933160, 933161, 933170, 933180, 933190, 941100, 941101, 941110, 941120, 941130, 941140, 941150, 941160, 941170, 941180, 941190, 941200, 941210, 941220, 941230, 941240, 941250, 941260, 941270, 941280, 941290, 941300, 941310, 941320, 941330, 941340, 941350, 942100, 942110, 942120, 942130, 942140, 942150, 942160, 942170, 942180, 942190, 942200, 942210, 942220, 942230, 942240, 942250, 942251, 942260, 942270, 942280, 942290, 942300, 942310, 942320, 942330, 942340, 942350, 942360, 942361, 942370, 942380, 942390, 942400, 942410, 942420, 942421, 942430, 942431, 942432, 942440, 942450, 942460, 942470, 942480, 942490, 943100, 943110, 943120, 944100, 944110, 944120, 944130, 944200, 944210, 944240, 944250, 944300, 950100, 950130, 951110, 951120, 951130, 951140, 951150, 951160, 951170, 951180, 951190, 951200, 951210, 951220, 951230, 951240, 951250, 951260, 952100, 952110, 953100, 953110, 953120, 954100, 954110, 954120, 954130, 4295001, 4295002, 4295003, 4295004, 4295005, 4295006}[r.Intn(213)])
	}
	this.RuleListType = RuleModeType([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	this.Mode = ves_io_schema4.WafModeType([]int32{0, 1}[r.Intn(2)])
	this.AnomalyScoreThreshold = uint32(r.Uint32())
	this.ParanoiaLevel = uint32(r.Uint32())
	v5 := r.Intn(10)
	this.RuleIds = make([]ves_io_schema_waf_rule_list.WafRuleID, v5)
	for i := 0; i < v5; i++ {
		this.RuleIds[i] = ves_io_schema_waf_rule_list.WafRuleID([]int32{0, 910000, 910100, 910150, 910160, 910170, 910180, 911100, 912120, 913100, 913101, 913102, 913110, 913120, 920100, 920120, 920121, 920130, 920140, 920160, 920170, 920171, 920180, 920190, 920200, 920201, 920202, 920210, 920220, 920230, 920240, 920250, 920260, 920270, 920271, 920272, 920273, 920274, 920341, 920350, 920360, 920370, 920380, 920390, 920400, 920410, 920420, 920430, 920440, 920450, 920460, 920470, 920480, 921110, 921120, 921130, 921140, 921150, 921151, 921160, 930100, 930110, 930120, 930130, 931100, 931110, 931120, 931130, 932100, 932105, 932106, 932110, 932115, 932120, 932130, 932140, 932150, 932160, 932170, 932171, 932180, 932190, 933100, 933110, 933111, 933120, 933130, 933131, 933140, 933150, 933151, 933160, 933161, 933170, 933180, 933190, 941100, 941101, 941110, 941120, 941130, 941140, 941150, 941160, 941170, 941180, 941190, 941200, 941210, 941220, 941230, 941240, 941250, 941260, 941270, 941280, 941290, 941300, 941310, 941320, 941330, 941340, 941350, 942100, 942110, 942120, 942130, 942140, 942150, 942160, 942170, 942180, 942190, 942200, 942210, 942220, 942230, 942240, 942250, 942251, 942260, 942270, 942280, 942290, 942300, 942310, 942320, 942330, 942340, 942350, 942360, 942361, 942370, 942380, 942390, 942400, 942410, 942420, 942421, 942430, 942431, 942432, 942440, 942450, 942460, 942470, 942480, 942490, 943100, 943110, 943120, 944100, 944110, 944120, 944130, 944200, 944210, 944240, 944250, 944300, 950100, 950130, 951110, 951120, 951130, 951140, 951150, 951160, 951170, 951180, 951190, 951200, 951210, 951220, 951230, 951240, 951250, 951260, 952100, 952110, 953100, 953110, 953120, 954100, 954110, 954120, 954130, 4295001, 4295002, 4295003, 4295004, 4295005, 4295006}[r.Intn(213)])
	}
	this.RuleListType = RuleModeType([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	this.Mode = ves_io_schema4.WafModeType([]int32{0, 1}[r.Intn(2)])
	this.AnomalyScoreThreshold = uint32(r.Uint32())
	this.ParanoiaLevel = uint32(r.Uint32())
	v6 := r.Intn(10)
	this.RuleIds = make([]ves_io_schema_waf_rule_list.WafRuleID, v6)
	for i := 0; i < v6; i++ {
		this.RuleIds[i] = ves_io_schema_waf_rule_list.WafRuleID([]int32{0, 910000, 910100, 910150, 910160, 910170, 910180, 911100, 912120, 913100, 913101, 913102, 913110, 913120, 920100, 920120, 920121, 920130, 920140, 920160, 920170, 920171, 920180, 920190, 920200, 920201, 920202, 920210, 920220, 920230, 920240, 920250, 920260, 920270, 920271, 920272, 920273, 920274, 920341, 920350, 920360, 920370, 920380, 920390, 920400, 920410, 920420, 920430, 920440, 920450, 920460, 920470, 920480, 921110, 921120, 921130, 921140, 921150, 921151, 921160, 930100, 930110, 930120, 930130, 931100, 931110, 931120, 931130, 932100, 932105, 932106, 932110, 932115, 932120, 932130, 932140, 932150, 932160, 932170, 932171, 932180, 932190, 933100, 933110, 933111, 933120, 933130, 933131, 933140, 933150, 933151, 933160, 933161, 933170, 933180, 933190, 941100, 941101, 941110, 941120, 941130, 941140, 941150, 941160, 941170, 941180, 941190, 941200, 941210, 941220, 941230, 941240, 941250, 941260, 941270, 941280, 941290, 941300, 941310, 941320, 941330, 941340, 941350, 942100, 942110, 942120, 942130, 942140, 942150, 942160, 942170, 942180, 942190, 942200, 942210, 942220, 942230, 942240, 942250, 942251, 942260, 942270, 942280, 942290, 942300, 942310, 942320, 942330, 942340, 942350, 942360, 942361, 942370, 942380, 942390, 942400, 942410, 942420, 942421, 942430, 942431, 942432, 942440, 942450, 942460, 942470, 942480, 942490, 943100, 943110, 943120, 944100, 944110, 944120, 944130, 944200, 944210, 944240, 944250, 944300, 950100, 950130, 951110, 951120, 951130, 951140, 951150, 951160, 951170, 951180, 951190, 951200, 951210, 951220, 951230, 951240, 951250, 951260, 952100, 952110, 953100, 953110, 953120, 954100, 954110, 954120, 954130, 4295001, 4295002, 4295003, 4295004, 4295005, 4295006}[r.Intn(213)])
	}
	this.RuleListType = RuleModeType([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v7 := r.Intn(100)
	tmps := make([]rune, v7)
	for i := 0; i < v7; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v8 := r.Int63()
		if r.Intn(2) == 0 {
			v8 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v8))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Rules) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Severity != 0 {
		n += 1 + sovTypes(uint64(m.Severity))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		n += 1 + sovTypes(uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		l = 0
		for _, e := range m.RuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.RuleListType != 0 {
		n += 1 + sovTypes(uint64(m.RuleListType))
	}
	if len(m.Waf) > 0 {
		for _, e := range m.Waf {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		n += 1 + sovTypes(uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		l = 0
		for _, e := range m.RuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.RuleListType != 0 {
		n += 1 + sovTypes(uint64(m.RuleListType))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		n += 1 + sovTypes(uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		l = 0
		for _, e := range m.RuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.RuleListType != 0 {
		n += 1 + sovTypes(uint64(m.RuleListType))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		n += 1 + sovTypes(uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		l = 0
		for _, e := range m.RuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.RuleListType != 0 {
		n += 1 + sovTypes(uint64(m.RuleListType))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Rules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Rules{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`Severity:` + fmt.Sprintf("%v", this.Severity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AnomalyScoreThreshold:` + fmt.Sprintf("%v", this.AnomalyScoreThreshold) + `,`,
		`ParanoiaLevel:` + fmt.Sprintf("%v", this.ParanoiaLevel) + `,`,
		`RuleIds:` + fmt.Sprintf("%v", this.RuleIds) + `,`,
		`RuleListType:` + fmt.Sprintf("%v", this.RuleListType) + `,`,
		`Waf:` + strings.Replace(fmt.Sprintf("%v", this.Waf), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AnomalyScoreThreshold:` + fmt.Sprintf("%v", this.AnomalyScoreThreshold) + `,`,
		`ParanoiaLevel:` + fmt.Sprintf("%v", this.ParanoiaLevel) + `,`,
		`RuleIds:` + fmt.Sprintf("%v", this.RuleIds) + `,`,
		`RuleListType:` + fmt.Sprintf("%v", this.RuleListType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AnomalyScoreThreshold:` + fmt.Sprintf("%v", this.AnomalyScoreThreshold) + `,`,
		`ParanoiaLevel:` + fmt.Sprintf("%v", this.ParanoiaLevel) + `,`,
		`RuleIds:` + fmt.Sprintf("%v", this.RuleIds) + `,`,
		`RuleListType:` + fmt.Sprintf("%v", this.RuleListType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AnomalyScoreThreshold:` + fmt.Sprintf("%v", this.AnomalyScoreThreshold) + `,`,
		`ParanoiaLevel:` + fmt.Sprintf("%v", this.ParanoiaLevel) + `,`,
		`RuleIds:` + fmt.Sprintf("%v", this.RuleIds) + `,`,
		`RuleListType:` + fmt.Sprintf("%v", this.RuleListType) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Rules) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (RuleModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= (SeverityType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (ves_io_schema4.WafModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyScoreThreshold", wireType)
			}
			m.AnomalyScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyScoreThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParanoiaLevel", wireType)
			}
			m.ParanoiaLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParanoiaLevel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v ves_io_schema_waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RuleIds = append(m.RuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ves_io_schema_waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RuleIds = append(m.RuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleListType", wireType)
			}
			m.RuleListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleListType |= (RuleModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waf = append(m.Waf, &ves_io_schema4.ObjectRefType{})
			if err := m.Waf[len(m.Waf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (ves_io_schema4.WafModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyScoreThreshold", wireType)
			}
			m.AnomalyScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyScoreThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParanoiaLevel", wireType)
			}
			m.ParanoiaLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParanoiaLevel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v ves_io_schema_waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RuleIds = append(m.RuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ves_io_schema_waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RuleIds = append(m.RuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleListType", wireType)
			}
			m.RuleListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleListType |= (RuleModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (ves_io_schema4.WafModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyScoreThreshold", wireType)
			}
			m.AnomalyScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyScoreThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParanoiaLevel", wireType)
			}
			m.ParanoiaLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParanoiaLevel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v ves_io_schema_waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RuleIds = append(m.RuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ves_io_schema_waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RuleIds = append(m.RuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleListType", wireType)
			}
			m.RuleListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleListType |= (RuleModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (ves_io_schema4.WafModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyScoreThreshold", wireType)
			}
			m.AnomalyScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyScoreThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParanoiaLevel", wireType)
			}
			m.ParanoiaLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParanoiaLevel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v ves_io_schema_waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RuleIds = append(m.RuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ves_io_schema_waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ves_io_schema_waf_rule_list.WafRuleID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RuleIds = append(m.RuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleListType", wireType)
			}
			m.RuleListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleListType |= (RuleModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/waf_rules/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 760 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0xcb, 0x6b, 0x1b, 0x47,
	0x1c, 0xd6, 0xac, 0xde, 0xa3, 0x47, 0xb7, 0x03, 0xc5, 0x5b, 0xd5, 0x2c, 0x42, 0xa5, 0xad, 0x10,
	0x78, 0xb7, 0xb8, 0x60, 0x68, 0x0f, 0x2d, 0x92, 0xbc, 0x15, 0x4b, 0xf5, 0x80, 0xb1, 0x8c, 0xdb,
	0x5e, 0xc4, 0x48, 0x3b, 0x92, 0xb6, 0x5d, 0x79, 0x96, 0xdd, 0x95, 0x1c, 0x1d, 0x02, 0xb9, 0xe5,
	0x90, 0x4b, 0xc8, 0x5f, 0x11, 0xf2, 0x17, 0x84, 0x9c, 0x7c, 0x0c, 0x0e, 0x09, 0x3e, 0xfa, 0x18,
	0x6d, 0x2e, 0xc9, 0xcd, 0xc7, 0x1c, 0xc3, 0xac, 0x64, 0x23, 0x89, 0x18, 0x83, 0x71, 0x6e, 0xbe,
	0x88, 0xf9, 0xcd, 0xf7, 0xfd, 0x5e, 0xdf, 0x27, 0x34, 0x82, 0xdf, 0x4f, 0xa8, 0xab, 0x98, 0x4c,
	0x75, 0x7b, 0x43, 0x3a, 0x22, 0xea, 0x11, 0xe9, 0x77, 0x9c, 0xb1, 0x45, 0x5d, 0xd5, 0x9b, 0xda,
	0xd4, 0x55, 0x6c, 0x87, 0x79, 0x0c, 0x6d, 0xcc, 0x49, 0xca, 0x9c, 0xa4, 0x5c, 0x92, 0x72, 0x5b,
	0x03, 0xd3, 0x1b, 0x8e, 0xbb, 0x4a, 0x8f, 0x8d, 0xd4, 0x01, 0x1b, 0x30, 0x35, 0xe0, 0x77, 0xc7,
	0xfd, 0x20, 0x0a, 0x82, 0xe0, 0x34, 0xaf, 0x93, 0xfb, 0x6e, 0xb5, 0x19, 0xb3, 0x3d, 0x93, 0x1d,
	0x2e, 0x9a, 0xe4, 0xbe, 0x5d, 0x05, 0x97, 0xfa, 0xe7, 0x36, 0x57, 0xa1, 0x09, 0xb1, 0x4c, 0x83,
	0x78, 0x74, 0x81, 0xe6, 0xd7, 0x50, 0x93, 0x1e, 0x75, 0x56, 0x4b, 0xff, 0xf4, 0xf9, 0x25, 0x3b,
	0x96, 0xe9, 0x7a, 0xcb, 0x8d, 0x0a, 0xaf, 0x00, 0x8c, 0x62, 0xbe, 0x19, 0xfa, 0x15, 0x46, 0x46,
	0xcc, 0xa0, 0x12, 0xc8, 0x83, 0x62, 0x76, 0xfb, 0x07, 0xe5, 0x0a, 0x05, 0x14, 0xce, 0x6e, 0x30,
	0x83, 0xb6, 0xa7, 0x36, 0xc5, 0x41, 0x0a, 0xca, 0x42, 0xc1, 0x34, 0x24, 0x21, 0x0f, 0x8a, 0x19,
	0x2c, 0x98, 0x06, 0xca, 0xc3, 0x94, 0x41, 0xdd, 0x9e, 0x63, 0x06, 0x33, 0x49, 0xe1, 0x3c, 0x28,
	0x26, 0xf1, 0xf2, 0x15, 0x42, 0x30, 0xe2, 0x91, 0x81, 0x2b, 0x45, 0xf2, 0xe1, 0x62, 0x12, 0x07,
	0x67, 0x54, 0x86, 0x09, 0x97, 0x4e, 0xa8, 0x63, 0x7a, 0x53, 0x29, 0x7a, 0xcd, 0x10, 0x7b, 0x0b,
	0x62, 0x30, 0xc4, 0x65, 0x5a, 0xe1, 0x61, 0x18, 0x66, 0x6b, 0x16, 0xeb, 0x12, 0x6b, 0xcf, 0xa6,
	0x3d, 0x0e, 0x22, 0x65, 0x65, 0xad, 0xdc, 0x5a, 0xc5, 0x03, 0xd2, 0x5f, 0xdb, 0xe5, 0x0f, 0xb8,
	0x41, 0x0e, 0xd9, 0x88, 0x58, 0xd3, 0x8e, 0xdb, 0x63, 0x0e, 0xed, 0x78, 0x43, 0x87, 0xba, 0x43,
	0x66, 0x2d, 0x16, 0xac, 0xc4, 0x5f, 0x7c, 0x38, 0x0e, 0x0b, 0xa5, 0x10, 0xfe, 0x66, 0xc1, 0xdb,
	0xe3, 0xb4, 0xf6, 0x05, 0x0b, 0xfd, 0x0c, 0xb3, 0x36, 0x71, 0xc8, 0x21, 0x33, 0x49, 0xc7, 0xa2,
	0x13, 0x6a, 0x05, 0xfb, 0x67, 0x2a, 0x49, 0x9e, 0x17, 0x29, 0x09, 0x52, 0x04, 0x67, 0x2e, 0x08,
	0x75, 0x8e, 0xa3, 0x06, 0x4c, 0x04, 0xe6, 0x98, 0xc6, 0x5c, 0x90, 0xec, 0xf6, 0x8f, 0x57, 0x2c,
	0x1e, 0xf8, 0xc7, 0x87, 0xe6, 0x26, 0xe8, 0xbb, 0x15, 0xc8, 0x6b, 0x46, 0x9f, 0x00, 0x41, 0x02,
	0x38, 0xce, 0x09, 0xba, 0xe1, 0xa2, 0xbf, 0x60, 0xf6, 0x92, 0xdb, 0xe1, 0x5e, 0x5f, 0xab, 0xe6,
	0x8a, 0xa5, 0x69, 0x7e, 0x57, 0x37, 0x5d, 0x2f, 0x90, 0x6f, 0x07, 0x86, 0x8f, 0x48, 0x5f, 0x8a,
	0xe5, 0xc3, 0xc5, 0xd4, 0xf6, 0xe6, 0x5a, 0x85, 0x56, 0xf7, 0x3f, 0xda, 0xf3, 0x30, 0xed, 0x73,
	0x6a, 0x25, 0xf6, 0xec, 0x3e, 0xe7, 0x62, 0xfe, 0x51, 0x78, 0x2d, 0xc0, 0x6c, 0xd5, 0xa1, 0xc4,
	0xa3, 0x37, 0x76, 0x62, 0xe7, 0x1a, 0x27, 0x6e, 0xcf, 0x80, 0xf2, 0x4d, 0x0d, 0xf8, 0x32, 0xa2,
	0xff, 0xf6, 0xf5, 0xc9, 0xef, 0x6b, 0x5f, 0xe3, 0xc2, 0x1b, 0x01, 0x7e, 0x85, 0xa9, 0x6d, 0x91,
	0xde, 0x9d, 0xa0, 0xb7, 0x22, 0xe8, 0x89, 0x00, 0x53, 0x35, 0xea, 0xdd, 0x89, 0x79, 0x0b, 0x62,
	0x96, 0x18, 0x4c, 0x2f, 0xff, 0x22, 0xa3, 0x0c, 0x4c, 0x6a, 0x0d, 0x0d, 0xd7, 0xb4, 0x66, 0xf5,
	0x1f, 0x31, 0x84, 0x92, 0x30, 0x5a, 0xae, 0x6b, 0xb8, 0x2d, 0x02, 0x94, 0x86, 0x89, 0x2a, 0xd6,
	0xdb, 0x7a, 0xb5, 0x5c, 0x17, 0x05, 0x0e, 0x68, 0x18, 0xb7, 0xb0, 0x18, 0x46, 0x29, 0x18, 0x3f,
	0x28, 0xe3, 0xa6, 0xde, 0xac, 0x89, 0x11, 0x04, 0x61, 0xac, 0xd9, 0x6a, 0xeb, 0x55, 0x4d, 0x8c,
	0xa2, 0x04, 0x8c, 0xe8, 0xcd, 0x3f, 0x5b, 0x62, 0x8c, 0xb3, 0x77, 0xb5, 0xca, 0x7e, 0x4d, 0x8c,
	0x97, 0x8a, 0x30, 0xbd, 0x3c, 0x21, 0xcf, 0xd6, 0xfe, 0xae, 0xd6, 0xf7, 0x77, 0x35, 0x31, 0xc4,
	0x03, 0xbd, 0x39, 0x0f, 0x40, 0xe5, 0x11, 0x38, 0x9d, 0xc9, 0xa1, 0xb3, 0x99, 0x1c, 0x3a, 0x9f,
	0xc9, 0xe0, 0xe3, 0x4c, 0x06, 0x0f, 0x7c, 0x19, 0x3c, 0xf5, 0x65, 0xf0, 0xdc, 0x97, 0xc1, 0xb1,
	0x2f, 0x83, 0x97, 0xbe, 0x0c, 0x4e, 0x7d, 0x19, 0x9c, 0xf9, 0x32, 0x78, 0xeb, 0xcb, 0xe0, 0xbd,
	0x2f, 0x87, 0xce, 0x7d, 0x19, 0x3c, 0x7e, 0x27, 0x87, 0xfe, 0x6d, 0x0c, 0x98, 0xfd, 0xff, 0x40,
	0x99, 0x30, 0xcb, 0xa3, 0x8e, 0x43, 0x94, 0xb1, 0xab, 0x06, 0x87, 0x3e, 0x73, 0x46, 0x5b, 0xb6,
	0xc3, 0x26, 0xa6, 0x41, 0x9d, 0xad, 0x0b, 0x58, 0xb5, 0xbb, 0x03, 0xa6, 0xd2, 0x7b, 0xde, 0xe2,
	0xdd, 0x5d, 0xff, 0x8f, 0xd1, 0x8d, 0x05, 0xaf, 0xee, 0x2f, 0x9f, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x80, 0x65, 0x61, 0x2d, 0x85, 0x08, 0x00, 0x00,
}

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/user/public_customapi.proto

package user

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	_ "github.com/gogo/googleapis/google/api"

	google_protobuf1 "github.com/gogo/protobuf/types"

	_ "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"

	_ "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema/vesenv"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	sortkeys "github.com/gogo/protobuf/sortkeys"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Billing flag
//
// x-displayName: "Billing flag"
// Possible billing flags used to indicate problems with customer billing.
type BillingFlag int32

const (
	// customer has a valid payment method on our file
	// x-displayName: "Valid payment method"
	VALID_PAYMENT_METHOD BillingFlag = 0
	// customer has at least one overdue invoice with with us
	// x-displayName: "Overdue invoice exists on customers file"
	OVERDUE_INVOICE BillingFlag = 1
	// status of customer's last transaction. a retry may be triggered so this is an early warning.
	// x-displayName: "Customer's last transaction is flagged as failed"
	LAST_TRANSACTION_STATUS BillingFlag = 2
	// this flag is on when the customer has no but expired payment method on it's file.
	// x-displayName: "All payment methods are expired"
	PAYMENT_METHOD_EXPIRED BillingFlag = 3
	// x-displayName: "We could not charge your primary payment method due to insufficient funds"
	// We could not charge your primary payment method due to insufficient funds
	PAYMENT_METHOD_INSUFFICIENT_FUNDS BillingFlag = 4
	// x-displayName: "Your primary payment method was declined"
	// Your primary payment method was declined
	PAYMENT_METHOD_PRIMARY_DECLINED BillingFlag = 5
	// x-displayName: "Security code for your primary payment method is incorrect"
	// Security code for your primary payment method is incorrect
	PAYMENT_METHOD_CVC_INVALID BillingFlag = 6
	// x-displayName: "ZIP code for your primary payment method is incorrect"
	// ZIP code for your primary payment method is incorrect
	PAYMENT_METHOD_ZIP_INVALID BillingFlag = 7
	// x-displayName: "We could not charge your primary payment method due to insufficient funds. Your secondary payment method was charged"
	// We could not charge your primary payment method due to insufficient funds. Your secondary payment method was charged
	PAYMENT_METHOD_INSUFFICIENT_FUNDS_SECONDARY_CHARGED BillingFlag = 8
	// x-displayName: "Your primary payment method has expired. Your secondary payment method was charged"
	// Your primary payment method has expired. Your secondary payment method was charged
	PAYMENT_METHOD_PRIMARY_EXPIRED_SECONDARY_CHARGED BillingFlag = 9
	// x-displayName: "Your primary payment method was declined. Your secondary payment method was charged"
	// Your primary payment method was declined. Your secondary payment method was charged
	PAYMENT_METHOD_PRIMARY_DECLINED_SECONDARY_CHARGED BillingFlag = 10
	// x-displayName: "We could not charge any of the active payment methods"
	// We could not charge any of the active payment methods
	PAYMENT_METHOD_BOTH_PAYMENT_METHOD_FAILED BillingFlag = 11
	// x-displayName: "We could not charge any of the active payment methods"
	// We could not charge any of the active payment methods
	PAYMENT_METHOD_GENERIC_FAILURE BillingFlag = 1000
	// x-displayName: "Adding a payment method resulted in an error"
	// Adding a payment method resulted in an error
	PAYMENT_METHOD_GENERIC_ADD_FAILURE BillingFlag = 1001
)

var BillingFlag_name = map[int32]string{
	0:    "VALID_PAYMENT_METHOD",
	1:    "OVERDUE_INVOICE",
	2:    "LAST_TRANSACTION_STATUS",
	3:    "PAYMENT_METHOD_EXPIRED",
	4:    "PAYMENT_METHOD_INSUFFICIENT_FUNDS",
	5:    "PAYMENT_METHOD_PRIMARY_DECLINED",
	6:    "PAYMENT_METHOD_CVC_INVALID",
	7:    "PAYMENT_METHOD_ZIP_INVALID",
	8:    "PAYMENT_METHOD_INSUFFICIENT_FUNDS_SECONDARY_CHARGED",
	9:    "PAYMENT_METHOD_PRIMARY_EXPIRED_SECONDARY_CHARGED",
	10:   "PAYMENT_METHOD_PRIMARY_DECLINED_SECONDARY_CHARGED",
	11:   "PAYMENT_METHOD_BOTH_PAYMENT_METHOD_FAILED",
	1000: "PAYMENT_METHOD_GENERIC_FAILURE",
	1001: "PAYMENT_METHOD_GENERIC_ADD_FAILURE",
}
var BillingFlag_value = map[string]int32{
	"VALID_PAYMENT_METHOD":                                0,
	"OVERDUE_INVOICE":                                     1,
	"LAST_TRANSACTION_STATUS":                             2,
	"PAYMENT_METHOD_EXPIRED":                              3,
	"PAYMENT_METHOD_INSUFFICIENT_FUNDS":                   4,
	"PAYMENT_METHOD_PRIMARY_DECLINED":                     5,
	"PAYMENT_METHOD_CVC_INVALID":                          6,
	"PAYMENT_METHOD_ZIP_INVALID":                          7,
	"PAYMENT_METHOD_INSUFFICIENT_FUNDS_SECONDARY_CHARGED": 8,
	"PAYMENT_METHOD_PRIMARY_EXPIRED_SECONDARY_CHARGED":    9,
	"PAYMENT_METHOD_PRIMARY_DECLINED_SECONDARY_CHARGED":   10,
	"PAYMENT_METHOD_BOTH_PAYMENT_METHOD_FAILED":           11,
	"PAYMENT_METHOD_GENERIC_FAILURE":                      1000,
	"PAYMENT_METHOD_GENERIC_ADD_FAILURE":                  1001,
}

func (BillingFlag) EnumDescriptor() ([]byte, []int) { return fileDescriptorPublicCustomapi, []int{0} }

// Billing flag action
//
// x-displayName: "Billing flag action"
// Action to be executed when customer click on the UI warning
type BillingFlagAction int32

const (
	// we don't expect customer to take any actoon
	// x-displayName: "No action required"
	NO_ACTION BillingFlagAction = 0
	// customer should provide a new payment method
	// x-displayName: "Add new payment method"
	ADD_NEW_PAYMENT_METHOD BillingFlagAction = 1
	// customer should send us an email
	// x-displayName: "Contact us"
	CONTACT_US BillingFlagAction = 2
)

var BillingFlagAction_name = map[int32]string{
	0: "NO_ACTION",
	1: "ADD_NEW_PAYMENT_METHOD",
	2: "CONTACT_US",
}
var BillingFlagAction_value = map[string]int32{
	"NO_ACTION":              0,
	"ADD_NEW_PAYMENT_METHOD": 1,
	"CONTACT_US":             2,
}

func (BillingFlagAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{1}
}

// Billing Feature Indicator
//
// x-displayName: "Billing feature indicator"
// Single instance of a billing indicator.
// It informs the customer of any problems with their billing, including failed payments, overdue invoices, or missing valid payment methods.
type BillingFeatureIndicator struct {
	// Billing flag name
	//
	// x-displayName: "Billing flag"
	// Name of the billing feature this flag relates to
	BillingFlag BillingFlag `protobuf:"varint,1,opt,name=billing_flag,json=billingFlag,proto3,enum=ves.io.schema.user.BillingFlag" json:"billing_flag,omitempty"`
	// Failed
	//
	// x-displayName: "Failed"
	// x-example: "true"
	// If true then the billing feature is failed and to be looked into.
	Failed bool `protobuf:"varint,2,opt,name=failed,proto3" json:"failed,omitempty"`
	// Additional info
	//
	// x-displayName: "Additional info"
	// x-example: "payment failed due to insufficient funds"
	// Any description (such as error message) related to this billing feature.
	AdditionalInfo string `protobuf:"bytes,3,opt,name=additional_info,json=additionalInfo,proto3" json:"additional_info,omitempty"`
	// Action the customer should take
	//
	// x-displayName: "Action to be performed"
	// Indicate an action the customer should make to mitigate the warning.
	Action BillingFlagAction `protobuf:"varint,4,opt,name=action,proto3,enum=ves.io.schema.user.BillingFlagAction" json:"action,omitempty"`
}

func (m *BillingFeatureIndicator) Reset()      { *m = BillingFeatureIndicator{} }
func (*BillingFeatureIndicator) ProtoMessage() {}
func (*BillingFeatureIndicator) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{0}
}

func (m *BillingFeatureIndicator) GetBillingFlag() BillingFlag {
	if m != nil {
		return m.BillingFlag
	}
	return VALID_PAYMENT_METHOD
}

func (m *BillingFeatureIndicator) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *BillingFeatureIndicator) GetAdditionalInfo() string {
	if m != nil {
		return m.AdditionalInfo
	}
	return ""
}

func (m *BillingFeatureIndicator) GetAction() BillingFlagAction {
	if m != nil {
		return m.Action
	}
	return NO_ACTION
}

// Send password email request
//
// x-displayName: "Send Password Email Request"
// SendPasswordEmailRequest is the request parameters for sending the password update.
// Note that only admin is allowed to resend the password for users.
type SendPasswordEmailRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// email of the user
	//
	// x-displayName: "Email"
	// x-example: "value"
	// x-required
	// email of the user requesting for
	Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *SendPasswordEmailRequest) Reset()      { *m = SendPasswordEmailRequest{} }
func (*SendPasswordEmailRequest) ProtoMessage() {}
func (*SendPasswordEmailRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{1}
}

func (m *SendPasswordEmailRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SendPasswordEmailRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

// Send password email response
//
// x-displayName: "Send Password Email Response"
// SendPasswordEmailResponse is an empty response after an email had been sent.
type SendPasswordEmailResponse struct {
}

func (m *SendPasswordEmailResponse) Reset()      { *m = SendPasswordEmailResponse{} }
func (*SendPasswordEmailResponse) ProtoMessage() {}
func (*SendPasswordEmailResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{2}
}

// Namespace Role Type
//
// x-displayName: "Namespace Role Type"
// Association of a role to namespaces
type NamespacesRoleType struct {
	// Namespaces
	//
	// x-displayName: "Namespaces"
	// x-example: "value"
	// Namespace, including star (`*`) which means all tenant's namespaces
	Namespaces []string `protobuf:"bytes,1,rep,name=namespaces" json:"namespaces,omitempty"`
	// Role
	//
	// x-displayName: "Role"
	// x-example: "value"
	// Users role for this namespace
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *NamespacesRoleType) Reset()      { *m = NamespacesRoleType{} }
func (*NamespacesRoleType) ProtoMessage() {}
func (*NamespacesRoleType) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{3}
}

func (m *NamespacesRoleType) GetNamespaces() []string {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func (m *NamespacesRoleType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// Namespace role
//
// x-displayName: "Namespace Role"
// Allows linking namespaces and roles
type NamespaceRoleType struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// x-required
	// Namespace the role applies to
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Role
	//
	// x-displayName: "Role"
	// x-example: "value"
	// x-required
	// Users role for this namespace
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *NamespaceRoleType) Reset()      { *m = NamespaceRoleType{} }
func (*NamespaceRoleType) ProtoMessage() {}
func (*NamespaceRoleType) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{4}
}

func (m *NamespaceRoleType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NamespaceRoleType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// User role
//
// x-displayName: "User Role"
// Allows creation of a user along with their roles in namespaces.
type UserRoleRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Tenant's namespace (system)
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "value"
	// user spec (name and so on)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// first name
	//
	// x-displayName: "First Name"
	// x-example: "value"
	// x-required
	// User's first name
	FirstName string `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// last name
	//
	// x-displayName: "Last Name"
	// x-example: "value"
	// x-required
	// User's last name
	LastName string `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// email
	//
	// x-displayName: "Email Address"
	// x-example: "value"
	// x-required
	// user's email
	Email string `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	// User type
	//
	// x-displayName: "User Type"
	// Type of the user account (USER, SERVICE)
	Type UserType `protobuf:"varint,6,opt,name=type,proto3,enum=ves.io.schema.user.UserType" json:"type,omitempty"`
	// Namespace roles
	//
	// x-displayName: "Namespace Roles"
	// List of roles that the user has for each namespace.
	NamespaceRoles []*NamespaceRoleType `protobuf:"bytes,7,rep,name=namespace_roles,json=namespaceRoles" json:"namespace_roles,omitempty"`
	// IDM Type
	//
	// x-displayName: "Identity Management Type"
	// Type of the Identity management
	IdmType IdmType `protobuf:"varint,8,opt,name=idm_type,json=idmType,proto3,enum=ves.io.schema.user.IdmType" json:"idm_type,omitempty"`
}

func (m *UserRoleRequest) Reset()                    { *m = UserRoleRequest{} }
func (*UserRoleRequest) ProtoMessage()               {}
func (*UserRoleRequest) Descriptor() ([]byte, []int) { return fileDescriptorPublicCustomapi, []int{5} }

func (m *UserRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *UserRoleRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UserRoleRequest) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *UserRoleRequest) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *UserRoleRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserRoleRequest) GetType() UserType {
	if m != nil {
		return m.Type
	}
	return USER
}

func (m *UserRoleRequest) GetNamespaceRoles() []*NamespaceRoleType {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

func (m *UserRoleRequest) GetIdmType() IdmType {
	if m != nil {
		return m.IdmType
	}
	return SSO
}

// List user roles
//
// x-displayName: "List User Roles"
// Allows list user roles in a namespace
type ListUserRoleRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace to use
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *ListUserRoleRequest) Reset()      { *m = ListUserRoleRequest{} }
func (*ListUserRoleRequest) ProtoMessage() {}
func (*ListUserRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{6}
}

func (m *ListUserRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Assign role
//
// x-displayName: "Assign Role"
// Allows user role in namespace assignment
type AssignRoleRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace the requesting user is calling the action from
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Namespace role
	//
	// x-displayName: "Namespace Role"
	// namespace role to assign
	NamespacesRole *NamespacesRoleType `protobuf:"bytes,2,opt,name=namespaces_role,json=namespacesRole" json:"namespaces_role,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "value"
	// name of the users we want to assign the role to (we query the tenant/system_namespace for the usernames)
	Username []string `protobuf:"bytes,3,rep,name=username" json:"username,omitempty"`
}

func (m *AssignRoleRequest) Reset()      { *m = AssignRoleRequest{} }
func (*AssignRoleRequest) ProtoMessage() {}
func (*AssignRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{7}
}

func (m *AssignRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AssignRoleRequest) GetNamespacesRole() *NamespacesRoleType {
	if m != nil {
		return m.NamespacesRole
	}
	return nil
}

func (m *AssignRoleRequest) GetUsername() []string {
	if m != nil {
		return m.Username
	}
	return nil
}

// List user roles
//
// x-displayName: "List User Roles"
// Allows user namespace roles retrieval
type ListUserRoleResponse struct {
	// User namespace roles
	//
	// x-displayName: "User Namespace Roles"
	// List of user namespace roles
	Items []*ListUserRoleResponseItem `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *ListUserRoleResponse) Reset()      { *m = ListUserRoleResponse{} }
func (*ListUserRoleResponse) ProtoMessage() {}
func (*ListUserRoleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{8}
}

func (m *ListUserRoleResponse) GetItems() []*ListUserRoleResponseItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// List user role
//
// x-displayName: "List User Role"
// Allows user namespace role retrieval
type ListUserRoleResponseItem struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace of the user object (namespace where the user object is stored).
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "value"
	// name of the user
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Email
	//
	// x-displayName: "Email Address"
	// x-example: "value"
	// Email of the user object
	Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	// First name
	//
	// x-displayName: "First Name"
	// x-example: "value"
	// First name of the customer
	FirstName string `protobuf:"bytes,4,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// Last name
	//
	// x-displayName: "Last Name"
	// x-example: "value"
	// Last name of the customer
	LastName string `protobuf:"bytes,5,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// User type
	//
	// x-displayName: "User Type"
	// Type of the user account (USER, SERVICE)
	Type UserType `protobuf:"varint,6,opt,name=type,proto3,enum=ves.io.schema.user.UserType" json:"type,omitempty"`
	// Namespace roles
	//
	// x-displayName: "Namespace Roles"
	// Namespace roles for the user
	NamespaceRoles []*NamespaceRoleType `protobuf:"bytes,7,rep,name=namespace_roles,json=namespaceRoles" json:"namespace_roles,omitempty"`
	// Tenant
	//
	// x-displayName: "Tenant"
	// x-example: "value"
	// tenant that the user belongs to
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Tenant type
	//
	// x-displayName: "Tenant Type"
	// tenant type of the user (FREEMIUM, ENTERPRISE, ...)
	TenantType ves_io_schema4.TenantType `protobuf:"varint,9,opt,name=tenant_type,json=tenantType,proto3,enum=ves.io.schema.TenantType" json:"tenant_type,omitempty"`
	// IDM type
	//
	// x-displayName: "Identity Management Type"
	// Identity management type of the user (Volterra Managed, SSO)
	IdmType IdmType `protobuf:"varint,10,opt,name=idm_type,json=idmType,proto3,enum=ves.io.schema.user.IdmType" json:"idm_type,omitempty"`
	//  Domain Owner
	//
	// x-displayName: "Domain Owner"
	// x-example: "true"
	// Domain owner is the first user who registered or signed up the associated Tenant.
	// User created via signup flow will have this value set to true.
	// Few restrictions apply to this user w.r.t role update and deletion.
	DomainOwner bool `protobuf:"varint,11,opt,name=domain_owner,json=domainOwner,proto3" json:"domain_owner,omitempty"`
	// OTP Enabled
	//
	// x-displayName: "OTP Enabled"
	// Shows if OTP is enabled in IDM Provider.
	OtpEnabled bool `protobuf:"varint,12,opt,name=otp_enabled,json=otpEnabled,proto3" json:"otp_enabled,omitempty"`
	// Disabled
	//
	// x-displayName: "Disabled"
	// If set to true user is completely disabled including IDM.
	Disabled bool `protobuf:"varint,13,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Creation timestamp
	//
	// x-displayName: "Creation timestamp"
	// Timestamp of user creation.
	CreationTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,14,opt,name=creation_timestamp,json=creationTimestamp" json:"creation_timestamp,omitempty"`
}

func (m *ListUserRoleResponseItem) Reset()      { *m = ListUserRoleResponseItem{} }
func (*ListUserRoleResponseItem) ProtoMessage() {}
func (*ListUserRoleResponseItem) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{9}
}

func (m *ListUserRoleResponseItem) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetType() UserType {
	if m != nil {
		return m.Type
	}
	return USER
}

func (m *ListUserRoleResponseItem) GetNamespaceRoles() []*NamespaceRoleType {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

func (m *ListUserRoleResponseItem) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetTenantType() ves_io_schema4.TenantType {
	if m != nil {
		return m.TenantType
	}
	return ves_io_schema4.UNKNOWN
}

func (m *ListUserRoleResponseItem) GetIdmType() IdmType {
	if m != nil {
		return m.IdmType
	}
	return SSO
}

func (m *ListUserRoleResponseItem) GetDomainOwner() bool {
	if m != nil {
		return m.DomainOwner
	}
	return false
}

func (m *ListUserRoleResponseItem) GetOtpEnabled() bool {
	if m != nil {
		return m.OtpEnabled
	}
	return false
}

func (m *ListUserRoleResponseItem) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *ListUserRoleResponseItem) GetCreationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

// Get user role
//
// x-displayName: "Get User Role"
// Allows user namespace role retrieval
type GetUserRoleRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace of the user object (namespace where the user object is stored).
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *GetUserRoleRequest) Reset()      { *m = GetUserRoleRequest{} }
func (*GetUserRoleRequest) ProtoMessage() {}
func (*GetUserRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{10}
}

func (m *GetUserRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// User role
//
// x-displayName: "User Role"
// Allows user and roles retrieval
type GetUserRoleResponse struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace of the user object (namespace where the user object is stored).
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "value"
	// name of the user
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Email
	//
	// x-displayName: "Email Address"
	// x-example: "value"
	// Email of the user object
	Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	// First name
	//
	// x-displayName: "First Name"
	// x-example: "value"
	// First name of the customer
	FirstName string `protobuf:"bytes,4,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// Last name
	//
	// x-displayName: "Last Name"
	// x-example: "value"
	// Last name of the customer
	LastName string `protobuf:"bytes,5,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// User type
	//
	// x-displayName: "User Type"
	// Type of the user account (USER, SERVICE)
	Type UserType `protobuf:"varint,6,opt,name=type,proto3,enum=ves.io.schema.user.UserType" json:"type,omitempty"`
	// Namespace roles
	//
	// x-displayName: "Namespace Roles"
	// Namespace roles for the user
	NamespaceRoles []*NamespaceRoleType `protobuf:"bytes,7,rep,name=namespace_roles,json=namespaceRoles" json:"namespace_roles,omitempty"`
	// Tenant
	//
	// x-displayName: "Tenant"
	// x-example: "value"
	// tenant that the user belongs to
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Tenant type
	//
	// x-displayName: "Tenant Type"
	// tenant type of the user (FREEMIUM, ENTERPRISE, ...)
	TenantType ves_io_schema4.TenantType `protobuf:"varint,9,opt,name=tenant_type,json=tenantType,proto3,enum=ves.io.schema.TenantType" json:"tenant_type,omitempty"`
	// Feature flag type
	//
	// x-displayName: "Feature Flag Type"
	// feature flag that shows whether this feature should be enabled on UI for the current plan
	FeatureFlags []*FeatureFlagType `protobuf:"bytes,10,rep,name=feature_flags,json=featureFlags" json:"feature_flags,omitempty"`
	// tos_current_version
	//
	// x-displayName: "TOS Current Version"
	// x-example: "value"
	// tos current version
	TosCurrentVersion string `protobuf:"bytes,11,opt,name=tos_current_version,json=tosCurrentVersion,proto3" json:"tos_current_version,omitempty"`
	// tos_accepted
	//
	// x-displayName: "TOS Accepted"
	// x-example: "value"
	// tos accepted version
	TosAccepted string `protobuf:"bytes,12,opt,name=tos_accepted,json=tosAccepted,proto3" json:"tos_accepted,omitempty"`
	// IDM type
	//
	// x-displayName: "Identity Management Type"
	// Identity management type of the user (Volterra Managed, SSO)
	IdmType IdmType `protobuf:"varint,13,opt,name=idm_type,json=idmType,proto3,enum=ves.io.schema.user.IdmType" json:"idm_type,omitempty"`
	// Namespace Access Map
	//
	// x-displayName: "Namespace Access Map"
	// A map of NamespaceAccess which contains access information for current user on a namespace.
	NamespaceAccess map[string]*NamespaceAccess `protobuf:"bytes,14,rep,name=namespace_access,json=namespaceAccess" json:"namespace_access,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	//  Domain Owner
	//
	// x-displayName: "Domain Owner"
	// x-example: "true"
	// Domain owner is the first user who registered or signed up the associated Tenant.
	// User created via signup flow will have this value set to true.
	// Few restrictions apply to this user w.r.t role update and deletion.
	DomainOwner bool `protobuf:"varint,15,opt,name=domain_owner,json=domainOwner,proto3" json:"domain_owner,omitempty"`
	// Cname
	// x-displayName: "CName"
	// x-example: "web"
	// CName via tenant will be accessed from url. <cname>.<domain>
	Cname string `protobuf:"bytes,16,opt,name=cname,proto3" json:"cname,omitempty"`
	// Billing flags
	// x-displayName: "Billing flags"
	// Collection of flags informing the customer of any billing related problems, such as overdue invoices.
	BillingFlags []*BillingFeatureIndicator `protobuf:"bytes,17,rep,name=billing_flags,json=billingFlags" json:"billing_flags,omitempty"`
	// Creation Timestamp
	// x-displayName: "Creation Timestamp"
	// User object creation timestamp
	CreationTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,18,opt,name=creation_timestamp,json=creationTimestamp" json:"creation_timestamp,omitempty"`
	// Company name
	// x-displayName: "Company"
	// x-example: "Acme Ltd."
	// Legal name of the company the user/tenant belongs to
	Company string `protobuf:"bytes,19,opt,name=company,proto3" json:"company,omitempty"`
	// Plan type
	//
	// x-displayName: "Plan Type"
	// plan type the tenant is subscribed to (FREE, INDIVIDUAL, TEAM, ORGANIZATION, ...)
	PlanType ves_io_schema4.PlanType `protobuf:"varint,20,opt,name=plan_type,json=planType,proto3,enum=ves.io.schema.PlanType" json:"plan_type,omitempty"`
	// Active plan transition id
	//
	// x-displayName: "Active plan transition id"
	// UUID of the plan transition request which is currently in progress. This field is empty
	// if there is no such request.
	ActivePlanTransitionUid string `protobuf:"bytes,21,opt,name=active_plan_transition_uid,json=activePlanTransitionUid,proto3" json:"active_plan_transition_uid,omitempty"`
}

func (m *GetUserRoleResponse) Reset()      { *m = GetUserRoleResponse{} }
func (*GetUserRoleResponse) ProtoMessage() {}
func (*GetUserRoleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{11}
}

func (m *GetUserRoleResponse) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetUserRoleResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetUserRoleResponse) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *GetUserRoleResponse) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *GetUserRoleResponse) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *GetUserRoleResponse) GetType() UserType {
	if m != nil {
		return m.Type
	}
	return USER
}

func (m *GetUserRoleResponse) GetNamespaceRoles() []*NamespaceRoleType {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

func (m *GetUserRoleResponse) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *GetUserRoleResponse) GetTenantType() ves_io_schema4.TenantType {
	if m != nil {
		return m.TenantType
	}
	return ves_io_schema4.UNKNOWN
}

func (m *GetUserRoleResponse) GetFeatureFlags() []*FeatureFlagType {
	if m != nil {
		return m.FeatureFlags
	}
	return nil
}

func (m *GetUserRoleResponse) GetTosCurrentVersion() string {
	if m != nil {
		return m.TosCurrentVersion
	}
	return ""
}

func (m *GetUserRoleResponse) GetTosAccepted() string {
	if m != nil {
		return m.TosAccepted
	}
	return ""
}

func (m *GetUserRoleResponse) GetIdmType() IdmType {
	if m != nil {
		return m.IdmType
	}
	return SSO
}

func (m *GetUserRoleResponse) GetNamespaceAccess() map[string]*NamespaceAccess {
	if m != nil {
		return m.NamespaceAccess
	}
	return nil
}

func (m *GetUserRoleResponse) GetDomainOwner() bool {
	if m != nil {
		return m.DomainOwner
	}
	return false
}

func (m *GetUserRoleResponse) GetCname() string {
	if m != nil {
		return m.Cname
	}
	return ""
}

func (m *GetUserRoleResponse) GetBillingFlags() []*BillingFeatureIndicator {
	if m != nil {
		return m.BillingFlags
	}
	return nil
}

func (m *GetUserRoleResponse) GetCreationTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *GetUserRoleResponse) GetCompany() string {
	if m != nil {
		return m.Company
	}
	return ""
}

func (m *GetUserRoleResponse) GetPlanType() ves_io_schema4.PlanType {
	if m != nil {
		return m.PlanType
	}
	return ves_io_schema4.FREE
}

func (m *GetUserRoleResponse) GetActivePlanTransitionUid() string {
	if m != nil {
		return m.ActivePlanTransitionUid
	}
	return ""
}

// Namespace Access
//
// x-displayName: "Namespace Access"
// Information needed to access a namespace
type NamespaceAccess struct {
	// User's Roles
	//
	// x-displayName: "User's Roles"
	// x-example: "value"
	// User's roles in a namespace
	Roles []string `protobuf:"bytes,1,rep,name=roles" json:"roles,omitempty"`
}

func (m *NamespaceAccess) Reset()                    { *m = NamespaceAccess{} }
func (*NamespaceAccess) ProtoMessage()               {}
func (*NamespaceAccess) Descriptor() ([]byte, []int) { return fileDescriptorPublicCustomapi, []int{12} }

func (m *NamespaceAccess) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// CascadeDeleteRequest
//
// x-displayName: "Delete the User and Associated Namespace Roles"
// CascadeDeleteRequest is the request to delete the user along with the associated namespace role objects.
// Note: only admin is allowed to delete the user and associated objects.
type CascadeDeleteRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// email of the user
	//
	// x-displayName: "Email"
	// x-example: "value"
	// x-required
	// email of the user requesting for
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *CascadeDeleteRequest) Reset()      { *m = CascadeDeleteRequest{} }
func (*CascadeDeleteRequest) ProtoMessage() {}
func (*CascadeDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{13}
}

func (m *CascadeDeleteRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CascadeDeleteRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

// CascadeDeleteResponse
//
// x-displayName: "Delete Response for the User and Associated Namespace Roles"
// CascadeDeleteResponse contains a list of user objects that were deleted
// and possibly any errors when attempting to delete those objects.
type CascadeDeleteResponse struct {
	// delete_ok
	//
	// x-displayName: "Delete Ok"
	// x-example: "true"
	// status of the deleted objects.
	// "true" value indicates that the operation had been successful for all the objects.
	// "false" value indicates that at least one of the delete operations had been unsuccessful.
	DeleteOk bool `protobuf:"varint,1,opt,name=delete_ok,json=deleteOk,proto3" json:"delete_ok,omitempty"`
	// items
	//
	// x-displayName: "Items"
	// The objects deleted for the specific user
	Items []*CascadeDeleteItemType `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
}

func (m *CascadeDeleteResponse) Reset()      { *m = CascadeDeleteResponse{} }
func (*CascadeDeleteResponse) ProtoMessage() {}
func (*CascadeDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{14}
}

func (m *CascadeDeleteResponse) GetDeleteOk() bool {
	if m != nil {
		return m.DeleteOk
	}
	return false
}

func (m *CascadeDeleteResponse) GetItems() []*CascadeDeleteItemType {
	if m != nil {
		return m.Items
	}
	return nil
}

// CascadeDeleteItemType
//
// x-displayName: "Cascade Deletion of User and Associated Namespace Roles"
// CascadeDeleteItemType contains details of object that was handled as part of cascade delete
// of user and whether it was successfully deleted
type CascadeDeleteItemType struct {
	// object's type
	//
	// x-displayName: "Object Type"
	// x-example: "value"
	// The type of the object
	ObjectType string `protobuf:"bytes,1,opt,name=object_type,json=objectType,proto3" json:"object_type,omitempty"`
	// object's uid
	//
	// x-displayName: "Object Uid"
	// x-example: "value"
	// The uid of the object
	ObjectUid string `protobuf:"bytes,2,opt,name=object_uid,json=objectUid,proto3" json:"object_uid,omitempty"`
	// object's name
	//
	// x-displayName: "Object Name"
	// x-example: "value"
	// Name of the object
	ObjectName string `protobuf:"bytes,3,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// error message
	//
	// x-displayName: "Error Message"
	// x-example: "value"
	// informative error message about the success or failure of the object's deletion response
	ErrorMessage string `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *CascadeDeleteItemType) Reset()      { *m = CascadeDeleteItemType{} }
func (*CascadeDeleteItemType) ProtoMessage() {}
func (*CascadeDeleteItemType) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{15}
}

func (m *CascadeDeleteItemType) GetObjectType() string {
	if m != nil {
		return m.ObjectType
	}
	return ""
}

func (m *CascadeDeleteItemType) GetObjectUid() string {
	if m != nil {
		return m.ObjectUid
	}
	return ""
}

func (m *CascadeDeleteItemType) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *CascadeDeleteItemType) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// Accept TOS request model
//
// x-displayName: "Accept TOS Request"
// Accept TOS request model
type AcceptTOSRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// tos_accepted
	//
	// x-displayName: "TOS Accepted"
	// x-example: "value"
	// tos accepted version
	TosAccepted string `protobuf:"bytes,2,opt,name=tos_accepted,json=tosAccepted,proto3" json:"tos_accepted,omitempty"`
}

func (m *AcceptTOSRequest) Reset()      { *m = AcceptTOSRequest{} }
func (*AcceptTOSRequest) ProtoMessage() {}
func (*AcceptTOSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{16}
}

func (m *AcceptTOSRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AcceptTOSRequest) GetTosAccepted() string {
	if m != nil {
		return m.TosAccepted
	}
	return ""
}

// Accept TOS response model
//
// x-displayName: "Accept TOS Response"
// Accept TOS response model
type AcceptTOSResponse struct {
}

func (m *AcceptTOSResponse) Reset()      { *m = AcceptTOSResponse{} }
func (*AcceptTOSResponse) ProtoMessage() {}
func (*AcceptTOSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPublicCustomapi, []int{17}
}

// Get TOS request model
//
// x-displayName: "Get TOS Request"
// Get TOS request model
type GetTOSRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *GetTOSRequest) Reset()                    { *m = GetTOSRequest{} }
func (*GetTOSRequest) ProtoMessage()               {}
func (*GetTOSRequest) Descriptor() ([]byte, []int) { return fileDescriptorPublicCustomapi, []int{18} }

func (m *GetTOSRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Get TOS response model
//
// x-displayName: "Get TOS Response"
// Get TOS response model
type GetTOSResponse struct {
	// Version
	//
	// x-displayName: "TOS Version"
	// x-example: "value"
	// Value of TOS version
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Text
	//
	// x-displayName: "TOS Text"
	// x-example: "value"
	// Value of TOS text
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *GetTOSResponse) Reset()                    { *m = GetTOSResponse{} }
func (*GetTOSResponse) ProtoMessage()               {}
func (*GetTOSResponse) Descriptor() ([]byte, []int) { return fileDescriptorPublicCustomapi, []int{19} }

func (m *GetTOSResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetTOSResponse) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorPublicCustomapi, []int{20} }

// FeatureFlagType
// x-displayName: "Feature and its Status for the Tenant's Plan"
type FeatureFlagType struct {
	// feature's name
	//
	// x-displayName: "Feature Name"
	// x-example: "value"
	// Name of the feature
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// disabled
	//
	// x-displayName "Disabled"
	// x-example: "true"
	// status of whether this feature should be disabled for current plan
	Disabled bool `protobuf:"varint,2,opt,name=disabled,proto3" json:"disabled,omitempty"`
}

func (m *FeatureFlagType) Reset()                    { *m = FeatureFlagType{} }
func (*FeatureFlagType) ProtoMessage()               {}
func (*FeatureFlagType) Descriptor() ([]byte, []int) { return fileDescriptorPublicCustomapi, []int{21} }

func (m *FeatureFlagType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FeatureFlagType) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func init() {
	proto.RegisterType((*BillingFeatureIndicator)(nil), "ves.io.schema.user.BillingFeatureIndicator")
	golang_proto.RegisterType((*BillingFeatureIndicator)(nil), "ves.io.schema.user.BillingFeatureIndicator")
	proto.RegisterType((*SendPasswordEmailRequest)(nil), "ves.io.schema.user.SendPasswordEmailRequest")
	golang_proto.RegisterType((*SendPasswordEmailRequest)(nil), "ves.io.schema.user.SendPasswordEmailRequest")
	proto.RegisterType((*SendPasswordEmailResponse)(nil), "ves.io.schema.user.SendPasswordEmailResponse")
	golang_proto.RegisterType((*SendPasswordEmailResponse)(nil), "ves.io.schema.user.SendPasswordEmailResponse")
	proto.RegisterType((*NamespacesRoleType)(nil), "ves.io.schema.user.NamespacesRoleType")
	golang_proto.RegisterType((*NamespacesRoleType)(nil), "ves.io.schema.user.NamespacesRoleType")
	proto.RegisterType((*NamespaceRoleType)(nil), "ves.io.schema.user.NamespaceRoleType")
	golang_proto.RegisterType((*NamespaceRoleType)(nil), "ves.io.schema.user.NamespaceRoleType")
	proto.RegisterType((*UserRoleRequest)(nil), "ves.io.schema.user.UserRoleRequest")
	golang_proto.RegisterType((*UserRoleRequest)(nil), "ves.io.schema.user.UserRoleRequest")
	proto.RegisterType((*ListUserRoleRequest)(nil), "ves.io.schema.user.ListUserRoleRequest")
	golang_proto.RegisterType((*ListUserRoleRequest)(nil), "ves.io.schema.user.ListUserRoleRequest")
	proto.RegisterType((*AssignRoleRequest)(nil), "ves.io.schema.user.AssignRoleRequest")
	golang_proto.RegisterType((*AssignRoleRequest)(nil), "ves.io.schema.user.AssignRoleRequest")
	proto.RegisterType((*ListUserRoleResponse)(nil), "ves.io.schema.user.ListUserRoleResponse")
	golang_proto.RegisterType((*ListUserRoleResponse)(nil), "ves.io.schema.user.ListUserRoleResponse")
	proto.RegisterType((*ListUserRoleResponseItem)(nil), "ves.io.schema.user.ListUserRoleResponseItem")
	golang_proto.RegisterType((*ListUserRoleResponseItem)(nil), "ves.io.schema.user.ListUserRoleResponseItem")
	proto.RegisterType((*GetUserRoleRequest)(nil), "ves.io.schema.user.GetUserRoleRequest")
	golang_proto.RegisterType((*GetUserRoleRequest)(nil), "ves.io.schema.user.GetUserRoleRequest")
	proto.RegisterType((*GetUserRoleResponse)(nil), "ves.io.schema.user.GetUserRoleResponse")
	golang_proto.RegisterType((*GetUserRoleResponse)(nil), "ves.io.schema.user.GetUserRoleResponse")
	proto.RegisterType((*NamespaceAccess)(nil), "ves.io.schema.user.NamespaceAccess")
	golang_proto.RegisterType((*NamespaceAccess)(nil), "ves.io.schema.user.NamespaceAccess")
	proto.RegisterType((*CascadeDeleteRequest)(nil), "ves.io.schema.user.CascadeDeleteRequest")
	golang_proto.RegisterType((*CascadeDeleteRequest)(nil), "ves.io.schema.user.CascadeDeleteRequest")
	proto.RegisterType((*CascadeDeleteResponse)(nil), "ves.io.schema.user.CascadeDeleteResponse")
	golang_proto.RegisterType((*CascadeDeleteResponse)(nil), "ves.io.schema.user.CascadeDeleteResponse")
	proto.RegisterType((*CascadeDeleteItemType)(nil), "ves.io.schema.user.CascadeDeleteItemType")
	golang_proto.RegisterType((*CascadeDeleteItemType)(nil), "ves.io.schema.user.CascadeDeleteItemType")
	proto.RegisterType((*AcceptTOSRequest)(nil), "ves.io.schema.user.AcceptTOSRequest")
	golang_proto.RegisterType((*AcceptTOSRequest)(nil), "ves.io.schema.user.AcceptTOSRequest")
	proto.RegisterType((*AcceptTOSResponse)(nil), "ves.io.schema.user.AcceptTOSResponse")
	golang_proto.RegisterType((*AcceptTOSResponse)(nil), "ves.io.schema.user.AcceptTOSResponse")
	proto.RegisterType((*GetTOSRequest)(nil), "ves.io.schema.user.GetTOSRequest")
	golang_proto.RegisterType((*GetTOSRequest)(nil), "ves.io.schema.user.GetTOSRequest")
	proto.RegisterType((*GetTOSResponse)(nil), "ves.io.schema.user.GetTOSResponse")
	golang_proto.RegisterType((*GetTOSResponse)(nil), "ves.io.schema.user.GetTOSResponse")
	proto.RegisterType((*Empty)(nil), "ves.io.schema.user.Empty")
	golang_proto.RegisterType((*Empty)(nil), "ves.io.schema.user.Empty")
	proto.RegisterType((*FeatureFlagType)(nil), "ves.io.schema.user.FeatureFlagType")
	golang_proto.RegisterType((*FeatureFlagType)(nil), "ves.io.schema.user.FeatureFlagType")
	proto.RegisterEnum("ves.io.schema.user.BillingFlag", BillingFlag_name, BillingFlag_value)
	golang_proto.RegisterEnum("ves.io.schema.user.BillingFlag", BillingFlag_name, BillingFlag_value)
	proto.RegisterEnum("ves.io.schema.user.BillingFlagAction", BillingFlagAction_name, BillingFlagAction_value)
	golang_proto.RegisterEnum("ves.io.schema.user.BillingFlagAction", BillingFlagAction_name, BillingFlagAction_value)
}
func (x BillingFlag) String() string {
	s, ok := BillingFlag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BillingFlagAction) String() string {
	s, ok := BillingFlagAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *BillingFeatureIndicator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BillingFeatureIndicator)
	if !ok {
		that2, ok := that.(BillingFeatureIndicator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BillingFlag != that1.BillingFlag {
		return false
	}
	if this.Failed != that1.Failed {
		return false
	}
	if this.AdditionalInfo != that1.AdditionalInfo {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *SendPasswordEmailRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendPasswordEmailRequest)
	if !ok {
		that2, ok := that.(SendPasswordEmailRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	return true
}
func (this *SendPasswordEmailResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendPasswordEmailResponse)
	if !ok {
		that2, ok := that.(SendPasswordEmailResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *NamespacesRoleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespacesRoleType)
	if !ok {
		that2, ok := that.(NamespacesRoleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Namespaces) != len(that1.Namespaces) {
		return false
	}
	for i := range this.Namespaces {
		if this.Namespaces[i] != that1.Namespaces[i] {
			return false
		}
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *NamespaceRoleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceRoleType)
	if !ok {
		that2, ok := that.(NamespaceRoleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *UserRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserRoleRequest)
	if !ok {
		that2, ok := that.(UserRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	if this.IdmType != that1.IdmType {
		return false
	}
	return true
}
func (this *ListUserRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserRoleRequest)
	if !ok {
		that2, ok := that.(ListUserRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *AssignRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssignRoleRequest)
	if !ok {
		that2, ok := that.(AssignRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if !this.NamespacesRole.Equal(that1.NamespacesRole) {
		return false
	}
	if len(this.Username) != len(that1.Username) {
		return false
	}
	for i := range this.Username {
		if this.Username[i] != that1.Username[i] {
			return false
		}
	}
	return true
}
func (this *ListUserRoleResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserRoleResponse)
	if !ok {
		that2, ok := that.(ListUserRoleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ListUserRoleResponseItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserRoleResponseItem)
	if !ok {
		that2, ok := that.(ListUserRoleResponseItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.TenantType != that1.TenantType {
		return false
	}
	if this.IdmType != that1.IdmType {
		return false
	}
	if this.DomainOwner != that1.DomainOwner {
		return false
	}
	if this.OtpEnabled != that1.OtpEnabled {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	return true
}
func (this *GetUserRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserRoleRequest)
	if !ok {
		that2, ok := that.(GetUserRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *GetUserRoleResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserRoleResponse)
	if !ok {
		that2, ok := that.(GetUserRoleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.TenantType != that1.TenantType {
		return false
	}
	if len(this.FeatureFlags) != len(that1.FeatureFlags) {
		return false
	}
	for i := range this.FeatureFlags {
		if !this.FeatureFlags[i].Equal(that1.FeatureFlags[i]) {
			return false
		}
	}
	if this.TosCurrentVersion != that1.TosCurrentVersion {
		return false
	}
	if this.TosAccepted != that1.TosAccepted {
		return false
	}
	if this.IdmType != that1.IdmType {
		return false
	}
	if len(this.NamespaceAccess) != len(that1.NamespaceAccess) {
		return false
	}
	for i := range this.NamespaceAccess {
		if !this.NamespaceAccess[i].Equal(that1.NamespaceAccess[i]) {
			return false
		}
	}
	if this.DomainOwner != that1.DomainOwner {
		return false
	}
	if this.Cname != that1.Cname {
		return false
	}
	if len(this.BillingFlags) != len(that1.BillingFlags) {
		return false
	}
	for i := range this.BillingFlags {
		if !this.BillingFlags[i].Equal(that1.BillingFlags[i]) {
			return false
		}
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if this.Company != that1.Company {
		return false
	}
	if this.PlanType != that1.PlanType {
		return false
	}
	if this.ActivePlanTransitionUid != that1.ActivePlanTransitionUid {
		return false
	}
	return true
}
func (this *NamespaceAccess) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceAccess)
	if !ok {
		that2, ok := that.(NamespaceAccess)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Roles) != len(that1.Roles) {
		return false
	}
	for i := range this.Roles {
		if this.Roles[i] != that1.Roles[i] {
			return false
		}
	}
	return true
}
func (this *CascadeDeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CascadeDeleteRequest)
	if !ok {
		that2, ok := that.(CascadeDeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	return true
}
func (this *CascadeDeleteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CascadeDeleteResponse)
	if !ok {
		that2, ok := that.(CascadeDeleteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeleteOk != that1.DeleteOk {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *CascadeDeleteItemType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CascadeDeleteItemType)
	if !ok {
		that2, ok := that.(CascadeDeleteItemType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ObjectType != that1.ObjectType {
		return false
	}
	if this.ObjectUid != that1.ObjectUid {
		return false
	}
	if this.ObjectName != that1.ObjectName {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	return true
}
func (this *AcceptTOSRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AcceptTOSRequest)
	if !ok {
		that2, ok := that.(AcceptTOSRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.TosAccepted != that1.TosAccepted {
		return false
	}
	return true
}
func (this *AcceptTOSResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AcceptTOSResponse)
	if !ok {
		that2, ok := that.(AcceptTOSResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetTOSRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTOSRequest)
	if !ok {
		that2, ok := that.(GetTOSRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *GetTOSResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTOSResponse)
	if !ok {
		that2, ok := that.(GetTOSResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *FeatureFlagType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeatureFlagType)
	if !ok {
		that2, ok := that.(FeatureFlagType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	return true
}
func (this *BillingFeatureIndicator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&user.BillingFeatureIndicator{")
	s = append(s, "BillingFlag: "+fmt.Sprintf("%#v", this.BillingFlag)+",\n")
	s = append(s, "Failed: "+fmt.Sprintf("%#v", this.Failed)+",\n")
	s = append(s, "AdditionalInfo: "+fmt.Sprintf("%#v", this.AdditionalInfo)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendPasswordEmailRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.SendPasswordEmailRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendPasswordEmailResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&user.SendPasswordEmailResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespacesRoleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.NamespacesRoleType{")
	s = append(s, "Namespaces: "+fmt.Sprintf("%#v", this.Namespaces)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceRoleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.NamespaceRoleType{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&user.UserRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "IdmType: "+fmt.Sprintf("%#v", this.IdmType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.ListUserRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AssignRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&user.AssignRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	if this.NamespacesRole != nil {
		s = append(s, "NamespacesRole: "+fmt.Sprintf("%#v", this.NamespacesRole)+",\n")
	}
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserRoleResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.ListUserRoleResponse{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserRoleResponseItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&user.ListUserRoleResponseItem{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "TenantType: "+fmt.Sprintf("%#v", this.TenantType)+",\n")
	s = append(s, "IdmType: "+fmt.Sprintf("%#v", this.IdmType)+",\n")
	s = append(s, "DomainOwner: "+fmt.Sprintf("%#v", this.DomainOwner)+",\n")
	s = append(s, "OtpEnabled: "+fmt.Sprintf("%#v", this.OtpEnabled)+",\n")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.GetUserRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserRoleResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 25)
	s = append(s, "&user.GetUserRoleResponse{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "TenantType: "+fmt.Sprintf("%#v", this.TenantType)+",\n")
	if this.FeatureFlags != nil {
		s = append(s, "FeatureFlags: "+fmt.Sprintf("%#v", this.FeatureFlags)+",\n")
	}
	s = append(s, "TosCurrentVersion: "+fmt.Sprintf("%#v", this.TosCurrentVersion)+",\n")
	s = append(s, "TosAccepted: "+fmt.Sprintf("%#v", this.TosAccepted)+",\n")
	s = append(s, "IdmType: "+fmt.Sprintf("%#v", this.IdmType)+",\n")
	keysForNamespaceAccess := make([]string, 0, len(this.NamespaceAccess))
	for k, _ := range this.NamespaceAccess {
		keysForNamespaceAccess = append(keysForNamespaceAccess, k)
	}
	sortkeys.Strings(keysForNamespaceAccess)
	mapStringForNamespaceAccess := "map[string]*NamespaceAccess{"
	for _, k := range keysForNamespaceAccess {
		mapStringForNamespaceAccess += fmt.Sprintf("%#v: %#v,", k, this.NamespaceAccess[k])
	}
	mapStringForNamespaceAccess += "}"
	if this.NamespaceAccess != nil {
		s = append(s, "NamespaceAccess: "+mapStringForNamespaceAccess+",\n")
	}
	s = append(s, "DomainOwner: "+fmt.Sprintf("%#v", this.DomainOwner)+",\n")
	s = append(s, "Cname: "+fmt.Sprintf("%#v", this.Cname)+",\n")
	if this.BillingFlags != nil {
		s = append(s, "BillingFlags: "+fmt.Sprintf("%#v", this.BillingFlags)+",\n")
	}
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	s = append(s, "Company: "+fmt.Sprintf("%#v", this.Company)+",\n")
	s = append(s, "PlanType: "+fmt.Sprintf("%#v", this.PlanType)+",\n")
	s = append(s, "ActivePlanTransitionUid: "+fmt.Sprintf("%#v", this.ActivePlanTransitionUid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceAccess) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.NamespaceAccess{")
	s = append(s, "Roles: "+fmt.Sprintf("%#v", this.Roles)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CascadeDeleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.CascadeDeleteRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CascadeDeleteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.CascadeDeleteResponse{")
	s = append(s, "DeleteOk: "+fmt.Sprintf("%#v", this.DeleteOk)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CascadeDeleteItemType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&user.CascadeDeleteItemType{")
	s = append(s, "ObjectType: "+fmt.Sprintf("%#v", this.ObjectType)+",\n")
	s = append(s, "ObjectUid: "+fmt.Sprintf("%#v", this.ObjectUid)+",\n")
	s = append(s, "ObjectName: "+fmt.Sprintf("%#v", this.ObjectName)+",\n")
	s = append(s, "ErrorMessage: "+fmt.Sprintf("%#v", this.ErrorMessage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AcceptTOSRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.AcceptTOSRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "TosAccepted: "+fmt.Sprintf("%#v", this.TosAccepted)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AcceptTOSResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&user.AcceptTOSResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTOSRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.GetTOSRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTOSResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.GetTOSResponse{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Text: "+fmt.Sprintf("%#v", this.Text)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&user.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FeatureFlagType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.FeatureFlagType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicCustomapi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CustomAPI service

type CustomAPIClient interface {
	// User with roles create
	//
	// x-displayName: "Create User with Role Assignment"
	// Create creates a user and namespace roles binding for this user
	Create(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error)
	// User with roles update
	//
	// x-displayName: "Update User and Role Assignments"
	// Replace updates user and namespace roles for this user
	Replace(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error)
	// User with roles list
	//
	// x-displayName: "Get User and Role Assignments"
	// List enumerates users and their namespace roles for this tenant
	List(ctx context.Context, in *ListUserRoleRequest, opts ...grpc.CallOption) (*ListUserRoleResponse, error)
	// User information details retrieval
	//
	// x-displayName: "Who am I"
	// Get fetches user information based on the username header from the request context
	Get(ctx context.Context, in *GetUserRoleRequest, opts ...grpc.CallOption) (*GetUserRoleResponse, error)
	// CascadeDelete
	//
	// x-displayName: "Delete User and Related Objects"
	// CascadeDelete deletes the user and associated namespace roles for this user.
	// Use this only if the user and its referenced objects need to be wiped out altogether.
	// Note: users will always be in the system namespace.
	CascadeDelete(ctx context.Context, in *CascadeDeleteRequest, opts ...grpc.CallOption) (*CascadeDeleteResponse, error)
	// Role assignment request
	//
	// x-displayName: "Assign role to User"
	// AssignRole allows customers to assign a namespace/role pair to multiple users
	AssignRole(ctx context.Context, in *AssignRoleRequest, opts ...grpc.CallOption) (*Empty, error)
	// Send password email
	//
	// x-displayName: "Send Password Email"
	// SendPasswordEmail allows admin user to send password email for the users to update their password.
	SendPasswordEmail(ctx context.Context, in *SendPasswordEmailRequest, opts ...grpc.CallOption) (*SendPasswordEmailResponse, error)
	// Accept TOS request
	//
	// x-displayName: "Accept TOS"
	// Accept TOS updates accepted version
	AcceptTOS(ctx context.Context, in *AcceptTOSRequest, opts ...grpc.CallOption) (*AcceptTOSResponse, error)
	// TOS request
	//
	// x-displayName: "Get TOS"
	// Get TOS provides TOS version with text
	GetTOS(ctx context.Context, in *GetTOSRequest, opts ...grpc.CallOption) (*GetTOSResponse, error)
}

type customAPIClient struct {
	cc *grpc.ClientConn
}

func NewCustomAPIClient(cc *grpc.ClientConn) CustomAPIClient {
	return &customAPIClient{cc}
}

func (c *customAPIClient) Create(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error) {
	out := new(Object)
	err := grpc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) Replace(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error) {
	out := new(Object)
	err := grpc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/Replace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) List(ctx context.Context, in *ListUserRoleRequest, opts ...grpc.CallOption) (*ListUserRoleResponse, error) {
	out := new(ListUserRoleResponse)
	err := grpc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) Get(ctx context.Context, in *GetUserRoleRequest, opts ...grpc.CallOption) (*GetUserRoleResponse, error) {
	out := new(GetUserRoleResponse)
	err := grpc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) CascadeDelete(ctx context.Context, in *CascadeDeleteRequest, opts ...grpc.CallOption) (*CascadeDeleteResponse, error) {
	out := new(CascadeDeleteResponse)
	err := grpc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/CascadeDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AssignRole(ctx context.Context, in *AssignRoleRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/AssignRole", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) SendPasswordEmail(ctx context.Context, in *SendPasswordEmailRequest, opts ...grpc.CallOption) (*SendPasswordEmailResponse, error) {
	out := new(SendPasswordEmailResponse)
	err := grpc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/SendPasswordEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AcceptTOS(ctx context.Context, in *AcceptTOSRequest, opts ...grpc.CallOption) (*AcceptTOSResponse, error) {
	out := new(AcceptTOSResponse)
	err := grpc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/AcceptTOS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) GetTOS(ctx context.Context, in *GetTOSRequest, opts ...grpc.CallOption) (*GetTOSResponse, error) {
	out := new(GetTOSResponse)
	err := grpc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/GetTOS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CustomAPI service

type CustomAPIServer interface {
	// User with roles create
	//
	// x-displayName: "Create User with Role Assignment"
	// Create creates a user and namespace roles binding for this user
	Create(context.Context, *UserRoleRequest) (*Object, error)
	// User with roles update
	//
	// x-displayName: "Update User and Role Assignments"
	// Replace updates user and namespace roles for this user
	Replace(context.Context, *UserRoleRequest) (*Object, error)
	// User with roles list
	//
	// x-displayName: "Get User and Role Assignments"
	// List enumerates users and their namespace roles for this tenant
	List(context.Context, *ListUserRoleRequest) (*ListUserRoleResponse, error)
	// User information details retrieval
	//
	// x-displayName: "Who am I"
	// Get fetches user information based on the username header from the request context
	Get(context.Context, *GetUserRoleRequest) (*GetUserRoleResponse, error)
	// CascadeDelete
	//
	// x-displayName: "Delete User and Related Objects"
	// CascadeDelete deletes the user and associated namespace roles for this user.
	// Use this only if the user and its referenced objects need to be wiped out altogether.
	// Note: users will always be in the system namespace.
	CascadeDelete(context.Context, *CascadeDeleteRequest) (*CascadeDeleteResponse, error)
	// Role assignment request
	//
	// x-displayName: "Assign role to User"
	// AssignRole allows customers to assign a namespace/role pair to multiple users
	AssignRole(context.Context, *AssignRoleRequest) (*Empty, error)
	// Send password email
	//
	// x-displayName: "Send Password Email"
	// SendPasswordEmail allows admin user to send password email for the users to update their password.
	SendPasswordEmail(context.Context, *SendPasswordEmailRequest) (*SendPasswordEmailResponse, error)
	// Accept TOS request
	//
	// x-displayName: "Accept TOS"
	// Accept TOS updates accepted version
	AcceptTOS(context.Context, *AcceptTOSRequest) (*AcceptTOSResponse, error)
	// TOS request
	//
	// x-displayName: "Get TOS"
	// Get TOS provides TOS version with text
	GetTOS(context.Context, *GetTOSRequest) (*GetTOSResponse, error)
}

func RegisterCustomAPIServer(s *grpc.Server, srv CustomAPIServer) {
	s.RegisterService(&_CustomAPI_serviceDesc, srv)
}

func _CustomAPI_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Create(ctx, req.(*UserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_Replace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Replace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/Replace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Replace(ctx, req.(*UserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).List(ctx, req.(*ListUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Get(ctx, req.(*GetUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_CascadeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CascadeDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).CascadeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/CascadeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).CascadeDelete(ctx, req.(*CascadeDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AssignRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AssignRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/AssignRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AssignRole(ctx, req.(*AssignRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_SendPasswordEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPasswordEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).SendPasswordEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/SendPasswordEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).SendPasswordEmail(ctx, req.(*SendPasswordEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AcceptTOS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptTOSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AcceptTOS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/AcceptTOS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AcceptTOS(ctx, req.(*AcceptTOSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_GetTOS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTOSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).GetTOS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/GetTOS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).GetTOS(ctx, req.(*GetTOSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.user.CustomAPI",
	HandlerType: (*CustomAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _CustomAPI_Create_Handler,
		},
		{
			MethodName: "Replace",
			Handler:    _CustomAPI_Replace_Handler,
		},
		{
			MethodName: "List",
			Handler:    _CustomAPI_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CustomAPI_Get_Handler,
		},
		{
			MethodName: "CascadeDelete",
			Handler:    _CustomAPI_CascadeDelete_Handler,
		},
		{
			MethodName: "AssignRole",
			Handler:    _CustomAPI_AssignRole_Handler,
		},
		{
			MethodName: "SendPasswordEmail",
			Handler:    _CustomAPI_SendPasswordEmail_Handler,
		},
		{
			MethodName: "AcceptTOS",
			Handler:    _CustomAPI_AcceptTOS_Handler,
		},
		{
			MethodName: "GetTOS",
			Handler:    _CustomAPI_GetTOS_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/user/public_customapi.proto",
}

func (m *BillingFeatureIndicator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BillingFeatureIndicator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BillingFlag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.BillingFlag))
	}
	if m.Failed {
		dAtA[i] = 0x10
		i++
		if m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AdditionalInfo) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.AdditionalInfo)))
		i += copy(dAtA[i:], m.AdditionalInfo)
	}
	if m.Action != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Action))
	}
	return i, nil
}

func (m *SendPasswordEmailRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPasswordEmailRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	return i, nil
}

func (m *SendPasswordEmailResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPasswordEmailResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NamespacesRoleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespacesRoleType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for _, s := range m.Namespaces {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	return i, nil
}

func (m *NamespaceRoleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceRoleType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	return i, nil
}

func (m *UserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.Type != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, msg := range m.NamespaceRoles {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IdmType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.IdmType))
	}
	return i, nil
}

func (m *ListUserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	return i, nil
}

func (m *AssignRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.NamespacesRole != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.NamespacesRole.Size()))
		n1, err := m.NamespacesRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Username) > 0 {
		for _, s := range m.Username {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ListUserRoleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRoleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListUserRoleResponseItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRoleResponseItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.Type != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, msg := range m.NamespaceRoles {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if m.TenantType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TenantType))
	}
	if m.IdmType != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.IdmType))
	}
	if m.DomainOwner {
		dAtA[i] = 0x58
		i++
		if m.DomainOwner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OtpEnabled {
		dAtA[i] = 0x60
		i++
		if m.OtpEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Disabled {
		dAtA[i] = 0x68
		i++
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CreationTimestamp != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.CreationTimestamp.Size()))
		n2, err := m.CreationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *GetUserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	return i, nil
}

func (m *GetUserRoleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRoleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.Type != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, msg := range m.NamespaceRoles {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if m.TenantType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TenantType))
	}
	if len(m.FeatureFlags) > 0 {
		for _, msg := range m.FeatureFlags {
			dAtA[i] = 0x52
			i++
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TosCurrentVersion) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosCurrentVersion)))
		i += copy(dAtA[i:], m.TosCurrentVersion)
	}
	if len(m.TosAccepted) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosAccepted)))
		i += copy(dAtA[i:], m.TosAccepted)
	}
	if m.IdmType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.IdmType))
	}
	if len(m.NamespaceAccess) > 0 {
		for k, _ := range m.NamespaceAccess {
			dAtA[i] = 0x72
			i++
			v := m.NamespaceAccess[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPublicCustomapi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + msgSize
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if m.DomainOwner {
		dAtA[i] = 0x78
		i++
		if m.DomainOwner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Cname) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Cname)))
		i += copy(dAtA[i:], m.Cname)
	}
	if len(m.BillingFlags) > 0 {
		for _, msg := range m.BillingFlags {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreationTimestamp != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.CreationTimestamp.Size()))
		n4, err := m.CreationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Company) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Company)))
		i += copy(dAtA[i:], m.Company)
	}
	if m.PlanType != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.PlanType))
	}
	if len(m.ActivePlanTransitionUid) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ActivePlanTransitionUid)))
		i += copy(dAtA[i:], m.ActivePlanTransitionUid)
	}
	return i, nil
}

func (m *NamespaceAccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceAccess) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CascadeDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CascadeDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	return i, nil
}

func (m *CascadeDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CascadeDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DeleteOk {
		dAtA[i] = 0x8
		i++
		if m.DeleteOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CascadeDeleteItemType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CascadeDeleteItemType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjectType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ObjectType)))
		i += copy(dAtA[i:], m.ObjectType)
	}
	if len(m.ObjectUid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ObjectUid)))
		i += copy(dAtA[i:], m.ObjectUid)
	}
	if len(m.ObjectName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ObjectName)))
		i += copy(dAtA[i:], m.ObjectName)
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	return i, nil
}

func (m *AcceptTOSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptTOSRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.TosAccepted) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosAccepted)))
		i += copy(dAtA[i:], m.TosAccepted)
	}
	return i, nil
}

func (m *AcceptTOSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptTOSResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetTOSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTOSRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	return i, nil
}

func (m *GetTOSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTOSResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FeatureFlagType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureFlagType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Disabled {
		dAtA[i] = 0x10
		i++
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintPublicCustomapi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BillingFeatureIndicator) Size() (n int) {
	var l int
	_ = l
	if m.BillingFlag != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.BillingFlag))
	}
	if m.Failed {
		n += 2
	}
	l = len(m.AdditionalInfo)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Action))
	}
	return n
}

func (m *SendPasswordEmailRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *SendPasswordEmailResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NamespacesRoleType) Size() (n int) {
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for _, s := range m.Namespaces {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *NamespaceRoleType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *UserRoleRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if m.IdmType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.IdmType))
	}
	return n
}

func (m *ListUserRoleRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *AssignRoleRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.NamespacesRole != nil {
		l = m.NamespacesRole.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Username) > 0 {
		for _, s := range m.Username {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *ListUserRoleResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *ListUserRoleResponseItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.TenantType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TenantType))
	}
	if m.IdmType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.IdmType))
	}
	if m.DomainOwner {
		n += 2
	}
	if m.OtpEnabled {
		n += 2
	}
	if m.Disabled {
		n += 2
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *GetUserRoleRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *GetUserRoleResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.TenantType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TenantType))
	}
	if len(m.FeatureFlags) > 0 {
		for _, e := range m.FeatureFlags {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.TosCurrentVersion)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TosAccepted)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.IdmType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.IdmType))
	}
	if len(m.NamespaceAccess) > 0 {
		for k, v := range m.NamespaceAccess {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	if m.DomainOwner {
		n += 2
	}
	l = len(m.Cname)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.BillingFlags) > 0 {
		for _, e := range m.BillingFlags {
			l = e.Size()
			n += 2 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Company)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.PlanType != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.PlanType))
	}
	l = len(m.ActivePlanTransitionUid)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *NamespaceAccess) Size() (n int) {
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *CascadeDeleteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *CascadeDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.DeleteOk {
		n += 2
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *CascadeDeleteItemType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ObjectType)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ObjectUid)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *AcceptTOSRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TosAccepted)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *AcceptTOSResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetTOSRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *GetTOSResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FeatureFlagType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	return n
}

func sovPublicCustomapi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPublicCustomapi(x uint64) (n int) {
	return sovPublicCustomapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BillingFeatureIndicator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BillingFeatureIndicator{`,
		`BillingFlag:` + fmt.Sprintf("%v", this.BillingFlag) + `,`,
		`Failed:` + fmt.Sprintf("%v", this.Failed) + `,`,
		`AdditionalInfo:` + fmt.Sprintf("%v", this.AdditionalInfo) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendPasswordEmailRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendPasswordEmailRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendPasswordEmailResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendPasswordEmailResponse{`,
		`}`,
	}, "")
	return s
}
func (this *NamespacesRoleType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespacesRoleType{`,
		`Namespaces:` + fmt.Sprintf("%v", this.Namespaces) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceRoleType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceRoleType{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NamespaceRoles:` + strings.Replace(fmt.Sprintf("%v", this.NamespaceRoles), "NamespaceRoleType", "NamespaceRoleType", 1) + `,`,
		`IdmType:` + fmt.Sprintf("%v", this.IdmType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListUserRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AssignRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AssignRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`NamespacesRole:` + strings.Replace(fmt.Sprintf("%v", this.NamespacesRole), "NamespacesRoleType", "NamespacesRoleType", 1) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserRoleResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListUserRoleResponse{`,
		`Items:` + strings.Replace(fmt.Sprintf("%v", this.Items), "ListUserRoleResponseItem", "ListUserRoleResponseItem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserRoleResponseItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListUserRoleResponseItem{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NamespaceRoles:` + strings.Replace(fmt.Sprintf("%v", this.NamespaceRoles), "NamespaceRoleType", "NamespaceRoleType", 1) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`TenantType:` + fmt.Sprintf("%v", this.TenantType) + `,`,
		`IdmType:` + fmt.Sprintf("%v", this.IdmType) + `,`,
		`DomainOwner:` + fmt.Sprintf("%v", this.DomainOwner) + `,`,
		`OtpEnabled:` + fmt.Sprintf("%v", this.OtpEnabled) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetUserRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetUserRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetUserRoleResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForNamespaceAccess := make([]string, 0, len(this.NamespaceAccess))
	for k, _ := range this.NamespaceAccess {
		keysForNamespaceAccess = append(keysForNamespaceAccess, k)
	}
	sortkeys.Strings(keysForNamespaceAccess)
	mapStringForNamespaceAccess := "map[string]*NamespaceAccess{"
	for _, k := range keysForNamespaceAccess {
		mapStringForNamespaceAccess += fmt.Sprintf("%v: %v,", k, this.NamespaceAccess[k])
	}
	mapStringForNamespaceAccess += "}"
	s := strings.Join([]string{`&GetUserRoleResponse{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NamespaceRoles:` + strings.Replace(fmt.Sprintf("%v", this.NamespaceRoles), "NamespaceRoleType", "NamespaceRoleType", 1) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`TenantType:` + fmt.Sprintf("%v", this.TenantType) + `,`,
		`FeatureFlags:` + strings.Replace(fmt.Sprintf("%v", this.FeatureFlags), "FeatureFlagType", "FeatureFlagType", 1) + `,`,
		`TosCurrentVersion:` + fmt.Sprintf("%v", this.TosCurrentVersion) + `,`,
		`TosAccepted:` + fmt.Sprintf("%v", this.TosAccepted) + `,`,
		`IdmType:` + fmt.Sprintf("%v", this.IdmType) + `,`,
		`NamespaceAccess:` + mapStringForNamespaceAccess + `,`,
		`DomainOwner:` + fmt.Sprintf("%v", this.DomainOwner) + `,`,
		`Cname:` + fmt.Sprintf("%v", this.Cname) + `,`,
		`BillingFlags:` + strings.Replace(fmt.Sprintf("%v", this.BillingFlags), "BillingFeatureIndicator", "BillingFeatureIndicator", 1) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`Company:` + fmt.Sprintf("%v", this.Company) + `,`,
		`PlanType:` + fmt.Sprintf("%v", this.PlanType) + `,`,
		`ActivePlanTransitionUid:` + fmt.Sprintf("%v", this.ActivePlanTransitionUid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceAccess) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceAccess{`,
		`Roles:` + fmt.Sprintf("%v", this.Roles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CascadeDeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CascadeDeleteRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CascadeDeleteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CascadeDeleteResponse{`,
		`DeleteOk:` + fmt.Sprintf("%v", this.DeleteOk) + `,`,
		`Items:` + strings.Replace(fmt.Sprintf("%v", this.Items), "CascadeDeleteItemType", "CascadeDeleteItemType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CascadeDeleteItemType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CascadeDeleteItemType{`,
		`ObjectType:` + fmt.Sprintf("%v", this.ObjectType) + `,`,
		`ObjectUid:` + fmt.Sprintf("%v", this.ObjectUid) + `,`,
		`ObjectName:` + fmt.Sprintf("%v", this.ObjectName) + `,`,
		`ErrorMessage:` + fmt.Sprintf("%v", this.ErrorMessage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptTOSRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptTOSRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`TosAccepted:` + fmt.Sprintf("%v", this.TosAccepted) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptTOSResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptTOSResponse{`,
		`}`,
	}, "")
	return s
}
func (this *GetTOSRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTOSRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTOSResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTOSResponse{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Text:` + fmt.Sprintf("%v", this.Text) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *FeatureFlagType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureFlagType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicCustomapi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BillingFeatureIndicator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BillingFeatureIndicator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BillingFeatureIndicator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingFlag", wireType)
			}
			m.BillingFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BillingFlag |= (BillingFlag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (BillingFlagAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPasswordEmailRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPasswordEmailRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPasswordEmailRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPasswordEmailResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPasswordEmailResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPasswordEmailResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespacesRoleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespacesRoleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespacesRoleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceRoleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceRoleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceRoleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (UserType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &NamespaceRoleType{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdmType", wireType)
			}
			m.IdmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdmType |= (IdmType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespacesRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NamespacesRole == nil {
				m.NamespacesRole = &NamespacesRoleType{}
			}
			if err := m.NamespacesRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = append(m.Username, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRoleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRoleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRoleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ListUserRoleResponseItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRoleResponseItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRoleResponseItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRoleResponseItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (UserType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &NamespaceRoleType{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantType", wireType)
			}
			m.TenantType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantType |= (ves_io_schema4.TenantType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdmType", wireType)
			}
			m.IdmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdmType |= (IdmType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainOwner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DomainOwner = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtpEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OtpEnabled = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRoleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRoleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRoleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (UserType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &NamespaceRoleType{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantType", wireType)
			}
			m.TenantType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantType |= (ves_io_schema4.TenantType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeatureFlags = append(m.FeatureFlags, &FeatureFlagType{})
			if err := m.FeatureFlags[len(m.FeatureFlags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosCurrentVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosCurrentVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAccepted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosAccepted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdmType", wireType)
			}
			m.IdmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdmType |= (IdmType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceAccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NamespaceAccess == nil {
				m.NamespaceAccess = make(map[string]*NamespaceAccess)
			}
			var mapkey string
			var mapvalue *NamespaceAccess
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamespaceAccess{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NamespaceAccess[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainOwner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DomainOwner = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillingFlags = append(m.BillingFlags, &BillingFeatureIndicator{})
			if err := m.BillingFlags[len(m.BillingFlags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &google_protobuf1.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Company", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Company = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanType", wireType)
			}
			m.PlanType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanType |= (ves_io_schema4.PlanType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePlanTransitionUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivePlanTransitionUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceAccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceAccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceAccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CascadeDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CascadeDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CascadeDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CascadeDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CascadeDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CascadeDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteOk = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &CascadeDeleteItemType{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CascadeDeleteItemType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CascadeDeleteItemType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CascadeDeleteItemType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptTOSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptTOSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptTOSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAccepted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosAccepted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptTOSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptTOSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptTOSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTOSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTOSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTOSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTOSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTOSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTOSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureFlagType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureFlagType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureFlagType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicCustomapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPublicCustomapi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPublicCustomapi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPublicCustomapi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicCustomapi   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("ves.io/schema/user/public_customapi.proto", fileDescriptorPublicCustomapi)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/user/public_customapi.proto", fileDescriptorPublicCustomapi)
}

var fileDescriptorPublicCustomapi = []byte{
	// 2145 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x52, 0xd4, 0x07, 0x1f, 0xf5, 0x41, 0x8d, 0x94, 0x78, 0x4d, 0x39, 0xb4, 0xbd, 0x8a,
	0x23, 0xc9, 0x09, 0x49, 0x57, 0x4e, 0x9a, 0xda, 0x4d, 0x6d, 0xd0, 0xe4, 0x5a, 0x62, 0x2b, 0x93,
	0xc2, 0x8a, 0x72, 0x63, 0x1b, 0xe9, 0x62, 0x45, 0x0e, 0xe9, 0xad, 0xc9, 0x9d, 0xed, 0xce, 0x52,
	0x8e, 0x52, 0x04, 0x68, 0xf3, 0x17, 0x14, 0x28, 0x7a, 0x29, 0xd0, 0xe6, 0x52, 0x14, 0xed, 0x5f,
	0xd0, 0x43, 0x0e, 0xcd, 0xcd, 0x45, 0x0a, 0xb4, 0x41, 0x7b, 0x68, 0x2e, 0x05, 0x6a, 0xa5, 0x87,
	0x34, 0xa7, 0x5c, 0x7b, 0x2b, 0x66, 0x66, 0x77, 0xb5, 0xa4, 0x96, 0x12, 0xe5, 0xa4, 0xe8, 0xa5,
	0xb7, 0x99, 0xf7, 0x35, 0xbf, 0x37, 0xef, 0xcd, 0xbc, 0x37, 0xbb, 0xb0, 0xba, 0x87, 0x69, 0xce,
	0x24, 0x79, 0x5a, 0x7f, 0x88, 0x3b, 0x46, 0xbe, 0x4b, 0xb1, 0x93, 0xb7, 0xbb, 0xbb, 0x6d, 0xb3,
	0xae, 0xd7, 0xbb, 0xd4, 0x25, 0x1d, 0xc3, 0x36, 0x73, 0xb6, 0x43, 0x5c, 0x82, 0x90, 0x10, 0xcd,
	0x09, 0xd1, 0x1c, 0x13, 0x4d, 0x67, 0x5b, 0xa6, 0xfb, 0xb0, 0xbb, 0x9b, 0xab, 0x93, 0x4e, 0xbe,
	0x45, 0x5a, 0x24, 0xcf, 0x45, 0x77, 0xbb, 0x4d, 0x3e, 0xe3, 0x13, 0x3e, 0x12, 0x26, 0xd2, 0xe7,
	0x5a, 0x84, 0xb4, 0xda, 0x38, 0x6f, 0xd8, 0x66, 0xde, 0xb0, 0x2c, 0xe2, 0x1a, 0xae, 0x49, 0x2c,
	0xea, 0x71, 0xcf, 0x7b, 0xdc, 0xc0, 0x86, 0x6b, 0x76, 0x30, 0x75, 0x8d, 0x8e, 0xed, 0x09, 0x2c,
	0xf6, 0x82, 0x25, 0x76, 0x58, 0xfb, 0x6c, 0x2f, 0xd3, 0xdd, 0xb7, 0x71, 0x60, 0x38, 0xc2, 0x49,
	0xb2, 0xfb, 0x7d, 0x5c, 0x77, 0x3d, 0x81, 0x4c, 0x84, 0x40, 0xd8, 0x80, 0xd2, 0xcb, 0xdf, 0xc3,
	0x14, 0x5b, 0x7b, 0xbd, 0xeb, 0x2b, 0x7f, 0x97, 0xe0, 0xcc, 0x2d, 0xb3, 0xdd, 0x36, 0xad, 0xd6,
	0x6d, 0x6c, 0xb8, 0x5d, 0x07, 0x97, 0xad, 0x86, 0x59, 0x37, 0x5c, 0xe2, 0xa0, 0x5b, 0x30, 0xb5,
	0x2b, 0x58, 0x7a, 0xb3, 0x6d, 0xb4, 0x64, 0xe9, 0x82, 0xb4, 0x32, 0xb3, 0x76, 0x3e, 0x77, 0x74,
	0x47, 0x73, 0xbe, 0x89, 0xb6, 0xd1, 0xd2, 0x92, 0xbb, 0x87, 0x13, 0xf4, 0x3c, 0x8c, 0x37, 0x0d,
	0xb3, 0x8d, 0x1b, 0x72, 0xec, 0x82, 0xb4, 0x32, 0xa9, 0x79, 0x33, 0xb4, 0x0c, 0xb3, 0x46, 0xa3,
	0x61, 0x32, 0x28, 0x46, 0x5b, 0x37, 0xad, 0x26, 0x91, 0x47, 0x2f, 0x48, 0x2b, 0x09, 0x6d, 0xe6,
	0x90, 0x5c, 0xb6, 0x9a, 0x04, 0x7d, 0x0b, 0xc6, 0x8d, 0x3a, 0x9b, 0xcb, 0x71, 0xbe, 0xfc, 0xa5,
	0x13, 0x96, 0x2f, 0x70, 0x61, 0xcd, 0x53, 0x52, 0x2a, 0x20, 0x6f, 0x63, 0xab, 0xb1, 0x65, 0x50,
	0xfa, 0x98, 0x38, 0x0d, 0xb5, 0x63, 0x98, 0x6d, 0x0d, 0xff, 0xa0, 0x8b, 0xa9, 0x8b, 0xce, 0x41,
	0xc2, 0x32, 0x3a, 0x98, 0xda, 0x46, 0x1d, 0x73, 0x78, 0x09, 0xed, 0x90, 0x80, 0x16, 0x60, 0x0c,
	0x33, 0x69, 0x0f, 0x97, 0x98, 0x28, 0x8b, 0x70, 0x36, 0xc2, 0x1e, 0xb5, 0x89, 0x45, 0xb1, 0xb2,
	0x01, 0xa8, 0xe2, 0xeb, 0x53, 0x8d, 0xb4, 0x71, 0x6d, 0xdf, 0xc6, 0x28, 0x03, 0x10, 0x58, 0xa5,
	0xb2, 0x74, 0x61, 0x74, 0x25, 0xa1, 0x85, 0x28, 0x08, 0x41, 0xdc, 0x21, 0x6d, 0x1f, 0x01, 0x1f,
	0x2b, 0x2a, 0xcc, 0x05, 0x96, 0x02, 0x43, 0x3d, 0x78, 0xa5, 0x7e, 0xbc, 0x51, 0x66, 0xfe, 0x1c,
	0x83, 0xd9, 0x1d, 0x8a, 0x1d, 0x66, 0x22, 0xd2, 0xeb, 0x28, 0x2b, 0x6c, 0xe2, 0x5b, 0x61, 0x63,
	0xf4, 0x02, 0x40, 0xd3, 0x74, 0xa8, 0xab, 0x73, 0x8e, 0xd8, 0x8e, 0x04, 0xa7, 0x30, 0x8c, 0x68,
	0x11, 0x12, 0x6d, 0xc3, 0xe7, 0xc6, 0x39, 0x77, 0x92, 0x11, 0x38, 0x33, 0xd8, 0xc5, 0xb1, 0xd0,
	0x2e, 0xa2, 0x2b, 0x10, 0x67, 0x89, 0x2a, 0x8f, 0xf3, 0x90, 0x9e, 0x8b, 0x0a, 0x29, 0x83, 0xcd,
	0xbc, 0xd6, 0xb8, 0x24, 0xaa, 0xc0, 0x6c, 0x00, 0x52, 0x67, 0xbe, 0x51, 0x79, 0xe2, 0xc2, 0xe8,
	0x4a, 0x32, 0x3a, 0x1f, 0x8e, 0xec, 0x9d, 0x36, 0x63, 0x85, 0x49, 0x14, 0x7d, 0x1d, 0x26, 0xcd,
	0x46, 0x47, 0xe7, 0x28, 0x26, 0x39, 0x8a, 0xc5, 0x28, 0x43, 0xe5, 0x46, 0x87, 0xab, 0x4f, 0x98,
	0x62, 0xa0, 0x5c, 0x85, 0xf9, 0x4d, 0x93, 0xba, 0xa7, 0xda, 0x54, 0xe5, 0x97, 0x12, 0xcc, 0x15,
	0x28, 0x35, 0x5b, 0xd6, 0xf0, 0x81, 0xa8, 0x86, 0x1c, 0xa6, 0x7a, 0x10, 0xd9, 0xe4, 0xda, 0x4b,
	0xc7, 0x3a, 0x4c, 0x23, 0x3c, 0xe6, 0x34, 0x94, 0x86, 0x49, 0x26, 0xea, 0xc5, 0x90, 0x25, 0x61,
	0x30, 0x57, 0xee, 0xc3, 0x42, 0xaf, 0x57, 0x22, 0xa1, 0xd1, 0x2d, 0x18, 0x33, 0x5d, 0xdc, 0x11,
	0x59, 0x9b, 0x5c, 0x7b, 0x25, 0x6a, 0xe9, 0x28, 0xc5, 0xb2, 0x8b, 0x3b, 0x9a, 0x50, 0x55, 0xfe,
	0x16, 0x07, 0x79, 0x90, 0xcc, 0x33, 0x24, 0x63, 0xe4, 0xb1, 0xec, 0x4b, 0xd1, 0xf8, 0xb1, 0x29,
	0x3a, 0xd6, 0x97, 0xa2, 0xff, 0xfb, 0x64, 0x7c, 0x1e, 0xc6, 0x5d, 0x6c, 0x19, 0x96, 0xcb, 0x53,
	0x31, 0xa1, 0x79, 0x33, 0x74, 0x1d, 0x92, 0x62, 0x24, 0xf2, 0x34, 0xc1, 0x01, 0x9e, 0xed, 0x5b,
	0xa3, 0xc6, 0x25, 0xb8, 0x5d, 0x70, 0x83, 0x71, 0x4f, 0x82, 0xc3, 0xf0, 0x09, 0x8e, 0x2e, 0xc2,
	0x54, 0x83, 0x74, 0x0c, 0xd3, 0xd2, 0xc9, 0x63, 0x0b, 0x3b, 0x72, 0x92, 0x5f, 0xdb, 0x49, 0x41,
	0xab, 0x32, 0x12, 0x3a, 0x0f, 0x49, 0xe2, 0xda, 0x3a, 0xb6, 0x8c, 0x5d, 0x76, 0xb1, 0x4f, 0x71,
	0x09, 0x20, 0xae, 0xad, 0x0a, 0x0a, 0x4b, 0xb5, 0x86, 0x49, 0x05, 0x77, 0x9a, 0x73, 0x83, 0x39,
	0x2a, 0x03, 0xaa, 0x3b, 0x98, 0x57, 0x50, 0x3d, 0xa8, 0x94, 0xf2, 0x0c, 0x4f, 0xed, 0x74, 0x4e,
	0xd4, 0xd2, 0x9c, 0x5f, 0x4b, 0x73, 0x35, 0x5f, 0x42, 0x9b, 0xf3, 0xb5, 0x02, 0x92, 0xb2, 0x06,
	0x68, 0x1d, 0x9f, 0xf2, 0x28, 0xfe, 0x7b, 0x12, 0xe6, 0x7b, 0x94, 0xbc, 0x4c, 0xff, 0x7f, 0x22,
	0xfe, 0xb7, 0x12, 0x71, 0x03, 0xa6, 0x9b, 0xa2, 0xb3, 0xe0, 0x5d, 0x04, 0x95, 0x81, 0x23, 0x5c,
	0x8a, 0x42, 0xe8, 0xb5, 0x20, 0xac, 0x8e, 0x73, 0x3b, 0x53, 0xcd, 0x43, 0x02, 0x45, 0x39, 0x98,
	0x77, 0x09, 0xd5, 0xeb, 0x5d, 0xc7, 0xc1, 0x96, 0xab, 0xef, 0x61, 0x87, 0xb2, 0xbe, 0x20, 0xc9,
	0xa1, 0xce, 0xb9, 0x84, 0x16, 0x05, 0xe7, 0xae, 0x60, 0xb0, 0x54, 0x66, 0xf2, 0x46, 0xbd, 0x8e,
	0x6d, 0xd7, 0x4b, 0xd4, 0x84, 0x96, 0x74, 0x09, 0x2d, 0x78, 0xa4, 0x9e, 0x53, 0x32, 0x7d, 0x8a,
	0x53, 0xd2, 0x82, 0xd4, 0xe1, 0xc6, 0xb3, 0x05, 0x28, 0x95, 0x67, 0xb8, 0x5f, 0x6f, 0x44, 0xe9,
	0x47, 0x64, 0xdc, 0x61, 0x34, 0x0a, 0x5c, 0x5d, 0xb5, 0x5c, 0x67, 0x5f, 0x3b, 0x0c, 0xa7, 0xa0,
	0x1e, 0x39, 0x8e, 0xb3, 0x47, 0x8f, 0xe3, 0x02, 0x8c, 0xd5, 0x79, 0x3e, 0xa5, 0x44, 0x22, 0xf2,
	0x09, 0xda, 0x82, 0xe9, 0x70, 0xf3, 0x46, 0xe5, 0x39, 0x0e, 0xef, 0xe5, 0xe3, 0xda, 0xa7, 0xbe,
	0x06, 0x50, 0x9b, 0x0a, 0x75, 0x72, 0x74, 0xc0, 0xc9, 0x45, 0xcf, 0x70, 0x72, 0x91, 0x0c, 0x13,
	0x75, 0xd2, 0xb1, 0x0d, 0x6b, 0x5f, 0x9e, 0xe7, 0xa0, 0xfd, 0x29, 0x7a, 0x15, 0x12, 0x76, 0xdb,
	0xb0, 0x44, 0x44, 0x16, 0x78, 0x44, 0xce, 0xf4, 0x41, 0xde, 0x6a, 0x1b, 0x16, 0x8f, 0xc6, 0xa4,
	0xed, 0x8d, 0xd0, 0x37, 0x21, 0xcd, 0xfa, 0xbd, 0x3d, 0xac, 0x0b, 0x65, 0xc7, 0xb0, 0x28, 0x6f,
	0x22, 0xf5, 0xae, 0xd9, 0x90, 0x9f, 0xe3, 0x4b, 0x9c, 0x11, 0x12, 0x5c, 0x3b, 0xe0, 0xef, 0x98,
	0x8d, 0x74, 0x0b, 0x16, 0xa2, 0x62, 0x81, 0x52, 0x30, 0xfa, 0x08, 0xef, 0x7b, 0x97, 0x01, 0x1b,
	0xa2, 0x6b, 0x30, 0xb6, 0x67, 0xb4, 0xbb, 0x7e, 0x25, 0x5e, 0x3a, 0xf6, 0x90, 0x09, 0x53, 0x9a,
	0xd0, 0xb8, 0x1e, 0xfb, 0x86, 0xa4, 0x2c, 0xc3, 0x6c, 0x1f, 0x97, 0xc5, 0x4e, 0x1c, 0x5b, 0xd1,
	0x16, 0x8a, 0x89, 0xf2, 0x6d, 0x58, 0x28, 0x1a, 0xb4, 0x6e, 0x34, 0x70, 0x09, 0xb7, 0xb1, 0x3b,
	0x64, 0xc7, 0x10, 0x5c, 0x48, 0xb1, 0x70, 0xc3, 0xda, 0x85, 0xe7, 0xfa, 0x6c, 0x79, 0x37, 0xde,
	0x22, 0x24, 0x1a, 0x9c, 0xa2, 0x93, 0x47, 0xdc, 0x18, 0xbb, 0xa5, 0x39, 0xa1, 0xfa, 0x08, 0xdd,
	0xf4, 0x0b, 0x7f, 0x8c, 0x67, 0xcd, 0x6a, 0x94, 0xa7, 0x3d, 0x66, 0x59, 0x35, 0xe7, 0x41, 0xf1,
	0xaa, 0xfe, 0x2f, 0xa4, 0xbe, 0x75, 0x7d, 0x01, 0x5e, 0x3d, 0xf8, 0x2b, 0x46, 0xc4, 0x58, 0xb8,
	0x01, 0x82, 0xc4, 0x05, 0x5e, 0x00, 0x6f, 0xc6, 0x83, 0xe7, 0xf5, 0xe5, 0x82, 0xb2, 0x63, 0x36,
	0x42, 0xfa, 0xa1, 0x76, 0xd4, 0xd3, 0xe0, 0xd7, 0xe8, 0x12, 0x4c, 0x63, 0xc7, 0x21, 0x8e, 0xde,
	0xc1, 0x94, 0x1a, 0x2d, 0xff, 0x16, 0x9e, 0xe2, 0xc4, 0x3b, 0x82, 0xa6, 0x6c, 0x43, 0x4a, 0x5c,
	0x02, 0xb5, 0xea, 0xf6, 0x70, 0xdb, 0xdb, 0x7f, 0x9b, 0xc4, 0x8e, 0xdc, 0x26, 0xca, 0x3c, 0xcc,
	0x85, 0x8c, 0x7a, 0x8f, 0x82, 0x2c, 0x4c, 0xaf, 0xe3, 0xa1, 0x97, 0x51, 0x6e, 0xc0, 0x8c, 0x2f,
	0xee, 0x05, 0x4a, 0x86, 0x09, 0xff, 0xaa, 0x13, 0xd2, 0xfe, 0x94, 0x95, 0x25, 0x17, 0xbf, 0xed,
	0xfa, 0x65, 0x89, 0x8d, 0x95, 0x09, 0x18, 0x53, 0x3b, 0xb6, 0xbb, 0xaf, 0x14, 0x60, 0xb6, 0xef,
	0x3a, 0x0d, 0xca, 0x98, 0x14, 0x2a, 0x63, 0xe1, 0x5a, 0x1d, 0xeb, 0xad, 0xd5, 0x97, 0x7f, 0x15,
	0x87, 0x64, 0xe8, 0x69, 0x85, 0x64, 0x58, 0xb8, 0x5b, 0xd8, 0x2c, 0x97, 0xf4, 0xad, 0xc2, 0xbd,
	0x3b, 0x6a, 0xa5, 0xa6, 0xdf, 0x51, 0x6b, 0x1b, 0xd5, 0x52, 0x6a, 0x04, 0xcd, 0xc3, 0x6c, 0xf5,
	0xae, 0xaa, 0x95, 0x76, 0x54, 0xbd, 0x5c, 0xb9, 0x5b, 0x2d, 0x17, 0xd5, 0x94, 0x84, 0x16, 0xe1,
	0xcc, 0x66, 0x61, 0xbb, 0xa6, 0xd7, 0xb4, 0x42, 0x65, 0xbb, 0x50, 0xac, 0x95, 0xab, 0x15, 0x7d,
	0xbb, 0x56, 0xa8, 0xed, 0x6c, 0xa7, 0x62, 0x28, 0x0d, 0xcf, 0xf7, 0x5a, 0xd1, 0xd5, 0x37, 0xb7,
	0xca, 0x9a, 0x5a, 0x4a, 0x8d, 0xa2, 0x4b, 0x70, 0xb1, 0x8f, 0x57, 0xae, 0x6c, 0xef, 0xdc, 0xbe,
	0x5d, 0x2e, 0x96, 0x19, 0xed, 0xf6, 0x4e, 0xa5, 0xb4, 0x9d, 0x8a, 0xa3, 0x25, 0x38, 0xdf, 0x27,
	0xb6, 0xa5, 0x95, 0xef, 0x14, 0xb4, 0x7b, 0x7a, 0x49, 0x2d, 0x6e, 0x96, 0x2b, 0x6a, 0x29, 0x35,
	0x86, 0x32, 0x90, 0xee, 0x13, 0x2a, 0xde, 0x2d, 0x32, 0x90, 0xcc, 0x91, 0xd4, 0x78, 0x04, 0xff,
	0x7e, 0x79, 0x2b, 0xe0, 0x4f, 0xa0, 0xd7, 0xe1, 0xea, 0x89, 0x58, 0xf4, 0x6d, 0xb5, 0x58, 0xad,
	0x94, 0xd8, 0xca, 0xc5, 0x8d, 0x82, 0xb6, 0xae, 0x96, 0x52, 0x93, 0xe8, 0x55, 0xb8, 0x32, 0x00,
	0x9d, 0xe7, 0x68, 0x84, 0x56, 0x02, 0xbd, 0x06, 0x5f, 0x3b, 0xc1, 0xa7, 0x08, 0x35, 0x40, 0x59,
	0x58, 0xed, 0x53, 0xbb, 0x55, 0xad, 0x6d, 0xf4, 0xc5, 0x49, 0xbf, 0x5d, 0x28, 0x6f, 0xaa, 0xa5,
	0x54, 0x12, 0x2d, 0x41, 0xa6, 0x8f, 0xb5, 0xae, 0x56, 0x54, 0xad, 0x5c, 0xe4, 0x22, 0x3b, 0x9a,
	0x9a, 0xfa, 0x6c, 0x02, 0x2d, 0x83, 0x32, 0x40, 0xa8, 0x50, 0x2a, 0x05, 0x82, 0xff, 0x9a, 0xb8,
	0x5c, 0x81, 0xb9, 0x23, 0x0f, 0x70, 0x34, 0x0d, 0x89, 0x4a, 0x55, 0x17, 0x51, 0x4f, 0x8d, 0xb0,
	0x70, 0x33, 0xad, 0x8a, 0xfa, 0xdd, 0xfe, 0xe4, 0x91, 0xd0, 0x0c, 0x40, 0xb1, 0x5a, 0xa9, 0x15,
	0x8a, 0x35, 0x9d, 0xa5, 0xc6, 0xda, 0x1f, 0x67, 0x20, 0x51, 0xe4, 0x9f, 0x71, 0x0a, 0x5b, 0x65,
	0xf4, 0x73, 0x09, 0xc6, 0x8b, 0xac, 0x82, 0x60, 0xb4, 0x34, 0xa8, 0x25, 0x0a, 0xf5, 0x7f, 0xe9,
	0x74, 0x94, 0x50, 0x95, 0x5f, 0x0f, 0x4a, 0xf5, 0xe0, 0x89, 0x9c, 0xda, 0xc3, 0x34, 0x6b, 0x92,
	0x6c, 0xd7, 0xe8, 0x64, 0x1f, 0x3b, 0xa6, 0x8b, 0xdf, 0xfb, 0xeb, 0x3f, 0x7f, 0x1a, 0x7b, 0x4d,
	0xb9, 0xe2, 0x7d, 0x41, 0xca, 0x8b, 0x2f, 0x48, 0xf9, 0xc3, 0xe7, 0x53, 0xfe, 0x87, 0xc1, 0xf8,
	0x5d, 0xfe, 0x95, 0x45, 0xb4, 0x5a, 0xd7, 0xa5, 0xcb, 0xe8, 0x77, 0xa3, 0x30, 0xa1, 0x61, 0xbb,
	0xcd, 0x2e, 0x88, 0x2f, 0x8d, 0xee, 0xf3, 0x58, 0x14, 0xbc, 0xcf, 0x9f, 0xc8, 0x9f, 0x48, 0xf0,
	0xa2, 0x47, 0x16, 0x6a, 0x59, 0xa6, 0x96, 0x0d, 0xf6, 0x28, 0xeb, 0x43, 0xd8, 0x80, 0x51, 0xbb,
	0xeb, 0xa2, 0xc2, 0x60, 0x57, 0x56, 0x1e, 0x18, 0xd9, 0x77, 0xde, 0x5a, 0x79, 0x90, 0x35, 0xb2,
	0xef, 0x5c, 0xc9, 0x5e, 0x7b, 0xeb, 0xf2, 0x03, 0x6f, 0xb0, 0x7a, 0x73, 0x35, 0xe4, 0x1b, 0x6a,
	0x42, 0xdc, 0x26, 0xd4, 0x45, 0xdf, 0xfb, 0xd2, 0xa6, 0x8e, 0x95, 0xe3, 0x7b, 0x4f, 0xd3, 0xcf,
	0xb2, 0xf7, 0xf7, 0xdf, 0x50, 0x5e, 0x3f, 0xad, 0x9a, 0x20, 0xbf, 0xcb, 0x22, 0xf7, 0x6b, 0x09,
	0xe2, 0xec, 0x59, 0x8a, 0x96, 0x4f, 0x7e, 0xd4, 0x8a, 0xd0, 0xad, 0x0c, 0xfb, 0xfa, 0x55, 0xbe,
	0x73, 0xf0, 0x44, 0x9e, 0x0d, 0xc5, 0xd1, 0xc1, 0x46, 0x83, 0x7b, 0xba, 0x86, 0x4e, 0xed, 0x29,
	0x7a, 0x5f, 0x82, 0xd1, 0x75, 0xec, 0xa2, 0x97, 0x4e, 0x6c, 0x2c, 0x05, 0xcc, 0xe5, 0x21, 0x1b,
	0x50, 0x65, 0x7d, 0x10, 0xca, 0x1c, 0x7a, 0x65, 0x38, 0x94, 0x8f, 0x1f, 0x12, 0xa3, 0x63, 0xa2,
	0xdf, 0x4b, 0x30, 0xdd, 0x53, 0xeb, 0xd1, 0xca, 0x89, 0xfd, 0x82, 0x8f, 0x76, 0x75, 0x08, 0x49,
	0x0f, 0xef, 0xbd, 0x81, 0x87, 0xf7, 0xa6, 0x72, 0x7d, 0xf8, 0x6d, 0xa5, 0xf9, 0xba, 0x30, 0xaf,
	0x8b, 0x6e, 0x87, 0x25, 0xc3, 0xfb, 0x12, 0xc0, 0xe1, 0x07, 0x1a, 0x14, 0xf9, 0x7a, 0x3a, 0xf2,
	0x01, 0x27, 0x7d, 0x36, 0x4a, 0x4c, 0x14, 0xdf, 0xaf, 0xe0, 0xa2, 0x61, 0xd1, 0xd7, 0x39, 0x60,
	0x86, 0xf0, 0x23, 0x09, 0xe6, 0x8e, 0x7c, 0x78, 0x44, 0x91, 0x1f, 0x64, 0x06, 0x7d, 0xef, 0x4c,
	0x67, 0x87, 0x94, 0xf6, 0xf6, 0xfb, 0xcd, 0x81, 0x3e, 0xdc, 0x50, 0xae, 0x0d, 0xe7, 0x03, 0xc5,
	0x56, 0x43, 0xb7, 0x3d, 0xeb, 0x3a, 0x6f, 0x48, 0x99, 0x33, 0xbf, 0x95, 0x20, 0x11, 0x34, 0x4a,
	0xe8, 0xc5, 0xc8, 0xdd, 0xee, 0x6b, 0xce, 0xd2, 0x97, 0x4e, 0x90, 0xf2, 0x40, 0x7f, 0x05, 0x1b,
	0x2f, 0x3a, 0x3c, 0xdd, 0x25, 0x7c, 0xe3, 0x7f, 0x26, 0xc1, 0xb8, 0x68, 0xc8, 0xd0, 0xc5, 0x01,
	0x27, 0x2b, 0x84, 0x52, 0x39, 0x4e, 0xc4, 0x83, 0x58, 0x1a, 0x74, 0xee, 0x5e, 0x46, 0xab, 0xc3,
	0x21, 0x74, 0x09, 0x4d, 0x2f, 0x7f, 0xf8, 0x81, 0x34, 0xfa, 0x97, 0x0f, 0xa4, 0xb3, 0x03, 0xeb,
	0xc9, 0x7b, 0x7f, 0x92, 0x63, 0x0f, 0xa5, 0x5b, 0x3f, 0x96, 0x3e, 0xba, 0x11, 0x2f, 0x6a, 0x3b,
	0x9b, 0x1f, 0x3f, 0xcd, 0x8c, 0x7c, 0xf2, 0x34, 0x33, 0xf2, 0xc5, 0xd3, 0x8c, 0xf4, 0xa3, 0x83,
	0x8c, 0xf4, 0x9b, 0x83, 0x8c, 0xf4, 0x87, 0x83, 0x8c, 0xf4, 0xf1, 0x41, 0x46, 0xfa, 0xc7, 0x41,
	0x46, 0xfa, 0xec, 0x20, 0x33, 0xf2, 0xc5, 0x41, 0x46, 0xfa, 0xc9, 0xa7, 0x99, 0x91, 0x0f, 0x3f,
	0xcd, 0x48, 0xf7, 0x37, 0x5a, 0xc4, 0x7e, 0xd4, 0xca, 0xed, 0x91, 0xb6, 0x8b, 0x1d, 0x87, 0xd9,
	0xce, 0xf3, 0x41, 0x93, 0x38, 0x9d, 0xac, 0xed, 0x90, 0x3d, 0xb3, 0x81, 0x9d, 0xac, 0xcf, 0xce,
	0xdb, 0xbb, 0x2d, 0x92, 0xc7, 0x6f, 0xbb, 0xde, 0xef, 0x86, 0xd0, 0x5f, 0x89, 0xdd, 0x71, 0xfe,
	0x2c, 0xbc, 0xfa, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd6, 0x87, 0x93, 0x40, 0xb8, 0x19, 0x00,
	0x00,
}

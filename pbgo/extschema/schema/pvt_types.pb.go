// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/pvt_types.proto

package schema

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	google_protobuf3 "github.com/gogo/protobuf/types"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Title
//
// x-displayName: "displayname"
// Only added so codegeneration does not break
type ServiceConnectionType int32

const (
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	TLS ServiceConnectionType = 0
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	NoTLS ServiceConnectionType = 1
)

var ServiceConnectionType_name = map[int32]string{
	0: "TLS",
	1: "NoTLS",
}
var ServiceConnectionType_value = map[string]int32{
	"TLS":   0,
	"NoTLS": 1,
}

func (ServiceConnectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorPvtTypes, []int{0}
}

// DaemonTLSParamsType
//
// x-displayName: "DaemonTLSParamsType"
// DaemonTLSParamsType specifies all TLS related information for a Volterra
// service-framework based daemon.
type DaemonTLSParamsType struct {
	// Server Params
	//
	// x-displayName: "Server Params"
	// TLS Params for server
	ServerParams *DaemonTlsParametersType `protobuf:"bytes,1,opt,name=server_params,json=serverParams" json:"server_params,omitempty"`
	// Client Params
	//
	// x-displayName: "Client Params"
	// TLS Params for client
	ClientParams *DaemonTlsParametersType `protobuf:"bytes,2,opt,name=client_params,json=clientParams" json:"client_params,omitempty"`
}

func (m *DaemonTLSParamsType) Reset()                    { *m = DaemonTLSParamsType{} }
func (*DaemonTLSParamsType) ProtoMessage()               {}
func (*DaemonTLSParamsType) Descriptor() ([]byte, []int) { return fileDescriptorPvtTypes, []int{0} }

func (m *DaemonTLSParamsType) GetServerParams() *DaemonTlsParametersType {
	if m != nil {
		return m.ServerParams
	}
	return nil
}

func (m *DaemonTLSParamsType) GetClientParams() *DaemonTlsParametersType {
	if m != nil {
		return m.ClientParams
	}
	return nil
}

// DaemonTlsCertificateType
//
// x-displayName: "TLS Certificate"
// Handle to fetch certificate and key
type DaemonTlsCertificateType struct {
	// certificate_url
	//
	// x-displayName: "Certificate URL"
	// The TLS certificate URL.
	CertificateUrl string `protobuf:"bytes,1,opt,name=certificate_url,json=certificateUrl,proto3" json:"certificate_url,omitempty"`
	// key_url
	//
	// x-displayName: "Key URL"
	// The TLS private key URL.
	PrivateKeyUrl string `protobuf:"bytes,2,opt,name=private_key_url,json=privateKeyUrl,proto3" json:"private_key_url,omitempty"`
}

func (m *DaemonTlsCertificateType) Reset()      { *m = DaemonTlsCertificateType{} }
func (*DaemonTlsCertificateType) ProtoMessage() {}
func (*DaemonTlsCertificateType) Descriptor() ([]byte, []int) {
	return fileDescriptorPvtTypes, []int{1}
}

func (m *DaemonTlsCertificateType) GetCertificateUrl() string {
	if m != nil {
		return m.CertificateUrl
	}
	return ""
}

func (m *DaemonTlsCertificateType) GetPrivateKeyUrl() string {
	if m != nil {
		return m.PrivateKeyUrl
	}
	return ""
}

// DaemonTlsParamsType
//
// x-displayName: "Daemon TLS parameters"
// Information of different aspects for TLS authentication related to ciphers,
// certificates and trust store
type DaemonTlsParametersType struct {
	// minimum_protocol_version
	//
	// x-displayName: "Minimum TLS version"
	// Minimum TLS protocol version. Not being used right now.
	MinimumProtocolVersion TlsProtocol `protobuf:"varint,1,opt,name=minimum_protocol_version,json=minimumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"minimum_protocol_version,omitempty"`
	// maximum_protocol_version
	//
	// x-displayName: "Maximum TLS version"
	// Maximum TLS protocol version. Not being used right now.
	MaximumProtocolVersion TlsProtocol `protobuf:"varint,2,opt,name=maximum_protocol_version,json=maximumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"maximum_protocol_version,omitempty"`
	// cipher_suites
	//
	// x-displayName: "Cipher Suites"
	// If specified, the TLS listener will only support the specified [cipher list.]
	// (https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>)
	// If not specified, the default list:
	//   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
	//   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
	//   ECDHE-ECDSA-AES128-SHA
	//   ECDHE-RSA-AES128-SHA
	//   AES128-GCM-SHA256
	//   AES128-SHA
	//   ECDHE-ECDSA-AES256-GCM-SHA384
	//   ECDHE-RSA-AES256-GCM-SHA384
	//   ECDHE-ECDSA-AES256-SHA
	//   ECDHE-RSA-AES256-SHA
	//   AES256-GCM-SHA384
	//   AES256-SHA
	// will be used. Not being used right now.
	CipherSuites []string `protobuf:"bytes,3,rep,name=cipher_suites,json=cipherSuites" json:"cipher_suites,omitempty"`
	// tls_certificates
	//
	// x-displayName: "TLS Certificates"
	// Set of TLS certificates
	TlsCertificates []*DaemonTlsCertificateType `protobuf:"bytes,4,rep,name=tls_certificates,json=tlsCertificates" json:"tls_certificates,omitempty"`
	// trusted_ca_url
	//
	// x-displayName: "Trusted CA"
	// The URL for a trust store
	TrustedCaUrl string `protobuf:"bytes,5,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"`
}

func (m *DaemonTlsParametersType) Reset()                    { *m = DaemonTlsParametersType{} }
func (*DaemonTlsParametersType) ProtoMessage()               {}
func (*DaemonTlsParametersType) Descriptor() ([]byte, []int) { return fileDescriptorPvtTypes, []int{2} }

func (m *DaemonTlsParametersType) GetMinimumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MinimumProtocolVersion
	}
	return TLS_AUTO
}

func (m *DaemonTlsParametersType) GetMaximumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MaximumProtocolVersion
	}
	return TLS_AUTO
}

func (m *DaemonTlsParametersType) GetCipherSuites() []string {
	if m != nil {
		return m.CipherSuites
	}
	return nil
}

func (m *DaemonTlsParametersType) GetTlsCertificates() []*DaemonTlsCertificateType {
	if m != nil {
		return m.TlsCertificates
	}
	return nil
}

func (m *DaemonTlsParametersType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
// UseragentType specifies all attributes encoded in Useragent header
// emitted by a service-framework based client.
type UseragentType struct {
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	ProgramName string `protobuf:"bytes,1,opt,name=program_name,json=programName,proto3" json:"program_name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	ServiceName string `protobuf:"bytes,3,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	SiteName string `protobuf:"bytes,4,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
}

func (m *UseragentType) Reset()                    { *m = UseragentType{} }
func (*UseragentType) ProtoMessage()               {}
func (*UseragentType) Descriptor() ([]byte, []int) { return fileDescriptorPvtTypes, []int{3} }

func (m *UseragentType) GetProgramName() string {
	if m != nil {
		return m.ProgramName
	}
	return ""
}

func (m *UseragentType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *UseragentType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *UseragentType) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
// ServiceParam groups all parameters required for a client to connect to a server
type ServiceParameters struct {
	// Title
	//
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// Title
	//
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	Ctype ServiceConnectionType `protobuf:"varint,2,opt,name=ctype,proto3,enum=ves.io.schema.ServiceConnectionType" json:"ctype,omitempty"`
}

func (m *ServiceParameters) Reset()                    { *m = ServiceParameters{} }
func (*ServiceParameters) ProtoMessage()               {}
func (*ServiceParameters) Descriptor() ([]byte, []int) { return fileDescriptorPvtTypes, []int{4} }

func (m *ServiceParameters) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ServiceParameters) GetCtype() ServiceConnectionType {
	if m != nil {
		return m.Ctype
	}
	return TLS
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
// OperMetaType is metadata that oper objects may have.
// Implementors can decided whether individual oper objects should have this field or not.
// If an oper object does have metadata, it should use this message type.
type OperMetaType struct {
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Tenant to which this object belongs.
	Tenant string `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Namespace defines the space within each name must be unique.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Name must be unique within a namespace.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// UID is the unique in time and space value for this object.
	Uid string `protobuf:"bytes,4,opt,name=uid,proto3" json:"uid,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Creation and last modification timestamps for this object.
	CreationTimestamp *google_protobuf3.Timestamp `protobuf:"bytes,5,opt,name=creation_timestamp,json=creationTimestamp" json:"creation_timestamp,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	ModificationTimestamp *google_protobuf3.Timestamp `protobuf:"bytes,6,opt,name=modification_timestamp,json=modificationTimestamp" json:"modification_timestamp,omitempty"`
}

func (m *OperMetaType) Reset()                    { *m = OperMetaType{} }
func (*OperMetaType) ProtoMessage()               {}
func (*OperMetaType) Descriptor() ([]byte, []int) { return fileDescriptorPvtTypes, []int{5} }

func (m *OperMetaType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *OperMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *OperMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OperMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *OperMetaType) GetCreationTimestamp() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *OperMetaType) GetModificationTimestamp() *google_protobuf3.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
// DaemonEnvironmentType is the specification of the environment in which the daemon is launched
type DaemonEnvironmentType struct {
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Name of the environment - staging, demo1, crt, etc.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// DNS suffix to use for internal communication - int.ves.io, int.volterra.us, etc.
	InternalDnsSuffix string `protobuf:"bytes,2,opt,name=internal_dns_suffix,json=internalDnsSuffix,proto3" json:"internal_dns_suffix,omitempty"`
}

func (m *DaemonEnvironmentType) Reset()                    { *m = DaemonEnvironmentType{} }
func (*DaemonEnvironmentType) ProtoMessage()               {}
func (*DaemonEnvironmentType) Descriptor() ([]byte, []int) { return fileDescriptorPvtTypes, []int{6} }

func (m *DaemonEnvironmentType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DaemonEnvironmentType) GetInternalDnsSuffix() string {
	if m != nil {
		return m.InternalDnsSuffix
	}
	return ""
}

func init() {
	proto.RegisterType((*DaemonTLSParamsType)(nil), "ves.io.schema.DaemonTLSParamsType")
	golang_proto.RegisterType((*DaemonTLSParamsType)(nil), "ves.io.schema.DaemonTLSParamsType")
	proto.RegisterType((*DaemonTlsCertificateType)(nil), "ves.io.schema.DaemonTlsCertificateType")
	golang_proto.RegisterType((*DaemonTlsCertificateType)(nil), "ves.io.schema.DaemonTlsCertificateType")
	proto.RegisterType((*DaemonTlsParametersType)(nil), "ves.io.schema.DaemonTlsParametersType")
	golang_proto.RegisterType((*DaemonTlsParametersType)(nil), "ves.io.schema.DaemonTlsParametersType")
	proto.RegisterType((*UseragentType)(nil), "ves.io.schema.UseragentType")
	golang_proto.RegisterType((*UseragentType)(nil), "ves.io.schema.UseragentType")
	proto.RegisterType((*ServiceParameters)(nil), "ves.io.schema.ServiceParameters")
	golang_proto.RegisterType((*ServiceParameters)(nil), "ves.io.schema.ServiceParameters")
	proto.RegisterType((*OperMetaType)(nil), "ves.io.schema.OperMetaType")
	golang_proto.RegisterType((*OperMetaType)(nil), "ves.io.schema.OperMetaType")
	proto.RegisterType((*DaemonEnvironmentType)(nil), "ves.io.schema.DaemonEnvironmentType")
	golang_proto.RegisterType((*DaemonEnvironmentType)(nil), "ves.io.schema.DaemonEnvironmentType")
	proto.RegisterEnum("ves.io.schema.ServiceConnectionType", ServiceConnectionType_name, ServiceConnectionType_value)
	golang_proto.RegisterEnum("ves.io.schema.ServiceConnectionType", ServiceConnectionType_name, ServiceConnectionType_value)
}
func (x ServiceConnectionType) String() string {
	s, ok := ServiceConnectionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *DaemonTLSParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonTLSParamsType)
	if !ok {
		that2, ok := that.(DaemonTLSParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerParams.Equal(that1.ServerParams) {
		return false
	}
	if !this.ClientParams.Equal(that1.ClientParams) {
		return false
	}
	return true
}
func (this *DaemonTlsCertificateType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonTlsCertificateType)
	if !ok {
		that2, ok := that.(DaemonTlsCertificateType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CertificateUrl != that1.CertificateUrl {
		return false
	}
	if this.PrivateKeyUrl != that1.PrivateKeyUrl {
		return false
	}
	return true
}
func (this *DaemonTlsParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonTlsParametersType)
	if !ok {
		that2, ok := that.(DaemonTlsParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinimumProtocolVersion != that1.MinimumProtocolVersion {
		return false
	}
	if this.MaximumProtocolVersion != that1.MaximumProtocolVersion {
		return false
	}
	if len(this.CipherSuites) != len(that1.CipherSuites) {
		return false
	}
	for i := range this.CipherSuites {
		if this.CipherSuites[i] != that1.CipherSuites[i] {
			return false
		}
	}
	if len(this.TlsCertificates) != len(that1.TlsCertificates) {
		return false
	}
	for i := range this.TlsCertificates {
		if !this.TlsCertificates[i].Equal(that1.TlsCertificates[i]) {
			return false
		}
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *UseragentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UseragentType)
	if !ok {
		that2, ok := that.(UseragentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProgramName != that1.ProgramName {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	return true
}
func (this *ServiceParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceParameters)
	if !ok {
		that2, ok := that.(ServiceParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.Ctype != that1.Ctype {
		return false
	}
	return true
}
func (this *OperMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OperMetaType)
	if !ok {
		that2, ok := that.(OperMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	return true
}
func (this *DaemonEnvironmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonEnvironmentType)
	if !ok {
		that2, ok := that.(DaemonEnvironmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.InternalDnsSuffix != that1.InternalDnsSuffix {
		return false
	}
	return true
}
func (this *DaemonTLSParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DaemonTLSParamsType{")
	if this.ServerParams != nil {
		s = append(s, "ServerParams: "+fmt.Sprintf("%#v", this.ServerParams)+",\n")
	}
	if this.ClientParams != nil {
		s = append(s, "ClientParams: "+fmt.Sprintf("%#v", this.ClientParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DaemonTlsCertificateType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DaemonTlsCertificateType{")
	s = append(s, "CertificateUrl: "+fmt.Sprintf("%#v", this.CertificateUrl)+",\n")
	s = append(s, "PrivateKeyUrl: "+fmt.Sprintf("%#v", this.PrivateKeyUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DaemonTlsParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.DaemonTlsParametersType{")
	s = append(s, "MinimumProtocolVersion: "+fmt.Sprintf("%#v", this.MinimumProtocolVersion)+",\n")
	s = append(s, "MaximumProtocolVersion: "+fmt.Sprintf("%#v", this.MaximumProtocolVersion)+",\n")
	s = append(s, "CipherSuites: "+fmt.Sprintf("%#v", this.CipherSuites)+",\n")
	if this.TlsCertificates != nil {
		s = append(s, "TlsCertificates: "+fmt.Sprintf("%#v", this.TlsCertificates)+",\n")
	}
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UseragentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.UseragentType{")
	s = append(s, "ProgramName: "+fmt.Sprintf("%#v", this.ProgramName)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.ServiceParameters{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "Ctype: "+fmt.Sprintf("%#v", this.Ctype)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OperMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.OperMetaType{")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DaemonEnvironmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DaemonEnvironmentType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "InternalDnsSuffix: "+fmt.Sprintf("%#v", this.InternalDnsSuffix)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPvtTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DaemonTLSParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonTLSParamsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerParams != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.ServerParams.Size()))
		n1, err := m.ServerParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ClientParams != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.ClientParams.Size()))
		n2, err := m.ClientParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *DaemonTlsCertificateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonTlsCertificateType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CertificateUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.CertificateUrl)))
		i += copy(dAtA[i:], m.CertificateUrl)
	}
	if len(m.PrivateKeyUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.PrivateKeyUrl)))
		i += copy(dAtA[i:], m.PrivateKeyUrl)
	}
	return i, nil
}

func (m *DaemonTlsParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonTlsParametersType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinimumProtocolVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.MinimumProtocolVersion))
	}
	if m.MaximumProtocolVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.MaximumProtocolVersion))
	}
	if len(m.CipherSuites) > 0 {
		for _, s := range m.CipherSuites {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TlsCertificates) > 0 {
		for _, msg := range m.TlsCertificates {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPvtTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TrustedCaUrl) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i += copy(dAtA[i:], m.TrustedCaUrl)
	}
	return i, nil
}

func (m *UseragentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseragentType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProgramName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.ProgramName)))
		i += copy(dAtA[i:], m.ProgramName)
	}
	if len(m.HostName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.SiteName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.SiteName)))
		i += copy(dAtA[i:], m.SiteName)
	}
	return i, nil
}

func (m *ServiceParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceParameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.Ctype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.Ctype))
	}
	return i, nil
}

func (m *OperMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperMetaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tenant) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Uid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if m.CreationTimestamp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.CreationTimestamp.Size()))
		n3, err := m.CreationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ModificationTimestamp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.ModificationTimestamp.Size()))
		n4, err := m.ModificationTimestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *DaemonEnvironmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonEnvironmentType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.InternalDnsSuffix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.InternalDnsSuffix)))
		i += copy(dAtA[i:], m.InternalDnsSuffix)
	}
	return i, nil
}

func encodeVarintPvtTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedDaemonTLSParamsType(r randyPvtTypes, easy bool) *DaemonTLSParamsType {
	this := &DaemonTLSParamsType{}
	if r.Intn(10) != 0 {
		this.ServerParams = NewPopulatedDaemonTlsParametersType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ClientParams = NewPopulatedDaemonTlsParametersType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDaemonTlsCertificateType(r randyPvtTypes, easy bool) *DaemonTlsCertificateType {
	this := &DaemonTlsCertificateType{}
	this.CertificateUrl = string(randStringPvtTypes(r))
	this.PrivateKeyUrl = string(randStringPvtTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDaemonTlsParametersType(r randyPvtTypes, easy bool) *DaemonTlsParametersType {
	this := &DaemonTlsParametersType{}
	this.MinimumProtocolVersion = TlsProtocol([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.MaximumProtocolVersion = TlsProtocol([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	v1 := r.Intn(10)
	this.CipherSuites = make([]string, v1)
	for i := 0; i < v1; i++ {
		this.CipherSuites[i] = string(randStringPvtTypes(r))
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.TlsCertificates = make([]*DaemonTlsCertificateType, v2)
		for i := 0; i < v2; i++ {
			this.TlsCertificates[i] = NewPopulatedDaemonTlsCertificateType(r, easy)
		}
	}
	this.TrustedCaUrl = string(randStringPvtTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUseragentType(r randyPvtTypes, easy bool) *UseragentType {
	this := &UseragentType{}
	this.ProgramName = string(randStringPvtTypes(r))
	this.HostName = string(randStringPvtTypes(r))
	this.ServiceName = string(randStringPvtTypes(r))
	this.SiteName = string(randStringPvtTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedServiceParameters(r randyPvtTypes, easy bool) *ServiceParameters {
	this := &ServiceParameters{}
	this.Url = string(randStringPvtTypes(r))
	this.Ctype = ServiceConnectionType([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOperMetaType(r randyPvtTypes, easy bool) *OperMetaType {
	this := &OperMetaType{}
	this.Tenant = string(randStringPvtTypes(r))
	this.Namespace = string(randStringPvtTypes(r))
	this.Name = string(randStringPvtTypes(r))
	this.Uid = string(randStringPvtTypes(r))
	if r.Intn(10) != 0 {
		this.CreationTimestamp = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ModificationTimestamp = google_protobuf3.NewPopulatedTimestamp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDaemonEnvironmentType(r randyPvtTypes, easy bool) *DaemonEnvironmentType {
	this := &DaemonEnvironmentType{}
	this.Name = string(randStringPvtTypes(r))
	this.InternalDnsSuffix = string(randStringPvtTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyPvtTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RunePvtTypes(r randyPvtTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringPvtTypes(r randyPvtTypes) string {
	v3 := r.Intn(100)
	tmps := make([]rune, v3)
	for i := 0; i < v3; i++ {
		tmps[i] = randUTF8RunePvtTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedPvtTypes(r randyPvtTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldPvtTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldPvtTypes(dAtA []byte, r randyPvtTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulatePvtTypes(dAtA, uint64(key))
		v4 := r.Int63()
		if r.Intn(2) == 0 {
			v4 *= -1
		}
		dAtA = encodeVarintPopulatePvtTypes(dAtA, uint64(v4))
	case 1:
		dAtA = encodeVarintPopulatePvtTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulatePvtTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulatePvtTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulatePvtTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulatePvtTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *DaemonTLSParamsType) Size() (n int) {
	var l int
	_ = l
	if m.ServerParams != nil {
		l = m.ServerParams.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.ClientParams != nil {
		l = m.ClientParams.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *DaemonTlsCertificateType) Size() (n int) {
	var l int
	_ = l
	l = len(m.CertificateUrl)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.PrivateKeyUrl)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *DaemonTlsParametersType) Size() (n int) {
	var l int
	_ = l
	if m.MinimumProtocolVersion != 0 {
		n += 1 + sovPvtTypes(uint64(m.MinimumProtocolVersion))
	}
	if m.MaximumProtocolVersion != 0 {
		n += 1 + sovPvtTypes(uint64(m.MaximumProtocolVersion))
	}
	if len(m.CipherSuites) > 0 {
		for _, s := range m.CipherSuites {
			l = len(s)
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	if len(m.TlsCertificates) > 0 {
		for _, e := range m.TlsCertificates {
			l = e.Size()
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *UseragentType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProgramName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *ServiceParameters) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.Ctype != 0 {
		n += 1 + sovPvtTypes(uint64(m.Ctype))
	}
	return n
}

func (m *OperMetaType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *DaemonEnvironmentType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.InternalDnsSuffix)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func sovPvtTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPvtTypes(x uint64) (n int) {
	return sovPvtTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DaemonTLSParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonTLSParamsType{`,
		`ServerParams:` + strings.Replace(fmt.Sprintf("%v", this.ServerParams), "DaemonTlsParametersType", "DaemonTlsParametersType", 1) + `,`,
		`ClientParams:` + strings.Replace(fmt.Sprintf("%v", this.ClientParams), "DaemonTlsParametersType", "DaemonTlsParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DaemonTlsCertificateType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonTlsCertificateType{`,
		`CertificateUrl:` + fmt.Sprintf("%v", this.CertificateUrl) + `,`,
		`PrivateKeyUrl:` + fmt.Sprintf("%v", this.PrivateKeyUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DaemonTlsParametersType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonTlsParametersType{`,
		`MinimumProtocolVersion:` + fmt.Sprintf("%v", this.MinimumProtocolVersion) + `,`,
		`MaximumProtocolVersion:` + fmt.Sprintf("%v", this.MaximumProtocolVersion) + `,`,
		`CipherSuites:` + fmt.Sprintf("%v", this.CipherSuites) + `,`,
		`TlsCertificates:` + strings.Replace(fmt.Sprintf("%v", this.TlsCertificates), "DaemonTlsCertificateType", "DaemonTlsCertificateType", 1) + `,`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UseragentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UseragentType{`,
		`ProgramName:` + fmt.Sprintf("%v", this.ProgramName) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceParameters{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Ctype:` + fmt.Sprintf("%v", this.Ctype) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OperMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OperMetaType{`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "google_protobuf3.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DaemonEnvironmentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonEnvironmentType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`InternalDnsSuffix:` + fmt.Sprintf("%v", this.InternalDnsSuffix) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPvtTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DaemonTLSParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonTLSParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonTLSParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerParams == nil {
				m.ServerParams = &DaemonTlsParametersType{}
			}
			if err := m.ServerParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientParams == nil {
				m.ClientParams = &DaemonTlsParametersType{}
			}
			if err := m.ClientParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonTlsCertificateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonTlsCertificateType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonTlsCertificateType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKeyUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKeyUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonTlsParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonTlsParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonTlsParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumProtocolVersion", wireType)
			}
			m.MinimumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumProtocolVersion |= (TlsProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumProtocolVersion", wireType)
			}
			m.MaximumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumProtocolVersion |= (TlsProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherSuites = append(m.CipherSuites, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertificates = append(m.TlsCertificates, &DaemonTlsCertificateType{})
			if err := m.TlsCertificates[len(m.TlsCertificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseragentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseragentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseragentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctype", wireType)
			}
			m.Ctype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctype |= (ServiceConnectionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &google_protobuf3.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &google_protobuf3.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonEnvironmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonEnvironmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonEnvironmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalDnsSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalDnsSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPvtTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPvtTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPvtTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPvtTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPvtTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPvtTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/pvt_types.proto", fileDescriptorPvtTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/pvt_types.proto", fileDescriptorPvtTypes) }

var fileDescriptorPvtTypes = []byte{
	// 822 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xbf, 0x73, 0x1b, 0x45,
	0x14, 0xd6, 0x4a, 0xb2, 0x63, 0xad, 0x25, 0x5b, 0xde, 0x8c, 0x8d, 0x50, 0x60, 0x71, 0x44, 0x26,
	0xf1, 0xc0, 0xf8, 0x34, 0x63, 0x3a, 0x4a, 0x1c, 0x0a, 0x92, 0x10, 0x40, 0x92, 0x29, 0xa0, 0xb8,
	0x59, 0x9f, 0x9e, 0xce, 0x3b, 0xb9, 0xdb, 0xbd, 0xd9, 0x5d, 0x1d, 0x76, 0x47, 0xc3, 0x0c, 0x1d,
	0xfc, 0x19, 0x74, 0xb4, 0x94, 0x29, 0x29, 0x53, 0xa6, 0xc4, 0x97, 0x86, 0xa1, 0x4a, 0x49, 0xc9,
	0xdc, 0xee, 0x9e, 0x25, 0x79, 0xe2, 0x01, 0x2a, 0xbd, 0xfb, 0xbe, 0xf7, 0x7d, 0xfb, 0x7e, 0xac,
	0x16, 0xbf, 0x9b, 0x83, 0x0e, 0xb8, 0x1c, 0xea, 0xe8, 0x0c, 0x52, 0x36, 0xcc, 0x72, 0x13, 0x9a,
	0x8b, 0x0c, 0x74, 0x90, 0x29, 0x69, 0x24, 0xe9, 0x38, 0x3a, 0x70, 0x74, 0xff, 0x30, 0xe6, 0xe6,
	0x6c, 0x7e, 0x1a, 0x44, 0x32, 0x1d, 0xc6, 0x32, 0x96, 0x43, 0x9b, 0x75, 0x3a, 0x9f, 0xd9, 0x2f,
	0xfb, 0x61, 0x23, 0xa7, 0xee, 0xbf, 0x17, 0x4b, 0x19, 0x27, 0xb0, 0xc8, 0x32, 0x3c, 0x05, 0x6d,
	0x58, 0x9a, 0xf9, 0x84, 0x3b, 0xab, 0xa7, 0xcb, 0xcc, 0x70, 0x29, 0xfc, 0xd9, 0xfd, 0xb7, 0x57,
	0xc9, 0xa5, 0xb2, 0x06, 0xbf, 0x22, 0x7c, 0xfb, 0x21, 0x83, 0x54, 0x8a, 0xc9, 0x93, 0xf1, 0x97,
	0x4c, 0xb1, 0x54, 0x4f, 0x2e, 0x32, 0x20, 0x8f, 0x71, 0x47, 0x83, 0xca, 0x41, 0x85, 0x99, 0x05,
	0x7b, 0x68, 0x1f, 0x1d, 0x6c, 0x1e, 0xdd, 0x0f, 0x56, 0xda, 0x08, 0xbc, 0x34, 0xd1, 0x56, 0x0a,
	0x06, 0x94, 0x95, 0x8f, 0xda, 0x4e, 0xec, 0x0c, 0x4b, 0xb3, 0x28, 0xe1, 0x20, 0x4c, 0x65, 0x56,
	0xff, 0x7f, 0x66, 0x4e, 0xec, 0xcc, 0x06, 0xdf, 0xe1, 0xde, 0x55, 0xe2, 0x31, 0x28, 0xc3, 0x67,
	0x3c, 0x62, 0x06, 0x6c, 0xd5, 0x0f, 0xf0, 0x76, 0xb4, 0x80, 0xc2, 0xb9, 0x4a, 0x6c, 0xdd, 0xad,
	0xd1, 0xd6, 0x12, 0x7c, 0xa2, 0x12, 0x72, 0x1f, 0x6f, 0x67, 0x8a, 0xe7, 0x65, 0xd2, 0x33, 0xb8,
	0xb0, 0x89, 0x75, 0x9b, 0xd8, 0xf1, 0xf0, 0x63, 0xb8, 0x38, 0x51, 0xc9, 0xa3, 0xe6, 0x46, 0xa3,
	0xdb, 0x7c, 0xd4, 0xdc, 0x68, 0x76, 0xd7, 0x06, 0x7f, 0xd5, 0xf1, 0x5b, 0x37, 0x94, 0x48, 0x26,
	0xb8, 0x97, 0x72, 0xc1, 0xd3, 0x79, 0x1a, 0xda, 0xb9, 0x46, 0x32, 0x09, 0x73, 0x50, 0x9a, 0x4b,
	0x61, 0x2b, 0xd8, 0x3a, 0xea, 0x5f, 0x6b, 0xb6, 0xf4, 0xf0, 0x99, 0xa3, 0x3d, 0xaf, 0xad, 0x80,
	0xaf, 0x9d, 0xd2, 0xba, 0xb2, 0xf3, 0x37, 0xbb, 0xd6, 0xff, 0x83, 0xab, 0xd3, 0x5e, 0x77, 0x7d,
	0x1f, 0x77, 0x22, 0x9e, 0x9d, 0x81, 0x0a, 0xf5, 0x9c, 0x1b, 0xd0, 0xbd, 0xc6, 0x7e, 0xe3, 0xa0,
	0x35, 0x6a, 0x3b, 0x70, 0x6c, 0x31, 0x32, 0xc2, 0x5d, 0x93, 0xe8, 0x70, 0x69, 0x6c, 0xba, 0xd7,
	0xdc, 0x6f, 0x1c, 0x6c, 0x1e, 0x3d, 0xb8, 0x69, 0x6b, 0xd7, 0x96, 0x31, 0xda, 0x36, 0x2b, 0x98,
	0x26, 0xf7, 0xf0, 0x96, 0x51, 0x73, 0x6d, 0x60, 0x1a, 0x46, 0xcc, 0xce, 0x7c, 0xcd, 0xce, 0xbc,
	0xed, 0xd1, 0x63, 0xe6, 0x46, 0xbe, 0xde, 0xbd, 0x35, 0xf8, 0x09, 0xe1, 0xce, 0x89, 0x06, 0xc5,
	0x62, 0x10, 0xc6, 0x8e, 0xf8, 0x2e, 0x6e, 0x67, 0x4a, 0xc6, 0x8a, 0xa5, 0xa1, 0x60, 0x29, 0xf8,
	0xc5, 0x6e, 0x7a, 0xec, 0x29, 0x4b, 0x81, 0xdc, 0xc1, 0xad, 0x33, 0xa9, 0x8d, 0xe3, 0xdd, 0x3e,
	0x37, 0x4a, 0xc0, 0x92, 0x77, 0xb1, 0xbd, 0x94, 0x3c, 0x02, 0xc7, 0x37, 0x9c, 0xde, 0x63, 0x95,
	0x5e, 0x73, 0xe3, 0xf9, 0xa6, 0xd3, 0x97, 0x40, 0x49, 0x0e, 0x18, 0xde, 0x19, 0xbb, 0xdc, 0xc5,
	0xee, 0x49, 0x17, 0x37, 0x16, 0x97, 0xac, 0x0c, 0xc9, 0xc7, 0x78, 0x2d, 0x2a, 0xff, 0x60, 0x7e,
	0x41, 0xf7, 0xae, 0x4d, 0xcb, 0x5b, 0x1c, 0x4b, 0x21, 0x20, 0x2a, 0xff, 0xa3, 0x76, 0x54, 0x4e,
	0x32, 0xf8, 0xb1, 0x8e, 0xdb, 0x5f, 0x64, 0xa0, 0x3e, 0x07, 0xc3, 0x6c, 0xcf, 0x7b, 0x78, 0xdd,
	0x80, 0x60, 0xc2, 0xf8, 0x13, 0xfc, 0x17, 0x79, 0x07, 0xb7, 0xca, 0x1a, 0x75, 0xc6, 0xa2, 0xaa,
	0xd1, 0x05, 0x40, 0x08, 0x6e, 0x2e, 0x75, 0x68, 0x63, 0x5b, 0x28, 0x9f, 0xfa, 0xa6, 0xca, 0x90,
	0x7c, 0x86, 0x49, 0xa4, 0x80, 0x95, 0x35, 0x84, 0x57, 0xaf, 0x89, 0xdd, 0xc8, 0xe6, 0x51, 0x3f,
	0x70, 0xef, 0x4d, 0x50, 0xbd, 0x37, 0xc1, 0xa4, 0xca, 0x18, 0xed, 0x54, 0xaa, 0x2b, 0x88, 0x7c,
	0x85, 0xf7, 0x52, 0x39, 0x75, 0x7b, 0x5e, 0xb5, 0x5b, 0xff, 0x57, 0xbb, 0xdd, 0x65, 0xe5, 0x15,
	0x3c, 0xf8, 0x16, 0xef, 0xba, 0x8b, 0xf5, 0xa9, 0xc8, 0xb9, 0x92, 0x22, 0xad, 0xae, 0x41, 0xd5,
	0x1c, 0x5a, 0x6a, 0x2e, 0xc0, 0xb7, 0xb9, 0x30, 0xa0, 0x04, 0x4b, 0xc2, 0xa9, 0xd0, 0xa1, 0x9e,
	0xcf, 0x66, 0xfc, 0xdc, 0x0f, 0x66, 0xa7, 0xa2, 0x1e, 0x0a, 0x3d, 0xb6, 0xc4, 0x07, 0x1f, 0xe2,
	0xdd, 0x37, 0xee, 0x81, 0xdc, 0xc2, 0x8d, 0xc9, 0x93, 0x71, 0xb7, 0x46, 0x5a, 0x78, 0xed, 0xa9,
	0x2c, 0x43, 0xf4, 0xc9, 0x0f, 0xe8, 0xc5, 0x25, 0xad, 0xbd, 0xbc, 0xa4, 0xb5, 0xd7, 0x97, 0x14,
	0xfd, 0x7d, 0x49, 0xd1, 0xf7, 0x05, 0x45, 0xbf, 0x14, 0x14, 0xfd, 0x56, 0x50, 0xf4, 0xbc, 0xa0,
	0xe8, 0xf7, 0x82, 0xa2, 0x17, 0x05, 0x45, 0x2f, 0x0b, 0x8a, 0xfe, 0x28, 0x28, 0xfa, 0xb3, 0xa0,
	0xb5, 0xd7, 0x05, 0x45, 0x3f, 0xbf, 0xa2, 0xb5, 0xe7, 0xaf, 0x28, 0xfa, 0xe6, 0x38, 0x96, 0xd9,
	0xb3, 0x38, 0xc8, 0x65, 0x62, 0x40, 0x29, 0x16, 0xcc, 0xf5, 0xd0, 0x06, 0x33, 0xa9, 0xd2, 0xc3,
	0x4c, 0xc9, 0x9c, 0x4f, 0x41, 0x1d, 0x56, 0xf4, 0x30, 0x3b, 0x8d, 0xe5, 0x10, 0xce, 0x8d, 0x7f,
	0xae, 0xdd, 0xcf, 0xe9, 0xba, 0x1d, 0xde, 0x47, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x9f, 0xc9,
	0xd6, 0x5f, 0x68, 0x06, 0x00, 0x00,
}

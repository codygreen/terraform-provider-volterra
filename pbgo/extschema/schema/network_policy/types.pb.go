// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/network_policy/types.proto

package network_policy

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	ves_io_schema3 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Network policy specification
//
// x-displayName: "Specification"
// Desired state for Network policy
type GlobalSpecType struct {
	// Local Endpoint
	//
	// x-displayName: "Local Endpoint"
	// local_endpoint identifies the endpoint on which policy is applied.
	// Egress rules are applied to traffic coming out of local endpoint, where local endpoint is source.
	// Ingress rules are applied to traffic go to local endpoint, where local endpoint is destination.
	// Not specifying any endpoint will result in creation of ANY endpoint
	//
	// Types that are valid to be assigned to LocalEndpoint:
	//	*GlobalSpecType_Prefix
	//	*GlobalSpecType_PrefixSelector
	LocalEndpoint isGlobalSpecType_LocalEndpoint `protobuf_oneof:"local_endpoint"`
	// ingress rules
	//
	// x-displayName: "Ingress Rules"
	// List of network policy rules that apply to incoming session for local endpoint
	// Sequence in which rule is configured (in repeated ingress rules) is the sequence in which ingress rules are applied
	// If ingress rules are not specified or is empty list, then policy will assume default deny and from ANY destination to local endpoint
	IngressRules []*ves_io_schema4.ObjectRefType `protobuf:"bytes,3,rep,name=ingress_rules,json=ingressRules" json:"ingress_rules,omitempty"`
	// egress rules
	//
	// x-displayName: "Egress Rules"
	// List of network policy rules that apply to outgoing session from local endpoint
	// Sequence in which rule is configured (in repeated egress rules) is the sequence in which egress rules are applied
	// If egress rules are not specified or is empty list, then policy will assume default deny and to ANY destination from local endpoint
	EgressRules []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=egress_rules,json=egressRules" json:"egress_rules,omitempty"`
	// Default Forwarding Classes
	//
	// x-displayName: "Default Forwarding Classes"
	// Ordered list of forwarding class to use for traffic that match any rules
	// Action valid only when policy is part of PBR.
	ForwardingClass []*ves_io_schema4.ObjectRefType `protobuf:"bytes,5,rep,name=forwarding_class,json=forwardingClass" json:"forwarding_class,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

type isGlobalSpecType_LocalEndpoint interface {
	isGlobalSpecType_LocalEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_Prefix struct {
	Prefix *ves_io_schema3.PrefixListType `protobuf:"bytes,1,opt,name=prefix,oneof"`
}
type GlobalSpecType_PrefixSelector struct {
	PrefixSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,2,opt,name=prefix_selector,json=prefixSelector,oneof"`
}

func (*GlobalSpecType_Prefix) isGlobalSpecType_LocalEndpoint()         {}
func (*GlobalSpecType_PrefixSelector) isGlobalSpecType_LocalEndpoint() {}

func (m *GlobalSpecType) GetLocalEndpoint() isGlobalSpecType_LocalEndpoint {
	if m != nil {
		return m.LocalEndpoint
	}
	return nil
}

func (m *GlobalSpecType) GetPrefix() *ves_io_schema3.PrefixListType {
	if x, ok := m.GetLocalEndpoint().(*GlobalSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *GlobalSpecType) GetPrefixSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetLocalEndpoint().(*GlobalSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *GlobalSpecType) GetIngressRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.IngressRules
	}
	return nil
}

func (m *GlobalSpecType) GetEgressRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

func (m *GlobalSpecType) GetForwardingClass() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ForwardingClass
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_Prefix)(nil),
		(*GlobalSpecType_PrefixSelector)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// local_endpoint
	switch x := m.LocalEndpoint.(type) {
	case *GlobalSpecType_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *GlobalSpecType_PrefixSelector:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PrefixSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.LocalEndpoint has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 1: // local_endpoint.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.PrefixListType)
		err := b.DecodeMessage(msg)
		m.LocalEndpoint = &GlobalSpecType_Prefix{msg}
		return true, err
	case 2: // local_endpoint.prefix_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.LocalEndpoint = &GlobalSpecType_PrefixSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// local_endpoint
	switch x := m.LocalEndpoint.(type) {
	case *GlobalSpecType_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_PrefixSelector:
		s := proto.Size(x.PrefixSelector)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create Network Policy
//
// x-displayName: "Create Network Policy"
// Creates a new network policy with configured parameters in specified namespace
type CreateSpecType struct {
	// Types that are valid to be assigned to LocalEndpoint:
	//	*CreateSpecType_Prefix
	//	*CreateSpecType_PrefixSelector
	LocalEndpoint isCreateSpecType_LocalEndpoint  `protobuf_oneof:"local_endpoint"`
	IngressRules  []*ves_io_schema4.ObjectRefType `protobuf:"bytes,3,rep,name=ingress_rules,json=ingressRules" json:"ingress_rules,omitempty"`
	EgressRules   []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=egress_rules,json=egressRules" json:"egress_rules,omitempty"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

type isCreateSpecType_LocalEndpoint interface {
	isCreateSpecType_LocalEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_Prefix struct {
	Prefix *ves_io_schema3.PrefixListType `protobuf:"bytes,1,opt,name=prefix,oneof"`
}
type CreateSpecType_PrefixSelector struct {
	PrefixSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,2,opt,name=prefix_selector,json=prefixSelector,oneof"`
}

func (*CreateSpecType_Prefix) isCreateSpecType_LocalEndpoint()         {}
func (*CreateSpecType_PrefixSelector) isCreateSpecType_LocalEndpoint() {}

func (m *CreateSpecType) GetLocalEndpoint() isCreateSpecType_LocalEndpoint {
	if m != nil {
		return m.LocalEndpoint
	}
	return nil
}

func (m *CreateSpecType) GetPrefix() *ves_io_schema3.PrefixListType {
	if x, ok := m.GetLocalEndpoint().(*CreateSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *CreateSpecType) GetPrefixSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetLocalEndpoint().(*CreateSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *CreateSpecType) GetIngressRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.IngressRules
	}
	return nil
}

func (m *CreateSpecType) GetEgressRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_Prefix)(nil),
		(*CreateSpecType_PrefixSelector)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// local_endpoint
	switch x := m.LocalEndpoint.(type) {
	case *CreateSpecType_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *CreateSpecType_PrefixSelector:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PrefixSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.LocalEndpoint has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 1: // local_endpoint.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.PrefixListType)
		err := b.DecodeMessage(msg)
		m.LocalEndpoint = &CreateSpecType_Prefix{msg}
		return true, err
	case 2: // local_endpoint.prefix_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.LocalEndpoint = &CreateSpecType_PrefixSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// local_endpoint
	switch x := m.LocalEndpoint.(type) {
	case *CreateSpecType_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_PrefixSelector:
		s := proto.Size(x.PrefixSelector)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace Network Policy
//
// x-displayName: "Replace Network Policy"
// Replaces configured Network Policy with new set of parameters in specified namespace
type ReplaceSpecType struct {
	// Types that are valid to be assigned to LocalEndpoint:
	//	*ReplaceSpecType_Prefix
	//	*ReplaceSpecType_PrefixSelector
	LocalEndpoint isReplaceSpecType_LocalEndpoint `protobuf_oneof:"local_endpoint"`
	IngressRules  []*ves_io_schema4.ObjectRefType `protobuf:"bytes,3,rep,name=ingress_rules,json=ingressRules" json:"ingress_rules,omitempty"`
	EgressRules   []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=egress_rules,json=egressRules" json:"egress_rules,omitempty"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isReplaceSpecType_LocalEndpoint interface {
	isReplaceSpecType_LocalEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_Prefix struct {
	Prefix *ves_io_schema3.PrefixListType `protobuf:"bytes,1,opt,name=prefix,oneof"`
}
type ReplaceSpecType_PrefixSelector struct {
	PrefixSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,2,opt,name=prefix_selector,json=prefixSelector,oneof"`
}

func (*ReplaceSpecType_Prefix) isReplaceSpecType_LocalEndpoint()         {}
func (*ReplaceSpecType_PrefixSelector) isReplaceSpecType_LocalEndpoint() {}

func (m *ReplaceSpecType) GetLocalEndpoint() isReplaceSpecType_LocalEndpoint {
	if m != nil {
		return m.LocalEndpoint
	}
	return nil
}

func (m *ReplaceSpecType) GetPrefix() *ves_io_schema3.PrefixListType {
	if x, ok := m.GetLocalEndpoint().(*ReplaceSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *ReplaceSpecType) GetPrefixSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetLocalEndpoint().(*ReplaceSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetIngressRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.IngressRules
	}
	return nil
}

func (m *ReplaceSpecType) GetEgressRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_Prefix)(nil),
		(*ReplaceSpecType_PrefixSelector)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// local_endpoint
	switch x := m.LocalEndpoint.(type) {
	case *ReplaceSpecType_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *ReplaceSpecType_PrefixSelector:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PrefixSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.LocalEndpoint has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 1: // local_endpoint.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.PrefixListType)
		err := b.DecodeMessage(msg)
		m.LocalEndpoint = &ReplaceSpecType_Prefix{msg}
		return true, err
	case 2: // local_endpoint.prefix_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.LocalEndpoint = &ReplaceSpecType_PrefixSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// local_endpoint
	switch x := m.LocalEndpoint.(type) {
	case *ReplaceSpecType_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_PrefixSelector:
		s := proto.Size(x.PrefixSelector)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get Network Policy
//
// x-displayName: "Get Network Policy"
// Gets Network Policy parameters in specified namespace
type GetSpecType struct {
	// Types that are valid to be assigned to LocalEndpoint:
	//	*GetSpecType_Prefix
	//	*GetSpecType_PrefixSelector
	LocalEndpoint isGetSpecType_LocalEndpoint     `protobuf_oneof:"local_endpoint"`
	IngressRules  []*ves_io_schema4.ObjectRefType `protobuf:"bytes,3,rep,name=ingress_rules,json=ingressRules" json:"ingress_rules,omitempty"`
	EgressRules   []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=egress_rules,json=egressRules" json:"egress_rules,omitempty"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

type isGetSpecType_LocalEndpoint interface {
	isGetSpecType_LocalEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_Prefix struct {
	Prefix *ves_io_schema3.PrefixListType `protobuf:"bytes,1,opt,name=prefix,oneof"`
}
type GetSpecType_PrefixSelector struct {
	PrefixSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,2,opt,name=prefix_selector,json=prefixSelector,oneof"`
}

func (*GetSpecType_Prefix) isGetSpecType_LocalEndpoint()         {}
func (*GetSpecType_PrefixSelector) isGetSpecType_LocalEndpoint() {}

func (m *GetSpecType) GetLocalEndpoint() isGetSpecType_LocalEndpoint {
	if m != nil {
		return m.LocalEndpoint
	}
	return nil
}

func (m *GetSpecType) GetPrefix() *ves_io_schema3.PrefixListType {
	if x, ok := m.GetLocalEndpoint().(*GetSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *GetSpecType) GetPrefixSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetLocalEndpoint().(*GetSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *GetSpecType) GetIngressRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.IngressRules
	}
	return nil
}

func (m *GetSpecType) GetEgressRules() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_Prefix)(nil),
		(*GetSpecType_PrefixSelector)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// local_endpoint
	switch x := m.LocalEndpoint.(type) {
	case *GetSpecType_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *GetSpecType_PrefixSelector:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PrefixSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.LocalEndpoint has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 1: // local_endpoint.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema3.PrefixListType)
		err := b.DecodeMessage(msg)
		m.LocalEndpoint = &GetSpecType_Prefix{msg}
		return true, err
	case 2: // local_endpoint.prefix_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.LocalEndpoint = &GetSpecType_PrefixSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// local_endpoint
	switch x := m.LocalEndpoint.(type) {
	case *GetSpecType_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_PrefixSelector:
		s := proto.Size(x.PrefixSelector)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_policy.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_policy.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_policy.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_policy.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_policy.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_policy.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_policy.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_policy.GetSpecType")
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LocalEndpoint == nil {
		if this.LocalEndpoint != nil {
			return false
		}
	} else if this.LocalEndpoint == nil {
		return false
	} else if !this.LocalEndpoint.Equal(that1.LocalEndpoint) {
		return false
	}
	if len(this.IngressRules) != len(that1.IngressRules) {
		return false
	}
	for i := range this.IngressRules {
		if !this.IngressRules[i].Equal(that1.IngressRules[i]) {
			return false
		}
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	if len(this.ForwardingClass) != len(that1.ForwardingClass) {
		return false
	}
	for i := range this.ForwardingClass {
		if !this.ForwardingClass[i].Equal(that1.ForwardingClass[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Prefix)
	if !ok {
		that2, ok := that.(GlobalSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *GlobalSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LocalEndpoint == nil {
		if this.LocalEndpoint != nil {
			return false
		}
	} else if this.LocalEndpoint == nil {
		return false
	} else if !this.LocalEndpoint.Equal(that1.LocalEndpoint) {
		return false
	}
	if len(this.IngressRules) != len(that1.IngressRules) {
		return false
	}
	for i := range this.IngressRules {
		if !this.IngressRules[i].Equal(that1.IngressRules[i]) {
			return false
		}
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Prefix)
	if !ok {
		that2, ok := that.(CreateSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *CreateSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(CreateSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LocalEndpoint == nil {
		if this.LocalEndpoint != nil {
			return false
		}
	} else if this.LocalEndpoint == nil {
		return false
	} else if !this.LocalEndpoint.Equal(that1.LocalEndpoint) {
		return false
	}
	if len(this.IngressRules) != len(that1.IngressRules) {
		return false
	}
	for i := range this.IngressRules {
		if !this.IngressRules[i].Equal(that1.IngressRules[i]) {
			return false
		}
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Prefix)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(ReplaceSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LocalEndpoint == nil {
		if this.LocalEndpoint != nil {
			return false
		}
	} else if this.LocalEndpoint == nil {
		return false
	} else if !this.LocalEndpoint.Equal(that1.LocalEndpoint) {
		return false
	}
	if len(this.IngressRules) != len(that1.IngressRules) {
		return false
	}
	for i := range this.IngressRules {
		if !this.IngressRules[i].Equal(that1.IngressRules[i]) {
			return false
		}
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Prefix)
	if !ok {
		that2, ok := that.(GetSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *GetSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(GetSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&network_policy.GlobalSpecType{")
	if this.LocalEndpoint != nil {
		s = append(s, "LocalEndpoint: "+fmt.Sprintf("%#v", this.LocalEndpoint)+",\n")
	}
	if this.IngressRules != nil {
		s = append(s, "IngressRules: "+fmt.Sprintf("%#v", this.IngressRules)+",\n")
	}
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	if this.ForwardingClass != nil {
		s = append(s, "ForwardingClass: "+fmt.Sprintf("%#v", this.ForwardingClass)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GlobalSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GlobalSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&network_policy.CreateSpecType{")
	if this.LocalEndpoint != nil {
		s = append(s, "LocalEndpoint: "+fmt.Sprintf("%#v", this.LocalEndpoint)+",\n")
	}
	if this.IngressRules != nil {
		s = append(s, "IngressRules: "+fmt.Sprintf("%#v", this.IngressRules)+",\n")
	}
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.CreateSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.CreateSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&network_policy.ReplaceSpecType{")
	if this.LocalEndpoint != nil {
		s = append(s, "LocalEndpoint: "+fmt.Sprintf("%#v", this.LocalEndpoint)+",\n")
	}
	if this.IngressRules != nil {
		s = append(s, "IngressRules: "+fmt.Sprintf("%#v", this.IngressRules)+",\n")
	}
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.ReplaceSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.ReplaceSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&network_policy.GetSpecType{")
	if this.LocalEndpoint != nil {
		s = append(s, "LocalEndpoint: "+fmt.Sprintf("%#v", this.LocalEndpoint)+",\n")
	}
	if this.IngressRules != nil {
		s = append(s, "IngressRules: "+fmt.Sprintf("%#v", this.IngressRules)+",\n")
	}
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GetSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *GetSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GetSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalEndpoint != nil {
		nn1, err := m.LocalEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if len(m.IngressRules) > 0 {
		for _, msg := range m.IngressRules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressRules) > 0 {
		for _, msg := range m.EgressRules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ForwardingClass) > 0 {
		for _, msg := range m.ForwardingClass {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GlobalSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n2, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *GlobalSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PrefixSelector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixSelector.Size()))
		n3, err := m.PrefixSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalEndpoint != nil {
		nn4, err := m.LocalEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if len(m.IngressRules) > 0 {
		for _, msg := range m.IngressRules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressRules) > 0 {
		for _, msg := range m.EgressRules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n5, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *CreateSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PrefixSelector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixSelector.Size()))
		n6, err := m.PrefixSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalEndpoint != nil {
		nn7, err := m.LocalEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if len(m.IngressRules) > 0 {
		for _, msg := range m.IngressRules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressRules) > 0 {
		for _, msg := range m.EgressRules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplaceSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n8, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ReplaceSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PrefixSelector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixSelector.Size()))
		n9, err := m.PrefixSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalEndpoint != nil {
		nn10, err := m.LocalEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	if len(m.IngressRules) > 0 {
		for _, msg := range m.IngressRules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressRules) > 0 {
		for _, msg := range m.EgressRules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n11, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *GetSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PrefixSelector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixSelector.Size()))
		n12, err := m.PrefixSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	oneofNumber_LocalEndpoint := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_LocalEndpoint {
	case 1:
		this.LocalEndpoint = NewPopulatedGlobalSpecType_Prefix(r, easy)
	case 2:
		this.LocalEndpoint = NewPopulatedGlobalSpecType_PrefixSelector(r, easy)
	}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.IngressRules = make([]*ves_io_schema4.ObjectRefType, v1)
		for i := 0; i < v1; i++ {
			this.IngressRules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.EgressRules = make([]*ves_io_schema4.ObjectRefType, v2)
		for i := 0; i < v2; i++ {
			this.EgressRules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.ForwardingClass = make([]*ves_io_schema4.ObjectRefType, v3)
		for i := 0; i < v3; i++ {
			this.ForwardingClass[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType_Prefix(r randyTypes, easy bool) *GlobalSpecType_Prefix {
	this := &GlobalSpecType_Prefix{}
	this.Prefix = ves_io_schema3.NewPopulatedPrefixListType(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_PrefixSelector(r randyTypes, easy bool) *GlobalSpecType_PrefixSelector {
	this := &GlobalSpecType_PrefixSelector{}
	this.PrefixSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	oneofNumber_LocalEndpoint := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_LocalEndpoint {
	case 1:
		this.LocalEndpoint = NewPopulatedCreateSpecType_Prefix(r, easy)
	case 2:
		this.LocalEndpoint = NewPopulatedCreateSpecType_PrefixSelector(r, easy)
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.IngressRules = make([]*ves_io_schema4.ObjectRefType, v4)
		for i := 0; i < v4; i++ {
			this.IngressRules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.EgressRules = make([]*ves_io_schema4.ObjectRefType, v5)
		for i := 0; i < v5; i++ {
			this.EgressRules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType_Prefix(r randyTypes, easy bool) *CreateSpecType_Prefix {
	this := &CreateSpecType_Prefix{}
	this.Prefix = ves_io_schema3.NewPopulatedPrefixListType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_PrefixSelector(r randyTypes, easy bool) *CreateSpecType_PrefixSelector {
	this := &CreateSpecType_PrefixSelector{}
	this.PrefixSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	oneofNumber_LocalEndpoint := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_LocalEndpoint {
	case 1:
		this.LocalEndpoint = NewPopulatedReplaceSpecType_Prefix(r, easy)
	case 2:
		this.LocalEndpoint = NewPopulatedReplaceSpecType_PrefixSelector(r, easy)
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.IngressRules = make([]*ves_io_schema4.ObjectRefType, v6)
		for i := 0; i < v6; i++ {
			this.IngressRules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.EgressRules = make([]*ves_io_schema4.ObjectRefType, v7)
		for i := 0; i < v7; i++ {
			this.EgressRules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType_Prefix(r randyTypes, easy bool) *ReplaceSpecType_Prefix {
	this := &ReplaceSpecType_Prefix{}
	this.Prefix = ves_io_schema3.NewPopulatedPrefixListType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_PrefixSelector(r randyTypes, easy bool) *ReplaceSpecType_PrefixSelector {
	this := &ReplaceSpecType_PrefixSelector{}
	this.PrefixSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}
func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	oneofNumber_LocalEndpoint := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_LocalEndpoint {
	case 1:
		this.LocalEndpoint = NewPopulatedGetSpecType_Prefix(r, easy)
	case 2:
		this.LocalEndpoint = NewPopulatedGetSpecType_PrefixSelector(r, easy)
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.IngressRules = make([]*ves_io_schema4.ObjectRefType, v8)
		for i := 0; i < v8; i++ {
			this.IngressRules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.EgressRules = make([]*ves_io_schema4.ObjectRefType, v9)
		for i := 0; i < v9; i++ {
			this.EgressRules[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType_Prefix(r randyTypes, easy bool) *GetSpecType_Prefix {
	this := &GetSpecType_Prefix{}
	this.Prefix = ves_io_schema3.NewPopulatedPrefixListType(r, easy)
	return this
}
func NewPopulatedGetSpecType_PrefixSelector(r randyTypes, easy bool) *GetSpecType_PrefixSelector {
	this := &GetSpecType_PrefixSelector{}
	this.PrefixSelector = ves_io_schema4.NewPopulatedLabelSelectorType(r, easy)
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v10 := r.Intn(100)
	tmps := make([]rune, v10)
	for i := 0; i < v10; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v11 := r.Int63()
		if r.Intn(2) == 0 {
			v11 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v11))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.LocalEndpoint != nil {
		n += m.LocalEndpoint.Size()
	}
	if len(m.IngressRules) > 0 {
		for _, e := range m.IngressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ForwardingClass) > 0 {
		for _, e := range m.ForwardingClass {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_PrefixSelector) Size() (n int) {
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.LocalEndpoint != nil {
		n += m.LocalEndpoint.Size()
	}
	if len(m.IngressRules) > 0 {
		for _, e := range m.IngressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_PrefixSelector) Size() (n int) {
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.LocalEndpoint != nil {
		n += m.LocalEndpoint.Size()
	}
	if len(m.IngressRules) > 0 {
		for _, e := range m.IngressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_PrefixSelector) Size() (n int) {
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.LocalEndpoint != nil {
		n += m.LocalEndpoint.Size()
	}
	if len(m.IngressRules) > 0 {
		for _, e := range m.IngressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_PrefixSelector) Size() (n int) {
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`LocalEndpoint:` + fmt.Sprintf("%v", this.LocalEndpoint) + `,`,
		`IngressRules:` + strings.Replace(fmt.Sprintf("%v", this.IngressRules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`EgressRules:` + strings.Replace(fmt.Sprintf("%v", this.EgressRules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`ForwardingClass:` + strings.Replace(fmt.Sprintf("%v", this.ForwardingClass), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "ves_io_schema3.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`LocalEndpoint:` + fmt.Sprintf("%v", this.LocalEndpoint) + `,`,
		`IngressRules:` + strings.Replace(fmt.Sprintf("%v", this.IngressRules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`EgressRules:` + strings.Replace(fmt.Sprintf("%v", this.EgressRules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "ves_io_schema3.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`LocalEndpoint:` + fmt.Sprintf("%v", this.LocalEndpoint) + `,`,
		`IngressRules:` + strings.Replace(fmt.Sprintf("%v", this.IngressRules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`EgressRules:` + strings.Replace(fmt.Sprintf("%v", this.EgressRules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "ves_io_schema3.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`LocalEndpoint:` + fmt.Sprintf("%v", this.LocalEndpoint) + `,`,
		`IngressRules:` + strings.Replace(fmt.Sprintf("%v", this.IngressRules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`EgressRules:` + strings.Replace(fmt.Sprintf("%v", this.EgressRules), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "ves_io_schema3.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &GlobalSpecType_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &GlobalSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressRules = append(m.IngressRules, &ves_io_schema4.ObjectRefType{})
			if err := m.IngressRules[len(m.IngressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, &ves_io_schema4.ObjectRefType{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingClass = append(m.ForwardingClass, &ves_io_schema4.ObjectRefType{})
			if err := m.ForwardingClass[len(m.ForwardingClass)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &CreateSpecType_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &CreateSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressRules = append(m.IngressRules, &ves_io_schema4.ObjectRefType{})
			if err := m.IngressRules[len(m.IngressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, &ves_io_schema4.ObjectRefType{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &ReplaceSpecType_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &ReplaceSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressRules = append(m.IngressRules, &ves_io_schema4.ObjectRefType{})
			if err := m.IngressRules[len(m.IngressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, &ves_io_schema4.ObjectRefType{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema3.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &GetSpecType_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &GetSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressRules = append(m.IngressRules, &ves_io_schema4.ObjectRefType{})
			if err := m.IngressRules[len(m.IngressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, &ves_io_schema4.ObjectRefType{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/network_policy/types.proto", fileDescriptorTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/network_policy/types.proto", fileDescriptorTypes)
}

var fileDescriptorTypes = []byte{
	// 620 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x96, 0x41, 0x6b, 0x13, 0x41,
	0x1c, 0xc5, 0xf3, 0xef, 0xb6, 0xb1, 0x6c, 0x6a, 0x1a, 0x57, 0xd0, 0x18, 0xeb, 0x18, 0x4b, 0x0f,
	0xbd, 0x74, 0x17, 0xea, 0x41, 0x10, 0xf4, 0x90, 0x1e, 0x2a, 0x5a, 0x50, 0xb7, 0x82, 0xe8, 0x25,
	0xec, 0x6e, 0xfe, 0xd9, 0xae, 0x9d, 0x64, 0x86, 0x99, 0x49, 0xda, 0x1e, 0x0a, 0x45, 0xfd, 0x00,
	0x52, 0xfc, 0x10, 0xd2, 0x4f, 0x20, 0xe6, 0x92, 0xa3, 0x78, 0xea, 0xb1, 0x47, 0xb3, 0xbd, 0xd4,
	0x5b, 0x8f, 0x45, 0x10, 0x24, 0x9b, 0xad, 0x66, 0x93, 0x0a, 0x5a, 0x84, 0x5e, 0x7a, 0x9b, 0xd9,
	0xf7, 0xfe, 0xef, 0x0d, 0xfb, 0x63, 0x99, 0xd5, 0x67, 0x9b, 0x28, 0xcd, 0x80, 0x59, 0xd2, 0x5b,
	0xc1, 0x9a, 0x63, 0xd5, 0x51, 0xad, 0x31, 0xb1, 0x5a, 0xe6, 0x8c, 0x06, 0xde, 0x86, 0xa5, 0x36,
	0x38, 0x4a, 0x93, 0x0b, 0xa6, 0x98, 0x31, 0xd5, 0x73, 0x9a, 0x3d, 0xa7, 0x99, 0x74, 0x16, 0xe6,
	0xfc, 0x40, 0xad, 0x34, 0x5c, 0xd3, 0x63, 0x35, 0xcb, 0x67, 0x3e, 0xb3, 0xa2, 0x21, 0xb7, 0x51,
	0x8d, 0x76, 0xd1, 0x26, 0x5a, 0xf5, 0xc2, 0x0a, 0x57, 0x87, 0x6a, 0x63, 0xe1, 0x7a, 0x52, 0x60,
	0x5c, 0x05, 0xac, 0x1e, 0x1f, 0xa1, 0x70, 0x2d, 0x29, 0xf6, 0x9d, 0xae, 0x30, 0x95, 0x94, 0x9a,
	0x0e, 0x0d, 0x2a, 0x8e, 0xc2, 0x58, 0x2d, 0x0e, 0xa8, 0x01, 0xae, 0x95, 0x93, 0xd1, 0x37, 0x87,
	0x1d, 0xb2, 0xbf, 0x60, 0xfa, 0x87, 0xa6, 0x67, 0x17, 0x29, 0x73, 0x1d, 0xba, 0xcc, 0xd1, 0x7b,
	0xb6, 0xc1, 0xd1, 0xb8, 0xa7, 0xa7, 0xb9, 0xc0, 0x6a, 0xb0, 0x9e, 0x87, 0x22, 0xcc, 0x66, 0xe6,
	0x6f, 0x98, 0xc9, 0x57, 0xf4, 0x24, 0x12, 0x97, 0x02, 0xa9, 0xba, 0xf6, 0xd2, 0xe8, 0x51, 0x0b,
	0x52, 0x0f, 0x52, 0x76, 0x3c, 0x64, 0x3c, 0xd5, 0x27, 0x7b, 0xab, 0xb2, 0x44, 0x8a, 0x9e, 0x62,
	0x22, 0x3f, 0x12, 0xe5, 0x14, 0x07, 0x72, 0x96, 0x1c, 0x17, 0xe9, 0x72, 0xec, 0x49, 0x44, 0x65,
	0x7b, 0x01, 0xc7, 0x9a, 0x51, 0xd1, 0x2f, 0x06, 0x75, 0x5f, 0xa0, 0x94, 0x65, 0xd1, 0xa0, 0x28,
	0xf3, 0x5a, 0x51, 0x9b, 0xcd, 0xcc, 0x4f, 0x0d, 0x04, 0x3e, 0x76, 0x5f, 0xa1, 0xa7, 0x6c, 0xac,
	0x46, 0x61, 0xb7, 0x76, 0x36, 0x2f, 0x27, 0x69, 0x46, 0xc3, 0x9f, 0xbe, 0xb5, 0xb5, 0xf4, 0x36,
	0x68, 0xb9, 0x2d, 0xb0, 0x27, 0xe2, 0x54, 0xbb, 0x1b, 0x6a, 0xb8, 0xfa, 0x04, 0xf6, 0x97, 0x8c,
	0xfe, 0x9f, 0x92, 0x0c, 0xf6, 0x75, 0xd4, 0xf4, 0x5c, 0x95, 0x89, 0x35, 0x47, 0x54, 0x82, 0xba,
	0x5f, 0xf6, 0xa8, 0x23, 0x65, 0x7e, 0xec, 0x2f, 0x7a, 0x66, 0x76, 0x36, 0x87, 0x06, 0xf7, 0x36,
	0xe1, 0xa0, 0x05, 0xd0, 0xed, 0x1a, 0xdb, 0x86, 0x91, 0x9c, 0x66, 0x4f, 0xfe, 0xb6, 0x2c, 0x74,
	0x1d, 0xa5, 0x82, 0x9e, 0xa5, 0xcc, 0x73, 0x68, 0x19, 0xeb, 0x15, 0xce, 0x82, 0xba, 0x32, 0xc6,
	0xdb, 0x2d, 0x80, 0xdd, 0x16, 0xa4, 0x1f, 0x8e, 0x8e, 0xa7, 0x73, 0x17, 0xa6, 0xdf, 0x68, 0x7a,
	0x76, 0x41, 0xa0, 0xa3, 0xf0, 0x17, 0xff, 0x3b, 0xff, 0xc4, 0xbf, 0x8f, 0xfc, 0xa3, 0x53, 0x93,
	0x3f, 0x81, 0xf9, 0x8b, 0xd3, 0x30, 0xbf, 0x72, 0x32, 0x8e, 0x01, 0xd0, 0xcf, 0x4f, 0x01, 0xfa,
	0x4f, 0xc9, 0xfd, 0x74, 0xef, 0x5e, 0xfa, 0x72, 0x7f, 0xe0, 0x63, 0x2a, 0xcd, 0x0c, 0x11, 0x30,
	0x5e, 0x7f, 0x87, 0x81, 0x67, 0xd3, 0x6f, 0x35, 0x7d, 0xd2, 0x46, 0x4e, 0x1d, 0xef, 0x1c, 0xc3,
	0x19, 0x62, 0xd8, 0xd2, 0xf4, 0xcc, 0x22, 0xaa, 0x73, 0x04, 0x67, 0x86, 0xa0, 0xf4, 0x1e, 0x76,
	0x3b, 0x24, 0xb5, 0xd7, 0x21, 0xa9, 0xc3, 0x0e, 0x81, 0xa3, 0x0e, 0x81, 0xad, 0x90, 0xc0, 0x87,
	0x90, 0xc0, 0xc7, 0x90, 0x40, 0x3b, 0x24, 0xf0, 0x39, 0x24, 0xb0, 0x1b, 0x12, 0xd8, 0x0b, 0x09,
	0x7c, 0x0d, 0x09, 0x1c, 0x84, 0x24, 0x75, 0x18, 0x12, 0x78, 0xb7, 0x4f, 0x52, 0xed, 0x7d, 0x02,
	0x2f, 0x6d, 0x9f, 0xf1, 0x55, 0xdf, 0x6c, 0x32, 0xaa, 0x50, 0x08, 0xc7, 0x6c, 0x48, 0x2b, 0x5a,
	0x54, 0x99, 0xa8, 0xcd, 0x71, 0xc1, 0x9a, 0x41, 0x05, 0xc5, 0xdc, 0xb1, 0x6c, 0x71, 0xd7, 0x67,
	0x16, 0xae, 0xab, 0xf8, 0x8a, 0x3c, 0xf1, 0x8f, 0xc1, 0x4d, 0x47, 0xb7, 0xe5, 0xed, 0x9f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x87, 0xee, 0x53, 0x95, 0x58, 0x08, 0x00, 0x00,
}

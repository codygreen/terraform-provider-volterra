// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/net.proto

package schema

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// VirtualNetworkType
//
// x-displayName: "Virtual Network Type"
// Different types of virtual networks understood by the system
type VirtualNetworkType int32

const (
	// x-displayName: "Site Local Network"
	// Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network.
	// This is an insecure network and is connected to public internet via NAT Gateways/firwalls
	// Virtual-network of this type is local to every site. Two virtual networks of this type on different
	// sites are neither related nor connected.
	//
	// Constraints:
	// There can be atmost one virtual network of this type in a given site.
	// This network type is supported on CE sites. This network is created automatically and present on all sites
	VIRTUAL_NETWORK_SITE_LOCAL VirtualNetworkType = 0
	// x-displayName: "Site Local Inside Network"
	// Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE is a private network inside site.
	// It is a secure network and is not connected to public network.
	// Virtual-network of this type is local to every site. Two virtual networks of this type on different
	// sites are neither related nor connected.
	//
	// Constraints:
	// There can be atmost one virtual network of this type in a given site.
	// This network type is supported on CE sites. This network is created during provisioning of site
	VIRTUAL_NETWORK_SITE_LOCAL_INSIDE VirtualNetworkType = 1
	// x-displayName: "Per Site Network"
	// User defined per-site virtual network. Scope of this virtual network is limited to the site.
	// This is not yet supported
	VIRTUAL_NETWORK_PER_SITE VirtualNetworkType = 2
	// x-displayName: "Public Network"
	// Virtual-network of type VIRTUAL_NETWORK_PUBLIC directly conects to the public internet.
	// Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected.
	//
	// Constraints:
	// There can be atmost one virtual network of this type in a given site.
	// This network type is supported on RE sites only
	// It is an internally created by the system. They must not be created by user
	VIRTUAL_NETWORK_PUBLIC VirtualNetworkType = 3
	// x-displayName: "Global Network"
	// Virtual Neworks with global scope across different sites in Volterra domain.
	// An example global virtual-network called "AIN Network" is created for every tenant.
	// for volterra fabric
	//
	// Constraints:
	// It is currently only supported as internally created by the system.
	VIRTUAL_NETWORK_GLOBAL VirtualNetworkType = 4
	// x-displayName: "Site Local Service Network"
	// Vk8s service network for a given tenant. Used to advertise a virtual host only to vk8s pods for that tenant
	// Constraints:
	// It is an internally created by the system. Must not be created by user
	VIRTUAL_NETWORK_SITE_SERVICE VirtualNetworkType = 5
	// x-displayName: "VER Internal Network"
	// VER internal network for the site. It can only be used for virtual hosts with SMA_PROXY type proxy
	// Constraints:
	// It is an internally created by the system. Must not be created by user
	VIRTUAL_NETWORK_VER_INTERNAL VirtualNetworkType = 6
	// x-displayName: "Site Local Inside And Outside Networks"
	// Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE represents both
	// VIRTUAL_NETWORK_SITE_LOCAL and VIRTUAL_NETWORK_SITE_LOCAL_INSIDE
	//
	// Constraints:
	// This network type is only meaningful in an advertise policy
	VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE VirtualNetworkType = 7
	// x-displayName: "IP Based Automatic Network"
	// When virtual-network of type VIRTUAL_NETWORK_IP_AUTO is selected for
	// an endpoint, VER will try to determine the network based on the provided
	// IP address
	//
	// Constraints:
	// This network type is only meaningful in an endpoint
	VIRTUAL_NETWORK_IP_AUTO VirtualNetworkType = 8
)

var VirtualNetworkType_name = map[int32]string{
	0: "VIRTUAL_NETWORK_SITE_LOCAL",
	1: "VIRTUAL_NETWORK_SITE_LOCAL_INSIDE",
	2: "VIRTUAL_NETWORK_PER_SITE",
	3: "VIRTUAL_NETWORK_PUBLIC",
	4: "VIRTUAL_NETWORK_GLOBAL",
	5: "VIRTUAL_NETWORK_SITE_SERVICE",
	6: "VIRTUAL_NETWORK_VER_INTERNAL",
	7: "VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE",
	8: "VIRTUAL_NETWORK_IP_AUTO",
}
var VirtualNetworkType_value = map[string]int32{
	"VIRTUAL_NETWORK_SITE_LOCAL":                0,
	"VIRTUAL_NETWORK_SITE_LOCAL_INSIDE":         1,
	"VIRTUAL_NETWORK_PER_SITE":                  2,
	"VIRTUAL_NETWORK_PUBLIC":                    3,
	"VIRTUAL_NETWORK_GLOBAL":                    4,
	"VIRTUAL_NETWORK_SITE_SERVICE":              5,
	"VIRTUAL_NETWORK_VER_INTERNAL":              6,
	"VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE": 7,
	"VIRTUAL_NETWORK_IP_AUTO":                   8,
}

func (VirtualNetworkType) EnumDescriptor() ([]byte, []int) { return fileDescriptorNet, []int{0} }

// MAC Address
//
// x-displayName: "MAC Address"
// Mac Address in string format
type MacAddressType struct {
	// Mac Address
	//
	// x-displayName: "MAC Address"
	// x-example: "01:10:20:0a:bb:1c"
	Mac string `protobuf:"bytes,1,opt,name=mac,proto3" json:"mac,omitempty"`
}

func (m *MacAddressType) Reset()                    { *m = MacAddressType{} }
func (*MacAddressType) ProtoMessage()               {}
func (*MacAddressType) Descriptor() ([]byte, []int) { return fileDescriptorNet, []int{0} }

func (m *MacAddressType) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

// IPv4 Address
//
// x-displayName: "IPv4 Address"
// IPv4 Address in dot-decimal notation
type Ipv4AddressType struct {
	// IPv4 Address
	//
	// x-displayName: "IPv4 Address"
	// x-example: "192.168.1.1"
	// IPv4 Address in string form with dot-decimal notation
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *Ipv4AddressType) Reset()                    { *m = Ipv4AddressType{} }
func (*Ipv4AddressType) ProtoMessage()               {}
func (*Ipv4AddressType) Descriptor() ([]byte, []int) { return fileDescriptorNet, []int{1} }

func (m *Ipv4AddressType) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// IPv4 Subnet
//
// x-displayName: "IPv4 Subnet"
// IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32
type Ipv4SubnetType struct {
	// Prefix
	//
	// x-displayName: "Prefix"
	// x-example: "192.168.1.0"
	// Prefix part of the IPv4 subnet in string form with dot-decimal notation
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Prefix Length
	//
	// x-displayName: "Prefix Length"
	// x-example: 24
	// Prefix-length of the IPv4 subnet. Must be <= 32
	Plen uint32 `protobuf:"varint,2,opt,name=plen,proto3" json:"plen,omitempty"`
}

func (m *Ipv4SubnetType) Reset()                    { *m = Ipv4SubnetType{} }
func (*Ipv4SubnetType) ProtoMessage()               {}
func (*Ipv4SubnetType) Descriptor() ([]byte, []int) { return fileDescriptorNet, []int{2} }

func (m *Ipv4SubnetType) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Ipv4SubnetType) GetPlen() uint32 {
	if m != nil {
		return m.Plen
	}
	return 0
}

// IPv6 Address
//
// x-displayName: "IPv6 Address"
// IPv6 Address specified as hexadecimal numbers seperated by ':'
type Ipv6AddressType struct {
	// IPv6 Address
	//
	// x-displayName: "IPv6 Address"
	// x-example: "2001:db8:0:0:0:0:2:1"
	// IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers sepearted by ':'
	// The address can be compacted by suppressing zeros
	// e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *Ipv6AddressType) Reset()                    { *m = Ipv6AddressType{} }
func (*Ipv6AddressType) ProtoMessage()               {}
func (*Ipv6AddressType) Descriptor() ([]byte, []int) { return fileDescriptorNet, []int{3} }

func (m *Ipv6AddressType) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// IPv6 Subnet
//
// x-displayName: "IPv6 Subnet"
// IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128
type Ipv6SubnetType struct {
	// Prefix
	//
	// x-displayName: "Prefix"
	// x-example: "2001:db8:0:0:0:0:2:0"
	// Prefix part of the IPv6 subnet given in form of string.
	// IPv6 address must be specified as hexadecimal numbers sepearted by ':'
	// e.g. "2001:db8:0:0:0:2:0:0"
	// The address can be compacted by suppressing zeros
	// e.g. "2001:db8::2::"
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Prefix length
	//
	// x-example: "38"
	// x-displayName: "Prefix Length"
	// Prefix length of the IPv6 subnet. Must be <= 128
	Plen uint32 `protobuf:"varint,2,opt,name=plen,proto3" json:"plen,omitempty"`
}

func (m *Ipv6SubnetType) Reset()                    { *m = Ipv6SubnetType{} }
func (*Ipv6SubnetType) ProtoMessage()               {}
func (*Ipv6SubnetType) Descriptor() ([]byte, []int) { return fileDescriptorNet, []int{4} }

func (m *Ipv6SubnetType) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Ipv6SubnetType) GetPlen() uint32 {
	if m != nil {
		return m.Plen
	}
	return 0
}

// IP Address
//
// x-displayName: "IP Address"
// IP Address used to specify an IPv4 or IPv6 address
type IpAddressType struct {
	// Version
	//
	// x-displayName: "Version"
	// IP Address version. Can be IPv4 Address or IPv6 Address
	//
	// Types that are valid to be assigned to Ver:
	//	*IpAddressType_Ipv4
	//	*IpAddressType_Ipv6
	Ver isIpAddressType_Ver `protobuf_oneof:"ver"`
}

func (m *IpAddressType) Reset()                    { *m = IpAddressType{} }
func (*IpAddressType) ProtoMessage()               {}
func (*IpAddressType) Descriptor() ([]byte, []int) { return fileDescriptorNet, []int{5} }

type isIpAddressType_Ver interface {
	isIpAddressType_Ver()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IpAddressType_Ipv4 struct {
	Ipv4 *Ipv4AddressType `protobuf:"bytes,1,opt,name=ipv4,oneof"`
}
type IpAddressType_Ipv6 struct {
	Ipv6 *Ipv6AddressType `protobuf:"bytes,2,opt,name=ipv6,oneof"`
}

func (*IpAddressType_Ipv4) isIpAddressType_Ver() {}
func (*IpAddressType_Ipv6) isIpAddressType_Ver() {}

func (m *IpAddressType) GetVer() isIpAddressType_Ver {
	if m != nil {
		return m.Ver
	}
	return nil
}

func (m *IpAddressType) GetIpv4() *Ipv4AddressType {
	if x, ok := m.GetVer().(*IpAddressType_Ipv4); ok {
		return x.Ipv4
	}
	return nil
}

func (m *IpAddressType) GetIpv6() *Ipv6AddressType {
	if x, ok := m.GetVer().(*IpAddressType_Ipv6); ok {
		return x.Ipv6
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IpAddressType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IpAddressType_OneofMarshaler, _IpAddressType_OneofUnmarshaler, _IpAddressType_OneofSizer, []interface{}{
		(*IpAddressType_Ipv4)(nil),
		(*IpAddressType_Ipv6)(nil),
	}
}

func _IpAddressType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IpAddressType)
	// ver
	switch x := m.Ver.(type) {
	case *IpAddressType_Ipv4:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv4); err != nil {
			return err
		}
	case *IpAddressType_Ipv6:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv6); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IpAddressType.Ver has unexpected type %T", x)
	}
	return nil
}

func _IpAddressType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IpAddressType)
	switch tag {
	case 1: // ver.ipv4
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Ipv4AddressType)
		err := b.DecodeMessage(msg)
		m.Ver = &IpAddressType_Ipv4{msg}
		return true, err
	case 2: // ver.ipv6
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Ipv6AddressType)
		err := b.DecodeMessage(msg)
		m.Ver = &IpAddressType_Ipv6{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IpAddressType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IpAddressType)
	// ver
	switch x := m.Ver.(type) {
	case *IpAddressType_Ipv4:
		s := proto.Size(x.Ipv4)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IpAddressType_Ipv6:
		s := proto.Size(x.Ipv6)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// IP Subnet
//
// x-displayName: "IP Subnet"
// IP Address used to specify an IPv4 or IPv6 subnet addresses
type IpSubnetType struct {
	// Version
	//
	// x-displayName: "Version"
	// IP Address version. Can be IPv4 subnet address or IPv6 subnet address
	//
	// Types that are valid to be assigned to Ver:
	//	*IpSubnetType_Ipv4
	//	*IpSubnetType_Ipv6
	Ver isIpSubnetType_Ver `protobuf_oneof:"ver"`
}

func (m *IpSubnetType) Reset()                    { *m = IpSubnetType{} }
func (*IpSubnetType) ProtoMessage()               {}
func (*IpSubnetType) Descriptor() ([]byte, []int) { return fileDescriptorNet, []int{6} }

type isIpSubnetType_Ver interface {
	isIpSubnetType_Ver()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IpSubnetType_Ipv4 struct {
	Ipv4 *Ipv4SubnetType `protobuf:"bytes,1,opt,name=ipv4,oneof"`
}
type IpSubnetType_Ipv6 struct {
	Ipv6 *Ipv6SubnetType `protobuf:"bytes,2,opt,name=ipv6,oneof"`
}

func (*IpSubnetType_Ipv4) isIpSubnetType_Ver() {}
func (*IpSubnetType_Ipv6) isIpSubnetType_Ver() {}

func (m *IpSubnetType) GetVer() isIpSubnetType_Ver {
	if m != nil {
		return m.Ver
	}
	return nil
}

func (m *IpSubnetType) GetIpv4() *Ipv4SubnetType {
	if x, ok := m.GetVer().(*IpSubnetType_Ipv4); ok {
		return x.Ipv4
	}
	return nil
}

func (m *IpSubnetType) GetIpv6() *Ipv6SubnetType {
	if x, ok := m.GetVer().(*IpSubnetType_Ipv6); ok {
		return x.Ipv6
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IpSubnetType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IpSubnetType_OneofMarshaler, _IpSubnetType_OneofUnmarshaler, _IpSubnetType_OneofSizer, []interface{}{
		(*IpSubnetType_Ipv4)(nil),
		(*IpSubnetType_Ipv6)(nil),
	}
}

func _IpSubnetType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IpSubnetType)
	// ver
	switch x := m.Ver.(type) {
	case *IpSubnetType_Ipv4:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv4); err != nil {
			return err
		}
	case *IpSubnetType_Ipv6:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv6); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IpSubnetType.Ver has unexpected type %T", x)
	}
	return nil
}

func _IpSubnetType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IpSubnetType)
	switch tag {
	case 1: // ver.ipv4
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Ipv4SubnetType)
		err := b.DecodeMessage(msg)
		m.Ver = &IpSubnetType_Ipv4{msg}
		return true, err
	case 2: // ver.ipv6
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Ipv6SubnetType)
		err := b.DecodeMessage(msg)
		m.Ver = &IpSubnetType_Ipv6{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IpSubnetType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IpSubnetType)
	// ver
	switch x := m.Ver.(type) {
	case *IpSubnetType_Ipv4:
		s := proto.Size(x.Ipv4)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IpSubnetType_Ipv6:
		s := proto.Size(x.Ipv6)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// IP Prefix List
//
// x-displayName: "IP Prefix List"
// List of IP Address prefixes. Prefix must contain both prefix and prefix-length
// The list can contain mix of both IPv4 and IPv6 prefixes
type PrefixListType struct {
	// Prefix
	//
	// x-displayName: "Prefix"
	// x-example: "[192.168.1.0/24, 192.168.2.0/24]" or "[2001:db8::1::/112, 2001::db8::2::/112]"
	// IP Address prefix in string format. String must contain both prefix and prefix-length
	Prefix []string `protobuf:"bytes,1,rep,name=prefix" json:"prefix,omitempty"`
}

func (m *PrefixListType) Reset()                    { *m = PrefixListType{} }
func (*PrefixListType) ProtoMessage()               {}
func (*PrefixListType) Descriptor() ([]byte, []int) { return fileDescriptorNet, []int{7} }

func (m *PrefixListType) GetPrefix() []string {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func init() {
	proto.RegisterType((*MacAddressType)(nil), "ves.io.schema.MacAddressType")
	golang_proto.RegisterType((*MacAddressType)(nil), "ves.io.schema.MacAddressType")
	proto.RegisterType((*Ipv4AddressType)(nil), "ves.io.schema.Ipv4AddressType")
	golang_proto.RegisterType((*Ipv4AddressType)(nil), "ves.io.schema.Ipv4AddressType")
	proto.RegisterType((*Ipv4SubnetType)(nil), "ves.io.schema.Ipv4SubnetType")
	golang_proto.RegisterType((*Ipv4SubnetType)(nil), "ves.io.schema.Ipv4SubnetType")
	proto.RegisterType((*Ipv6AddressType)(nil), "ves.io.schema.Ipv6AddressType")
	golang_proto.RegisterType((*Ipv6AddressType)(nil), "ves.io.schema.Ipv6AddressType")
	proto.RegisterType((*Ipv6SubnetType)(nil), "ves.io.schema.Ipv6SubnetType")
	golang_proto.RegisterType((*Ipv6SubnetType)(nil), "ves.io.schema.Ipv6SubnetType")
	proto.RegisterType((*IpAddressType)(nil), "ves.io.schema.IpAddressType")
	golang_proto.RegisterType((*IpAddressType)(nil), "ves.io.schema.IpAddressType")
	proto.RegisterType((*IpSubnetType)(nil), "ves.io.schema.IpSubnetType")
	golang_proto.RegisterType((*IpSubnetType)(nil), "ves.io.schema.IpSubnetType")
	proto.RegisterType((*PrefixListType)(nil), "ves.io.schema.PrefixListType")
	golang_proto.RegisterType((*PrefixListType)(nil), "ves.io.schema.PrefixListType")
	proto.RegisterEnum("ves.io.schema.VirtualNetworkType", VirtualNetworkType_name, VirtualNetworkType_value)
	golang_proto.RegisterEnum("ves.io.schema.VirtualNetworkType", VirtualNetworkType_name, VirtualNetworkType_value)
}
func (x VirtualNetworkType) String() string {
	s, ok := VirtualNetworkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *MacAddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MacAddressType)
	if !ok {
		that2, ok := that.(MacAddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mac != that1.Mac {
		return false
	}
	return true
}
func (this *Ipv4AddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ipv4AddressType)
	if !ok {
		that2, ok := that.(Ipv4AddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	return true
}
func (this *Ipv4SubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ipv4SubnetType)
	if !ok {
		that2, ok := that.(Ipv4SubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	if this.Plen != that1.Plen {
		return false
	}
	return true
}
func (this *Ipv6AddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ipv6AddressType)
	if !ok {
		that2, ok := that.(Ipv6AddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	return true
}
func (this *Ipv6SubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ipv6SubnetType)
	if !ok {
		that2, ok := that.(Ipv6SubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	if this.Plen != that1.Plen {
		return false
	}
	return true
}
func (this *IpAddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpAddressType)
	if !ok {
		that2, ok := that.(IpAddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Ver == nil {
		if this.Ver != nil {
			return false
		}
	} else if this.Ver == nil {
		return false
	} else if !this.Ver.Equal(that1.Ver) {
		return false
	}
	return true
}
func (this *IpAddressType_Ipv4) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpAddressType_Ipv4)
	if !ok {
		that2, ok := that.(IpAddressType_Ipv4)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4.Equal(that1.Ipv4) {
		return false
	}
	return true
}
func (this *IpAddressType_Ipv6) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpAddressType_Ipv6)
	if !ok {
		that2, ok := that.(IpAddressType_Ipv6)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv6.Equal(that1.Ipv6) {
		return false
	}
	return true
}
func (this *IpSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpSubnetType)
	if !ok {
		that2, ok := that.(IpSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Ver == nil {
		if this.Ver != nil {
			return false
		}
	} else if this.Ver == nil {
		return false
	} else if !this.Ver.Equal(that1.Ver) {
		return false
	}
	return true
}
func (this *IpSubnetType_Ipv4) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpSubnetType_Ipv4)
	if !ok {
		that2, ok := that.(IpSubnetType_Ipv4)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4.Equal(that1.Ipv4) {
		return false
	}
	return true
}
func (this *IpSubnetType_Ipv6) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpSubnetType_Ipv6)
	if !ok {
		that2, ok := that.(IpSubnetType_Ipv6)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv6.Equal(that1.Ipv6) {
		return false
	}
	return true
}
func (this *PrefixListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrefixListType)
	if !ok {
		that2, ok := that.(PrefixListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Prefix) != len(that1.Prefix) {
		return false
	}
	for i := range this.Prefix {
		if this.Prefix[i] != that1.Prefix[i] {
			return false
		}
	}
	return true
}
func (this *MacAddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.MacAddressType{")
	s = append(s, "Mac: "+fmt.Sprintf("%#v", this.Mac)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ipv4AddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.Ipv4AddressType{")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ipv4SubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Ipv4SubnetType{")
	s = append(s, "Prefix: "+fmt.Sprintf("%#v", this.Prefix)+",\n")
	s = append(s, "Plen: "+fmt.Sprintf("%#v", this.Plen)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ipv6AddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.Ipv6AddressType{")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ipv6SubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Ipv6SubnetType{")
	s = append(s, "Prefix: "+fmt.Sprintf("%#v", this.Prefix)+",\n")
	s = append(s, "Plen: "+fmt.Sprintf("%#v", this.Plen)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpAddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.IpAddressType{")
	if this.Ver != nil {
		s = append(s, "Ver: "+fmt.Sprintf("%#v", this.Ver)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpAddressType_Ipv4) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.IpAddressType_Ipv4{` +
		`Ipv4:` + fmt.Sprintf("%#v", this.Ipv4) + `}`}, ", ")
	return s
}
func (this *IpAddressType_Ipv6) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.IpAddressType_Ipv6{` +
		`Ipv6:` + fmt.Sprintf("%#v", this.Ipv6) + `}`}, ", ")
	return s
}
func (this *IpSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.IpSubnetType{")
	if this.Ver != nil {
		s = append(s, "Ver: "+fmt.Sprintf("%#v", this.Ver)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpSubnetType_Ipv4) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.IpSubnetType_Ipv4{` +
		`Ipv4:` + fmt.Sprintf("%#v", this.Ipv4) + `}`}, ", ")
	return s
}
func (this *IpSubnetType_Ipv6) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.IpSubnetType_Ipv6{` +
		`Ipv6:` + fmt.Sprintf("%#v", this.Ipv6) + `}`}, ", ")
	return s
}
func (this *PrefixListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.PrefixListType{")
	s = append(s, "Prefix: "+fmt.Sprintf("%#v", this.Prefix)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringNet(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *MacAddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MacAddressType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mac) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNet(dAtA, i, uint64(len(m.Mac)))
		i += copy(dAtA[i:], m.Mac)
	}
	return i, nil
}

func (m *Ipv4AddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv4AddressType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNet(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	return i, nil
}

func (m *Ipv4SubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv4SubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNet(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.Plen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNet(dAtA, i, uint64(m.Plen))
	}
	return i, nil
}

func (m *Ipv6AddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv6AddressType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNet(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	return i, nil
}

func (m *Ipv6SubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv6SubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNet(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.Plen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNet(dAtA, i, uint64(m.Plen))
	}
	return i, nil
}

func (m *IpAddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpAddressType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != nil {
		nn1, err := m.Ver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *IpAddressType_Ipv4) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ipv4 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNet(dAtA, i, uint64(m.Ipv4.Size()))
		n2, err := m.Ipv4.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *IpAddressType_Ipv6) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ipv6 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNet(dAtA, i, uint64(m.Ipv6.Size()))
		n3, err := m.Ipv6.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *IpSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpSubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != nil {
		nn4, err := m.Ver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	return i, nil
}

func (m *IpSubnetType_Ipv4) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ipv4 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNet(dAtA, i, uint64(m.Ipv4.Size()))
		n5, err := m.Ipv4.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *IpSubnetType_Ipv6) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ipv6 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNet(dAtA, i, uint64(m.Ipv6.Size()))
		n6, err := m.Ipv6.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *PrefixListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrefixListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		for _, s := range m.Prefix {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintNet(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedMacAddressType(r randyNet, easy bool) *MacAddressType {
	this := &MacAddressType{}
	this.Mac = string(randStringNet(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpv4AddressType(r randyNet, easy bool) *Ipv4AddressType {
	this := &Ipv4AddressType{}
	this.Addr = string(randStringNet(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpv4SubnetType(r randyNet, easy bool) *Ipv4SubnetType {
	this := &Ipv4SubnetType{}
	this.Prefix = string(randStringNet(r))
	this.Plen = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpv6AddressType(r randyNet, easy bool) *Ipv6AddressType {
	this := &Ipv6AddressType{}
	this.Addr = string(randStringNet(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpv6SubnetType(r randyNet, easy bool) *Ipv6SubnetType {
	this := &Ipv6SubnetType{}
	this.Prefix = string(randStringNet(r))
	this.Plen = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpAddressType(r randyNet, easy bool) *IpAddressType {
	this := &IpAddressType{}
	oneofNumber_Ver := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_Ver {
	case 1:
		this.Ver = NewPopulatedIpAddressType_Ipv4(r, easy)
	case 2:
		this.Ver = NewPopulatedIpAddressType_Ipv6(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpAddressType_Ipv4(r randyNet, easy bool) *IpAddressType_Ipv4 {
	this := &IpAddressType_Ipv4{}
	this.Ipv4 = NewPopulatedIpv4AddressType(r, easy)
	return this
}
func NewPopulatedIpAddressType_Ipv6(r randyNet, easy bool) *IpAddressType_Ipv6 {
	this := &IpAddressType_Ipv6{}
	this.Ipv6 = NewPopulatedIpv6AddressType(r, easy)
	return this
}
func NewPopulatedIpSubnetType(r randyNet, easy bool) *IpSubnetType {
	this := &IpSubnetType{}
	oneofNumber_Ver := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_Ver {
	case 1:
		this.Ver = NewPopulatedIpSubnetType_Ipv4(r, easy)
	case 2:
		this.Ver = NewPopulatedIpSubnetType_Ipv6(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpSubnetType_Ipv4(r randyNet, easy bool) *IpSubnetType_Ipv4 {
	this := &IpSubnetType_Ipv4{}
	this.Ipv4 = NewPopulatedIpv4SubnetType(r, easy)
	return this
}
func NewPopulatedIpSubnetType_Ipv6(r randyNet, easy bool) *IpSubnetType_Ipv6 {
	this := &IpSubnetType_Ipv6{}
	this.Ipv6 = NewPopulatedIpv6SubnetType(r, easy)
	return this
}
func NewPopulatedPrefixListType(r randyNet, easy bool) *PrefixListType {
	this := &PrefixListType{}
	v1 := r.Intn(10)
	this.Prefix = make([]string, v1)
	for i := 0; i < v1; i++ {
		this.Prefix[i] = string(randStringNet(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyNet interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneNet(r randyNet) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringNet(r randyNet) string {
	v2 := r.Intn(100)
	tmps := make([]rune, v2)
	for i := 0; i < v2; i++ {
		tmps[i] = randUTF8RuneNet(r)
	}
	return string(tmps)
}
func randUnrecognizedNet(r randyNet, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldNet(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldNet(dAtA []byte, r randyNet, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateNet(dAtA, uint64(key))
		v3 := r.Int63()
		if r.Intn(2) == 0 {
			v3 *= -1
		}
		dAtA = encodeVarintPopulateNet(dAtA, uint64(v3))
	case 1:
		dAtA = encodeVarintPopulateNet(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateNet(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateNet(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateNet(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateNet(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *MacAddressType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}

func (m *Ipv4AddressType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}

func (m *Ipv4SubnetType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	if m.Plen != 0 {
		n += 1 + sovNet(uint64(m.Plen))
	}
	return n
}

func (m *Ipv6AddressType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}

func (m *Ipv6SubnetType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	if m.Plen != 0 {
		n += 1 + sovNet(uint64(m.Plen))
	}
	return n
}

func (m *IpAddressType) Size() (n int) {
	var l int
	_ = l
	if m.Ver != nil {
		n += m.Ver.Size()
	}
	return n
}

func (m *IpAddressType_Ipv4) Size() (n int) {
	var l int
	_ = l
	if m.Ipv4 != nil {
		l = m.Ipv4.Size()
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}
func (m *IpAddressType_Ipv6) Size() (n int) {
	var l int
	_ = l
	if m.Ipv6 != nil {
		l = m.Ipv6.Size()
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}
func (m *IpSubnetType) Size() (n int) {
	var l int
	_ = l
	if m.Ver != nil {
		n += m.Ver.Size()
	}
	return n
}

func (m *IpSubnetType_Ipv4) Size() (n int) {
	var l int
	_ = l
	if m.Ipv4 != nil {
		l = m.Ipv4.Size()
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}
func (m *IpSubnetType_Ipv6) Size() (n int) {
	var l int
	_ = l
	if m.Ipv6 != nil {
		l = m.Ipv6.Size()
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}
func (m *PrefixListType) Size() (n int) {
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		for _, s := range m.Prefix {
			l = len(s)
			n += 1 + l + sovNet(uint64(l))
		}
	}
	return n
}

func sovNet(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNet(x uint64) (n int) {
	return sovNet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MacAddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MacAddressType{`,
		`Mac:` + fmt.Sprintf("%v", this.Mac) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ipv4AddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ipv4AddressType{`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ipv4SubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ipv4SubnetType{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`Plen:` + fmt.Sprintf("%v", this.Plen) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ipv6AddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ipv6AddressType{`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ipv6SubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ipv6SubnetType{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`Plen:` + fmt.Sprintf("%v", this.Plen) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpAddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpAddressType{`,
		`Ver:` + fmt.Sprintf("%v", this.Ver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpAddressType_Ipv4) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpAddressType_Ipv4{`,
		`Ipv4:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4), "Ipv4AddressType", "Ipv4AddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpAddressType_Ipv6) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpAddressType_Ipv6{`,
		`Ipv6:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6), "Ipv6AddressType", "Ipv6AddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpSubnetType{`,
		`Ver:` + fmt.Sprintf("%v", this.Ver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpSubnetType_Ipv4) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpSubnetType_Ipv4{`,
		`Ipv4:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4), "Ipv4SubnetType", "Ipv4SubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpSubnetType_Ipv6) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpSubnetType_Ipv6{`,
		`Ipv6:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6), "Ipv6SubnetType", "Ipv6SubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrefixListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrefixListType{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringNet(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *MacAddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacAddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacAddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv4AddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ipv4AddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ipv4AddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv4SubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ipv4SubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ipv4SubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plen", wireType)
			}
			m.Plen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv6AddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ipv6AddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ipv6AddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv6SubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ipv6SubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ipv6SubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plen", wireType)
			}
			m.Plen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpAddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpAddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpAddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Ipv4AddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ver = &IpAddressType_Ipv4{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Ipv6AddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ver = &IpAddressType_Ipv6{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Ipv4SubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ver = &IpSubnetType_Ipv4{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Ipv6SubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ver = &IpSubnetType_Ipv6{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrefixListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrefixListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrefixListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNet
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNet
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNet(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNet = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNet   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/net.proto", fileDescriptorNet) }
func init() { golang_proto.RegisterFile("ves.io/schema/net.proto", fileDescriptorNet) }

var fileDescriptorNet = []byte{
	// 718 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xbf, 0x6f, 0xda, 0x4e,
	0x18, 0xc6, 0x79, 0x31, 0x21, 0xc9, 0x7d, 0xbf, 0x10, 0xcb, 0x43, 0x82, 0x68, 0x7a, 0x25, 0x96,
	0x52, 0xa5, 0x51, 0x31, 0x6a, 0xa0, 0x0c, 0x1d, 0x2a, 0x01, 0xb5, 0x1a, 0xb7, 0x2e, 0x44, 0xe6,
	0x47, 0xa5, 0xa8, 0x92, 0x65, 0xc0, 0x21, 0x56, 0x00, 0x5b, 0xc6, 0x90, 0x74, 0xa8, 0xc4, 0xd2,
	0xbd, 0xca, 0x5c, 0xa9, 0x6b, 0xff, 0x84, 0xa8, 0x2c, 0x8c, 0x1d, 0x19, 0x33, 0x16, 0x67, 0x69,
	0xb7, 0xa8, 0x53, 0xc6, 0x8a, 0x03, 0x1a, 0x1b, 0xa8, 0xda, 0xc9, 0x77, 0x7a, 0x9e, 0xe7, 0xbd,
	0xcf, 0xfb, 0x9e, 0x75, 0x68, 0xa3, 0xa3, 0xb6, 0x38, 0x4d, 0x8f, 0xb5, 0x2a, 0xc7, 0x6a, 0x43,
	0x89, 0x35, 0x55, 0x8b, 0x33, 0x4c, 0xdd, 0xd2, 0x99, 0xc0, 0x58, 0xe0, 0xc6, 0x42, 0x38, 0x5a,
	0xd3, 0xac, 0xe3, 0x76, 0x99, 0xab, 0xe8, 0x8d, 0x58, 0x4d, 0xaf, 0xe9, 0x31, 0xe2, 0x2a, 0xb7,
	0x8f, 0xc8, 0x8e, 0x6c, 0xc8, 0x6a, 0x9c, 0x0e, 0xdf, 0x71, 0x97, 0xd5, 0x0d, 0x4b, 0xd3, 0x9b,
	0xad, 0x89, 0xb8, 0xe9, 0x16, 0x3b, 0x4a, 0x5d, 0xab, 0x2a, 0x96, 0x3a, 0x51, 0x23, 0x33, 0xaa,
	0xa6, 0x9e, 0xca, 0xae, 0x3c, 0xbb, 0x87, 0x82, 0xaf, 0x94, 0x4a, 0xaa, 0x5a, 0x35, 0xd5, 0x56,
	0xab, 0xf0, 0xd6, 0x50, 0x99, 0x08, 0xa2, 0x1a, 0x4a, 0x25, 0x04, 0x11, 0xd8, 0x59, 0x4d, 0x07,
	0x6f, 0x7a, 0xe0, 0xf9, 0xf2, 0xa3, 0x4f, 0x2d, 0x99, 0xd4, 0x05, 0x80, 0x34, 0x92, 0xd8, 0x04,
	0x5a, 0x13, 0x8c, 0x4e, 0xc2, 0x19, 0xda, 0x42, 0x3e, 0xa5, 0x5a, 0x35, 0x27, 0xa9, 0xc0, 0x34,
	0xe5, 0x33, 0xbd, 0x67, 0x20, 0x11, 0x89, 0x3d, 0x44, 0xc1, 0x51, 0x2a, 0xdf, 0x2e, 0x37, 0x55,
	0x8b, 0x84, 0xb6, 0x91, 0xdf, 0x30, 0xd5, 0x23, 0xed, 0x6c, 0x71, 0x6c, 0x22, 0x8e, 0x6a, 0x1b,
	0x75, 0xb5, 0x19, 0xf2, 0x46, 0x60, 0x27, 0xe0, 0x30, 0xed, 0x7a, 0x43, 0x11, 0x89, 0x48, 0xec,
	0x63, 0x42, 0x94, 0x74, 0x12, 0xb1, 0x2e, 0x22, 0x67, 0x1f, 0x5d, 0x98, 0x22, 0xbd, 0x21, 0x48,
	0x49, 0x07, 0xd2, 0xfd, 0x19, 0xa4, 0xd9, 0xdc, 0x94, 0x89, 0x75, 0x31, 0xdd, 0xba, 0x76, 0xa9,
	0x50, 0x17, 0x26, 0x50, 0x9f, 0x00, 0x05, 0x04, 0xc3, 0xc9, 0x94, 0x40, 0x3e, 0xcd, 0xe8, 0x24,
	0x48, 0xed, 0xff, 0xf6, 0x30, 0xe7, 0xfa, 0x2d, 0xb8, 0x99, 0x99, 0xee, 0x7b, 0x24, 0xe2, 0x9e,
	0xa4, 0x92, 0xe4, 0xac, 0x85, 0xa9, 0xe4, 0x7c, 0x2a, 0xf9, 0xc4, 0xf7, 0xf3, 0x29, 0xc4, 0xd3,
	0xeb, 0x88, 0xea, 0xa8, 0x26, 0xb3, 0xd6, 0xef, 0x01, 0x0c, 0x7a, 0x40, 0xd9, 0x3d, 0xa0, 0x1e,
	0x3d, 0xdc, 0x7b, 0xe1, 0x5b, 0xa1, 0x68, 0x1f, 0xfb, 0x11, 0xd0, 0xff, 0x82, 0xe1, 0x68, 0x3f,
	0xee, 0x02, 0xbc, 0xbb, 0x00, 0xf0, 0xd6, 0xfc, 0x9b, 0x2f, 0xee, 0xe2, 0x5b, 0x10, 0x4a, 0xce,
	0x85, 0xfe, 0x0d, 0x6f, 0x1f, 0x05, 0x0f, 0xc8, 0xb8, 0x45, 0xad, 0x35, 0xe6, 0x4b, 0x3a, 0xae,
	0x87, 0xda, 0x59, 0x4d, 0xe3, 0xe9, 0xe0, 0xd1, 0x39, 0x2c, 0xb3, 0x4b, 0x26, 0x75, 0x03, 0x30,
	0xda, 0xfa, 0xcf, 0x81, 0xa2, 0xbb, 0xde, 0xe9, 0x75, 0xed, 0x0e, 0xbc, 0x88, 0x29, 0x69, 0xa6,
	0xd5, 0x56, 0xea, 0x59, 0xd5, 0x3a, 0xd5, 0xcd, 0x13, 0x52, 0x0e, 0xa3, 0x70, 0x49, 0x90, 0x0a,
	0xc5, 0x94, 0x28, 0x67, 0xf9, 0xc2, 0xeb, 0x9c, 0xf4, 0x52, 0xce, 0x0b, 0x05, 0x5e, 0x16, 0x73,
	0x99, 0x94, 0x48, 0x7b, 0x98, 0x6d, 0xb4, 0xf5, 0x67, 0x5d, 0x16, 0xb2, 0x79, 0xe1, 0x19, 0x4f,
	0x03, 0xb3, 0x89, 0x42, 0xb3, 0xb6, 0x03, 0x5e, 0x22, 0x56, 0xda, 0xcb, 0xdc, 0x43, 0xeb, 0x73,
	0x6a, 0x31, 0x2d, 0x0a, 0x19, 0x9a, 0x0a, 0x53, 0xdd, 0x77, 0xc0, 0x84, 0xe7, 0x0d, 0xcf, 0xc5,
	0x5c, 0x3a, 0x25, 0xd2, 0x3e, 0x26, 0x82, 0x36, 0x17, 0x12, 0xe4, 0x79, 0xa9, 0x24, 0x64, 0x78,
	0x7a, 0x89, 0xd9, 0x9e, 0x77, 0x94, 0x78, 0x49, 0x16, 0xb2, 0x05, 0x5e, 0xca, 0xa6, 0x44, 0xda,
	0x3f, 0x3e, 0x24, 0x8a, 0x1e, 0xfc, 0xb5, 0x15, 0x39, 0x57, 0x2c, 0x90, 0x96, 0x96, 0x99, 0x08,
	0xda, 0x98, 0xb5, 0x0b, 0x07, 0x72, 0xaa, 0x58, 0xc8, 0xd1, 0x2b, 0xa4, 0x60, 0xfa, 0x3d, 0x0c,
	0x86, 0xd8, 0x73, 0x39, 0xc4, 0x9e, 0xeb, 0x21, 0x86, 0x9b, 0x21, 0x86, 0xae, 0x8d, 0xe1, 0xb3,
	0x8d, 0xe1, 0xc2, 0xc6, 0xd0, 0xb7, 0x31, 0x7c, 0xb5, 0x31, 0x0c, 0x6c, 0x0c, 0x97, 0x36, 0x86,
	0x6f, 0x36, 0x86, 0xef, 0x36, 0xf6, 0x5c, 0xdb, 0x18, 0x3e, 0x5c, 0x61, 0x4f, 0xff, 0x0a, 0xc3,
	0x61, 0xa6, 0xa6, 0x1b, 0x27, 0x35, 0xae, 0xa3, 0xd7, 0x2d, 0xd5, 0x34, 0x15, 0xae, 0xdd, 0x8a,
	0x91, 0xc5, 0x91, 0x6e, 0x36, 0xa2, 0x86, 0xa9, 0x77, 0xb4, 0xaa, 0x6a, 0x46, 0xa7, 0x72, 0xcc,
	0x28, 0xd7, 0xf4, 0x98, 0x7a, 0x66, 0x4d, 0x1e, 0xb3, 0xf1, 0xa7, 0xec, 0x27, 0xef, 0x58, 0xfc,
	0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7a, 0x31, 0x8b, 0x4c, 0x7d, 0x05, 0x00, 0x00,
}

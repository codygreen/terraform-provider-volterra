// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/network_interface/types.proto

package network_interface

import (
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"

	fmt "fmt"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	_ "github.com/gogo/protobuf/types"

	ves_io_schema3 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"

	strconv "strconv"

	strings "strings"

	reflect "reflect"

	sortkeys "github.com/gogo/protobuf/sortkeys"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// DHCP POOL SETTING
//
// x-displayName: "Interface Network Type"
// Identifies the how to pick the network for Interface.
type DHCPPoolSettingType int32

const (
	// x-displayName: "Include IP Addresses from DHCP Pools"
	// Address ranges in DHCP pool list are allocation list
	INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS DHCPPoolSettingType = 0
	// x-displayName: "Exclude IP Addresses from DHCP Pools"
	// Address ranges in DHCP pool list are exclude list
	EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS DHCPPoolSettingType = 1
)

var DHCPPoolSettingType_name = map[int32]string{
	0: "INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS",
	1: "EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS",
}
var DHCPPoolSettingType_value = map[string]int32{
	"INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS": 0,
	"EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS": 1,
}

func (DHCPPoolSettingType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// Interface Network Type
//
// x-displayName: "Interface Network Type"
// Identifies the how to pick the network for Interface.
type InterfaceNetworkType int32

const (
	// x-displayName: "Network Reference"
	// Backward compatibility to existing config or per site network
	NETWORK_INTERFACE_NETWORK_REF InterfaceNetworkType = 0
	// x-displayName: "Site Local Network"
	// Take site local from from fleet
	NETWORK_INTERFACE_SITE_LOCAL InterfaceNetworkType = 1
	// x-displayName: "Site Local Inside Network"
	// Take site local inside from from fleet
	NETWORK_INTERFACE_SITE_LOCAL_INSIDE InterfaceNetworkType = 2
	// x-displayName: "Site Storage Network"
	// Network interface is used to connect to storage network
	NETWORK_INTERFACE_STORAGE InterfaceNetworkType = 3
	// x-displayName: "Site Management Network"
	// Network interface is used to connect to storage network
	NETWORK_INTERFACE_MANAGEMENT InterfaceNetworkType = 4
)

var InterfaceNetworkType_name = map[int32]string{
	0: "NETWORK_INTERFACE_NETWORK_REF",
	1: "NETWORK_INTERFACE_SITE_LOCAL",
	2: "NETWORK_INTERFACE_SITE_LOCAL_INSIDE",
	3: "NETWORK_INTERFACE_STORAGE",
	4: "NETWORK_INTERFACE_MANAGEMENT",
}
var InterfaceNetworkType_value = map[string]int32{
	"NETWORK_INTERFACE_NETWORK_REF":       0,
	"NETWORK_INTERFACE_SITE_LOCAL":        1,
	"NETWORK_INTERFACE_SITE_LOCAL_INSIDE": 2,
	"NETWORK_INTERFACE_STORAGE":           3,
	"NETWORK_INTERFACE_MANAGEMENT":        4,
}

func (InterfaceNetworkType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// Network Interface Type
//
// x-displayName: "Network Interface Type"
// Identifies the type of the interface.
type NetworkInterfaceType int32

const (
	// x-displayName: "Ethernet"
	// Network interface is an Ethernet interface
	NETWORK_INTERFACE_ETHERNET NetworkInterfaceType = 0
	// x-displayName: "VLAN"
	// Network interface is a VLAN interface
	NETWORK_INTERFACE_VLAN_INTERFACE NetworkInterfaceType = 1
	// x-displayName: "Link Aggregation"
	// Network interface is a bond interface running LACP
	NETWORK_INTERFACE_LACP_INTERFACE NetworkInterfaceType = 2
	// x-displayName: "Tunnel Interface"
	// Network interface is a tunnel interface
	NETWORK_INTERFACE_TUNNEL_INTERFACE NetworkInterfaceType = 3
)

var NetworkInterfaceType_name = map[int32]string{
	0: "NETWORK_INTERFACE_ETHERNET",
	1: "NETWORK_INTERFACE_VLAN_INTERFACE",
	2: "NETWORK_INTERFACE_LACP_INTERFACE",
	3: "NETWORK_INTERFACE_TUNNEL_INTERFACE",
}
var NetworkInterfaceType_value = map[string]int32{
	"NETWORK_INTERFACE_ETHERNET":         0,
	"NETWORK_INTERFACE_VLAN_INTERFACE":   1,
	"NETWORK_INTERFACE_LACP_INTERFACE":   2,
	"NETWORK_INTERFACE_TUNNEL_INTERFACE": 3,
}

func (NetworkInterfaceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// Network Interface DHCP Client
//
// x-displayName: "DHCP Client"
// Controls whether or not DHCP client is enabled on the interface
type NetworkInterfaceDHCP int32

const (
	// x-displayName: "Disable"
	// DHCP client is disabled
	NETWORK_INTERFACE_DHCP_DISABLE NetworkInterfaceDHCP = 0
	// x-displayName: "Enable"
	// DHCP client is enabled
	NETWORK_INTERFACE_DHCP_ENABLE NetworkInterfaceDHCP = 1
)

var NetworkInterfaceDHCP_name = map[int32]string{
	0: "NETWORK_INTERFACE_DHCP_DISABLE",
	1: "NETWORK_INTERFACE_DHCP_ENABLE",
}
var NetworkInterfaceDHCP_value = map[string]int32{
	"NETWORK_INTERFACE_DHCP_DISABLE": 0,
	"NETWORK_INTERFACE_DHCP_ENABLE":  1,
}

func (NetworkInterfaceDHCP) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// Network Interface VLAN Tagging
//
// x-displayName: "Vlan Tagging"
// Controls whether or not VLAN tagging is enabled on the interface
type NetworkInterfaceVLANTagging int32

const (
	// x-displayName: "Disable"
	// Vlan tagging is disabled
	NETWORK_INTERFACE_VLAN_TAGGING_DISABLE NetworkInterfaceVLANTagging = 0
	// x-displayName: "Enable"
	// Vlan tagging is enabled
	NETWORK_INTERFACE_VLAN_TAGGING_ENABLE NetworkInterfaceVLANTagging = 1
)

var NetworkInterfaceVLANTagging_name = map[int32]string{
	0: "NETWORK_INTERFACE_VLAN_TAGGING_DISABLE",
	1: "NETWORK_INTERFACE_VLAN_TAGGING_ENABLE",
}
var NetworkInterfaceVLANTagging_value = map[string]int32{
	"NETWORK_INTERFACE_VLAN_TAGGING_DISABLE": 0,
	"NETWORK_INTERFACE_VLAN_TAGGING_ENABLE":  1,
}

func (NetworkInterfaceVLANTagging) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{4}
}

// Network Interface Gateway Mode
//
// x-displayName: "Gateway Mode"
// Controls the mode of obtaining gateway address for the interface
type NetworkInterfaceGatewayMode int32

const (
	// x-displayName: "Disable"
	// Gateway is disabled
	NETWORK_INTERFACE_GATEWAY_DISABLE NetworkInterfaceGatewayMode = 0
	// x-displayName: "System Allocated"
	// Gateway is allocated by the system
	NETWORK_INTERFACE_GATEWAY_AUTO_ALLOCATE NetworkInterfaceGatewayMode = 1
	// x-displayName: "User Configured"
	// Use the specified gateway
	NETWORK_INTERFACE_GATEWAY_USE_CONFIGURED NetworkInterfaceGatewayMode = 2
)

var NetworkInterfaceGatewayMode_name = map[int32]string{
	0: "NETWORK_INTERFACE_GATEWAY_DISABLE",
	1: "NETWORK_INTERFACE_GATEWAY_AUTO_ALLOCATE",
	2: "NETWORK_INTERFACE_GATEWAY_USE_CONFIGURED",
}
var NetworkInterfaceGatewayMode_value = map[string]int32{
	"NETWORK_INTERFACE_GATEWAY_DISABLE":        0,
	"NETWORK_INTERFACE_GATEWAY_AUTO_ALLOCATE":  1,
	"NETWORK_INTERFACE_GATEWAY_USE_CONFIGURED": 2,
}

func (NetworkInterfaceGatewayMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{5}
}

// Network Interface DNS Mode
//
// x-displayName: "DNS Mode"
// Controls the mode of obtaining DNS address for the interface
type NetworkInterfaceDNSMode int32

const (
	// x-displayName: "Disable"
	// DNS is disabled
	NETWORK_INTERFACE_DNS_DISABLE NetworkInterfaceDNSMode = 0
	// x-displayName: "System Allocated"
	// DNS is allocated by the system
	NETWORK_INTERFACE_DNS_AUTO_ALLOCATE NetworkInterfaceDNSMode = 1
	// x-displayName: "User Configured"
	// Use the specified DNS
	NETWORK_INTERFACE_DNS_USE_CONFIGURED NetworkInterfaceDNSMode = 2
)

var NetworkInterfaceDNSMode_name = map[int32]string{
	0: "NETWORK_INTERFACE_DNS_DISABLE",
	1: "NETWORK_INTERFACE_DNS_AUTO_ALLOCATE",
	2: "NETWORK_INTERFACE_DNS_USE_CONFIGURED",
}
var NetworkInterfaceDNSMode_value = map[string]int32{
	"NETWORK_INTERFACE_DNS_DISABLE":        0,
	"NETWORK_INTERFACE_DNS_AUTO_ALLOCATE":  1,
	"NETWORK_INTERFACE_DNS_USE_CONFIGURED": 2,
}

func (NetworkInterfaceDNSMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

// Network Interface DHCP Server
//
// x-displayName: "DHCP Server"
// Controls whether or not DHCP server runs on the interface
type NetworkInterfaceDHCPServer int32

const (
	// x-displayName: "Disable DHCP Server"
	// DHCP server is disabled
	NETWORK_INTERFACE_DHCP_SERVER_DISABLE NetworkInterfaceDHCPServer = 0
	// x-displayName: "Enable DHCP Server"
	// DHCP server is enabled
	NETWORK_INTERFACE_DHCP_SERVER_ENABLE NetworkInterfaceDHCPServer = 1
	// x-displayName: "Enable Enhanced DHCP Server"
	// Enhanced DHCP server is enabled
	NETWORK_INTERFACE_ENHANCED_DHCP_SERVER_ENABLE NetworkInterfaceDHCPServer = 2
)

var NetworkInterfaceDHCPServer_name = map[int32]string{
	0: "NETWORK_INTERFACE_DHCP_SERVER_DISABLE",
	1: "NETWORK_INTERFACE_DHCP_SERVER_ENABLE",
	2: "NETWORK_INTERFACE_ENHANCED_DHCP_SERVER_ENABLE",
}
var NetworkInterfaceDHCPServer_value = map[string]int32{
	"NETWORK_INTERFACE_DHCP_SERVER_DISABLE":         0,
	"NETWORK_INTERFACE_DHCP_SERVER_ENABLE":          1,
	"NETWORK_INTERFACE_ENHANCED_DHCP_SERVER_ENABLE": 2,
}

func (NetworkInterfaceDHCPServer) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{7}
}

// Interface State
//
// x-displayName: "Interface State"
// Shows the interface link state
type NetworkInterfaceUpDown int32

const (
	// x-displayName: "Admin Down"
	// Interface is admistratively down
	NETWORK_INTERFACE_ADMINISTRATIVELY_DOWN NetworkInterfaceUpDown = 0
	// x-displayName: "Operationally Down"
	// Interface is operationally down
	NETWORK_INTERFACE_OPERATIONALY_DOWN NetworkInterfaceUpDown = 1
	// x-displayName: "Operationally up"
	// Interface is operationally up
	NETWORK_INTERFACE_OPERATIONALY_UP NetworkInterfaceUpDown = 2
)

var NetworkInterfaceUpDown_name = map[int32]string{
	0: "NETWORK_INTERFACE_ADMINISTRATIVELY_DOWN",
	1: "NETWORK_INTERFACE_OPERATIONALY_DOWN",
	2: "NETWORK_INTERFACE_OPERATIONALY_UP",
}
var NetworkInterfaceUpDown_value = map[string]int32{
	"NETWORK_INTERFACE_ADMINISTRATIVELY_DOWN": 0,
	"NETWORK_INTERFACE_OPERATIONALY_DOWN":     1,
	"NETWORK_INTERFACE_OPERATIONALY_UP":       2,
}

func (NetworkInterfaceUpDown) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

// Network Interface Default Gateway
//
// x-displayName: "Default Gateway"
// Controls how the Default Gateway of the Network interface is derived
type NetworkInterfaceDFGW struct {
	// Default Gateway Mode
	//
	// x-displayName: "Default Gateway Mode"
	// x-required
	// Mode of obtaining default gateway
	DefaultGatewayMode NetworkInterfaceGatewayMode `protobuf:"varint,1,opt,name=default_gateway_mode,json=defaultGatewayMode,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceGatewayMode" json:"default_gateway_mode,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// Address of default gateway when mode is "use-configured"
	DefaultGatewayAddress *ves_io_schema3.Ipv4AddressType `protobuf:"bytes,2,opt,name=default_gateway_address,json=defaultGatewayAddress" json:"default_gateway_address,omitempty"`
}

func (m *NetworkInterfaceDFGW) Reset()                    { *m = NetworkInterfaceDFGW{} }
func (*NetworkInterfaceDFGW) ProtoMessage()               {}
func (*NetworkInterfaceDFGW) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *NetworkInterfaceDFGW) GetDefaultGatewayMode() NetworkInterfaceGatewayMode {
	if m != nil {
		return m.DefaultGatewayMode
	}
	return NETWORK_INTERFACE_GATEWAY_DISABLE
}

func (m *NetworkInterfaceDFGW) GetDefaultGatewayAddress() *ves_io_schema3.Ipv4AddressType {
	if m != nil {
		return m.DefaultGatewayAddress
	}
	return nil
}

// Network Interface DNS server
//
// x-displayName: "DNS Server"
// Controls how the DNS Server of the Network interface is derived
type NetworkInterfaceDNS struct {
	// DNS Server Mode
	//
	// x-displayName: "DNS Server Mode"
	// x-required
	// Mode of obtaining DNS server
	DnsMode NetworkInterfaceDNSMode `protobuf:"varint,1,opt,name=dns_mode,json=dnsMode,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDNSMode" json:"dns_mode,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// Address of DNS server when mode is "use-configured"
	DnsServer []*ves_io_schema3.Ipv4AddressType `protobuf:"bytes,2,rep,name=dns_server,json=dnsServer" json:"dns_server,omitempty"`
}

func (m *NetworkInterfaceDNS) Reset()                    { *m = NetworkInterfaceDNS{} }
func (*NetworkInterfaceDNS) ProtoMessage()               {}
func (*NetworkInterfaceDNS) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *NetworkInterfaceDNS) GetDnsMode() NetworkInterfaceDNSMode {
	if m != nil {
		return m.DnsMode
	}
	return NETWORK_INTERFACE_DNS_DISABLE
}

func (m *NetworkInterfaceDNS) GetDnsServer() []*ves_io_schema3.Ipv4AddressType {
	if m != nil {
		return m.DnsServer
	}
	return nil
}

// Network Interface Tunnel
//
// x-displayName: "Tunnel"
// Tunnel attached to this interface, enables encapsulation on interface
type NetworkInterfaceTunnel struct {
	// Tunnel
	//
	// x-displayName: "Tunnel"
	// Tunnel which is attached to this interface
	Tunnel []*ves_io_schema4.ObjectRefType `protobuf:"bytes,1,rep,name=tunnel" json:"tunnel,omitempty"`
}

func (m *NetworkInterfaceTunnel) Reset()                    { *m = NetworkInterfaceTunnel{} }
func (*NetworkInterfaceTunnel) ProtoMessage()               {}
func (*NetworkInterfaceTunnel) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *NetworkInterfaceTunnel) GetTunnel() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

// DHCP IP Range
//
// x-displayName: "DHCP IP Range"
// DHCP pool is a range of IP addresses (start ip and end ip).
type DHCPPoolType struct {
	// Start IP
	//
	// x-displayName: "Starting IP"
	// x-example: "10.1.1.5"
	// Starting IP of the pool range.
	// In case of address allocator, offset is derived based on network prefix.
	// 10.1.1.5 with prefix length of 24, start offset is 0.0.0.5
	StartIp string `protobuf:"bytes,1,opt,name=start_ip,json=startIp,proto3" json:"start_ip,omitempty"`
	// End IP
	//
	// x-displayName: "Ending IP"
	// x-example: "10.1.1.200"
	// Ending IP of the pool range.
	// In case of address allocator, offset is derived based on network prefix.
	// 10.1.1.200 with prefix length of 24, end offset is 0.0.0.200
	EndIp string `protobuf:"bytes,2,opt,name=end_ip,json=endIp,proto3" json:"end_ip,omitempty"`
	// Exclude
	//
	// x-displayName: "Exclude"
	// If exclude is true, IP addresses are not assigned from this range.
	Exclude bool `protobuf:"varint,3,opt,name=exclude,proto3" json:"exclude,omitempty"`
}

func (m *DHCPPoolType) Reset()                    { *m = DHCPPoolType{} }
func (*DHCPPoolType) ProtoMessage()               {}
func (*DHCPPoolType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *DHCPPoolType) GetStartIp() string {
	if m != nil {
		return m.StartIp
	}
	return ""
}

func (m *DHCPPoolType) GetEndIp() string {
	if m != nil {
		return m.EndIp
	}
	return ""
}

func (m *DHCPPoolType) GetExclude() bool {
	if m != nil {
		return m.Exclude
	}
	return false
}

// DHCP Network
//
// x-displayName: "DHCP Network"
// DHCP network configuration
type DHCPNetworkType struct {
	// Network Prefix choice
	//
	// x-displayName: "Select Network Prefix Method"
	// x-required
	// Select DHCP network prefix for a site
	//
	// Types that are valid to be assigned to NetworkPrefixChoice:
	//	*DHCPNetworkType_NetworkPrefix
	//	*DHCPNetworkType_NetworkPrefixAllocator
	NetworkPrefixChoice isDHCPNetworkType_NetworkPrefixChoice `protobuf_oneof:"network_prefix_choice"`
	// DHCP pools
	//
	// x-displayName: "DHCP Pools"
	// List of non overlapping ip address ranges.
	Pools []*DHCPPoolType `protobuf:"bytes,4,rep,name=pools" json:"pools,omitempty"`
	// Default gateway Address
	//
	// x-displayName: "Select Default Gateway address"
	// x-required
	// Select how default gateway address is determined
	//
	// Types that are valid to be assigned to GatewayChoice:
	//	*DHCPNetworkType_FirstAddress
	//	*DHCPNetworkType_LastAddress
	//	*DHCPNetworkType_DgwAddress
	GatewayChoice isDHCPNetworkType_GatewayChoice `protobuf_oneof:"gateway_choice"`
	// DNS server Address
	//
	// x-displayName: "Select DNS server address"
	// x-required
	// Select how default gateway address is determined
	//
	// Types that are valid to be assigned to DnsChoice:
	//	*DHCPNetworkType_SameAsDgw
	//	*DHCPNetworkType_DnsAddress
	DnsChoice isDHCPNetworkType_DnsChoice `protobuf_oneof:"dns_choice"`
	// DHCP Pool Settings
	//
	// x-displayName: "DHCP Pool Settings"
	// x-required
	// Controls how DHCP pools are handled
	PoolSettings DHCPPoolSettingType `protobuf:"varint,12,opt,name=pool_settings,json=poolSettings,proto3,enum=ves.io.schema.network_interface.DHCPPoolSettingType" json:"pool_settings,omitempty"`
}

func (m *DHCPNetworkType) Reset()                    { *m = DHCPNetworkType{} }
func (*DHCPNetworkType) ProtoMessage()               {}
func (*DHCPNetworkType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isDHCPNetworkType_NetworkPrefixChoice interface {
	isDHCPNetworkType_NetworkPrefixChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isDHCPNetworkType_GatewayChoice interface {
	isDHCPNetworkType_GatewayChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isDHCPNetworkType_DnsChoice interface {
	isDHCPNetworkType_DnsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DHCPNetworkType_NetworkPrefix struct {
	NetworkPrefix string `protobuf:"bytes,2,opt,name=network_prefix,json=networkPrefix,proto3,oneof"`
}
type DHCPNetworkType_NetworkPrefixAllocator struct {
	NetworkPrefixAllocator *ves_io_schema_views.ObjectRefType `protobuf:"bytes,3,opt,name=network_prefix_allocator,json=networkPrefixAllocator,oneof"`
}
type DHCPNetworkType_FirstAddress struct {
	FirstAddress *ves_io_schema4.Empty `protobuf:"bytes,6,opt,name=first_address,json=firstAddress,oneof"`
}
type DHCPNetworkType_LastAddress struct {
	LastAddress *ves_io_schema4.Empty `protobuf:"bytes,7,opt,name=last_address,json=lastAddress,oneof"`
}
type DHCPNetworkType_DgwAddress struct {
	DgwAddress string `protobuf:"bytes,8,opt,name=dgw_address,json=dgwAddress,proto3,oneof"`
}
type DHCPNetworkType_SameAsDgw struct {
	SameAsDgw *ves_io_schema4.Empty `protobuf:"bytes,10,opt,name=same_as_dgw,json=sameAsDgw,oneof"`
}
type DHCPNetworkType_DnsAddress struct {
	DnsAddress string `protobuf:"bytes,11,opt,name=dns_address,json=dnsAddress,proto3,oneof"`
}

func (*DHCPNetworkType_NetworkPrefix) isDHCPNetworkType_NetworkPrefixChoice()          {}
func (*DHCPNetworkType_NetworkPrefixAllocator) isDHCPNetworkType_NetworkPrefixChoice() {}
func (*DHCPNetworkType_FirstAddress) isDHCPNetworkType_GatewayChoice()                 {}
func (*DHCPNetworkType_LastAddress) isDHCPNetworkType_GatewayChoice()                  {}
func (*DHCPNetworkType_DgwAddress) isDHCPNetworkType_GatewayChoice()                   {}
func (*DHCPNetworkType_SameAsDgw) isDHCPNetworkType_DnsChoice()                        {}
func (*DHCPNetworkType_DnsAddress) isDHCPNetworkType_DnsChoice()                       {}

func (m *DHCPNetworkType) GetNetworkPrefixChoice() isDHCPNetworkType_NetworkPrefixChoice {
	if m != nil {
		return m.NetworkPrefixChoice
	}
	return nil
}
func (m *DHCPNetworkType) GetGatewayChoice() isDHCPNetworkType_GatewayChoice {
	if m != nil {
		return m.GatewayChoice
	}
	return nil
}
func (m *DHCPNetworkType) GetDnsChoice() isDHCPNetworkType_DnsChoice {
	if m != nil {
		return m.DnsChoice
	}
	return nil
}

func (m *DHCPNetworkType) GetNetworkPrefix() string {
	if x, ok := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefix); ok {
		return x.NetworkPrefix
	}
	return ""
}

func (m *DHCPNetworkType) GetNetworkPrefixAllocator() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefixAllocator); ok {
		return x.NetworkPrefixAllocator
	}
	return nil
}

func (m *DHCPNetworkType) GetPools() []*DHCPPoolType {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *DHCPNetworkType) GetFirstAddress() *ves_io_schema4.Empty {
	if x, ok := m.GetGatewayChoice().(*DHCPNetworkType_FirstAddress); ok {
		return x.FirstAddress
	}
	return nil
}

func (m *DHCPNetworkType) GetLastAddress() *ves_io_schema4.Empty {
	if x, ok := m.GetGatewayChoice().(*DHCPNetworkType_LastAddress); ok {
		return x.LastAddress
	}
	return nil
}

func (m *DHCPNetworkType) GetDgwAddress() string {
	if x, ok := m.GetGatewayChoice().(*DHCPNetworkType_DgwAddress); ok {
		return x.DgwAddress
	}
	return ""
}

func (m *DHCPNetworkType) GetSameAsDgw() *ves_io_schema4.Empty {
	if x, ok := m.GetDnsChoice().(*DHCPNetworkType_SameAsDgw); ok {
		return x.SameAsDgw
	}
	return nil
}

func (m *DHCPNetworkType) GetDnsAddress() string {
	if x, ok := m.GetDnsChoice().(*DHCPNetworkType_DnsAddress); ok {
		return x.DnsAddress
	}
	return ""
}

func (m *DHCPNetworkType) GetPoolSettings() DHCPPoolSettingType {
	if m != nil {
		return m.PoolSettings
	}
	return INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DHCPNetworkType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DHCPNetworkType_OneofMarshaler, _DHCPNetworkType_OneofUnmarshaler, _DHCPNetworkType_OneofSizer, []interface{}{
		(*DHCPNetworkType_NetworkPrefix)(nil),
		(*DHCPNetworkType_NetworkPrefixAllocator)(nil),
		(*DHCPNetworkType_FirstAddress)(nil),
		(*DHCPNetworkType_LastAddress)(nil),
		(*DHCPNetworkType_DgwAddress)(nil),
		(*DHCPNetworkType_SameAsDgw)(nil),
		(*DHCPNetworkType_DnsAddress)(nil),
	}
}

func _DHCPNetworkType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DHCPNetworkType)
	// network_prefix_choice
	switch x := m.NetworkPrefixChoice.(type) {
	case *DHCPNetworkType_NetworkPrefix:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.NetworkPrefix)
	case *DHCPNetworkType_NetworkPrefixAllocator:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetworkPrefixAllocator); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DHCPNetworkType.NetworkPrefixChoice has unexpected type %T", x)
	}
	// gateway_choice
	switch x := m.GatewayChoice.(type) {
	case *DHCPNetworkType_FirstAddress:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FirstAddress); err != nil {
			return err
		}
	case *DHCPNetworkType_LastAddress:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LastAddress); err != nil {
			return err
		}
	case *DHCPNetworkType_DgwAddress:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DgwAddress)
	case nil:
	default:
		return fmt.Errorf("DHCPNetworkType.GatewayChoice has unexpected type %T", x)
	}
	// dns_choice
	switch x := m.DnsChoice.(type) {
	case *DHCPNetworkType_SameAsDgw:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SameAsDgw); err != nil {
			return err
		}
	case *DHCPNetworkType_DnsAddress:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DnsAddress)
	case nil:
	default:
		return fmt.Errorf("DHCPNetworkType.DnsChoice has unexpected type %T", x)
	}
	return nil
}

func _DHCPNetworkType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DHCPNetworkType)
	switch tag {
	case 2: // network_prefix_choice.network_prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.NetworkPrefixChoice = &DHCPNetworkType_NetworkPrefix{x}
		return true, err
	case 3: // network_prefix_choice.network_prefix_allocator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.NetworkPrefixChoice = &DHCPNetworkType_NetworkPrefixAllocator{msg}
		return true, err
	case 6: // gateway_choice.first_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GatewayChoice = &DHCPNetworkType_FirstAddress{msg}
		return true, err
	case 7: // gateway_choice.last_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GatewayChoice = &DHCPNetworkType_LastAddress{msg}
		return true, err
	case 8: // gateway_choice.dgw_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.GatewayChoice = &DHCPNetworkType_DgwAddress{x}
		return true, err
	case 10: // dns_choice.same_as_dgw
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DnsChoice = &DHCPNetworkType_SameAsDgw{msg}
		return true, err
	case 11: // dns_choice.dns_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DnsChoice = &DHCPNetworkType_DnsAddress{x}
		return true, err
	default:
		return false, nil
	}
}

func _DHCPNetworkType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DHCPNetworkType)
	// network_prefix_choice
	switch x := m.NetworkPrefixChoice.(type) {
	case *DHCPNetworkType_NetworkPrefix:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.NetworkPrefix)))
		n += len(x.NetworkPrefix)
	case *DHCPNetworkType_NetworkPrefixAllocator:
		s := proto.Size(x.NetworkPrefixAllocator)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// gateway_choice
	switch x := m.GatewayChoice.(type) {
	case *DHCPNetworkType_FirstAddress:
		s := proto.Size(x.FirstAddress)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DHCPNetworkType_LastAddress:
		s := proto.Size(x.LastAddress)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DHCPNetworkType_DgwAddress:
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DgwAddress)))
		n += len(x.DgwAddress)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dns_choice
	switch x := m.DnsChoice.(type) {
	case *DHCPNetworkType_SameAsDgw:
		s := proto.Size(x.SameAsDgw)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DHCPNetworkType_DnsAddress:
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DnsAddress)))
		n += len(x.DnsAddress)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Interface IP Assignments
//
// x-displayName: "Interface IP Assignments"
// Map of Interface IP assignments per node
type DHCPInterfaceIPType struct {
	// Site:Node to IP mapping
	//
	// x-displayName: "Site:Node to IP Mapping"
	// Map of Site:Node to IP address.
	InterfaceIpMap map[string]string `protobuf:"bytes,1,rep,name=interface_ip_map,json=interfaceIpMap" json:"interface_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DHCPInterfaceIPType) Reset()                    { *m = DHCPInterfaceIPType{} }
func (*DHCPInterfaceIPType) ProtoMessage()               {}
func (*DHCPInterfaceIPType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *DHCPInterfaceIPType) GetInterfaceIpMap() map[string]string {
	if m != nil {
		return m.InterfaceIpMap
	}
	return nil
}

type DHCPServerParametersType struct {
	// DHCP Networks
	//
	// x-displayName: "DHCP Networks"
	// x-required
	// List of networks from which DHCP server can allocate ip addresses
	DhcpNetworks []*DHCPNetworkType `protobuf:"bytes,1,rep,name=dhcp_networks,json=dhcpNetworks" json:"dhcp_networks,omitempty"`
	// Interface IP(s)
	//
	// x-displayName: "Select Interface Addressing"
	// x-required
	// Specify how interfaces on each node are assigned local address
	//
	// Types that are valid to be assigned to InterfacesAddressingChoice:
	//	*DHCPServerParametersType_AutomaticFromStart
	//	*DHCPServerParametersType_AutomaticFromEnd
	//	*DHCPServerParametersType_InterfaceIpMap
	InterfacesAddressingChoice isDHCPServerParametersType_InterfacesAddressingChoice `protobuf_oneof:"interfaces_addressing_choice"`
	// Fixed IP Assignments
	//
	// x-displayName: "Fixed MAC address to IP Assignments"
	// Fixed MAC address to ip assignments, Key: Mac address, Value: IP Address
	FixedIpMap map[string]string `protobuf:"bytes,6,rep,name=fixed_ip_map,json=fixedIpMap" json:"fixed_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Option 82 Tag
	//
	// x-displayName: "Option 82 Tag"
	// x-example: "network_red"
	// Optional tag that can be given to this configuration
	DhcpOption82Tag string `protobuf:"bytes,7,opt,name=dhcp_option82_tag,json=dhcpOption82Tag,proto3" json:"dhcp_option82_tag,omitempty"`
}

func (m *DHCPServerParametersType) Reset()                    { *m = DHCPServerParametersType{} }
func (*DHCPServerParametersType) ProtoMessage()               {}
func (*DHCPServerParametersType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

type isDHCPServerParametersType_InterfacesAddressingChoice interface {
	isDHCPServerParametersType_InterfacesAddressingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DHCPServerParametersType_AutomaticFromStart struct {
	AutomaticFromStart *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=automatic_from_start,json=automaticFromStart,oneof"`
}
type DHCPServerParametersType_AutomaticFromEnd struct {
	AutomaticFromEnd *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=automatic_from_end,json=automaticFromEnd,oneof"`
}
type DHCPServerParametersType_InterfaceIpMap struct {
	InterfaceIpMap *DHCPInterfaceIPType `protobuf:"bytes,5,opt,name=interface_ip_map,json=interfaceIpMap,oneof"`
}

func (*DHCPServerParametersType_AutomaticFromStart) isDHCPServerParametersType_InterfacesAddressingChoice() {
}
func (*DHCPServerParametersType_AutomaticFromEnd) isDHCPServerParametersType_InterfacesAddressingChoice() {
}
func (*DHCPServerParametersType_InterfaceIpMap) isDHCPServerParametersType_InterfacesAddressingChoice() {
}

func (m *DHCPServerParametersType) GetInterfacesAddressingChoice() isDHCPServerParametersType_InterfacesAddressingChoice {
	if m != nil {
		return m.InterfacesAddressingChoice
	}
	return nil
}

func (m *DHCPServerParametersType) GetDhcpNetworks() []*DHCPNetworkType {
	if m != nil {
		return m.DhcpNetworks
	}
	return nil
}

func (m *DHCPServerParametersType) GetAutomaticFromStart() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_AutomaticFromStart); ok {
		return x.AutomaticFromStart
	}
	return nil
}

func (m *DHCPServerParametersType) GetAutomaticFromEnd() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_AutomaticFromEnd); ok {
		return x.AutomaticFromEnd
	}
	return nil
}

func (m *DHCPServerParametersType) GetInterfaceIpMap() *DHCPInterfaceIPType {
	if x, ok := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_InterfaceIpMap); ok {
		return x.InterfaceIpMap
	}
	return nil
}

func (m *DHCPServerParametersType) GetFixedIpMap() map[string]string {
	if m != nil {
		return m.FixedIpMap
	}
	return nil
}

func (m *DHCPServerParametersType) GetDhcpOption82Tag() string {
	if m != nil {
		return m.DhcpOption82Tag
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DHCPServerParametersType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DHCPServerParametersType_OneofMarshaler, _DHCPServerParametersType_OneofUnmarshaler, _DHCPServerParametersType_OneofSizer, []interface{}{
		(*DHCPServerParametersType_AutomaticFromStart)(nil),
		(*DHCPServerParametersType_AutomaticFromEnd)(nil),
		(*DHCPServerParametersType_InterfaceIpMap)(nil),
	}
}

func _DHCPServerParametersType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DHCPServerParametersType)
	// interfaces_addressing_choice
	switch x := m.InterfacesAddressingChoice.(type) {
	case *DHCPServerParametersType_AutomaticFromStart:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AutomaticFromStart); err != nil {
			return err
		}
	case *DHCPServerParametersType_AutomaticFromEnd:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AutomaticFromEnd); err != nil {
			return err
		}
	case *DHCPServerParametersType_InterfaceIpMap:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InterfaceIpMap); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DHCPServerParametersType.InterfacesAddressingChoice has unexpected type %T", x)
	}
	return nil
}

func _DHCPServerParametersType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DHCPServerParametersType)
	switch tag {
	case 3: // interfaces_addressing_choice.automatic_from_start
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfacesAddressingChoice = &DHCPServerParametersType_AutomaticFromStart{msg}
		return true, err
	case 4: // interfaces_addressing_choice.automatic_from_end
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfacesAddressingChoice = &DHCPServerParametersType_AutomaticFromEnd{msg}
		return true, err
	case 5: // interfaces_addressing_choice.interface_ip_map
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DHCPInterfaceIPType)
		err := b.DecodeMessage(msg)
		m.InterfacesAddressingChoice = &DHCPServerParametersType_InterfaceIpMap{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DHCPServerParametersType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DHCPServerParametersType)
	// interfaces_addressing_choice
	switch x := m.InterfacesAddressingChoice.(type) {
	case *DHCPServerParametersType_AutomaticFromStart:
		s := proto.Size(x.AutomaticFromStart)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DHCPServerParametersType_AutomaticFromEnd:
		s := proto.Size(x.AutomaticFromEnd)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DHCPServerParametersType_InterfaceIpMap:
		s := proto.Size(x.InterfaceIpMap)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Static IP Parameters
//
// x-displayName: "Node: Static IP Parameters"
// Configure Static IP parameters for a node
type StaticIpParametersNodeType struct {
	// Default Gateway
	//
	// x-displayName: "IP address/Prefix Length"
	// x-example: "192.168.20.1/24"
	// x-required
	// IPv4 address of the interface and prefix length
	IpAddress string `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// x-example: "192.168.20.1"
	// IPv4 address of the default gateway.
	DefaultGw string `protobuf:"bytes,2,opt,name=default_gw,json=defaultGw,proto3" json:"default_gw,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// x-example: "192.168.20.1"
	// IPv4 address of the DNS server
	DnsServer string `protobuf:"bytes,3,opt,name=dns_server,json=dnsServer,proto3" json:"dns_server,omitempty"`
}

func (m *StaticIpParametersNodeType) Reset()                    { *m = StaticIpParametersNodeType{} }
func (*StaticIpParametersNodeType) ProtoMessage()               {}
func (*StaticIpParametersNodeType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *StaticIpParametersNodeType) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *StaticIpParametersNodeType) GetDefaultGw() string {
	if m != nil {
		return m.DefaultGw
	}
	return ""
}

func (m *StaticIpParametersNodeType) GetDnsServer() string {
	if m != nil {
		return m.DnsServer
	}
	return ""
}

// Static IP Parameters
//
// x-displayName: "Cluster: Static IP Parameters"
// Configure Static IP parameters  for cluster
type StaticIpParametersClusterType struct {
	// Site:Node to IP mapping
	//
	// x-displayName: "Node to IP Mapping"
	// Map of Node to Static ip configuration value, Key:Node, Value:IP Address
	InterfaceIpMap map[string]*StaticIpParametersNodeType `protobuf:"bytes,1,rep,name=interface_ip_map,json=interfaceIpMap" json:"interface_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StaticIpParametersClusterType) Reset()      { *m = StaticIpParametersClusterType{} }
func (*StaticIpParametersClusterType) ProtoMessage() {}
func (*StaticIpParametersClusterType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{8}
}

func (m *StaticIpParametersClusterType) GetInterfaceIpMap() map[string]*StaticIpParametersNodeType {
	if m != nil {
		return m.InterfaceIpMap
	}
	return nil
}

// Static IP Parameters
//
// x-displayName: "Fleet: Static IP Parameters"
// Configure Static IP parameters
type StaticIpParametersFleetType struct {
	// Fleet
	//
	// x-displayName: "Fleet address allocator"
	// Static IP configuration for the fleet
	NetworkPrefixAllocator *ves_io_schema_views.ObjectRefType `protobuf:"bytes,1,opt,name=network_prefix_allocator,json=networkPrefixAllocator" json:"network_prefix_allocator,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// x-example: "192.168.20.1"
	// IPv4 address offset of the default gateway, prefix len is used to calculate offset
	DefaultGw string `protobuf:"bytes,2,opt,name=default_gw,json=defaultGw,proto3" json:"default_gw,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// x-example: "192.168.20.1"
	// IPv4 address offset of the DNS server, prefix len is used to calculate offset
	DnsServer string `protobuf:"bytes,3,opt,name=dns_server,json=dnsServer,proto3" json:"dns_server,omitempty"`
}

func (m *StaticIpParametersFleetType) Reset()      { *m = StaticIpParametersFleetType{} }
func (*StaticIpParametersFleetType) ProtoMessage() {}
func (*StaticIpParametersFleetType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{9}
}

func (m *StaticIpParametersFleetType) GetNetworkPrefixAllocator() *ves_io_schema_views.ObjectRefType {
	if m != nil {
		return m.NetworkPrefixAllocator
	}
	return nil
}

func (m *StaticIpParametersFleetType) GetDefaultGw() string {
	if m != nil {
		return m.DefaultGw
	}
	return ""
}

func (m *StaticIpParametersFleetType) GetDnsServer() string {
	if m != nil {
		return m.DnsServer
	}
	return ""
}

// Static IP Parameters
//
// x-displayName: "Static IP Parameters"
// Configure Static IP parameters
type StaticIPParametersType struct {
	// Network Prefix choice
	//
	// x-displayName: "Select Static IP Configuration"
	// x-required
	// Select static ip configuration for Node/Cluster/Fleet
	//
	// Types that are valid to be assigned to NetworkPrefixChoice:
	//	*StaticIPParametersType_NodeStaticIp
	//	*StaticIPParametersType_ClusterStaticIp
	//	*StaticIPParametersType_FleetStaticIp
	NetworkPrefixChoice isStaticIPParametersType_NetworkPrefixChoice `protobuf_oneof:"network_prefix_choice"`
}

func (m *StaticIPParametersType) Reset()                    { *m = StaticIPParametersType{} }
func (*StaticIPParametersType) ProtoMessage()               {}
func (*StaticIPParametersType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

type isStaticIPParametersType_NetworkPrefixChoice interface {
	isStaticIPParametersType_NetworkPrefixChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StaticIPParametersType_NodeStaticIp struct {
	NodeStaticIp *StaticIpParametersNodeType `protobuf:"bytes,2,opt,name=node_static_ip,json=nodeStaticIp,oneof"`
}
type StaticIPParametersType_ClusterStaticIp struct {
	ClusterStaticIp *StaticIpParametersClusterType `protobuf:"bytes,3,opt,name=cluster_static_ip,json=clusterStaticIp,oneof"`
}
type StaticIPParametersType_FleetStaticIp struct {
	FleetStaticIp *StaticIpParametersFleetType `protobuf:"bytes,4,opt,name=fleet_static_ip,json=fleetStaticIp,oneof"`
}

func (*StaticIPParametersType_NodeStaticIp) isStaticIPParametersType_NetworkPrefixChoice()    {}
func (*StaticIPParametersType_ClusterStaticIp) isStaticIPParametersType_NetworkPrefixChoice() {}
func (*StaticIPParametersType_FleetStaticIp) isStaticIPParametersType_NetworkPrefixChoice()   {}

func (m *StaticIPParametersType) GetNetworkPrefixChoice() isStaticIPParametersType_NetworkPrefixChoice {
	if m != nil {
		return m.NetworkPrefixChoice
	}
	return nil
}

func (m *StaticIPParametersType) GetNodeStaticIp() *StaticIpParametersNodeType {
	if x, ok := m.GetNetworkPrefixChoice().(*StaticIPParametersType_NodeStaticIp); ok {
		return x.NodeStaticIp
	}
	return nil
}

func (m *StaticIPParametersType) GetClusterStaticIp() *StaticIpParametersClusterType {
	if x, ok := m.GetNetworkPrefixChoice().(*StaticIPParametersType_ClusterStaticIp); ok {
		return x.ClusterStaticIp
	}
	return nil
}

func (m *StaticIPParametersType) GetFleetStaticIp() *StaticIpParametersFleetType {
	if x, ok := m.GetNetworkPrefixChoice().(*StaticIPParametersType_FleetStaticIp); ok {
		return x.FleetStaticIp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StaticIPParametersType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StaticIPParametersType_OneofMarshaler, _StaticIPParametersType_OneofUnmarshaler, _StaticIPParametersType_OneofSizer, []interface{}{
		(*StaticIPParametersType_NodeStaticIp)(nil),
		(*StaticIPParametersType_ClusterStaticIp)(nil),
		(*StaticIPParametersType_FleetStaticIp)(nil),
	}
}

func _StaticIPParametersType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StaticIPParametersType)
	// network_prefix_choice
	switch x := m.NetworkPrefixChoice.(type) {
	case *StaticIPParametersType_NodeStaticIp:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NodeStaticIp); err != nil {
			return err
		}
	case *StaticIPParametersType_ClusterStaticIp:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClusterStaticIp); err != nil {
			return err
		}
	case *StaticIPParametersType_FleetStaticIp:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FleetStaticIp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StaticIPParametersType.NetworkPrefixChoice has unexpected type %T", x)
	}
	return nil
}

func _StaticIPParametersType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StaticIPParametersType)
	switch tag {
	case 2: // network_prefix_choice.node_static_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StaticIpParametersNodeType)
		err := b.DecodeMessage(msg)
		m.NetworkPrefixChoice = &StaticIPParametersType_NodeStaticIp{msg}
		return true, err
	case 3: // network_prefix_choice.cluster_static_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StaticIpParametersClusterType)
		err := b.DecodeMessage(msg)
		m.NetworkPrefixChoice = &StaticIPParametersType_ClusterStaticIp{msg}
		return true, err
	case 4: // network_prefix_choice.fleet_static_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StaticIpParametersFleetType)
		err := b.DecodeMessage(msg)
		m.NetworkPrefixChoice = &StaticIPParametersType_FleetStaticIp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StaticIPParametersType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StaticIPParametersType)
	// network_prefix_choice
	switch x := m.NetworkPrefixChoice.(type) {
	case *StaticIPParametersType_NodeStaticIp:
		s := proto.Size(x.NodeStaticIp)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StaticIPParametersType_ClusterStaticIp:
		s := proto.Size(x.ClusterStaticIp)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StaticIPParametersType_FleetStaticIp:
		s := proto.Size(x.FleetStaticIp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Dedicated Interface
//
// x-displayName: "Dedicated Interface"
// Dedicated Interface Configuration
type DedicatedInterfaceType struct {
	// Device
	//
	// x-displayName: "Interface Device"
	// x-example: "eth0"
	// x-required
	// Name of the device for which interface is configured. Use wwan0 for 4G/LTE.
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Select Node Independent or Node Specific Interface
	//
	// x-displayName: "Select Configuration for Cluster or Specific Node"
	// x-required
	// Cluster configuration will apply to a given device on all nodes of the site.
	// Node configuration will apply to a given device on a specific node.
	//
	// Types that are valid to be assigned to NodeChoice:
	//	*DedicatedInterfaceType_Cluster
	//	*DedicatedInterfaceType_Node
	NodeChoice isDedicatedInterfaceType_NodeChoice `protobuf_oneof:"node_choice"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,8,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in outside network
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,9,opt,name=priority,proto3" json:"priority,omitempty"`
	// Primary Interface
	//
	// x-displayName: "Select Primary Interface"
	// x-required
	// Select if this interface is primary interface, only one interface can be primary in a given fleet
	//
	// Types that are valid to be assigned to PrimaryChoice:
	//	*DedicatedInterfaceType_NotPrimary
	//	*DedicatedInterfaceType_IsPrimary
	PrimaryChoice isDedicatedInterfaceType_PrimaryChoice `protobuf_oneof:"primary_choice"`
}

func (m *DedicatedInterfaceType) Reset()                    { *m = DedicatedInterfaceType{} }
func (*DedicatedInterfaceType) ProtoMessage()               {}
func (*DedicatedInterfaceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

type isDedicatedInterfaceType_NodeChoice interface {
	isDedicatedInterfaceType_NodeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isDedicatedInterfaceType_PrimaryChoice interface {
	isDedicatedInterfaceType_PrimaryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DedicatedInterfaceType_Cluster struct {
	Cluster *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=cluster,oneof"`
}
type DedicatedInterfaceType_Node struct {
	Node string `protobuf:"bytes,4,opt,name=node,proto3,oneof"`
}
type DedicatedInterfaceType_NotPrimary struct {
	NotPrimary *ves_io_schema4.Empty `protobuf:"bytes,11,opt,name=not_primary,json=notPrimary,oneof"`
}
type DedicatedInterfaceType_IsPrimary struct {
	IsPrimary *ves_io_schema4.Empty `protobuf:"bytes,12,opt,name=is_primary,json=isPrimary,oneof"`
}

func (*DedicatedInterfaceType_Cluster) isDedicatedInterfaceType_NodeChoice()       {}
func (*DedicatedInterfaceType_Node) isDedicatedInterfaceType_NodeChoice()          {}
func (*DedicatedInterfaceType_NotPrimary) isDedicatedInterfaceType_PrimaryChoice() {}
func (*DedicatedInterfaceType_IsPrimary) isDedicatedInterfaceType_PrimaryChoice()  {}

func (m *DedicatedInterfaceType) GetNodeChoice() isDedicatedInterfaceType_NodeChoice {
	if m != nil {
		return m.NodeChoice
	}
	return nil
}
func (m *DedicatedInterfaceType) GetPrimaryChoice() isDedicatedInterfaceType_PrimaryChoice {
	if m != nil {
		return m.PrimaryChoice
	}
	return nil
}

func (m *DedicatedInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *DedicatedInterfaceType) GetCluster() *ves_io_schema4.Empty {
	if x, ok := m.GetNodeChoice().(*DedicatedInterfaceType_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *DedicatedInterfaceType) GetNode() string {
	if x, ok := m.GetNodeChoice().(*DedicatedInterfaceType_Node); ok {
		return x.Node
	}
	return ""
}

func (m *DedicatedInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *DedicatedInterfaceType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *DedicatedInterfaceType) GetNotPrimary() *ves_io_schema4.Empty {
	if x, ok := m.GetPrimaryChoice().(*DedicatedInterfaceType_NotPrimary); ok {
		return x.NotPrimary
	}
	return nil
}

func (m *DedicatedInterfaceType) GetIsPrimary() *ves_io_schema4.Empty {
	if x, ok := m.GetPrimaryChoice().(*DedicatedInterfaceType_IsPrimary); ok {
		return x.IsPrimary
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DedicatedInterfaceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DedicatedInterfaceType_OneofMarshaler, _DedicatedInterfaceType_OneofUnmarshaler, _DedicatedInterfaceType_OneofSizer, []interface{}{
		(*DedicatedInterfaceType_Cluster)(nil),
		(*DedicatedInterfaceType_Node)(nil),
		(*DedicatedInterfaceType_NotPrimary)(nil),
		(*DedicatedInterfaceType_IsPrimary)(nil),
	}
}

func _DedicatedInterfaceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DedicatedInterfaceType)
	// node_choice
	switch x := m.NodeChoice.(type) {
	case *DedicatedInterfaceType_Cluster:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cluster); err != nil {
			return err
		}
	case *DedicatedInterfaceType_Node:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Node)
	case nil:
	default:
		return fmt.Errorf("DedicatedInterfaceType.NodeChoice has unexpected type %T", x)
	}
	// primary_choice
	switch x := m.PrimaryChoice.(type) {
	case *DedicatedInterfaceType_NotPrimary:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NotPrimary); err != nil {
			return err
		}
	case *DedicatedInterfaceType_IsPrimary:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IsPrimary); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DedicatedInterfaceType.PrimaryChoice has unexpected type %T", x)
	}
	return nil
}

func _DedicatedInterfaceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DedicatedInterfaceType)
	switch tag {
	case 3: // node_choice.cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NodeChoice = &DedicatedInterfaceType_Cluster{msg}
		return true, err
	case 4: // node_choice.node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.NodeChoice = &DedicatedInterfaceType_Node{x}
		return true, err
	case 11: // primary_choice.not_primary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PrimaryChoice = &DedicatedInterfaceType_NotPrimary{msg}
		return true, err
	case 12: // primary_choice.is_primary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PrimaryChoice = &DedicatedInterfaceType_IsPrimary{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DedicatedInterfaceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DedicatedInterfaceType)
	// node_choice
	switch x := m.NodeChoice.(type) {
	case *DedicatedInterfaceType_Cluster:
		s := proto.Size(x.Cluster)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DedicatedInterfaceType_Node:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Node)))
		n += len(x.Node)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// primary_choice
	switch x := m.PrimaryChoice.(type) {
	case *DedicatedInterfaceType_NotPrimary:
		s := proto.Size(x.NotPrimary)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DedicatedInterfaceType_IsPrimary:
		s := proto.Size(x.IsPrimary)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Dedicated Management Interface
//
// x-displayName: "Dedicated Management Interface"
// Dedicated Interface Configuration
type DedicatedManagementInterfaceType struct {
	// Device
	//
	// x-displayName: "Interface Device"
	// x-example: "eth0"
	// x-required
	// Name of the device for which interface is configured
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Select Node Independent or Node Specific Interface
	//
	// x-displayName: "Select Configuration for Cluster or Specific Node"
	// x-required
	// Cluster configuration will apply to a given device on all nodes of the site.
	// Node configuration will apply to a given device on a specific node.
	//
	// Types that are valid to be assigned to NodeChoice:
	//	*DedicatedManagementInterfaceType_Cluster
	//	*DedicatedManagementInterfaceType_Node
	NodeChoice isDedicatedManagementInterfaceType_NodeChoice `protobuf_oneof:"node_choice"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,5,opt,name=mtu,proto3" json:"mtu,omitempty"`
}

func (m *DedicatedManagementInterfaceType) Reset()      { *m = DedicatedManagementInterfaceType{} }
func (*DedicatedManagementInterfaceType) ProtoMessage() {}
func (*DedicatedManagementInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{12}
}

type isDedicatedManagementInterfaceType_NodeChoice interface {
	isDedicatedManagementInterfaceType_NodeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DedicatedManagementInterfaceType_Cluster struct {
	Cluster *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=cluster,oneof"`
}
type DedicatedManagementInterfaceType_Node struct {
	Node string `protobuf:"bytes,4,opt,name=node,proto3,oneof"`
}

func (*DedicatedManagementInterfaceType_Cluster) isDedicatedManagementInterfaceType_NodeChoice() {}
func (*DedicatedManagementInterfaceType_Node) isDedicatedManagementInterfaceType_NodeChoice()    {}

func (m *DedicatedManagementInterfaceType) GetNodeChoice() isDedicatedManagementInterfaceType_NodeChoice {
	if m != nil {
		return m.NodeChoice
	}
	return nil
}

func (m *DedicatedManagementInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *DedicatedManagementInterfaceType) GetCluster() *ves_io_schema4.Empty {
	if x, ok := m.GetNodeChoice().(*DedicatedManagementInterfaceType_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *DedicatedManagementInterfaceType) GetNode() string {
	if x, ok := m.GetNodeChoice().(*DedicatedManagementInterfaceType_Node); ok {
		return x.Node
	}
	return ""
}

func (m *DedicatedManagementInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DedicatedManagementInterfaceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DedicatedManagementInterfaceType_OneofMarshaler, _DedicatedManagementInterfaceType_OneofUnmarshaler, _DedicatedManagementInterfaceType_OneofSizer, []interface{}{
		(*DedicatedManagementInterfaceType_Cluster)(nil),
		(*DedicatedManagementInterfaceType_Node)(nil),
	}
}

func _DedicatedManagementInterfaceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DedicatedManagementInterfaceType)
	// node_choice
	switch x := m.NodeChoice.(type) {
	case *DedicatedManagementInterfaceType_Cluster:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cluster); err != nil {
			return err
		}
	case *DedicatedManagementInterfaceType_Node:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Node)
	case nil:
	default:
		return fmt.Errorf("DedicatedManagementInterfaceType.NodeChoice has unexpected type %T", x)
	}
	return nil
}

func _DedicatedManagementInterfaceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DedicatedManagementInterfaceType)
	switch tag {
	case 3: // node_choice.cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NodeChoice = &DedicatedManagementInterfaceType_Cluster{msg}
		return true, err
	case 4: // node_choice.node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.NodeChoice = &DedicatedManagementInterfaceType_Node{x}
		return true, err
	default:
		return false, nil
	}
}

func _DedicatedManagementInterfaceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DedicatedManagementInterfaceType)
	// node_choice
	switch x := m.NodeChoice.(type) {
	case *DedicatedManagementInterfaceType_Cluster:
		s := proto.Size(x.Cluster)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DedicatedManagementInterfaceType_Node:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Node)))
		n += len(x.Node)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Ethernet Interface
//
// x-displayName: "Ethernet Interface"
// Ethernet Interface Configuration
type EthernetInterfaceType struct {
	// Device
	//
	// x-displayName: "Ethernet Device"
	// x-example: "eth0"
	// x-required
	// Interface configuration for the ethernet device
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Select Node Independent or Node Specific Interface
	//
	// x-displayName: "Select Configuration for Cluster or Specific Node"
	// x-required
	// Cluster configuration will apply to a given device on all nodes of the site.
	// Node configuration will apply to a given device on a given node.
	//
	// Types that are valid to be assigned to NodeChoice:
	//	*EthernetInterfaceType_Cluster
	//	*EthernetInterfaceType_Node
	NodeChoice isEthernetInterfaceType_NodeChoice `protobuf_oneof:"node_choice"`
	// Select Untagged or VLAN tagged
	//
	// x-displayName: "Select Untagged or VLAN tagged"
	// x-required
	// Select if this interface is VLAN tagged or untagged
	//
	// Types that are valid to be assigned to VlanChoice:
	//	*EthernetInterfaceType_Untagged
	//	*EthernetInterfaceType_VlanId
	VlanChoice isEthernetInterfaceType_VlanChoice `protobuf_oneof:"vlan_choice"`
	// Interface Addressing
	//
	// x-displayName: "Select Interface Address Method"
	// x-required
	// Select how ip address will be assigned to Interface
	//
	// Types that are valid to be assigned to AddressChoice:
	//	*EthernetInterfaceType_DhcpClient
	//	*EthernetInterfaceType_DhcpServer
	//	*EthernetInterfaceType_StaticIp
	AddressChoice isEthernetInterfaceType_AddressChoice `protobuf_oneof:"address_choice"`
	// Network for this Interface
	//
	// x-displayName: "Select Virtual Network"
	// x-required
	// Select virtual network of this interface
	//
	// Types that are valid to be assigned to NetworkChoice:
	//	*EthernetInterfaceType_SiteLocalNetwork
	//	*EthernetInterfaceType_SiteLocalInsideNetwork
	//	*EthernetInterfaceType_InsideNetwork
	//	*EthernetInterfaceType_StorageNetwork
	NetworkChoice isEthernetInterfaceType_NetworkChoice `protobuf_oneof:"network_choice"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,16,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in outside network
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,17,opt,name=priority,proto3" json:"priority,omitempty"`
	// Primary Interface
	//
	// x-displayName: "Select Primary Interface"
	// x-required
	// Select if this interface is primary interface, only one interface can be primary in a given fleet
	//
	// Types that are valid to be assigned to PrimaryChoice:
	//	*EthernetInterfaceType_NotPrimary
	//	*EthernetInterfaceType_IsPrimary
	PrimaryChoice isEthernetInterfaceType_PrimaryChoice `protobuf_oneof:"primary_choice"`
}

func (m *EthernetInterfaceType) Reset()                    { *m = EthernetInterfaceType{} }
func (*EthernetInterfaceType) ProtoMessage()               {}
func (*EthernetInterfaceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

type isEthernetInterfaceType_NodeChoice interface {
	isEthernetInterfaceType_NodeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_VlanChoice interface {
	isEthernetInterfaceType_VlanChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_AddressChoice interface {
	isEthernetInterfaceType_AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_NetworkChoice interface {
	isEthernetInterfaceType_NetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_PrimaryChoice interface {
	isEthernetInterfaceType_PrimaryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type EthernetInterfaceType_Cluster struct {
	Cluster *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=cluster,oneof"`
}
type EthernetInterfaceType_Node struct {
	Node string `protobuf:"bytes,4,opt,name=node,proto3,oneof"`
}
type EthernetInterfaceType_Untagged struct {
	Untagged *ves_io_schema4.Empty `protobuf:"bytes,6,opt,name=untagged,oneof"`
}
type EthernetInterfaceType_VlanId struct {
	VlanId uint32 `protobuf:"varint,7,opt,name=vlan_id,json=vlanId,proto3,oneof"`
}
type EthernetInterfaceType_DhcpClient struct {
	DhcpClient *ves_io_schema4.Empty `protobuf:"bytes,9,opt,name=dhcp_client,json=dhcpClient,oneof"`
}
type EthernetInterfaceType_DhcpServer struct {
	DhcpServer *DHCPServerParametersType `protobuf:"bytes,10,opt,name=dhcp_server,json=dhcpServer,oneof"`
}
type EthernetInterfaceType_StaticIp struct {
	StaticIp *StaticIPParametersType `protobuf:"bytes,11,opt,name=static_ip,json=staticIp,oneof"`
}
type EthernetInterfaceType_SiteLocalNetwork struct {
	SiteLocalNetwork *ves_io_schema4.Empty `protobuf:"bytes,13,opt,name=site_local_network,json=siteLocalNetwork,oneof"`
}
type EthernetInterfaceType_SiteLocalInsideNetwork struct {
	SiteLocalInsideNetwork *ves_io_schema4.Empty `protobuf:"bytes,14,opt,name=site_local_inside_network,json=siteLocalInsideNetwork,oneof"`
}
type EthernetInterfaceType_InsideNetwork struct {
	InsideNetwork *ves_io_schema_views.ObjectRefType `protobuf:"bytes,15,opt,name=inside_network,json=insideNetwork,oneof"`
}
type EthernetInterfaceType_StorageNetwork struct {
	StorageNetwork *ves_io_schema4.Empty `protobuf:"bytes,21,opt,name=storage_network,json=storageNetwork,oneof"`
}
type EthernetInterfaceType_NotPrimary struct {
	NotPrimary *ves_io_schema4.Empty `protobuf:"bytes,19,opt,name=not_primary,json=notPrimary,oneof"`
}
type EthernetInterfaceType_IsPrimary struct {
	IsPrimary *ves_io_schema4.Empty `protobuf:"bytes,20,opt,name=is_primary,json=isPrimary,oneof"`
}

func (*EthernetInterfaceType_Cluster) isEthernetInterfaceType_NodeChoice()                   {}
func (*EthernetInterfaceType_Node) isEthernetInterfaceType_NodeChoice()                      {}
func (*EthernetInterfaceType_Untagged) isEthernetInterfaceType_VlanChoice()                  {}
func (*EthernetInterfaceType_VlanId) isEthernetInterfaceType_VlanChoice()                    {}
func (*EthernetInterfaceType_DhcpClient) isEthernetInterfaceType_AddressChoice()             {}
func (*EthernetInterfaceType_DhcpServer) isEthernetInterfaceType_AddressChoice()             {}
func (*EthernetInterfaceType_StaticIp) isEthernetInterfaceType_AddressChoice()               {}
func (*EthernetInterfaceType_SiteLocalNetwork) isEthernetInterfaceType_NetworkChoice()       {}
func (*EthernetInterfaceType_SiteLocalInsideNetwork) isEthernetInterfaceType_NetworkChoice() {}
func (*EthernetInterfaceType_InsideNetwork) isEthernetInterfaceType_NetworkChoice()          {}
func (*EthernetInterfaceType_StorageNetwork) isEthernetInterfaceType_NetworkChoice()         {}
func (*EthernetInterfaceType_NotPrimary) isEthernetInterfaceType_PrimaryChoice()             {}
func (*EthernetInterfaceType_IsPrimary) isEthernetInterfaceType_PrimaryChoice()              {}

func (m *EthernetInterfaceType) GetNodeChoice() isEthernetInterfaceType_NodeChoice {
	if m != nil {
		return m.NodeChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetVlanChoice() isEthernetInterfaceType_VlanChoice {
	if m != nil {
		return m.VlanChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetAddressChoice() isEthernetInterfaceType_AddressChoice {
	if m != nil {
		return m.AddressChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetNetworkChoice() isEthernetInterfaceType_NetworkChoice {
	if m != nil {
		return m.NetworkChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetPrimaryChoice() isEthernetInterfaceType_PrimaryChoice {
	if m != nil {
		return m.PrimaryChoice
	}
	return nil
}

func (m *EthernetInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *EthernetInterfaceType) GetCluster() *ves_io_schema4.Empty {
	if x, ok := m.GetNodeChoice().(*EthernetInterfaceType_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *EthernetInterfaceType) GetNode() string {
	if x, ok := m.GetNodeChoice().(*EthernetInterfaceType_Node); ok {
		return x.Node
	}
	return ""
}

func (m *EthernetInterfaceType) GetUntagged() *ves_io_schema4.Empty {
	if x, ok := m.GetVlanChoice().(*EthernetInterfaceType_Untagged); ok {
		return x.Untagged
	}
	return nil
}

func (m *EthernetInterfaceType) GetVlanId() uint32 {
	if x, ok := m.GetVlanChoice().(*EthernetInterfaceType_VlanId); ok {
		return x.VlanId
	}
	return 0
}

func (m *EthernetInterfaceType) GetDhcpClient() *ves_io_schema4.Empty {
	if x, ok := m.GetAddressChoice().(*EthernetInterfaceType_DhcpClient); ok {
		return x.DhcpClient
	}
	return nil
}

func (m *EthernetInterfaceType) GetDhcpServer() *DHCPServerParametersType {
	if x, ok := m.GetAddressChoice().(*EthernetInterfaceType_DhcpServer); ok {
		return x.DhcpServer
	}
	return nil
}

func (m *EthernetInterfaceType) GetStaticIp() *StaticIPParametersType {
	if x, ok := m.GetAddressChoice().(*EthernetInterfaceType_StaticIp); ok {
		return x.StaticIp
	}
	return nil
}

func (m *EthernetInterfaceType) GetSiteLocalNetwork() *ves_io_schema4.Empty {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_SiteLocalNetwork); ok {
		return x.SiteLocalNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetSiteLocalInsideNetwork() *ves_io_schema4.Empty {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_SiteLocalInsideNetwork); ok {
		return x.SiteLocalInsideNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetInsideNetwork() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_InsideNetwork); ok {
		return x.InsideNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetStorageNetwork() *ves_io_schema4.Empty {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_StorageNetwork); ok {
		return x.StorageNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *EthernetInterfaceType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *EthernetInterfaceType) GetNotPrimary() *ves_io_schema4.Empty {
	if x, ok := m.GetPrimaryChoice().(*EthernetInterfaceType_NotPrimary); ok {
		return x.NotPrimary
	}
	return nil
}

func (m *EthernetInterfaceType) GetIsPrimary() *ves_io_schema4.Empty {
	if x, ok := m.GetPrimaryChoice().(*EthernetInterfaceType_IsPrimary); ok {
		return x.IsPrimary
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EthernetInterfaceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EthernetInterfaceType_OneofMarshaler, _EthernetInterfaceType_OneofUnmarshaler, _EthernetInterfaceType_OneofSizer, []interface{}{
		(*EthernetInterfaceType_Cluster)(nil),
		(*EthernetInterfaceType_Node)(nil),
		(*EthernetInterfaceType_Untagged)(nil),
		(*EthernetInterfaceType_VlanId)(nil),
		(*EthernetInterfaceType_DhcpClient)(nil),
		(*EthernetInterfaceType_DhcpServer)(nil),
		(*EthernetInterfaceType_StaticIp)(nil),
		(*EthernetInterfaceType_SiteLocalNetwork)(nil),
		(*EthernetInterfaceType_SiteLocalInsideNetwork)(nil),
		(*EthernetInterfaceType_InsideNetwork)(nil),
		(*EthernetInterfaceType_StorageNetwork)(nil),
		(*EthernetInterfaceType_NotPrimary)(nil),
		(*EthernetInterfaceType_IsPrimary)(nil),
	}
}

func _EthernetInterfaceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EthernetInterfaceType)
	// node_choice
	switch x := m.NodeChoice.(type) {
	case *EthernetInterfaceType_Cluster:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cluster); err != nil {
			return err
		}
	case *EthernetInterfaceType_Node:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Node)
	case nil:
	default:
		return fmt.Errorf("EthernetInterfaceType.NodeChoice has unexpected type %T", x)
	}
	// vlan_choice
	switch x := m.VlanChoice.(type) {
	case *EthernetInterfaceType_Untagged:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Untagged); err != nil {
			return err
		}
	case *EthernetInterfaceType_VlanId:
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.VlanId))
	case nil:
	default:
		return fmt.Errorf("EthernetInterfaceType.VlanChoice has unexpected type %T", x)
	}
	// address_choice
	switch x := m.AddressChoice.(type) {
	case *EthernetInterfaceType_DhcpClient:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DhcpClient); err != nil {
			return err
		}
	case *EthernetInterfaceType_DhcpServer:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DhcpServer); err != nil {
			return err
		}
	case *EthernetInterfaceType_StaticIp:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StaticIp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EthernetInterfaceType.AddressChoice has unexpected type %T", x)
	}
	// network_choice
	switch x := m.NetworkChoice.(type) {
	case *EthernetInterfaceType_SiteLocalNetwork:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SiteLocalNetwork); err != nil {
			return err
		}
	case *EthernetInterfaceType_SiteLocalInsideNetwork:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SiteLocalInsideNetwork); err != nil {
			return err
		}
	case *EthernetInterfaceType_InsideNetwork:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InsideNetwork); err != nil {
			return err
		}
	case *EthernetInterfaceType_StorageNetwork:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageNetwork); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EthernetInterfaceType.NetworkChoice has unexpected type %T", x)
	}
	// primary_choice
	switch x := m.PrimaryChoice.(type) {
	case *EthernetInterfaceType_NotPrimary:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NotPrimary); err != nil {
			return err
		}
	case *EthernetInterfaceType_IsPrimary:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IsPrimary); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EthernetInterfaceType.PrimaryChoice has unexpected type %T", x)
	}
	return nil
}

func _EthernetInterfaceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EthernetInterfaceType)
	switch tag {
	case 3: // node_choice.cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NodeChoice = &EthernetInterfaceType_Cluster{msg}
		return true, err
	case 4: // node_choice.node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.NodeChoice = &EthernetInterfaceType_Node{x}
		return true, err
	case 6: // vlan_choice.untagged
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.VlanChoice = &EthernetInterfaceType_Untagged{msg}
		return true, err
	case 7: // vlan_choice.vlan_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.VlanChoice = &EthernetInterfaceType_VlanId{uint32(x)}
		return true, err
	case 9: // address_choice.dhcp_client
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.AddressChoice = &EthernetInterfaceType_DhcpClient{msg}
		return true, err
	case 10: // address_choice.dhcp_server
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DHCPServerParametersType)
		err := b.DecodeMessage(msg)
		m.AddressChoice = &EthernetInterfaceType_DhcpServer{msg}
		return true, err
	case 11: // address_choice.static_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StaticIPParametersType)
		err := b.DecodeMessage(msg)
		m.AddressChoice = &EthernetInterfaceType_StaticIp{msg}
		return true, err
	case 13: // network_choice.site_local_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NetworkChoice = &EthernetInterfaceType_SiteLocalNetwork{msg}
		return true, err
	case 14: // network_choice.site_local_inside_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NetworkChoice = &EthernetInterfaceType_SiteLocalInsideNetwork{msg}
		return true, err
	case 15: // network_choice.inside_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.NetworkChoice = &EthernetInterfaceType_InsideNetwork{msg}
		return true, err
	case 21: // network_choice.storage_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NetworkChoice = &EthernetInterfaceType_StorageNetwork{msg}
		return true, err
	case 19: // primary_choice.not_primary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PrimaryChoice = &EthernetInterfaceType_NotPrimary{msg}
		return true, err
	case 20: // primary_choice.is_primary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.PrimaryChoice = &EthernetInterfaceType_IsPrimary{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EthernetInterfaceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EthernetInterfaceType)
	// node_choice
	switch x := m.NodeChoice.(type) {
	case *EthernetInterfaceType_Cluster:
		s := proto.Size(x.Cluster)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EthernetInterfaceType_Node:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Node)))
		n += len(x.Node)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// vlan_choice
	switch x := m.VlanChoice.(type) {
	case *EthernetInterfaceType_Untagged:
		s := proto.Size(x.Untagged)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EthernetInterfaceType_VlanId:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.VlanId))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// address_choice
	switch x := m.AddressChoice.(type) {
	case *EthernetInterfaceType_DhcpClient:
		s := proto.Size(x.DhcpClient)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EthernetInterfaceType_DhcpServer:
		s := proto.Size(x.DhcpServer)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EthernetInterfaceType_StaticIp:
		s := proto.Size(x.StaticIp)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// network_choice
	switch x := m.NetworkChoice.(type) {
	case *EthernetInterfaceType_SiteLocalNetwork:
		s := proto.Size(x.SiteLocalNetwork)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EthernetInterfaceType_SiteLocalInsideNetwork:
		s := proto.Size(x.SiteLocalInsideNetwork)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EthernetInterfaceType_InsideNetwork:
		s := proto.Size(x.InsideNetwork)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EthernetInterfaceType_StorageNetwork:
		s := proto.Size(x.StorageNetwork)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// primary_choice
	switch x := m.PrimaryChoice.(type) {
	case *EthernetInterfaceType_NotPrimary:
		s := proto.Size(x.NotPrimary)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EthernetInterfaceType_IsPrimary:
		s := proto.Size(x.IsPrimary)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Tunnel Interface
//
// x-displayName: "Tunnel Interface"
// Tunnel Interface Configuration
type TunnelInterfaceType struct {
	// Select Node Independent or Node Specific Interface
	//
	// x-displayName: "Select Configuration for Cluster or Specific Node"
	// x-required
	// Cluster configuration will apply to a given device on all nodes of the Site.
	// Node configuration will apply to a device on a specific node.
	//
	// Types that are valid to be assigned to NodeChoice:
	//	*TunnelInterfaceType_Cluster
	//	*TunnelInterfaceType_Node
	NodeChoice isTunnelInterfaceType_NodeChoice `protobuf_oneof:"node_choice"`
	// Tunnel
	//
	// x-displayName: "Tunnel"
	// Tunnel Configuration for this Interface
	Tunnel *ves_io_schema_views.ObjectRefType `protobuf:"bytes,4,opt,name=tunnel" json:"tunnel,omitempty"`
	// Static IP
	//
	// x-displayName: "Static IP"
	// Interface IP is configured statically
	StaticIp *StaticIPParametersType `protobuf:"bytes,5,opt,name=static_ip,json=staticIp" json:"static_ip,omitempty"`
	// Network for this Interface
	//
	// x-displayName: "Select Virtual Network"
	// x-required
	// Select virtual network of this interface
	//
	// Types that are valid to be assigned to NetworkChoice:
	//	*TunnelInterfaceType_SiteLocalNetwork
	//	*TunnelInterfaceType_SiteLocalInsideNetwork
	//	*TunnelInterfaceType_InsideNetwork
	NetworkChoice isTunnelInterfaceType_NetworkChoice `protobuf_oneof:"network_choice"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,10,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in outside network
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,11,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *TunnelInterfaceType) Reset()                    { *m = TunnelInterfaceType{} }
func (*TunnelInterfaceType) ProtoMessage()               {}
func (*TunnelInterfaceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

type isTunnelInterfaceType_NodeChoice interface {
	isTunnelInterfaceType_NodeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTunnelInterfaceType_NetworkChoice interface {
	isTunnelInterfaceType_NetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TunnelInterfaceType_Cluster struct {
	Cluster *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=cluster,oneof"`
}
type TunnelInterfaceType_Node struct {
	Node string `protobuf:"bytes,3,opt,name=node,proto3,oneof"`
}
type TunnelInterfaceType_SiteLocalNetwork struct {
	SiteLocalNetwork *ves_io_schema4.Empty `protobuf:"bytes,7,opt,name=site_local_network,json=siteLocalNetwork,oneof"`
}
type TunnelInterfaceType_SiteLocalInsideNetwork struct {
	SiteLocalInsideNetwork *ves_io_schema4.Empty `protobuf:"bytes,8,opt,name=site_local_inside_network,json=siteLocalInsideNetwork,oneof"`
}
type TunnelInterfaceType_InsideNetwork struct {
	InsideNetwork *ves_io_schema_views.ObjectRefType `protobuf:"bytes,9,opt,name=inside_network,json=insideNetwork,oneof"`
}

func (*TunnelInterfaceType_Cluster) isTunnelInterfaceType_NodeChoice()                   {}
func (*TunnelInterfaceType_Node) isTunnelInterfaceType_NodeChoice()                      {}
func (*TunnelInterfaceType_SiteLocalNetwork) isTunnelInterfaceType_NetworkChoice()       {}
func (*TunnelInterfaceType_SiteLocalInsideNetwork) isTunnelInterfaceType_NetworkChoice() {}
func (*TunnelInterfaceType_InsideNetwork) isTunnelInterfaceType_NetworkChoice()          {}

func (m *TunnelInterfaceType) GetNodeChoice() isTunnelInterfaceType_NodeChoice {
	if m != nil {
		return m.NodeChoice
	}
	return nil
}
func (m *TunnelInterfaceType) GetNetworkChoice() isTunnelInterfaceType_NetworkChoice {
	if m != nil {
		return m.NetworkChoice
	}
	return nil
}

func (m *TunnelInterfaceType) GetCluster() *ves_io_schema4.Empty {
	if x, ok := m.GetNodeChoice().(*TunnelInterfaceType_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *TunnelInterfaceType) GetNode() string {
	if x, ok := m.GetNodeChoice().(*TunnelInterfaceType_Node); ok {
		return x.Node
	}
	return ""
}

func (m *TunnelInterfaceType) GetTunnel() *ves_io_schema_views.ObjectRefType {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

func (m *TunnelInterfaceType) GetStaticIp() *StaticIPParametersType {
	if m != nil {
		return m.StaticIp
	}
	return nil
}

func (m *TunnelInterfaceType) GetSiteLocalNetwork() *ves_io_schema4.Empty {
	if x, ok := m.GetNetworkChoice().(*TunnelInterfaceType_SiteLocalNetwork); ok {
		return x.SiteLocalNetwork
	}
	return nil
}

func (m *TunnelInterfaceType) GetSiteLocalInsideNetwork() *ves_io_schema4.Empty {
	if x, ok := m.GetNetworkChoice().(*TunnelInterfaceType_SiteLocalInsideNetwork); ok {
		return x.SiteLocalInsideNetwork
	}
	return nil
}

func (m *TunnelInterfaceType) GetInsideNetwork() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetNetworkChoice().(*TunnelInterfaceType_InsideNetwork); ok {
		return x.InsideNetwork
	}
	return nil
}

func (m *TunnelInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *TunnelInterfaceType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TunnelInterfaceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TunnelInterfaceType_OneofMarshaler, _TunnelInterfaceType_OneofUnmarshaler, _TunnelInterfaceType_OneofSizer, []interface{}{
		(*TunnelInterfaceType_Cluster)(nil),
		(*TunnelInterfaceType_Node)(nil),
		(*TunnelInterfaceType_SiteLocalNetwork)(nil),
		(*TunnelInterfaceType_SiteLocalInsideNetwork)(nil),
		(*TunnelInterfaceType_InsideNetwork)(nil),
	}
}

func _TunnelInterfaceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TunnelInterfaceType)
	// node_choice
	switch x := m.NodeChoice.(type) {
	case *TunnelInterfaceType_Cluster:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cluster); err != nil {
			return err
		}
	case *TunnelInterfaceType_Node:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Node)
	case nil:
	default:
		return fmt.Errorf("TunnelInterfaceType.NodeChoice has unexpected type %T", x)
	}
	// network_choice
	switch x := m.NetworkChoice.(type) {
	case *TunnelInterfaceType_SiteLocalNetwork:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SiteLocalNetwork); err != nil {
			return err
		}
	case *TunnelInterfaceType_SiteLocalInsideNetwork:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SiteLocalInsideNetwork); err != nil {
			return err
		}
	case *TunnelInterfaceType_InsideNetwork:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InsideNetwork); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TunnelInterfaceType.NetworkChoice has unexpected type %T", x)
	}
	return nil
}

func _TunnelInterfaceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TunnelInterfaceType)
	switch tag {
	case 2: // node_choice.cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NodeChoice = &TunnelInterfaceType_Cluster{msg}
		return true, err
	case 3: // node_choice.node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.NodeChoice = &TunnelInterfaceType_Node{x}
		return true, err
	case 7: // network_choice.site_local_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NetworkChoice = &TunnelInterfaceType_SiteLocalNetwork{msg}
		return true, err
	case 8: // network_choice.site_local_inside_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NetworkChoice = &TunnelInterfaceType_SiteLocalInsideNetwork{msg}
		return true, err
	case 9: // network_choice.inside_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.NetworkChoice = &TunnelInterfaceType_InsideNetwork{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TunnelInterfaceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TunnelInterfaceType)
	// node_choice
	switch x := m.NodeChoice.(type) {
	case *TunnelInterfaceType_Cluster:
		s := proto.Size(x.Cluster)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TunnelInterfaceType_Node:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Node)))
		n += len(x.Node)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// network_choice
	switch x := m.NetworkChoice.(type) {
	case *TunnelInterfaceType_SiteLocalNetwork:
		s := proto.Size(x.SiteLocalNetwork)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TunnelInterfaceType_SiteLocalInsideNetwork:
		s := proto.Size(x.SiteLocalInsideNetwork)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TunnelInterfaceType_InsideNetwork:
		s := proto.Size(x.InsideNetwork)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Legacy Configuration
//
// x-displayName: "Legacy Configuration
// Legacy Interface Configuration
type LegacyInterfaceType struct {
	// Interface Type
	//
	// x-displayName: "Type"
	// x-required
	// Specifies the type of interface (ethernet, vlan, lacp etc)
	Type NetworkInterfaceType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceType" json:"type,omitempty"`
	// Mtu
	//
	// x-displayName: "MTU"
	// x-example: "0"
	// Maximum Transfer Unit (Max packet length) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Virtual Network
	//
	// x-displayName: "Virtual Network"
	// Virtual-network for the interface
	// This is optional and can contain at most one entry
	VirtualNetwork []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=virtual_network,json=virtualNetwork" json:"virtual_network,omitempty"`
	// DHCP Client
	//
	// x-displayName: "Enable DHCP Client"
	// x-required
	// Enable DHCP based address assignment for this interface.
	DhcpAddress NetworkInterfaceDHCP `protobuf:"varint,5,opt,name=dhcp_address,json=dhcpAddress,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCP" json:"dhcp_address,omitempty"`
	// Static IP
	//
	// x-displayName: "Static IP"
	// If DHCP server is enabled, configures the subnet to be used for IP allocation.
	StaticAddresses []*ves_io_schema3.Ipv4SubnetType `protobuf:"bytes,6,rep,name=static_addresses,json=staticAddresses" json:"static_addresses,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// Configures how default gateway is derived for the subnet static addresses
	DefaultGateway *NetworkInterfaceDFGW `protobuf:"bytes,7,opt,name=default_gateway,json=defaultGateway" json:"default_gateway,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// Configures how DNS server is derived for the subnet in static addresses
	DNSServer *NetworkInterfaceDNS `protobuf:"bytes,8,opt,name=DNS_server,json=DNSServer" json:"DNS_server,omitempty"`
	// DHCP Server
	//
	// x-displayName: "Enable DHCP Server"
	// x-required
	// Behave as DHCP server for subnet configured in static addresses.
	DHCPServer NetworkInterfaceDHCPServer `protobuf:"varint,9,opt,name=DHCP_server,json=DHCPServer,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCPServer" json:"DHCP_server,omitempty"`
	// Vlan Tagging
	//
	// x-displayName: "Enable VLAN Tagging"
	// x-example: "NETWORK_INTERFACE_VLAN_TAGGING_DISABLE"
	// Enable/Disable VLAN tagging on this interface.
	// Must be enabled for VLAN interfaces
	VlanTagging NetworkInterfaceVLANTagging `protobuf:"varint,10,opt,name=vlan_tagging,json=vlanTagging,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceVLANTagging" json:"vlan_tagging,omitempty"`
	// Device Name
	//
	// x-displayName: "Device Name"
	// x-example: "value"
	// x-required
	// Name of the physical network interface device  which this network interface represents.
	DeviceName string `protobuf:"bytes,11,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	// Vlan Tag
	//
	// x-displayName: "VLAN Tag"
	// x-example: "0"
	// Vlan tag of the interface, valid only if VLAN tagging is enabled
	// when vlan_tagging is enabled, value must be between 1 - 4094
	VlanTag uint32 `protobuf:"varint,13,opt,name=vlan_tag,json=vlanTag,proto3" json:"vlan_tag,omitempty"`
	// Tunnel
	//
	// x-displayName: "Tunnel"
	// When interface is created as TUNNEL type, then reference to tunnel is specified here
	Tunnel *NetworkInterfaceTunnel `protobuf:"bytes,14,opt,name=tunnel" json:"tunnel,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in the fleet object
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,15,opt,name=priority,proto3" json:"priority,omitempty"`
	// Address Allocator
	//
	// x-displayName: "Address Allocator"
	// Reference to an address allocator for the network interface. When set, the allocator is used to
	// allocate a subnet for the interface and an address from the subnet is set on the interface.
	AddressAllocator []*ves_io_schema4.ObjectRefType `protobuf:"bytes,16,rep,name=address_allocator,json=addressAllocator" json:"address_allocator,omitempty"`
}

func (m *LegacyInterfaceType) Reset()                    { *m = LegacyInterfaceType{} }
func (*LegacyInterfaceType) ProtoMessage()               {}
func (*LegacyInterfaceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *LegacyInterfaceType) GetType() NetworkInterfaceType {
	if m != nil {
		return m.Type
	}
	return NETWORK_INTERFACE_ETHERNET
}

func (m *LegacyInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *LegacyInterfaceType) GetVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.VirtualNetwork
	}
	return nil
}

func (m *LegacyInterfaceType) GetDhcpAddress() NetworkInterfaceDHCP {
	if m != nil {
		return m.DhcpAddress
	}
	return NETWORK_INTERFACE_DHCP_DISABLE
}

func (m *LegacyInterfaceType) GetStaticAddresses() []*ves_io_schema3.Ipv4SubnetType {
	if m != nil {
		return m.StaticAddresses
	}
	return nil
}

func (m *LegacyInterfaceType) GetDefaultGateway() *NetworkInterfaceDFGW {
	if m != nil {
		return m.DefaultGateway
	}
	return nil
}

func (m *LegacyInterfaceType) GetDNSServer() *NetworkInterfaceDNS {
	if m != nil {
		return m.DNSServer
	}
	return nil
}

func (m *LegacyInterfaceType) GetDHCPServer() NetworkInterfaceDHCPServer {
	if m != nil {
		return m.DHCPServer
	}
	return NETWORK_INTERFACE_DHCP_SERVER_DISABLE
}

func (m *LegacyInterfaceType) GetVlanTagging() NetworkInterfaceVLANTagging {
	if m != nil {
		return m.VlanTagging
	}
	return NETWORK_INTERFACE_VLAN_TAGGING_DISABLE
}

func (m *LegacyInterfaceType) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *LegacyInterfaceType) GetVlanTag() uint32 {
	if m != nil {
		return m.VlanTag
	}
	return 0
}

func (m *LegacyInterfaceType) GetTunnel() *NetworkInterfaceTunnel {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

func (m *LegacyInterfaceType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *LegacyInterfaceType) GetAddressAllocator() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.AddressAllocator
	}
	return nil
}

// Global Specification
//
// x-displayName: "Global Specification"
// Network Interface specification
type GlobalSpecType struct {
	// Interface Type
	//
	// x-displayName: "Type"
	// x-required
	// Specifies the type of interface (ethernet, vlan, lacp etc)
	Type NetworkInterfaceType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceType" json:"type,omitempty"`
	// Mtu
	//
	// x-displayName: "MTU"
	// x-example: "0"
	// Maximum Transfer Unit (Max packet length) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Virtual Network
	//
	// x-displayName: "Virtual Network"
	// Virtual-network for the interface
	// This is optional and can contain at most one entry
	VirtualNetwork []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=virtual_network,json=virtualNetwork" json:"virtual_network,omitempty"`
	// DHCP Client
	//
	// x-displayName: "Enable DHCP Client"
	// x-required
	// Enable DHCP based address assignment for this interface.
	DhcpAddress NetworkInterfaceDHCP `protobuf:"varint,5,opt,name=dhcp_address,json=dhcpAddress,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCP" json:"dhcp_address,omitempty"`
	// Static IP
	//
	// x-displayName: "Static IP"
	// If DHCP server is enabled, configures the subnet to be used for IP allocation.
	StaticAddresses []*ves_io_schema3.Ipv4SubnetType `protobuf:"bytes,6,rep,name=static_addresses,json=staticAddresses" json:"static_addresses,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// Configures how default gateway is derived for the subnet static addresses
	DefaultGateway *NetworkInterfaceDFGW `protobuf:"bytes,7,opt,name=default_gateway,json=defaultGateway" json:"default_gateway,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// Configures how DNS server is derived for the subnet in static addresses
	DNSServer *NetworkInterfaceDNS `protobuf:"bytes,8,opt,name=DNS_server,json=DNSServer" json:"DNS_server,omitempty"`
	// DHCP Server
	//
	// x-displayName: "Enable DHCP Server"
	// x-required
	// Behave as DHCP server for subnet configured in static addresses.
	DHCPServer NetworkInterfaceDHCPServer `protobuf:"varint,9,opt,name=DHCP_server,json=DHCPServer,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCPServer" json:"DHCP_server,omitempty"`
	// Vlan Tagging
	//
	// x-displayName: "Enable VLAN Tagging"
	// x-example: "NETWORK_INTERFACE_VLAN_TAGGING_DISABLE"
	// Enable/Disable VLAN tagging on this interface.
	// Must be enabled for VLAN interfaces
	VlanTagging NetworkInterfaceVLANTagging `protobuf:"varint,10,opt,name=vlan_tagging,json=vlanTagging,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceVLANTagging" json:"vlan_tagging,omitempty"`
	// Device Name
	//
	// x-displayName: "Device Name"
	// x-example: "value"
	// x-required
	// Name of the physical network interface device  which this network interface represents.
	DeviceName string `protobuf:"bytes,11,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	// Parent Network Interface
	//
	// x-displayName: "Parent Interface"
	// When interface is created as VLAN tagged sub-interface or LACP (interface type),
	// then reference to parent network interface is specified here. Valid only for subinterfaces
	ParentNetworkInterface []*ves_io_schema4.ObjectRefType `protobuf:"bytes,12,rep,name=parent_network_interface,json=parentNetworkInterface" json:"parent_network_interface,omitempty"`
	// Vlan Tag
	//
	// x-displayName: "VLAN Tag"
	// x-example: "0"
	// Vlan tag of the interface, valid only if VLAN tagging is enabled
	// when vlan_tagging is enabled, value must be between 1 - 4094
	VlanTag uint32 `protobuf:"varint,13,opt,name=vlan_tag,json=vlanTag,proto3" json:"vlan_tag,omitempty"`
	// Tunnel
	//
	// x-displayName: "Tunnel"
	// When interface is created as TUNNEL type, then reference to tunnel is specified here
	Tunnel *NetworkInterfaceTunnel `protobuf:"bytes,14,opt,name=tunnel" json:"tunnel,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in the fleet object
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,15,opt,name=priority,proto3" json:"priority,omitempty"`
	// Address Allocator
	//
	// x-displayName: "Address Allocator"
	// Reference to an address allocator for the network interface. When set, the allocator is used to
	// allocate a subnet for the interface and an address from the subnet is set on the interface.
	AddressAllocator []*ves_io_schema4.ObjectRefType `protobuf:"bytes,16,rep,name=address_allocator,json=addressAllocator" json:"address_allocator,omitempty"`
	// DHCP server parameters
	//
	// x-displayName: "DHCP server parameters"
	// DHCP server parameters
	DhcpServerParams *DHCPServerParametersType `protobuf:"bytes,28,opt,name=dhcp_server_params,json=dhcpServerParams" json:"dhcp_server_params,omitempty"`
	// Network Config Method
	//
	// x-displayName: "Network Config Method"
	// Configuration to pick network from interface or fleet
	NetworkConfig InterfaceNetworkType `protobuf:"varint,29,opt,name=network_config,json=networkConfig,proto3,enum=ves.io.schema.network_interface.InterfaceNetworkType" json:"network_config,omitempty"`
	// Site:Node to IP mapping
	//
	// x-displayName: "Site:Node to IP Mapping"
	// Map of Site:Node to IP address offset. Key:Node, Value:Map
	// Value of 10.1.1.5 with network prefix 24, offset is 0.0.0.5
	InterfaceIpMap map[string]string `protobuf:"bytes,30,rep,name=interface_ip_map,json=interfaceIpMap" json:"interface_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Primary Interface
	//
	// x-displayName: "Primary Interface"
	// This interface is primary interface
	IsPrimary bool `protobuf:"varint,31,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
	// Interface Config Type
	//
	// x-displayName: "Interface Config Type"
	// x-required
	// Select the interface configuration type
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*GlobalSpecType_DedicatedInterface
	//	*GlobalSpecType_EthernetInterface
	//	*GlobalSpecType_TunnelInterface
	//	*GlobalSpecType_Legacy
	//	*GlobalSpecType_DedicatedManagementInterface
	InterfaceChoice isGlobalSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

type isGlobalSpecType_InterfaceChoice interface {
	isGlobalSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_DedicatedInterface struct {
	DedicatedInterface *ves_io_schema4.Empty `protobuf:"bytes,1001,opt,name=dedicated_interface,json=dedicatedInterface,oneof"`
}
type GlobalSpecType_EthernetInterface struct {
	EthernetInterface *ves_io_schema4.Empty `protobuf:"bytes,1002,opt,name=ethernet_interface,json=ethernetInterface,oneof"`
}
type GlobalSpecType_TunnelInterface struct {
	TunnelInterface *ves_io_schema4.Empty `protobuf:"bytes,1003,opt,name=tunnel_interface,json=tunnelInterface,oneof"`
}
type GlobalSpecType_Legacy struct {
	Legacy *ves_io_schema4.Empty `protobuf:"bytes,1004,opt,name=legacy,oneof"`
}
type GlobalSpecType_DedicatedManagementInterface struct {
	DedicatedManagementInterface *ves_io_schema4.Empty `protobuf:"bytes,1005,opt,name=dedicated_management_interface,json=dedicatedManagementInterface,oneof"`
}

func (*GlobalSpecType_DedicatedInterface) isGlobalSpecType_InterfaceChoice()           {}
func (*GlobalSpecType_EthernetInterface) isGlobalSpecType_InterfaceChoice()            {}
func (*GlobalSpecType_TunnelInterface) isGlobalSpecType_InterfaceChoice()              {}
func (*GlobalSpecType_Legacy) isGlobalSpecType_InterfaceChoice()                       {}
func (*GlobalSpecType_DedicatedManagementInterface) isGlobalSpecType_InterfaceChoice() {}

func (m *GlobalSpecType) GetInterfaceChoice() isGlobalSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *GlobalSpecType) GetType() NetworkInterfaceType {
	if m != nil {
		return m.Type
	}
	return NETWORK_INTERFACE_ETHERNET
}

func (m *GlobalSpecType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *GlobalSpecType) GetVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.VirtualNetwork
	}
	return nil
}

func (m *GlobalSpecType) GetDhcpAddress() NetworkInterfaceDHCP {
	if m != nil {
		return m.DhcpAddress
	}
	return NETWORK_INTERFACE_DHCP_DISABLE
}

func (m *GlobalSpecType) GetStaticAddresses() []*ves_io_schema3.Ipv4SubnetType {
	if m != nil {
		return m.StaticAddresses
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultGateway() *NetworkInterfaceDFGW {
	if m != nil {
		return m.DefaultGateway
	}
	return nil
}

func (m *GlobalSpecType) GetDNSServer() *NetworkInterfaceDNS {
	if m != nil {
		return m.DNSServer
	}
	return nil
}

func (m *GlobalSpecType) GetDHCPServer() NetworkInterfaceDHCPServer {
	if m != nil {
		return m.DHCPServer
	}
	return NETWORK_INTERFACE_DHCP_SERVER_DISABLE
}

func (m *GlobalSpecType) GetVlanTagging() NetworkInterfaceVLANTagging {
	if m != nil {
		return m.VlanTagging
	}
	return NETWORK_INTERFACE_VLAN_TAGGING_DISABLE
}

func (m *GlobalSpecType) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *GlobalSpecType) GetParentNetworkInterface() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.ParentNetworkInterface
	}
	return nil
}

func (m *GlobalSpecType) GetVlanTag() uint32 {
	if m != nil {
		return m.VlanTag
	}
	return 0
}

func (m *GlobalSpecType) GetTunnel() *NetworkInterfaceTunnel {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

func (m *GlobalSpecType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *GlobalSpecType) GetAddressAllocator() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.AddressAllocator
	}
	return nil
}

func (m *GlobalSpecType) GetDhcpServerParams() *DHCPServerParametersType {
	if m != nil {
		return m.DhcpServerParams
	}
	return nil
}

func (m *GlobalSpecType) GetNetworkConfig() InterfaceNetworkType {
	if m != nil {
		return m.NetworkConfig
	}
	return NETWORK_INTERFACE_NETWORK_REF
}

func (m *GlobalSpecType) GetInterfaceIpMap() map[string]string {
	if m != nil {
		return m.InterfaceIpMap
	}
	return nil
}

func (m *GlobalSpecType) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *GlobalSpecType) GetDedicatedInterface() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_DedicatedInterface); ok {
		return x.DedicatedInterface
	}
	return nil
}

func (m *GlobalSpecType) GetEthernetInterface() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_EthernetInterface); ok {
		return x.EthernetInterface
	}
	return nil
}

func (m *GlobalSpecType) GetTunnelInterface() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_TunnelInterface); ok {
		return x.TunnelInterface
	}
	return nil
}

func (m *GlobalSpecType) GetLegacy() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_Legacy); ok {
		return x.Legacy
	}
	return nil
}

func (m *GlobalSpecType) GetDedicatedManagementInterface() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_DedicatedManagementInterface); ok {
		return x.DedicatedManagementInterface
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_DedicatedInterface)(nil),
		(*GlobalSpecType_EthernetInterface)(nil),
		(*GlobalSpecType_TunnelInterface)(nil),
		(*GlobalSpecType_Legacy)(nil),
		(*GlobalSpecType_DedicatedManagementInterface)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *GlobalSpecType_DedicatedInterface:
		_ = b.EncodeVarint(1001<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DedicatedInterface); err != nil {
			return err
		}
	case *GlobalSpecType_EthernetInterface:
		_ = b.EncodeVarint(1002<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EthernetInterface); err != nil {
			return err
		}
	case *GlobalSpecType_TunnelInterface:
		_ = b.EncodeVarint(1003<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TunnelInterface); err != nil {
			return err
		}
	case *GlobalSpecType_Legacy:
		_ = b.EncodeVarint(1004<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Legacy); err != nil {
			return err
		}
	case *GlobalSpecType_DedicatedManagementInterface:
		_ = b.EncodeVarint(1005<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DedicatedManagementInterface); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.InterfaceChoice has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 1001: // interface_choice.dedicated_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GlobalSpecType_DedicatedInterface{msg}
		return true, err
	case 1002: // interface_choice.ethernet_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GlobalSpecType_EthernetInterface{msg}
		return true, err
	case 1003: // interface_choice.tunnel_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GlobalSpecType_TunnelInterface{msg}
		return true, err
	case 1004: // interface_choice.legacy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GlobalSpecType_Legacy{msg}
		return true, err
	case 1005: // interface_choice.dedicated_management_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GlobalSpecType_DedicatedManagementInterface{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *GlobalSpecType_DedicatedInterface:
		s := proto.Size(x.DedicatedInterface)
		n += proto.SizeVarint(1001<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_EthernetInterface:
		s := proto.Size(x.EthernetInterface)
		n += proto.SizeVarint(1002<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_TunnelInterface:
		s := proto.Size(x.TunnelInterface)
		n += proto.SizeVarint(1003<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_Legacy:
		s := proto.Size(x.Legacy)
		n += proto.SizeVarint(1004<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_DedicatedManagementInterface:
		s := proto.Size(x.DedicatedManagementInterface)
		n += proto.SizeVarint(1005<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create network interface
//
// x-displayName: "Specification"
// Network interface represents configuration of a network device.
// It is created by users in system namespace.
type CreateSpecType struct {
	// Interface Config Type
	//
	// x-displayName: "Interface Config Type"
	// x-required
	// Select the interface configuration type
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*CreateSpecType_DedicatedInterface
	//	*CreateSpecType_EthernetInterface
	//	*CreateSpecType_TunnelInterface
	//	*CreateSpecType_LegacyInterface
	//	*CreateSpecType_DedicatedManagementInterface
	InterfaceChoice isCreateSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

type isCreateSpecType_InterfaceChoice interface {
	isCreateSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_DedicatedInterface struct {
	DedicatedInterface *DedicatedInterfaceType `protobuf:"bytes,18,opt,name=dedicated_interface,json=dedicatedInterface,oneof"`
}
type CreateSpecType_EthernetInterface struct {
	EthernetInterface *EthernetInterfaceType `protobuf:"bytes,19,opt,name=ethernet_interface,json=ethernetInterface,oneof"`
}
type CreateSpecType_TunnelInterface struct {
	TunnelInterface *TunnelInterfaceType `protobuf:"bytes,20,opt,name=tunnel_interface,json=tunnelInterface,oneof"`
}
type CreateSpecType_LegacyInterface struct {
	LegacyInterface *LegacyInterfaceType `protobuf:"bytes,21,opt,name=legacy_interface,json=legacyInterface,oneof"`
}
type CreateSpecType_DedicatedManagementInterface struct {
	DedicatedManagementInterface *DedicatedManagementInterfaceType `protobuf:"bytes,22,opt,name=dedicated_management_interface,json=dedicatedManagementInterface,oneof"`
}

func (*CreateSpecType_DedicatedInterface) isCreateSpecType_InterfaceChoice()           {}
func (*CreateSpecType_EthernetInterface) isCreateSpecType_InterfaceChoice()            {}
func (*CreateSpecType_TunnelInterface) isCreateSpecType_InterfaceChoice()              {}
func (*CreateSpecType_LegacyInterface) isCreateSpecType_InterfaceChoice()              {}
func (*CreateSpecType_DedicatedManagementInterface) isCreateSpecType_InterfaceChoice() {}

func (m *CreateSpecType) GetInterfaceChoice() isCreateSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *CreateSpecType) GetDedicatedInterface() *DedicatedInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_DedicatedInterface); ok {
		return x.DedicatedInterface
	}
	return nil
}

func (m *CreateSpecType) GetEthernetInterface() *EthernetInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_EthernetInterface); ok {
		return x.EthernetInterface
	}
	return nil
}

func (m *CreateSpecType) GetTunnelInterface() *TunnelInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_TunnelInterface); ok {
		return x.TunnelInterface
	}
	return nil
}

func (m *CreateSpecType) GetLegacyInterface() *LegacyInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_LegacyInterface); ok {
		return x.LegacyInterface
	}
	return nil
}

func (m *CreateSpecType) GetDedicatedManagementInterface() *DedicatedManagementInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_DedicatedManagementInterface); ok {
		return x.DedicatedManagementInterface
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_DedicatedInterface)(nil),
		(*CreateSpecType_EthernetInterface)(nil),
		(*CreateSpecType_TunnelInterface)(nil),
		(*CreateSpecType_LegacyInterface)(nil),
		(*CreateSpecType_DedicatedManagementInterface)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *CreateSpecType_DedicatedInterface:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DedicatedInterface); err != nil {
			return err
		}
	case *CreateSpecType_EthernetInterface:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EthernetInterface); err != nil {
			return err
		}
	case *CreateSpecType_TunnelInterface:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TunnelInterface); err != nil {
			return err
		}
	case *CreateSpecType_LegacyInterface:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LegacyInterface); err != nil {
			return err
		}
	case *CreateSpecType_DedicatedManagementInterface:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DedicatedManagementInterface); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.InterfaceChoice has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 18: // interface_choice.dedicated_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DedicatedInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &CreateSpecType_DedicatedInterface{msg}
		return true, err
	case 19: // interface_choice.ethernet_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EthernetInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &CreateSpecType_EthernetInterface{msg}
		return true, err
	case 20: // interface_choice.tunnel_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TunnelInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &CreateSpecType_TunnelInterface{msg}
		return true, err
	case 21: // interface_choice.legacy_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LegacyInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &CreateSpecType_LegacyInterface{msg}
		return true, err
	case 22: // interface_choice.dedicated_management_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DedicatedManagementInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &CreateSpecType_DedicatedManagementInterface{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *CreateSpecType_DedicatedInterface:
		s := proto.Size(x.DedicatedInterface)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_EthernetInterface:
		s := proto.Size(x.EthernetInterface)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_TunnelInterface:
		s := proto.Size(x.TunnelInterface)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_LegacyInterface:
		s := proto.Size(x.LegacyInterface)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DedicatedManagementInterface:
		s := proto.Size(x.DedicatedManagementInterface)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace network interface
//
// x-displayName: "Specification"
// Network interface represents configuration of a network device.
// Replace network interface will replace the contents of given network interface object.
type ReplaceSpecType struct {
	// Interface Config Type
	//
	// x-displayName: "Interface Config Type"
	// x-required
	// Select the interface configuration type
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*ReplaceSpecType_DedicatedInterface
	//	*ReplaceSpecType_EthernetInterface
	//	*ReplaceSpecType_TunnelInterface
	//	*ReplaceSpecType_LegacyInterface
	//	*ReplaceSpecType_DedicatedManagementInterface
	InterfaceChoice isReplaceSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

type isReplaceSpecType_InterfaceChoice interface {
	isReplaceSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_DedicatedInterface struct {
	DedicatedInterface *DedicatedInterfaceType `protobuf:"bytes,18,opt,name=dedicated_interface,json=dedicatedInterface,oneof"`
}
type ReplaceSpecType_EthernetInterface struct {
	EthernetInterface *EthernetInterfaceType `protobuf:"bytes,19,opt,name=ethernet_interface,json=ethernetInterface,oneof"`
}
type ReplaceSpecType_TunnelInterface struct {
	TunnelInterface *TunnelInterfaceType `protobuf:"bytes,20,opt,name=tunnel_interface,json=tunnelInterface,oneof"`
}
type ReplaceSpecType_LegacyInterface struct {
	LegacyInterface *LegacyInterfaceType `protobuf:"bytes,21,opt,name=legacy_interface,json=legacyInterface,oneof"`
}
type ReplaceSpecType_DedicatedManagementInterface struct {
	DedicatedManagementInterface *DedicatedManagementInterfaceType `protobuf:"bytes,22,opt,name=dedicated_management_interface,json=dedicatedManagementInterface,oneof"`
}

func (*ReplaceSpecType_DedicatedInterface) isReplaceSpecType_InterfaceChoice()           {}
func (*ReplaceSpecType_EthernetInterface) isReplaceSpecType_InterfaceChoice()            {}
func (*ReplaceSpecType_TunnelInterface) isReplaceSpecType_InterfaceChoice()              {}
func (*ReplaceSpecType_LegacyInterface) isReplaceSpecType_InterfaceChoice()              {}
func (*ReplaceSpecType_DedicatedManagementInterface) isReplaceSpecType_InterfaceChoice() {}

func (m *ReplaceSpecType) GetInterfaceChoice() isReplaceSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetDedicatedInterface() *DedicatedInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_DedicatedInterface); ok {
		return x.DedicatedInterface
	}
	return nil
}

func (m *ReplaceSpecType) GetEthernetInterface() *EthernetInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_EthernetInterface); ok {
		return x.EthernetInterface
	}
	return nil
}

func (m *ReplaceSpecType) GetTunnelInterface() *TunnelInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_TunnelInterface); ok {
		return x.TunnelInterface
	}
	return nil
}

func (m *ReplaceSpecType) GetLegacyInterface() *LegacyInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_LegacyInterface); ok {
		return x.LegacyInterface
	}
	return nil
}

func (m *ReplaceSpecType) GetDedicatedManagementInterface() *DedicatedManagementInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_DedicatedManagementInterface); ok {
		return x.DedicatedManagementInterface
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_DedicatedInterface)(nil),
		(*ReplaceSpecType_EthernetInterface)(nil),
		(*ReplaceSpecType_TunnelInterface)(nil),
		(*ReplaceSpecType_LegacyInterface)(nil),
		(*ReplaceSpecType_DedicatedManagementInterface)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *ReplaceSpecType_DedicatedInterface:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DedicatedInterface); err != nil {
			return err
		}
	case *ReplaceSpecType_EthernetInterface:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EthernetInterface); err != nil {
			return err
		}
	case *ReplaceSpecType_TunnelInterface:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TunnelInterface); err != nil {
			return err
		}
	case *ReplaceSpecType_LegacyInterface:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LegacyInterface); err != nil {
			return err
		}
	case *ReplaceSpecType_DedicatedManagementInterface:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DedicatedManagementInterface); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.InterfaceChoice has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 18: // interface_choice.dedicated_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DedicatedInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &ReplaceSpecType_DedicatedInterface{msg}
		return true, err
	case 19: // interface_choice.ethernet_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EthernetInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &ReplaceSpecType_EthernetInterface{msg}
		return true, err
	case 20: // interface_choice.tunnel_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TunnelInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &ReplaceSpecType_TunnelInterface{msg}
		return true, err
	case 21: // interface_choice.legacy_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LegacyInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &ReplaceSpecType_LegacyInterface{msg}
		return true, err
	case 22: // interface_choice.dedicated_management_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DedicatedManagementInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &ReplaceSpecType_DedicatedManagementInterface{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *ReplaceSpecType_DedicatedInterface:
		s := proto.Size(x.DedicatedInterface)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_EthernetInterface:
		s := proto.Size(x.EthernetInterface)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_TunnelInterface:
		s := proto.Size(x.TunnelInterface)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_LegacyInterface:
		s := proto.Size(x.LegacyInterface)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DedicatedManagementInterface:
		s := proto.Size(x.DedicatedManagementInterface)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get network interface
//
// x-displayName: "Specification"
// Get network interface from system namespace
type GetSpecType struct {
	// Interface Config Type
	//
	// x-displayName: "Interface Config Type"
	// x-required
	// Select the interface configuration type
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*GetSpecType_DedicatedInterface
	//	*GetSpecType_EthernetInterface
	//	*GetSpecType_TunnelInterface
	//	*GetSpecType_LegacyInterface
	//	*GetSpecType_DedicatedManagementInterface
	InterfaceChoice isGetSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

type isGetSpecType_InterfaceChoice interface {
	isGetSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_DedicatedInterface struct {
	DedicatedInterface *DedicatedInterfaceType `protobuf:"bytes,18,opt,name=dedicated_interface,json=dedicatedInterface,oneof"`
}
type GetSpecType_EthernetInterface struct {
	EthernetInterface *EthernetInterfaceType `protobuf:"bytes,19,opt,name=ethernet_interface,json=ethernetInterface,oneof"`
}
type GetSpecType_TunnelInterface struct {
	TunnelInterface *TunnelInterfaceType `protobuf:"bytes,20,opt,name=tunnel_interface,json=tunnelInterface,oneof"`
}
type GetSpecType_LegacyInterface struct {
	LegacyInterface *LegacyInterfaceType `protobuf:"bytes,21,opt,name=legacy_interface,json=legacyInterface,oneof"`
}
type GetSpecType_DedicatedManagementInterface struct {
	DedicatedManagementInterface *DedicatedManagementInterfaceType `protobuf:"bytes,22,opt,name=dedicated_management_interface,json=dedicatedManagementInterface,oneof"`
}

func (*GetSpecType_DedicatedInterface) isGetSpecType_InterfaceChoice()           {}
func (*GetSpecType_EthernetInterface) isGetSpecType_InterfaceChoice()            {}
func (*GetSpecType_TunnelInterface) isGetSpecType_InterfaceChoice()              {}
func (*GetSpecType_LegacyInterface) isGetSpecType_InterfaceChoice()              {}
func (*GetSpecType_DedicatedManagementInterface) isGetSpecType_InterfaceChoice() {}

func (m *GetSpecType) GetInterfaceChoice() isGetSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *GetSpecType) GetDedicatedInterface() *DedicatedInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_DedicatedInterface); ok {
		return x.DedicatedInterface
	}
	return nil
}

func (m *GetSpecType) GetEthernetInterface() *EthernetInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_EthernetInterface); ok {
		return x.EthernetInterface
	}
	return nil
}

func (m *GetSpecType) GetTunnelInterface() *TunnelInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_TunnelInterface); ok {
		return x.TunnelInterface
	}
	return nil
}

func (m *GetSpecType) GetLegacyInterface() *LegacyInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_LegacyInterface); ok {
		return x.LegacyInterface
	}
	return nil
}

func (m *GetSpecType) GetDedicatedManagementInterface() *DedicatedManagementInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_DedicatedManagementInterface); ok {
		return x.DedicatedManagementInterface
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_DedicatedInterface)(nil),
		(*GetSpecType_EthernetInterface)(nil),
		(*GetSpecType_TunnelInterface)(nil),
		(*GetSpecType_LegacyInterface)(nil),
		(*GetSpecType_DedicatedManagementInterface)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *GetSpecType_DedicatedInterface:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DedicatedInterface); err != nil {
			return err
		}
	case *GetSpecType_EthernetInterface:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EthernetInterface); err != nil {
			return err
		}
	case *GetSpecType_TunnelInterface:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TunnelInterface); err != nil {
			return err
		}
	case *GetSpecType_LegacyInterface:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LegacyInterface); err != nil {
			return err
		}
	case *GetSpecType_DedicatedManagementInterface:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DedicatedManagementInterface); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.InterfaceChoice has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 18: // interface_choice.dedicated_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DedicatedInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GetSpecType_DedicatedInterface{msg}
		return true, err
	case 19: // interface_choice.ethernet_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EthernetInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GetSpecType_EthernetInterface{msg}
		return true, err
	case 20: // interface_choice.tunnel_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TunnelInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GetSpecType_TunnelInterface{msg}
		return true, err
	case 21: // interface_choice.legacy_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LegacyInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GetSpecType_LegacyInterface{msg}
		return true, err
	case 22: // interface_choice.dedicated_management_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DedicatedManagementInterfaceType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GetSpecType_DedicatedManagementInterface{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *GetSpecType_DedicatedInterface:
		s := proto.Size(x.DedicatedInterface)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_EthernetInterface:
		s := proto.Size(x.EthernetInterface)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_TunnelInterface:
		s := proto.Size(x.TunnelInterface)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_LegacyInterface:
		s := proto.Size(x.LegacyInterface)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DedicatedManagementInterface:
		s := proto.Size(x.DedicatedManagementInterface)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Network Interface Status
//
// x-displayName: "Status"
// Current Status of the Network interface
type NetworkInterfaceStatus struct {
	// Interface State
	//
	// x-displayName: "Interface State"
	// Current state of the interface
	UpDown NetworkInterfaceUpDown `protobuf:"varint,1,opt,name=up_down,json=upDown,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceUpDown" json:"up_down,omitempty"`
}

func (m *NetworkInterfaceStatus) Reset()                    { *m = NetworkInterfaceStatus{} }
func (*NetworkInterfaceStatus) ProtoMessage()               {}
func (*NetworkInterfaceStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20} }

func (m *NetworkInterfaceStatus) GetUpDown() NetworkInterfaceUpDown {
	if m != nil {
		return m.UpDown
	}
	return NETWORK_INTERFACE_ADMINISTRATIVELY_DOWN
}

func init() {
	proto.RegisterType((*NetworkInterfaceDFGW)(nil), "ves.io.schema.network_interface.NetworkInterfaceDFGW")
	golang_proto.RegisterType((*NetworkInterfaceDFGW)(nil), "ves.io.schema.network_interface.NetworkInterfaceDFGW")
	proto.RegisterType((*NetworkInterfaceDNS)(nil), "ves.io.schema.network_interface.NetworkInterfaceDNS")
	golang_proto.RegisterType((*NetworkInterfaceDNS)(nil), "ves.io.schema.network_interface.NetworkInterfaceDNS")
	proto.RegisterType((*NetworkInterfaceTunnel)(nil), "ves.io.schema.network_interface.NetworkInterfaceTunnel")
	golang_proto.RegisterType((*NetworkInterfaceTunnel)(nil), "ves.io.schema.network_interface.NetworkInterfaceTunnel")
	proto.RegisterType((*DHCPPoolType)(nil), "ves.io.schema.network_interface.DHCPPoolType")
	golang_proto.RegisterType((*DHCPPoolType)(nil), "ves.io.schema.network_interface.DHCPPoolType")
	proto.RegisterType((*DHCPNetworkType)(nil), "ves.io.schema.network_interface.DHCPNetworkType")
	golang_proto.RegisterType((*DHCPNetworkType)(nil), "ves.io.schema.network_interface.DHCPNetworkType")
	proto.RegisterType((*DHCPInterfaceIPType)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPType")
	golang_proto.RegisterType((*DHCPInterfaceIPType)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPType")
	proto.RegisterType((*DHCPServerParametersType)(nil), "ves.io.schema.network_interface.DHCPServerParametersType")
	golang_proto.RegisterType((*DHCPServerParametersType)(nil), "ves.io.schema.network_interface.DHCPServerParametersType")
	proto.RegisterType((*StaticIpParametersNodeType)(nil), "ves.io.schema.network_interface.StaticIpParametersNodeType")
	golang_proto.RegisterType((*StaticIpParametersNodeType)(nil), "ves.io.schema.network_interface.StaticIpParametersNodeType")
	proto.RegisterType((*StaticIpParametersClusterType)(nil), "ves.io.schema.network_interface.StaticIpParametersClusterType")
	golang_proto.RegisterType((*StaticIpParametersClusterType)(nil), "ves.io.schema.network_interface.StaticIpParametersClusterType")
	proto.RegisterType((*StaticIpParametersFleetType)(nil), "ves.io.schema.network_interface.StaticIpParametersFleetType")
	golang_proto.RegisterType((*StaticIpParametersFleetType)(nil), "ves.io.schema.network_interface.StaticIpParametersFleetType")
	proto.RegisterType((*StaticIPParametersType)(nil), "ves.io.schema.network_interface.StaticIPParametersType")
	golang_proto.RegisterType((*StaticIPParametersType)(nil), "ves.io.schema.network_interface.StaticIPParametersType")
	proto.RegisterType((*DedicatedInterfaceType)(nil), "ves.io.schema.network_interface.DedicatedInterfaceType")
	golang_proto.RegisterType((*DedicatedInterfaceType)(nil), "ves.io.schema.network_interface.DedicatedInterfaceType")
	proto.RegisterType((*DedicatedManagementInterfaceType)(nil), "ves.io.schema.network_interface.DedicatedManagementInterfaceType")
	golang_proto.RegisterType((*DedicatedManagementInterfaceType)(nil), "ves.io.schema.network_interface.DedicatedManagementInterfaceType")
	proto.RegisterType((*EthernetInterfaceType)(nil), "ves.io.schema.network_interface.EthernetInterfaceType")
	golang_proto.RegisterType((*EthernetInterfaceType)(nil), "ves.io.schema.network_interface.EthernetInterfaceType")
	proto.RegisterType((*TunnelInterfaceType)(nil), "ves.io.schema.network_interface.TunnelInterfaceType")
	golang_proto.RegisterType((*TunnelInterfaceType)(nil), "ves.io.schema.network_interface.TunnelInterfaceType")
	proto.RegisterType((*LegacyInterfaceType)(nil), "ves.io.schema.network_interface.LegacyInterfaceType")
	golang_proto.RegisterType((*LegacyInterfaceType)(nil), "ves.io.schema.network_interface.LegacyInterfaceType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_interface.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_interface.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_interface.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_interface.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_interface.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_interface.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_interface.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_interface.GetSpecType")
	proto.RegisterType((*NetworkInterfaceStatus)(nil), "ves.io.schema.network_interface.NetworkInterfaceStatus")
	golang_proto.RegisterType((*NetworkInterfaceStatus)(nil), "ves.io.schema.network_interface.NetworkInterfaceStatus")
	proto.RegisterEnum("ves.io.schema.network_interface.DHCPPoolSettingType", DHCPPoolSettingType_name, DHCPPoolSettingType_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.DHCPPoolSettingType", DHCPPoolSettingType_name, DHCPPoolSettingType_value)
	proto.RegisterEnum("ves.io.schema.network_interface.InterfaceNetworkType", InterfaceNetworkType_name, InterfaceNetworkType_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.InterfaceNetworkType", InterfaceNetworkType_name, InterfaceNetworkType_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceType", NetworkInterfaceType_name, NetworkInterfaceType_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceType", NetworkInterfaceType_name, NetworkInterfaceType_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDHCP", NetworkInterfaceDHCP_name, NetworkInterfaceDHCP_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDHCP", NetworkInterfaceDHCP_name, NetworkInterfaceDHCP_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceVLANTagging", NetworkInterfaceVLANTagging_name, NetworkInterfaceVLANTagging_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceVLANTagging", NetworkInterfaceVLANTagging_name, NetworkInterfaceVLANTagging_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceGatewayMode", NetworkInterfaceGatewayMode_name, NetworkInterfaceGatewayMode_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceGatewayMode", NetworkInterfaceGatewayMode_name, NetworkInterfaceGatewayMode_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDNSMode", NetworkInterfaceDNSMode_name, NetworkInterfaceDNSMode_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDNSMode", NetworkInterfaceDNSMode_name, NetworkInterfaceDNSMode_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDHCPServer", NetworkInterfaceDHCPServer_name, NetworkInterfaceDHCPServer_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDHCPServer", NetworkInterfaceDHCPServer_name, NetworkInterfaceDHCPServer_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceUpDown", NetworkInterfaceUpDown_name, NetworkInterfaceUpDown_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceUpDown", NetworkInterfaceUpDown_name, NetworkInterfaceUpDown_value)
}
func (x DHCPPoolSettingType) String() string {
	s, ok := DHCPPoolSettingType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x InterfaceNetworkType) String() string {
	s, ok := InterfaceNetworkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceType) String() string {
	s, ok := NetworkInterfaceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceDHCP) String() string {
	s, ok := NetworkInterfaceDHCP_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceVLANTagging) String() string {
	s, ok := NetworkInterfaceVLANTagging_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceGatewayMode) String() string {
	s, ok := NetworkInterfaceGatewayMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceDNSMode) String() string {
	s, ok := NetworkInterfaceDNSMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceDHCPServer) String() string {
	s, ok := NetworkInterfaceDHCPServer_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceUpDown) String() string {
	s, ok := NetworkInterfaceUpDown_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NetworkInterfaceDFGW) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceDFGW)
	if !ok {
		that2, ok := that.(NetworkInterfaceDFGW)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefaultGatewayMode != that1.DefaultGatewayMode {
		return false
	}
	if !this.DefaultGatewayAddress.Equal(that1.DefaultGatewayAddress) {
		return false
	}
	return true
}
func (this *NetworkInterfaceDNS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceDNS)
	if !ok {
		that2, ok := that.(NetworkInterfaceDNS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsMode != that1.DnsMode {
		return false
	}
	if len(this.DnsServer) != len(that1.DnsServer) {
		return false
	}
	for i := range this.DnsServer {
		if !this.DnsServer[i].Equal(that1.DnsServer[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkInterfaceTunnel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceTunnel)
	if !ok {
		that2, ok := that.(NetworkInterfaceTunnel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Tunnel) != len(that1.Tunnel) {
		return false
	}
	for i := range this.Tunnel {
		if !this.Tunnel[i].Equal(that1.Tunnel[i]) {
			return false
		}
	}
	return true
}
func (this *DHCPPoolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPPoolType)
	if !ok {
		that2, ok := that.(DHCPPoolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartIp != that1.StartIp {
		return false
	}
	if this.EndIp != that1.EndIp {
		return false
	}
	if this.Exclude != that1.Exclude {
		return false
	}
	return true
}
func (this *DHCPNetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType)
	if !ok {
		that2, ok := that.(DHCPNetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NetworkPrefixChoice == nil {
		if this.NetworkPrefixChoice != nil {
			return false
		}
	} else if this.NetworkPrefixChoice == nil {
		return false
	} else if !this.NetworkPrefixChoice.Equal(that1.NetworkPrefixChoice) {
		return false
	}
	if len(this.Pools) != len(that1.Pools) {
		return false
	}
	for i := range this.Pools {
		if !this.Pools[i].Equal(that1.Pools[i]) {
			return false
		}
	}
	if that1.GatewayChoice == nil {
		if this.GatewayChoice != nil {
			return false
		}
	} else if this.GatewayChoice == nil {
		return false
	} else if !this.GatewayChoice.Equal(that1.GatewayChoice) {
		return false
	}
	if that1.DnsChoice == nil {
		if this.DnsChoice != nil {
			return false
		}
	} else if this.DnsChoice == nil {
		return false
	} else if !this.DnsChoice.Equal(that1.DnsChoice) {
		return false
	}
	if this.PoolSettings != that1.PoolSettings {
		return false
	}
	return true
}
func (this *DHCPNetworkType_NetworkPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_NetworkPrefix)
	if !ok {
		that2, ok := that.(DHCPNetworkType_NetworkPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetworkPrefix != that1.NetworkPrefix {
		return false
	}
	return true
}
func (this *DHCPNetworkType_NetworkPrefixAllocator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_NetworkPrefixAllocator)
	if !ok {
		that2, ok := that.(DHCPNetworkType_NetworkPrefixAllocator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetworkPrefixAllocator.Equal(that1.NetworkPrefixAllocator) {
		return false
	}
	return true
}
func (this *DHCPNetworkType_FirstAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_FirstAddress)
	if !ok {
		that2, ok := that.(DHCPNetworkType_FirstAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FirstAddress.Equal(that1.FirstAddress) {
		return false
	}
	return true
}
func (this *DHCPNetworkType_LastAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_LastAddress)
	if !ok {
		that2, ok := that.(DHCPNetworkType_LastAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LastAddress.Equal(that1.LastAddress) {
		return false
	}
	return true
}
func (this *DHCPNetworkType_DgwAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_DgwAddress)
	if !ok {
		that2, ok := that.(DHCPNetworkType_DgwAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DgwAddress != that1.DgwAddress {
		return false
	}
	return true
}
func (this *DHCPNetworkType_SameAsDgw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_SameAsDgw)
	if !ok {
		that2, ok := that.(DHCPNetworkType_SameAsDgw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SameAsDgw.Equal(that1.SameAsDgw) {
		return false
	}
	return true
}
func (this *DHCPNetworkType_DnsAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_DnsAddress)
	if !ok {
		that2, ok := that.(DHCPNetworkType_DnsAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsAddress != that1.DnsAddress {
		return false
	}
	return true
}
func (this *DHCPInterfaceIPType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPInterfaceIPType)
	if !ok {
		that2, ok := that.(DHCPInterfaceIPType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InterfaceIpMap) != len(that1.InterfaceIpMap) {
		return false
	}
	for i := range this.InterfaceIpMap {
		if this.InterfaceIpMap[i] != that1.InterfaceIpMap[i] {
			return false
		}
	}
	return true
}
func (this *DHCPServerParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPServerParametersType)
	if !ok {
		that2, ok := that.(DHCPServerParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DhcpNetworks) != len(that1.DhcpNetworks) {
		return false
	}
	for i := range this.DhcpNetworks {
		if !this.DhcpNetworks[i].Equal(that1.DhcpNetworks[i]) {
			return false
		}
	}
	if that1.InterfacesAddressingChoice == nil {
		if this.InterfacesAddressingChoice != nil {
			return false
		}
	} else if this.InterfacesAddressingChoice == nil {
		return false
	} else if !this.InterfacesAddressingChoice.Equal(that1.InterfacesAddressingChoice) {
		return false
	}
	if len(this.FixedIpMap) != len(that1.FixedIpMap) {
		return false
	}
	for i := range this.FixedIpMap {
		if this.FixedIpMap[i] != that1.FixedIpMap[i] {
			return false
		}
	}
	if this.DhcpOption82Tag != that1.DhcpOption82Tag {
		return false
	}
	return true
}
func (this *DHCPServerParametersType_AutomaticFromStart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPServerParametersType_AutomaticFromStart)
	if !ok {
		that2, ok := that.(DHCPServerParametersType_AutomaticFromStart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AutomaticFromStart.Equal(that1.AutomaticFromStart) {
		return false
	}
	return true
}
func (this *DHCPServerParametersType_AutomaticFromEnd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPServerParametersType_AutomaticFromEnd)
	if !ok {
		that2, ok := that.(DHCPServerParametersType_AutomaticFromEnd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AutomaticFromEnd.Equal(that1.AutomaticFromEnd) {
		return false
	}
	return true
}
func (this *DHCPServerParametersType_InterfaceIpMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPServerParametersType_InterfaceIpMap)
	if !ok {
		that2, ok := that.(DHCPServerParametersType_InterfaceIpMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceIpMap.Equal(that1.InterfaceIpMap) {
		return false
	}
	return true
}
func (this *StaticIpParametersNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIpParametersNodeType)
	if !ok {
		that2, ok := that.(StaticIpParametersNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IpAddress != that1.IpAddress {
		return false
	}
	if this.DefaultGw != that1.DefaultGw {
		return false
	}
	if this.DnsServer != that1.DnsServer {
		return false
	}
	return true
}
func (this *StaticIpParametersClusterType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIpParametersClusterType)
	if !ok {
		that2, ok := that.(StaticIpParametersClusterType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InterfaceIpMap) != len(that1.InterfaceIpMap) {
		return false
	}
	for i := range this.InterfaceIpMap {
		if !this.InterfaceIpMap[i].Equal(that1.InterfaceIpMap[i]) {
			return false
		}
	}
	return true
}
func (this *StaticIpParametersFleetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIpParametersFleetType)
	if !ok {
		that2, ok := that.(StaticIpParametersFleetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetworkPrefixAllocator.Equal(that1.NetworkPrefixAllocator) {
		return false
	}
	if this.DefaultGw != that1.DefaultGw {
		return false
	}
	if this.DnsServer != that1.DnsServer {
		return false
	}
	return true
}
func (this *StaticIPParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIPParametersType)
	if !ok {
		that2, ok := that.(StaticIPParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NetworkPrefixChoice == nil {
		if this.NetworkPrefixChoice != nil {
			return false
		}
	} else if this.NetworkPrefixChoice == nil {
		return false
	} else if !this.NetworkPrefixChoice.Equal(that1.NetworkPrefixChoice) {
		return false
	}
	return true
}
func (this *StaticIPParametersType_NodeStaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIPParametersType_NodeStaticIp)
	if !ok {
		that2, ok := that.(StaticIPParametersType_NodeStaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeStaticIp.Equal(that1.NodeStaticIp) {
		return false
	}
	return true
}
func (this *StaticIPParametersType_ClusterStaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIPParametersType_ClusterStaticIp)
	if !ok {
		that2, ok := that.(StaticIPParametersType_ClusterStaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClusterStaticIp.Equal(that1.ClusterStaticIp) {
		return false
	}
	return true
}
func (this *StaticIPParametersType_FleetStaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIPParametersType_FleetStaticIp)
	if !ok {
		that2, ok := that.(StaticIPParametersType_FleetStaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FleetStaticIp.Equal(that1.FleetStaticIp) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if that1.NodeChoice == nil {
		if this.NodeChoice != nil {
			return false
		}
	} else if this.NodeChoice == nil {
		return false
	} else if !this.NodeChoice.Equal(that1.NodeChoice) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if that1.PrimaryChoice == nil {
		if this.PrimaryChoice != nil {
			return false
		}
	} else if this.PrimaryChoice == nil {
		return false
	} else if !this.PrimaryChoice.Equal(that1.PrimaryChoice) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_Cluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_Cluster)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_Cluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cluster.Equal(that1.Cluster) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_Node)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_NotPrimary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_NotPrimary)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_NotPrimary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NotPrimary.Equal(that1.NotPrimary) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_IsPrimary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_IsPrimary)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_IsPrimary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsPrimary.Equal(that1.IsPrimary) {
		return false
	}
	return true
}
func (this *DedicatedManagementInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedManagementInterfaceType)
	if !ok {
		that2, ok := that.(DedicatedManagementInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if that1.NodeChoice == nil {
		if this.NodeChoice != nil {
			return false
		}
	} else if this.NodeChoice == nil {
		return false
	} else if !this.NodeChoice.Equal(that1.NodeChoice) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	return true
}
func (this *DedicatedManagementInterfaceType_Cluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedManagementInterfaceType_Cluster)
	if !ok {
		that2, ok := that.(DedicatedManagementInterfaceType_Cluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cluster.Equal(that1.Cluster) {
		return false
	}
	return true
}
func (this *DedicatedManagementInterfaceType_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedManagementInterfaceType_Node)
	if !ok {
		that2, ok := that.(DedicatedManagementInterfaceType_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *EthernetInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType)
	if !ok {
		that2, ok := that.(EthernetInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if that1.NodeChoice == nil {
		if this.NodeChoice != nil {
			return false
		}
	} else if this.NodeChoice == nil {
		return false
	} else if !this.NodeChoice.Equal(that1.NodeChoice) {
		return false
	}
	if that1.VlanChoice == nil {
		if this.VlanChoice != nil {
			return false
		}
	} else if this.VlanChoice == nil {
		return false
	} else if !this.VlanChoice.Equal(that1.VlanChoice) {
		return false
	}
	if that1.AddressChoice == nil {
		if this.AddressChoice != nil {
			return false
		}
	} else if this.AddressChoice == nil {
		return false
	} else if !this.AddressChoice.Equal(that1.AddressChoice) {
		return false
	}
	if that1.NetworkChoice == nil {
		if this.NetworkChoice != nil {
			return false
		}
	} else if this.NetworkChoice == nil {
		return false
	} else if !this.NetworkChoice.Equal(that1.NetworkChoice) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if that1.PrimaryChoice == nil {
		if this.PrimaryChoice != nil {
			return false
		}
	} else if this.PrimaryChoice == nil {
		return false
	} else if !this.PrimaryChoice.Equal(that1.PrimaryChoice) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_Cluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_Cluster)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_Cluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cluster.Equal(that1.Cluster) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_Node)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_Untagged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_Untagged)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_Untagged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Untagged.Equal(that1.Untagged) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_VlanId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_VlanId)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_VlanId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VlanId != that1.VlanId {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_DhcpClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_DhcpClient)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_DhcpClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhcpClient.Equal(that1.DhcpClient) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_DhcpServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_DhcpServer)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_DhcpServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhcpServer.Equal(that1.DhcpServer) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_StaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_StaticIp)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_StaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StaticIp.Equal(that1.StaticIp) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_SiteLocalNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_SiteLocalNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_SiteLocalNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalNetwork.Equal(that1.SiteLocalNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_SiteLocalInsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_SiteLocalInsideNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_SiteLocalInsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInsideNetwork.Equal(that1.SiteLocalInsideNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_InsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_InsideNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_InsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideNetwork.Equal(that1.InsideNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_StorageNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_StorageNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_StorageNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageNetwork.Equal(that1.StorageNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_NotPrimary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_NotPrimary)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_NotPrimary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NotPrimary.Equal(that1.NotPrimary) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_IsPrimary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_IsPrimary)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_IsPrimary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsPrimary.Equal(that1.IsPrimary) {
		return false
	}
	return true
}
func (this *TunnelInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType)
	if !ok {
		that2, ok := that.(TunnelInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NodeChoice == nil {
		if this.NodeChoice != nil {
			return false
		}
	} else if this.NodeChoice == nil {
		return false
	} else if !this.NodeChoice.Equal(that1.NodeChoice) {
		return false
	}
	if !this.Tunnel.Equal(that1.Tunnel) {
		return false
	}
	if !this.StaticIp.Equal(that1.StaticIp) {
		return false
	}
	if that1.NetworkChoice == nil {
		if this.NetworkChoice != nil {
			return false
		}
	} else if this.NetworkChoice == nil {
		return false
	} else if !this.NetworkChoice.Equal(that1.NetworkChoice) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_Cluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_Cluster)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_Cluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cluster.Equal(that1.Cluster) {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_Node)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_SiteLocalNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_SiteLocalNetwork)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_SiteLocalNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalNetwork.Equal(that1.SiteLocalNetwork) {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_SiteLocalInsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_SiteLocalInsideNetwork)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_SiteLocalInsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInsideNetwork.Equal(that1.SiteLocalInsideNetwork) {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_InsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_InsideNetwork)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_InsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideNetwork.Equal(that1.InsideNetwork) {
		return false
	}
	return true
}
func (this *LegacyInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LegacyInterfaceType)
	if !ok {
		that2, ok := that.(LegacyInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if len(this.VirtualNetwork) != len(that1.VirtualNetwork) {
		return false
	}
	for i := range this.VirtualNetwork {
		if !this.VirtualNetwork[i].Equal(that1.VirtualNetwork[i]) {
			return false
		}
	}
	if this.DhcpAddress != that1.DhcpAddress {
		return false
	}
	if len(this.StaticAddresses) != len(that1.StaticAddresses) {
		return false
	}
	for i := range this.StaticAddresses {
		if !this.StaticAddresses[i].Equal(that1.StaticAddresses[i]) {
			return false
		}
	}
	if !this.DefaultGateway.Equal(that1.DefaultGateway) {
		return false
	}
	if !this.DNSServer.Equal(that1.DNSServer) {
		return false
	}
	if this.DHCPServer != that1.DHCPServer {
		return false
	}
	if this.VlanTagging != that1.VlanTagging {
		return false
	}
	if this.DeviceName != that1.DeviceName {
		return false
	}
	if this.VlanTag != that1.VlanTag {
		return false
	}
	if !this.Tunnel.Equal(that1.Tunnel) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if len(this.AddressAllocator) != len(that1.AddressAllocator) {
		return false
	}
	for i := range this.AddressAllocator {
		if !this.AddressAllocator[i].Equal(that1.AddressAllocator[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if len(this.VirtualNetwork) != len(that1.VirtualNetwork) {
		return false
	}
	for i := range this.VirtualNetwork {
		if !this.VirtualNetwork[i].Equal(that1.VirtualNetwork[i]) {
			return false
		}
	}
	if this.DhcpAddress != that1.DhcpAddress {
		return false
	}
	if len(this.StaticAddresses) != len(that1.StaticAddresses) {
		return false
	}
	for i := range this.StaticAddresses {
		if !this.StaticAddresses[i].Equal(that1.StaticAddresses[i]) {
			return false
		}
	}
	if !this.DefaultGateway.Equal(that1.DefaultGateway) {
		return false
	}
	if !this.DNSServer.Equal(that1.DNSServer) {
		return false
	}
	if this.DHCPServer != that1.DHCPServer {
		return false
	}
	if this.VlanTagging != that1.VlanTagging {
		return false
	}
	if this.DeviceName != that1.DeviceName {
		return false
	}
	if len(this.ParentNetworkInterface) != len(that1.ParentNetworkInterface) {
		return false
	}
	for i := range this.ParentNetworkInterface {
		if !this.ParentNetworkInterface[i].Equal(that1.ParentNetworkInterface[i]) {
			return false
		}
	}
	if this.VlanTag != that1.VlanTag {
		return false
	}
	if !this.Tunnel.Equal(that1.Tunnel) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if len(this.AddressAllocator) != len(that1.AddressAllocator) {
		return false
	}
	for i := range this.AddressAllocator {
		if !this.AddressAllocator[i].Equal(that1.AddressAllocator[i]) {
			return false
		}
	}
	if !this.DhcpServerParams.Equal(that1.DhcpServerParams) {
		return false
	}
	if this.NetworkConfig != that1.NetworkConfig {
		return false
	}
	if len(this.InterfaceIpMap) != len(that1.InterfaceIpMap) {
		return false
	}
	for i := range this.InterfaceIpMap {
		if this.InterfaceIpMap[i] != that1.InterfaceIpMap[i] {
			return false
		}
	}
	if this.IsPrimary != that1.IsPrimary {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DedicatedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DedicatedInterface)
	if !ok {
		that2, ok := that.(GlobalSpecType_DedicatedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedInterface.Equal(that1.DedicatedInterface) {
		return false
	}
	return true
}
func (this *GlobalSpecType_EthernetInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_EthernetInterface)
	if !ok {
		that2, ok := that.(GlobalSpecType_EthernetInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EthernetInterface.Equal(that1.EthernetInterface) {
		return false
	}
	return true
}
func (this *GlobalSpecType_TunnelInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_TunnelInterface)
	if !ok {
		that2, ok := that.(GlobalSpecType_TunnelInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TunnelInterface.Equal(that1.TunnelInterface) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Legacy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Legacy)
	if !ok {
		that2, ok := that.(GlobalSpecType_Legacy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Legacy.Equal(that1.Legacy) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DedicatedManagementInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DedicatedManagementInterface)
	if !ok {
		that2, ok := that.(GlobalSpecType_DedicatedManagementInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedManagementInterface.Equal(that1.DedicatedManagementInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_DedicatedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DedicatedInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_DedicatedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedInterface.Equal(that1.DedicatedInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType_EthernetInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_EthernetInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_EthernetInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EthernetInterface.Equal(that1.EthernetInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType_TunnelInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_TunnelInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_TunnelInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TunnelInterface.Equal(that1.TunnelInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType_LegacyInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LegacyInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_LegacyInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyInterface.Equal(that1.LegacyInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType_DedicatedManagementInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DedicatedManagementInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_DedicatedManagementInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedManagementInterface.Equal(that1.DedicatedManagementInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DedicatedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DedicatedInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DedicatedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedInterface.Equal(that1.DedicatedInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_EthernetInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_EthernetInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_EthernetInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EthernetInterface.Equal(that1.EthernetInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_TunnelInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_TunnelInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_TunnelInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TunnelInterface.Equal(that1.TunnelInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LegacyInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LegacyInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LegacyInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyInterface.Equal(that1.LegacyInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DedicatedManagementInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DedicatedManagementInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DedicatedManagementInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedManagementInterface.Equal(that1.DedicatedManagementInterface) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_DedicatedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DedicatedInterface)
	if !ok {
		that2, ok := that.(GetSpecType_DedicatedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedInterface.Equal(that1.DedicatedInterface) {
		return false
	}
	return true
}
func (this *GetSpecType_EthernetInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_EthernetInterface)
	if !ok {
		that2, ok := that.(GetSpecType_EthernetInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EthernetInterface.Equal(that1.EthernetInterface) {
		return false
	}
	return true
}
func (this *GetSpecType_TunnelInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_TunnelInterface)
	if !ok {
		that2, ok := that.(GetSpecType_TunnelInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TunnelInterface.Equal(that1.TunnelInterface) {
		return false
	}
	return true
}
func (this *GetSpecType_LegacyInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LegacyInterface)
	if !ok {
		that2, ok := that.(GetSpecType_LegacyInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyInterface.Equal(that1.LegacyInterface) {
		return false
	}
	return true
}
func (this *GetSpecType_DedicatedManagementInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DedicatedManagementInterface)
	if !ok {
		that2, ok := that.(GetSpecType_DedicatedManagementInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedManagementInterface.Equal(that1.DedicatedManagementInterface) {
		return false
	}
	return true
}
func (this *NetworkInterfaceStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceStatus)
	if !ok {
		that2, ok := that.(NetworkInterfaceStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UpDown != that1.UpDown {
		return false
	}
	return true
}
func (this *NetworkInterfaceDFGW) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_interface.NetworkInterfaceDFGW{")
	s = append(s, "DefaultGatewayMode: "+fmt.Sprintf("%#v", this.DefaultGatewayMode)+",\n")
	if this.DefaultGatewayAddress != nil {
		s = append(s, "DefaultGatewayAddress: "+fmt.Sprintf("%#v", this.DefaultGatewayAddress)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkInterfaceDNS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_interface.NetworkInterfaceDNS{")
	s = append(s, "DnsMode: "+fmt.Sprintf("%#v", this.DnsMode)+",\n")
	if this.DnsServer != nil {
		s = append(s, "DnsServer: "+fmt.Sprintf("%#v", this.DnsServer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkInterfaceTunnel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.NetworkInterfaceTunnel{")
	if this.Tunnel != nil {
		s = append(s, "Tunnel: "+fmt.Sprintf("%#v", this.Tunnel)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPPoolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.DHCPPoolType{")
	s = append(s, "StartIp: "+fmt.Sprintf("%#v", this.StartIp)+",\n")
	s = append(s, "EndIp: "+fmt.Sprintf("%#v", this.EndIp)+",\n")
	s = append(s, "Exclude: "+fmt.Sprintf("%#v", this.Exclude)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPNetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&network_interface.DHCPNetworkType{")
	if this.NetworkPrefixChoice != nil {
		s = append(s, "NetworkPrefixChoice: "+fmt.Sprintf("%#v", this.NetworkPrefixChoice)+",\n")
	}
	if this.Pools != nil {
		s = append(s, "Pools: "+fmt.Sprintf("%#v", this.Pools)+",\n")
	}
	if this.GatewayChoice != nil {
		s = append(s, "GatewayChoice: "+fmt.Sprintf("%#v", this.GatewayChoice)+",\n")
	}
	if this.DnsChoice != nil {
		s = append(s, "DnsChoice: "+fmt.Sprintf("%#v", this.DnsChoice)+",\n")
	}
	s = append(s, "PoolSettings: "+fmt.Sprintf("%#v", this.PoolSettings)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPNetworkType_NetworkPrefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_NetworkPrefix{` +
		`NetworkPrefix:` + fmt.Sprintf("%#v", this.NetworkPrefix) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_NetworkPrefixAllocator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_NetworkPrefixAllocator{` +
		`NetworkPrefixAllocator:` + fmt.Sprintf("%#v", this.NetworkPrefixAllocator) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_FirstAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_FirstAddress{` +
		`FirstAddress:` + fmt.Sprintf("%#v", this.FirstAddress) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_LastAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_LastAddress{` +
		`LastAddress:` + fmt.Sprintf("%#v", this.LastAddress) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_DgwAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_DgwAddress{` +
		`DgwAddress:` + fmt.Sprintf("%#v", this.DgwAddress) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_SameAsDgw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_SameAsDgw{` +
		`SameAsDgw:` + fmt.Sprintf("%#v", this.SameAsDgw) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_DnsAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_DnsAddress{` +
		`DnsAddress:` + fmt.Sprintf("%#v", this.DnsAddress) + `}`}, ", ")
	return s
}
func (this *DHCPInterfaceIPType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.DHCPInterfaceIPType{")
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%#v: %#v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	if this.InterfaceIpMap != nil {
		s = append(s, "InterfaceIpMap: "+mapStringForInterfaceIpMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPServerParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&network_interface.DHCPServerParametersType{")
	if this.DhcpNetworks != nil {
		s = append(s, "DhcpNetworks: "+fmt.Sprintf("%#v", this.DhcpNetworks)+",\n")
	}
	if this.InterfacesAddressingChoice != nil {
		s = append(s, "InterfacesAddressingChoice: "+fmt.Sprintf("%#v", this.InterfacesAddressingChoice)+",\n")
	}
	keysForFixedIpMap := make([]string, 0, len(this.FixedIpMap))
	for k, _ := range this.FixedIpMap {
		keysForFixedIpMap = append(keysForFixedIpMap, k)
	}
	sortkeys.Strings(keysForFixedIpMap)
	mapStringForFixedIpMap := "map[string]string{"
	for _, k := range keysForFixedIpMap {
		mapStringForFixedIpMap += fmt.Sprintf("%#v: %#v,", k, this.FixedIpMap[k])
	}
	mapStringForFixedIpMap += "}"
	if this.FixedIpMap != nil {
		s = append(s, "FixedIpMap: "+mapStringForFixedIpMap+",\n")
	}
	s = append(s, "DhcpOption82Tag: "+fmt.Sprintf("%#v", this.DhcpOption82Tag)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPServerParametersType_AutomaticFromStart) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPServerParametersType_AutomaticFromStart{` +
		`AutomaticFromStart:` + fmt.Sprintf("%#v", this.AutomaticFromStart) + `}`}, ", ")
	return s
}
func (this *DHCPServerParametersType_AutomaticFromEnd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPServerParametersType_AutomaticFromEnd{` +
		`AutomaticFromEnd:` + fmt.Sprintf("%#v", this.AutomaticFromEnd) + `}`}, ", ")
	return s
}
func (this *DHCPServerParametersType_InterfaceIpMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPServerParametersType_InterfaceIpMap{` +
		`InterfaceIpMap:` + fmt.Sprintf("%#v", this.InterfaceIpMap) + `}`}, ", ")
	return s
}
func (this *StaticIpParametersNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.StaticIpParametersNodeType{")
	s = append(s, "IpAddress: "+fmt.Sprintf("%#v", this.IpAddress)+",\n")
	s = append(s, "DefaultGw: "+fmt.Sprintf("%#v", this.DefaultGw)+",\n")
	s = append(s, "DnsServer: "+fmt.Sprintf("%#v", this.DnsServer)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticIpParametersClusterType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.StaticIpParametersClusterType{")
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]*StaticIpParametersNodeType{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%#v: %#v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	if this.InterfaceIpMap != nil {
		s = append(s, "InterfaceIpMap: "+mapStringForInterfaceIpMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticIpParametersFleetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.StaticIpParametersFleetType{")
	if this.NetworkPrefixAllocator != nil {
		s = append(s, "NetworkPrefixAllocator: "+fmt.Sprintf("%#v", this.NetworkPrefixAllocator)+",\n")
	}
	s = append(s, "DefaultGw: "+fmt.Sprintf("%#v", this.DefaultGw)+",\n")
	s = append(s, "DnsServer: "+fmt.Sprintf("%#v", this.DnsServer)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticIPParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.StaticIPParametersType{")
	if this.NetworkPrefixChoice != nil {
		s = append(s, "NetworkPrefixChoice: "+fmt.Sprintf("%#v", this.NetworkPrefixChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticIPParametersType_NodeStaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.StaticIPParametersType_NodeStaticIp{` +
		`NodeStaticIp:` + fmt.Sprintf("%#v", this.NodeStaticIp) + `}`}, ", ")
	return s
}
func (this *StaticIPParametersType_ClusterStaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.StaticIPParametersType_ClusterStaticIp{` +
		`ClusterStaticIp:` + fmt.Sprintf("%#v", this.ClusterStaticIp) + `}`}, ", ")
	return s
}
func (this *StaticIPParametersType_FleetStaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.StaticIPParametersType_FleetStaticIp{` +
		`FleetStaticIp:` + fmt.Sprintf("%#v", this.FleetStaticIp) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&network_interface.DedicatedInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	if this.NodeChoice != nil {
		s = append(s, "NodeChoice: "+fmt.Sprintf("%#v", this.NodeChoice)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.PrimaryChoice != nil {
		s = append(s, "PrimaryChoice: "+fmt.Sprintf("%#v", this.PrimaryChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DedicatedInterfaceType_Cluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_Cluster{` +
		`Cluster:` + fmt.Sprintf("%#v", this.Cluster) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_Node{` +
		`Node:` + fmt.Sprintf("%#v", this.Node) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType_NotPrimary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_NotPrimary{` +
		`NotPrimary:` + fmt.Sprintf("%#v", this.NotPrimary) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType_IsPrimary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_IsPrimary{` +
		`IsPrimary:` + fmt.Sprintf("%#v", this.IsPrimary) + `}`}, ", ")
	return s
}
func (this *DedicatedManagementInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&network_interface.DedicatedManagementInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	if this.NodeChoice != nil {
		s = append(s, "NodeChoice: "+fmt.Sprintf("%#v", this.NodeChoice)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DedicatedManagementInterfaceType_Cluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedManagementInterfaceType_Cluster{` +
		`Cluster:` + fmt.Sprintf("%#v", this.Cluster) + `}`}, ", ")
	return s
}
func (this *DedicatedManagementInterfaceType_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedManagementInterfaceType_Node{` +
		`Node:` + fmt.Sprintf("%#v", this.Node) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&network_interface.EthernetInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	if this.NodeChoice != nil {
		s = append(s, "NodeChoice: "+fmt.Sprintf("%#v", this.NodeChoice)+",\n")
	}
	if this.VlanChoice != nil {
		s = append(s, "VlanChoice: "+fmt.Sprintf("%#v", this.VlanChoice)+",\n")
	}
	if this.AddressChoice != nil {
		s = append(s, "AddressChoice: "+fmt.Sprintf("%#v", this.AddressChoice)+",\n")
	}
	if this.NetworkChoice != nil {
		s = append(s, "NetworkChoice: "+fmt.Sprintf("%#v", this.NetworkChoice)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.PrimaryChoice != nil {
		s = append(s, "PrimaryChoice: "+fmt.Sprintf("%#v", this.PrimaryChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EthernetInterfaceType_Cluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_Cluster{` +
		`Cluster:` + fmt.Sprintf("%#v", this.Cluster) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_Node{` +
		`Node:` + fmt.Sprintf("%#v", this.Node) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_Untagged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_Untagged{` +
		`Untagged:` + fmt.Sprintf("%#v", this.Untagged) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_VlanId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_VlanId{` +
		`VlanId:` + fmt.Sprintf("%#v", this.VlanId) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_DhcpClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_DhcpClient{` +
		`DhcpClient:` + fmt.Sprintf("%#v", this.DhcpClient) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_DhcpServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_DhcpServer{` +
		`DhcpServer:` + fmt.Sprintf("%#v", this.DhcpServer) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_StaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_StaticIp{` +
		`StaticIp:` + fmt.Sprintf("%#v", this.StaticIp) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_SiteLocalNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_SiteLocalNetwork{` +
		`SiteLocalNetwork:` + fmt.Sprintf("%#v", this.SiteLocalNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_SiteLocalInsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{` +
		`SiteLocalInsideNetwork:` + fmt.Sprintf("%#v", this.SiteLocalInsideNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_InsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_InsideNetwork{` +
		`InsideNetwork:` + fmt.Sprintf("%#v", this.InsideNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_StorageNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_StorageNetwork{` +
		`StorageNetwork:` + fmt.Sprintf("%#v", this.StorageNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_NotPrimary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_NotPrimary{` +
		`NotPrimary:` + fmt.Sprintf("%#v", this.NotPrimary) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_IsPrimary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_IsPrimary{` +
		`IsPrimary:` + fmt.Sprintf("%#v", this.IsPrimary) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&network_interface.TunnelInterfaceType{")
	if this.NodeChoice != nil {
		s = append(s, "NodeChoice: "+fmt.Sprintf("%#v", this.NodeChoice)+",\n")
	}
	if this.Tunnel != nil {
		s = append(s, "Tunnel: "+fmt.Sprintf("%#v", this.Tunnel)+",\n")
	}
	if this.StaticIp != nil {
		s = append(s, "StaticIp: "+fmt.Sprintf("%#v", this.StaticIp)+",\n")
	}
	if this.NetworkChoice != nil {
		s = append(s, "NetworkChoice: "+fmt.Sprintf("%#v", this.NetworkChoice)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelInterfaceType_Cluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_Cluster{` +
		`Cluster:` + fmt.Sprintf("%#v", this.Cluster) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_Node{` +
		`Node:` + fmt.Sprintf("%#v", this.Node) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType_SiteLocalNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_SiteLocalNetwork{` +
		`SiteLocalNetwork:` + fmt.Sprintf("%#v", this.SiteLocalNetwork) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType_SiteLocalInsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_SiteLocalInsideNetwork{` +
		`SiteLocalInsideNetwork:` + fmt.Sprintf("%#v", this.SiteLocalInsideNetwork) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType_InsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_InsideNetwork{` +
		`InsideNetwork:` + fmt.Sprintf("%#v", this.InsideNetwork) + `}`}, ", ")
	return s
}
func (this *LegacyInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&network_interface.LegacyInterfaceType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	if this.VirtualNetwork != nil {
		s = append(s, "VirtualNetwork: "+fmt.Sprintf("%#v", this.VirtualNetwork)+",\n")
	}
	s = append(s, "DhcpAddress: "+fmt.Sprintf("%#v", this.DhcpAddress)+",\n")
	if this.StaticAddresses != nil {
		s = append(s, "StaticAddresses: "+fmt.Sprintf("%#v", this.StaticAddresses)+",\n")
	}
	if this.DefaultGateway != nil {
		s = append(s, "DefaultGateway: "+fmt.Sprintf("%#v", this.DefaultGateway)+",\n")
	}
	if this.DNSServer != nil {
		s = append(s, "DNSServer: "+fmt.Sprintf("%#v", this.DNSServer)+",\n")
	}
	s = append(s, "DHCPServer: "+fmt.Sprintf("%#v", this.DHCPServer)+",\n")
	s = append(s, "VlanTagging: "+fmt.Sprintf("%#v", this.VlanTagging)+",\n")
	s = append(s, "DeviceName: "+fmt.Sprintf("%#v", this.DeviceName)+",\n")
	s = append(s, "VlanTag: "+fmt.Sprintf("%#v", this.VlanTag)+",\n")
	if this.Tunnel != nil {
		s = append(s, "Tunnel: "+fmt.Sprintf("%#v", this.Tunnel)+",\n")
	}
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.AddressAllocator != nil {
		s = append(s, "AddressAllocator: "+fmt.Sprintf("%#v", this.AddressAllocator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 28)
	s = append(s, "&network_interface.GlobalSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	if this.VirtualNetwork != nil {
		s = append(s, "VirtualNetwork: "+fmt.Sprintf("%#v", this.VirtualNetwork)+",\n")
	}
	s = append(s, "DhcpAddress: "+fmt.Sprintf("%#v", this.DhcpAddress)+",\n")
	if this.StaticAddresses != nil {
		s = append(s, "StaticAddresses: "+fmt.Sprintf("%#v", this.StaticAddresses)+",\n")
	}
	if this.DefaultGateway != nil {
		s = append(s, "DefaultGateway: "+fmt.Sprintf("%#v", this.DefaultGateway)+",\n")
	}
	if this.DNSServer != nil {
		s = append(s, "DNSServer: "+fmt.Sprintf("%#v", this.DNSServer)+",\n")
	}
	s = append(s, "DHCPServer: "+fmt.Sprintf("%#v", this.DHCPServer)+",\n")
	s = append(s, "VlanTagging: "+fmt.Sprintf("%#v", this.VlanTagging)+",\n")
	s = append(s, "DeviceName: "+fmt.Sprintf("%#v", this.DeviceName)+",\n")
	if this.ParentNetworkInterface != nil {
		s = append(s, "ParentNetworkInterface: "+fmt.Sprintf("%#v", this.ParentNetworkInterface)+",\n")
	}
	s = append(s, "VlanTag: "+fmt.Sprintf("%#v", this.VlanTag)+",\n")
	if this.Tunnel != nil {
		s = append(s, "Tunnel: "+fmt.Sprintf("%#v", this.Tunnel)+",\n")
	}
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.AddressAllocator != nil {
		s = append(s, "AddressAllocator: "+fmt.Sprintf("%#v", this.AddressAllocator)+",\n")
	}
	if this.DhcpServerParams != nil {
		s = append(s, "DhcpServerParams: "+fmt.Sprintf("%#v", this.DhcpServerParams)+",\n")
	}
	s = append(s, "NetworkConfig: "+fmt.Sprintf("%#v", this.NetworkConfig)+",\n")
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%#v: %#v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	if this.InterfaceIpMap != nil {
		s = append(s, "InterfaceIpMap: "+mapStringForInterfaceIpMap+",\n")
	}
	s = append(s, "IsPrimary: "+fmt.Sprintf("%#v", this.IsPrimary)+",\n")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_DedicatedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_DedicatedInterface{` +
		`DedicatedInterface:` + fmt.Sprintf("%#v", this.DedicatedInterface) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_EthernetInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_EthernetInterface{` +
		`EthernetInterface:` + fmt.Sprintf("%#v", this.EthernetInterface) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_TunnelInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_TunnelInterface{` +
		`TunnelInterface:` + fmt.Sprintf("%#v", this.TunnelInterface) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Legacy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_Legacy{` +
		`Legacy:` + fmt.Sprintf("%#v", this.Legacy) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DedicatedManagementInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_DedicatedManagementInterface{` +
		`DedicatedManagementInterface:` + fmt.Sprintf("%#v", this.DedicatedManagementInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&network_interface.CreateSpecType{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_DedicatedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_DedicatedInterface{` +
		`DedicatedInterface:` + fmt.Sprintf("%#v", this.DedicatedInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_EthernetInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_EthernetInterface{` +
		`EthernetInterface:` + fmt.Sprintf("%#v", this.EthernetInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_TunnelInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_TunnelInterface{` +
		`TunnelInterface:` + fmt.Sprintf("%#v", this.TunnelInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_LegacyInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_LegacyInterface{` +
		`LegacyInterface:` + fmt.Sprintf("%#v", this.LegacyInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DedicatedManagementInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_DedicatedManagementInterface{` +
		`DedicatedManagementInterface:` + fmt.Sprintf("%#v", this.DedicatedManagementInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&network_interface.ReplaceSpecType{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_DedicatedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_DedicatedInterface{` +
		`DedicatedInterface:` + fmt.Sprintf("%#v", this.DedicatedInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_EthernetInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_EthernetInterface{` +
		`EthernetInterface:` + fmt.Sprintf("%#v", this.EthernetInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_TunnelInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_TunnelInterface{` +
		`TunnelInterface:` + fmt.Sprintf("%#v", this.TunnelInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LegacyInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_LegacyInterface{` +
		`LegacyInterface:` + fmt.Sprintf("%#v", this.LegacyInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DedicatedManagementInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_DedicatedManagementInterface{` +
		`DedicatedManagementInterface:` + fmt.Sprintf("%#v", this.DedicatedManagementInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&network_interface.GetSpecType{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_DedicatedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_DedicatedInterface{` +
		`DedicatedInterface:` + fmt.Sprintf("%#v", this.DedicatedInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType_EthernetInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_EthernetInterface{` +
		`EthernetInterface:` + fmt.Sprintf("%#v", this.EthernetInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType_TunnelInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_TunnelInterface{` +
		`TunnelInterface:` + fmt.Sprintf("%#v", this.TunnelInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LegacyInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_LegacyInterface{` +
		`LegacyInterface:` + fmt.Sprintf("%#v", this.LegacyInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DedicatedManagementInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_DedicatedManagementInterface{` +
		`DedicatedManagementInterface:` + fmt.Sprintf("%#v", this.DedicatedManagementInterface) + `}`}, ", ")
	return s
}
func (this *NetworkInterfaceStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.NetworkInterfaceStatus{")
	s = append(s, "UpDown: "+fmt.Sprintf("%#v", this.UpDown)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NetworkInterfaceDFGW) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceDFGW) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DefaultGatewayMode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultGatewayMode))
	}
	if m.DefaultGatewayAddress != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultGatewayAddress.Size()))
		n1, err := m.DefaultGatewayAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *NetworkInterfaceDNS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceDNS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DnsMode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsMode))
	}
	if len(m.DnsServer) > 0 {
		for _, msg := range m.DnsServer {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NetworkInterfaceTunnel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceTunnel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tunnel) > 0 {
		for _, msg := range m.Tunnel {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DHCPPoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPPoolType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StartIp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StartIp)))
		i += copy(dAtA[i:], m.StartIp)
	}
	if len(m.EndIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndIp)))
		i += copy(dAtA[i:], m.EndIp)
	}
	if m.Exclude {
		dAtA[i] = 0x18
		i++
		if m.Exclude {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DHCPNetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPNetworkType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		nn2, err := m.NetworkPrefixChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	if len(m.Pools) > 0 {
		for _, msg := range m.Pools {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GatewayChoice != nil {
		nn3, err := m.GatewayChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if m.DnsChoice != nil {
		nn4, err := m.DnsChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.PoolSettings != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PoolSettings))
	}
	return i, nil
}

func (m *DHCPNetworkType_NetworkPrefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkPrefix)))
	i += copy(dAtA[i:], m.NetworkPrefix)
	return i, nil
}
func (m *DHCPNetworkType_NetworkPrefixAllocator) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetworkPrefixAllocator != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkPrefixAllocator.Size()))
		n5, err := m.NetworkPrefixAllocator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *DHCPNetworkType_FirstAddress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FirstAddress != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.FirstAddress.Size()))
		n6, err := m.FirstAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *DHCPNetworkType_LastAddress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LastAddress != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LastAddress.Size()))
		n7, err := m.LastAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *DHCPNetworkType_DgwAddress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x42
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DgwAddress)))
	i += copy(dAtA[i:], m.DgwAddress)
	return i, nil
}
func (m *DHCPNetworkType_SameAsDgw) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SameAsDgw != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SameAsDgw.Size()))
		n8, err := m.SameAsDgw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *DHCPNetworkType_DnsAddress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x5a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsAddress)))
	i += copy(dAtA[i:], m.DnsAddress)
	return i, nil
}
func (m *DHCPInterfaceIPType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPInterfaceIPType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		keysForInterfaceIpMap := make([]string, 0, len(m.InterfaceIpMap))
		for k, _ := range m.InterfaceIpMap {
			keysForInterfaceIpMap = append(keysForInterfaceIpMap, string(k))
		}
		sortkeys.Strings(keysForInterfaceIpMap)
		for _, k := range keysForInterfaceIpMap {
			dAtA[i] = 0xa
			i++
			v := m.InterfaceIpMap[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *DHCPServerParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPServerParametersType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DhcpNetworks) > 0 {
		for _, msg := range m.DhcpNetworks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InterfacesAddressingChoice != nil {
		nn9, err := m.InterfacesAddressingChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	if len(m.FixedIpMap) > 0 {
		keysForFixedIpMap := make([]string, 0, len(m.FixedIpMap))
		for k, _ := range m.FixedIpMap {
			keysForFixedIpMap = append(keysForFixedIpMap, string(k))
		}
		sortkeys.Strings(keysForFixedIpMap)
		for _, k := range keysForFixedIpMap {
			dAtA[i] = 0x32
			i++
			v := m.FixedIpMap[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.DhcpOption82Tag) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DhcpOption82Tag)))
		i += copy(dAtA[i:], m.DhcpOption82Tag)
	}
	return i, nil
}

func (m *DHCPServerParametersType_AutomaticFromStart) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AutomaticFromStart != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AutomaticFromStart.Size()))
		n10, err := m.AutomaticFromStart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *DHCPServerParametersType_AutomaticFromEnd) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AutomaticFromEnd != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AutomaticFromEnd.Size()))
		n11, err := m.AutomaticFromEnd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *DHCPServerParametersType_InterfaceIpMap) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InterfaceIpMap != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InterfaceIpMap.Size()))
		n12, err := m.InterfaceIpMap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *StaticIpParametersNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticIpParametersNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if len(m.DefaultGw) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultGw)))
		i += copy(dAtA[i:], m.DefaultGw)
	}
	if len(m.DnsServer) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsServer)))
		i += copy(dAtA[i:], m.DnsServer)
	}
	return i, nil
}

func (m *StaticIpParametersClusterType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticIpParametersClusterType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		keysForInterfaceIpMap := make([]string, 0, len(m.InterfaceIpMap))
		for k, _ := range m.InterfaceIpMap {
			keysForInterfaceIpMap = append(keysForInterfaceIpMap, string(k))
		}
		sortkeys.Strings(keysForInterfaceIpMap)
		for _, k := range keysForInterfaceIpMap {
			dAtA[i] = 0xa
			i++
			v := m.InterfaceIpMap[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	return i, nil
}

func (m *StaticIpParametersFleetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticIpParametersFleetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkPrefixAllocator != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkPrefixAllocator.Size()))
		n14, err := m.NetworkPrefixAllocator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.DefaultGw) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultGw)))
		i += copy(dAtA[i:], m.DefaultGw)
	}
	if len(m.DnsServer) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsServer)))
		i += copy(dAtA[i:], m.DnsServer)
	}
	return i, nil
}

func (m *StaticIPParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticIPParametersType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		nn15, err := m.NetworkPrefixChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	return i, nil
}

func (m *StaticIPParametersType_NodeStaticIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NodeStaticIp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NodeStaticIp.Size()))
		n16, err := m.NodeStaticIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *StaticIPParametersType_ClusterStaticIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ClusterStaticIp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClusterStaticIp.Size()))
		n17, err := m.ClusterStaticIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *StaticIPParametersType_FleetStaticIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FleetStaticIp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.FleetStaticIp.Size()))
		n18, err := m.FleetStaticIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *DedicatedInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DedicatedInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Device) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i += copy(dAtA[i:], m.Device)
	}
	if m.NodeChoice != nil {
		nn19, err := m.NodeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn19
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
	}
	if m.PrimaryChoice != nil {
		nn20, err := m.PrimaryChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	return i, nil
}

func (m *DedicatedInterfaceType_Cluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Cluster != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Cluster.Size()))
		n21, err := m.Cluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *DedicatedInterfaceType_Node) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
	i += copy(dAtA[i:], m.Node)
	return i, nil
}
func (m *DedicatedInterfaceType_NotPrimary) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NotPrimary != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NotPrimary.Size()))
		n22, err := m.NotPrimary.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *DedicatedInterfaceType_IsPrimary) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IsPrimary != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IsPrimary.Size()))
		n23, err := m.IsPrimary.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *DedicatedManagementInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DedicatedManagementInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Device) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i += copy(dAtA[i:], m.Device)
	}
	if m.NodeChoice != nil {
		nn24, err := m.NodeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
	}
	return i, nil
}

func (m *DedicatedManagementInterfaceType_Cluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Cluster != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Cluster.Size()))
		n25, err := m.Cluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *DedicatedManagementInterfaceType_Node) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
	i += copy(dAtA[i:], m.Node)
	return i, nil
}
func (m *EthernetInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthernetInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Device) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i += copy(dAtA[i:], m.Device)
	}
	if m.NodeChoice != nil {
		nn26, err := m.NodeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	if m.VlanChoice != nil {
		nn27, err := m.VlanChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn27
	}
	if m.AddressChoice != nil {
		nn28, err := m.AddressChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn28
	}
	if m.NetworkChoice != nil {
		nn29, err := m.NetworkChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn29
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
	}
	if m.PrimaryChoice != nil {
		nn30, err := m.PrimaryChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn30
	}
	return i, nil
}

func (m *EthernetInterfaceType_Cluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Cluster != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Cluster.Size()))
		n31, err := m.Cluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *EthernetInterfaceType_Node) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
	i += copy(dAtA[i:], m.Node)
	return i, nil
}
func (m *EthernetInterfaceType_Untagged) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Untagged != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Untagged.Size()))
		n32, err := m.Untagged.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *EthernetInterfaceType_VlanId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x38
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.VlanId))
	return i, nil
}
func (m *EthernetInterfaceType_DhcpClient) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DhcpClient != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DhcpClient.Size()))
		n33, err := m.DhcpClient.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *EthernetInterfaceType_DhcpServer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DhcpServer != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DhcpServer.Size()))
		n34, err := m.DhcpServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *EthernetInterfaceType_StaticIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StaticIp != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StaticIp.Size()))
		n35, err := m.StaticIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *EthernetInterfaceType_SiteLocalNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SiteLocalNetwork != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteLocalNetwork.Size()))
		n36, err := m.SiteLocalNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *EthernetInterfaceType_SiteLocalInsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SiteLocalInsideNetwork != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteLocalInsideNetwork.Size()))
		n37, err := m.SiteLocalInsideNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *EthernetInterfaceType_InsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InsideNetwork != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InsideNetwork.Size()))
		n38, err := m.InsideNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *EthernetInterfaceType_NotPrimary) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NotPrimary != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NotPrimary.Size()))
		n39, err := m.NotPrimary.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *EthernetInterfaceType_IsPrimary) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IsPrimary != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IsPrimary.Size()))
		n40, err := m.IsPrimary.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *EthernetInterfaceType_StorageNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageNetwork != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageNetwork.Size()))
		n41, err := m.StorageNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *TunnelInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeChoice != nil {
		nn42, err := m.NodeChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn42
	}
	if m.Tunnel != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Tunnel.Size()))
		n43, err := m.Tunnel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.StaticIp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StaticIp.Size()))
		n44, err := m.StaticIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.NetworkChoice != nil {
		nn45, err := m.NetworkChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn45
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
	}
	return i, nil
}

func (m *TunnelInterfaceType_Cluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Cluster != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Cluster.Size()))
		n46, err := m.Cluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func (m *TunnelInterfaceType_Node) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
	i += copy(dAtA[i:], m.Node)
	return i, nil
}
func (m *TunnelInterfaceType_SiteLocalNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SiteLocalNetwork != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteLocalNetwork.Size()))
		n47, err := m.SiteLocalNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}
func (m *TunnelInterfaceType_SiteLocalInsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SiteLocalInsideNetwork != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteLocalInsideNetwork.Size()))
		n48, err := m.SiteLocalInsideNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *TunnelInterfaceType_InsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InsideNetwork != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InsideNetwork.Size()))
		n49, err := m.InsideNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *LegacyInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LegacyInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, msg := range m.VirtualNetwork {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DhcpAddress != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DhcpAddress))
	}
	if len(m.StaticAddresses) > 0 {
		for _, msg := range m.StaticAddresses {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DefaultGateway != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultGateway.Size()))
		n50, err := m.DefaultGateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.DNSServer != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DNSServer.Size()))
		n51, err := m.DNSServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.DHCPServer != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DHCPServer))
	}
	if m.VlanTagging != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTagging))
	}
	if len(m.DeviceName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceName)))
		i += copy(dAtA[i:], m.DeviceName)
	}
	if m.VlanTag != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTag))
	}
	if m.Tunnel != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Tunnel.Size()))
		n52, err := m.Tunnel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.Priority != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
	}
	if len(m.AddressAllocator) > 0 {
		for _, msg := range m.AddressAllocator {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, msg := range m.VirtualNetwork {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DhcpAddress != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DhcpAddress))
	}
	if len(m.StaticAddresses) > 0 {
		for _, msg := range m.StaticAddresses {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DefaultGateway != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultGateway.Size()))
		n53, err := m.DefaultGateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.DNSServer != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DNSServer.Size()))
		n54, err := m.DNSServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.DHCPServer != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DHCPServer))
	}
	if m.VlanTagging != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTagging))
	}
	if len(m.DeviceName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceName)))
		i += copy(dAtA[i:], m.DeviceName)
	}
	if len(m.ParentNetworkInterface) > 0 {
		for _, msg := range m.ParentNetworkInterface {
			dAtA[i] = 0x62
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.VlanTag != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTag))
	}
	if m.Tunnel != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Tunnel.Size()))
		n55, err := m.Tunnel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.Priority != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
	}
	if len(m.AddressAllocator) > 0 {
		for _, msg := range m.AddressAllocator {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DhcpServerParams != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DhcpServerParams.Size()))
		n56, err := m.DhcpServerParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.NetworkConfig != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkConfig))
	}
	if len(m.InterfaceIpMap) > 0 {
		keysForInterfaceIpMap := make([]string, 0, len(m.InterfaceIpMap))
		for k, _ := range m.InterfaceIpMap {
			keysForInterfaceIpMap = append(keysForInterfaceIpMap, string(k))
		}
		sortkeys.Strings(keysForInterfaceIpMap)
		for _, k := range keysForInterfaceIpMap {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			v := m.InterfaceIpMap[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.IsPrimary {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.IsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InterfaceChoice != nil {
		nn57, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn57
	}
	return i, nil
}

func (m *GlobalSpecType_DedicatedInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DedicatedInterface != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DedicatedInterface.Size()))
		n58, err := m.DedicatedInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}
func (m *GlobalSpecType_EthernetInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EthernetInterface != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EthernetInterface.Size()))
		n59, err := m.EthernetInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}
func (m *GlobalSpecType_TunnelInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TunnelInterface != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelInterface.Size()))
		n60, err := m.TunnelInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}
func (m *GlobalSpecType_Legacy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Legacy != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Legacy.Size()))
		n61, err := m.Legacy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}
func (m *GlobalSpecType_DedicatedManagementInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DedicatedManagementInterface != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DedicatedManagementInterface.Size()))
		n62, err := m.DedicatedManagementInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		nn63, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn63
	}
	return i, nil
}

func (m *CreateSpecType_DedicatedInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DedicatedInterface != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DedicatedInterface.Size()))
		n64, err := m.DedicatedInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}
func (m *CreateSpecType_EthernetInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EthernetInterface != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EthernetInterface.Size()))
		n65, err := m.EthernetInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}
func (m *CreateSpecType_TunnelInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TunnelInterface != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelInterface.Size()))
		n66, err := m.TunnelInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	return i, nil
}
func (m *CreateSpecType_LegacyInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LegacyInterface != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LegacyInterface.Size()))
		n67, err := m.LegacyInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}
func (m *CreateSpecType_DedicatedManagementInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DedicatedManagementInterface != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DedicatedManagementInterface.Size()))
		n68, err := m.DedicatedManagementInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		nn69, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn69
	}
	return i, nil
}

func (m *ReplaceSpecType_DedicatedInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DedicatedInterface != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DedicatedInterface.Size()))
		n70, err := m.DedicatedInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}
func (m *ReplaceSpecType_EthernetInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EthernetInterface != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EthernetInterface.Size()))
		n71, err := m.EthernetInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}
func (m *ReplaceSpecType_TunnelInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TunnelInterface != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelInterface.Size()))
		n72, err := m.TunnelInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	return i, nil
}
func (m *ReplaceSpecType_LegacyInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LegacyInterface != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LegacyInterface.Size()))
		n73, err := m.LegacyInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}
func (m *ReplaceSpecType_DedicatedManagementInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DedicatedManagementInterface != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DedicatedManagementInterface.Size()))
		n74, err := m.DedicatedManagementInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		nn75, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn75
	}
	return i, nil
}

func (m *GetSpecType_DedicatedInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DedicatedInterface != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DedicatedInterface.Size()))
		n76, err := m.DedicatedInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}
func (m *GetSpecType_EthernetInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EthernetInterface != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EthernetInterface.Size()))
		n77, err := m.EthernetInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	return i, nil
}
func (m *GetSpecType_TunnelInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TunnelInterface != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelInterface.Size()))
		n78, err := m.TunnelInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}
func (m *GetSpecType_LegacyInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LegacyInterface != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LegacyInterface.Size()))
		n79, err := m.LegacyInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	return i, nil
}
func (m *GetSpecType_DedicatedManagementInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DedicatedManagementInterface != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DedicatedManagementInterface.Size()))
		n80, err := m.DedicatedManagementInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}
func (m *NetworkInterfaceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpDown != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UpDown))
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedNetworkInterfaceDFGW(r randyTypes, easy bool) *NetworkInterfaceDFGW {
	this := &NetworkInterfaceDFGW{}
	this.DefaultGatewayMode = NetworkInterfaceGatewayMode([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(10) != 0 {
		this.DefaultGatewayAddress = ves_io_schema3.NewPopulatedIpv4AddressType(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNetworkInterfaceDNS(r randyTypes, easy bool) *NetworkInterfaceDNS {
	this := &NetworkInterfaceDNS{}
	this.DnsMode = NetworkInterfaceDNSMode([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.DnsServer = make([]*ves_io_schema3.Ipv4AddressType, v1)
		for i := 0; i < v1; i++ {
			this.DnsServer[i] = ves_io_schema3.NewPopulatedIpv4AddressType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNetworkInterfaceTunnel(r randyTypes, easy bool) *NetworkInterfaceTunnel {
	this := &NetworkInterfaceTunnel{}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.Tunnel = make([]*ves_io_schema4.ObjectRefType, v2)
		for i := 0; i < v2; i++ {
			this.Tunnel[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDHCPPoolType(r randyTypes, easy bool) *DHCPPoolType {
	this := &DHCPPoolType{}
	this.StartIp = string(randStringTypes(r))
	this.EndIp = string(randStringTypes(r))
	this.Exclude = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDHCPNetworkType(r randyTypes, easy bool) *DHCPNetworkType {
	this := &DHCPNetworkType{}
	oneofNumber_NetworkPrefixChoice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_NetworkPrefixChoice {
	case 2:
		this.NetworkPrefixChoice = NewPopulatedDHCPNetworkType_NetworkPrefix(r, easy)
	case 3:
		this.NetworkPrefixChoice = NewPopulatedDHCPNetworkType_NetworkPrefixAllocator(r, easy)
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Pools = make([]*DHCPPoolType, v3)
		for i := 0; i < v3; i++ {
			this.Pools[i] = NewPopulatedDHCPPoolType(r, easy)
		}
	}
	oneofNumber_GatewayChoice := []int32{6, 7, 8}[r.Intn(3)]
	switch oneofNumber_GatewayChoice {
	case 6:
		this.GatewayChoice = NewPopulatedDHCPNetworkType_FirstAddress(r, easy)
	case 7:
		this.GatewayChoice = NewPopulatedDHCPNetworkType_LastAddress(r, easy)
	case 8:
		this.GatewayChoice = NewPopulatedDHCPNetworkType_DgwAddress(r, easy)
	}
	oneofNumber_DnsChoice := []int32{10, 11}[r.Intn(2)]
	switch oneofNumber_DnsChoice {
	case 10:
		this.DnsChoice = NewPopulatedDHCPNetworkType_SameAsDgw(r, easy)
	case 11:
		this.DnsChoice = NewPopulatedDHCPNetworkType_DnsAddress(r, easy)
	}
	this.PoolSettings = DHCPPoolSettingType([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDHCPNetworkType_NetworkPrefix(r randyTypes, easy bool) *DHCPNetworkType_NetworkPrefix {
	this := &DHCPNetworkType_NetworkPrefix{}
	this.NetworkPrefix = string(randStringTypes(r))
	return this
}
func NewPopulatedDHCPNetworkType_NetworkPrefixAllocator(r randyTypes, easy bool) *DHCPNetworkType_NetworkPrefixAllocator {
	this := &DHCPNetworkType_NetworkPrefixAllocator{}
	this.NetworkPrefixAllocator = ves_io_schema_views.NewPopulatedObjectRefType(r, easy)
	return this
}
func NewPopulatedDHCPNetworkType_FirstAddress(r randyTypes, easy bool) *DHCPNetworkType_FirstAddress {
	this := &DHCPNetworkType_FirstAddress{}
	this.FirstAddress = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDHCPNetworkType_LastAddress(r randyTypes, easy bool) *DHCPNetworkType_LastAddress {
	this := &DHCPNetworkType_LastAddress{}
	this.LastAddress = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDHCPNetworkType_DgwAddress(r randyTypes, easy bool) *DHCPNetworkType_DgwAddress {
	this := &DHCPNetworkType_DgwAddress{}
	this.DgwAddress = string(randStringTypes(r))
	return this
}
func NewPopulatedDHCPNetworkType_SameAsDgw(r randyTypes, easy bool) *DHCPNetworkType_SameAsDgw {
	this := &DHCPNetworkType_SameAsDgw{}
	this.SameAsDgw = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDHCPNetworkType_DnsAddress(r randyTypes, easy bool) *DHCPNetworkType_DnsAddress {
	this := &DHCPNetworkType_DnsAddress{}
	this.DnsAddress = string(randStringTypes(r))
	return this
}
func NewPopulatedDHCPInterfaceIPType(r randyTypes, easy bool) *DHCPInterfaceIPType {
	this := &DHCPInterfaceIPType{}
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.InterfaceIpMap = make(map[string]string)
		for i := 0; i < v4; i++ {
			this.InterfaceIpMap[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDHCPServerParametersType(r randyTypes, easy bool) *DHCPServerParametersType {
	this := &DHCPServerParametersType{}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.DhcpNetworks = make([]*DHCPNetworkType, v5)
		for i := 0; i < v5; i++ {
			this.DhcpNetworks[i] = NewPopulatedDHCPNetworkType(r, easy)
		}
	}
	oneofNumber_InterfacesAddressingChoice := []int32{3, 4, 5}[r.Intn(3)]
	switch oneofNumber_InterfacesAddressingChoice {
	case 3:
		this.InterfacesAddressingChoice = NewPopulatedDHCPServerParametersType_AutomaticFromStart(r, easy)
	case 4:
		this.InterfacesAddressingChoice = NewPopulatedDHCPServerParametersType_AutomaticFromEnd(r, easy)
	case 5:
		this.InterfacesAddressingChoice = NewPopulatedDHCPServerParametersType_InterfaceIpMap(r, easy)
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(10)
		this.FixedIpMap = make(map[string]string)
		for i := 0; i < v6; i++ {
			this.FixedIpMap[randStringTypes(r)] = randStringTypes(r)
		}
	}
	this.DhcpOption82Tag = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDHCPServerParametersType_AutomaticFromStart(r randyTypes, easy bool) *DHCPServerParametersType_AutomaticFromStart {
	this := &DHCPServerParametersType_AutomaticFromStart{}
	this.AutomaticFromStart = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDHCPServerParametersType_AutomaticFromEnd(r randyTypes, easy bool) *DHCPServerParametersType_AutomaticFromEnd {
	this := &DHCPServerParametersType_AutomaticFromEnd{}
	this.AutomaticFromEnd = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDHCPServerParametersType_InterfaceIpMap(r randyTypes, easy bool) *DHCPServerParametersType_InterfaceIpMap {
	this := &DHCPServerParametersType_InterfaceIpMap{}
	this.InterfaceIpMap = NewPopulatedDHCPInterfaceIPType(r, easy)
	return this
}
func NewPopulatedStaticIpParametersNodeType(r randyTypes, easy bool) *StaticIpParametersNodeType {
	this := &StaticIpParametersNodeType{}
	this.IpAddress = string(randStringTypes(r))
	this.DefaultGw = string(randStringTypes(r))
	this.DnsServer = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStaticIpParametersClusterType(r randyTypes, easy bool) *StaticIpParametersClusterType {
	this := &StaticIpParametersClusterType{}
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.InterfaceIpMap = make(map[string]*StaticIpParametersNodeType)
		for i := 0; i < v7; i++ {
			this.InterfaceIpMap[randStringTypes(r)] = NewPopulatedStaticIpParametersNodeType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStaticIpParametersFleetType(r randyTypes, easy bool) *StaticIpParametersFleetType {
	this := &StaticIpParametersFleetType{}
	if r.Intn(10) != 0 {
		this.NetworkPrefixAllocator = ves_io_schema_views.NewPopulatedObjectRefType(r, easy)
	}
	this.DefaultGw = string(randStringTypes(r))
	this.DnsServer = string(randStringTypes(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStaticIPParametersType(r randyTypes, easy bool) *StaticIPParametersType {
	this := &StaticIPParametersType{}
	oneofNumber_NetworkPrefixChoice := []int32{2, 3, 4}[r.Intn(3)]
	switch oneofNumber_NetworkPrefixChoice {
	case 2:
		this.NetworkPrefixChoice = NewPopulatedStaticIPParametersType_NodeStaticIp(r, easy)
	case 3:
		this.NetworkPrefixChoice = NewPopulatedStaticIPParametersType_ClusterStaticIp(r, easy)
	case 4:
		this.NetworkPrefixChoice = NewPopulatedStaticIPParametersType_FleetStaticIp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStaticIPParametersType_NodeStaticIp(r randyTypes, easy bool) *StaticIPParametersType_NodeStaticIp {
	this := &StaticIPParametersType_NodeStaticIp{}
	this.NodeStaticIp = NewPopulatedStaticIpParametersNodeType(r, easy)
	return this
}
func NewPopulatedStaticIPParametersType_ClusterStaticIp(r randyTypes, easy bool) *StaticIPParametersType_ClusterStaticIp {
	this := &StaticIPParametersType_ClusterStaticIp{}
	this.ClusterStaticIp = NewPopulatedStaticIpParametersClusterType(r, easy)
	return this
}
func NewPopulatedStaticIPParametersType_FleetStaticIp(r randyTypes, easy bool) *StaticIPParametersType_FleetStaticIp {
	this := &StaticIPParametersType_FleetStaticIp{}
	this.FleetStaticIp = NewPopulatedStaticIpParametersFleetType(r, easy)
	return this
}
func NewPopulatedDedicatedInterfaceType(r randyTypes, easy bool) *DedicatedInterfaceType {
	this := &DedicatedInterfaceType{}
	this.Device = string(randStringTypes(r))
	oneofNumber_NodeChoice := []int32{3, 4}[r.Intn(2)]
	switch oneofNumber_NodeChoice {
	case 3:
		this.NodeChoice = NewPopulatedDedicatedInterfaceType_Cluster(r, easy)
	case 4:
		this.NodeChoice = NewPopulatedDedicatedInterfaceType_Node(r, easy)
	}
	this.Mtu = uint32(r.Uint32())
	this.Priority = uint32(r.Uint32())
	oneofNumber_PrimaryChoice := []int32{11, 12}[r.Intn(2)]
	switch oneofNumber_PrimaryChoice {
	case 11:
		this.PrimaryChoice = NewPopulatedDedicatedInterfaceType_NotPrimary(r, easy)
	case 12:
		this.PrimaryChoice = NewPopulatedDedicatedInterfaceType_IsPrimary(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDedicatedInterfaceType_Cluster(r randyTypes, easy bool) *DedicatedInterfaceType_Cluster {
	this := &DedicatedInterfaceType_Cluster{}
	this.Cluster = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDedicatedInterfaceType_Node(r randyTypes, easy bool) *DedicatedInterfaceType_Node {
	this := &DedicatedInterfaceType_Node{}
	this.Node = string(randStringTypes(r))
	return this
}
func NewPopulatedDedicatedInterfaceType_NotPrimary(r randyTypes, easy bool) *DedicatedInterfaceType_NotPrimary {
	this := &DedicatedInterfaceType_NotPrimary{}
	this.NotPrimary = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDedicatedInterfaceType_IsPrimary(r randyTypes, easy bool) *DedicatedInterfaceType_IsPrimary {
	this := &DedicatedInterfaceType_IsPrimary{}
	this.IsPrimary = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDedicatedManagementInterfaceType(r randyTypes, easy bool) *DedicatedManagementInterfaceType {
	this := &DedicatedManagementInterfaceType{}
	this.Device = string(randStringTypes(r))
	oneofNumber_NodeChoice := []int32{3, 4}[r.Intn(2)]
	switch oneofNumber_NodeChoice {
	case 3:
		this.NodeChoice = NewPopulatedDedicatedManagementInterfaceType_Cluster(r, easy)
	case 4:
		this.NodeChoice = NewPopulatedDedicatedManagementInterfaceType_Node(r, easy)
	}
	this.Mtu = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDedicatedManagementInterfaceType_Cluster(r randyTypes, easy bool) *DedicatedManagementInterfaceType_Cluster {
	this := &DedicatedManagementInterfaceType_Cluster{}
	this.Cluster = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedDedicatedManagementInterfaceType_Node(r randyTypes, easy bool) *DedicatedManagementInterfaceType_Node {
	this := &DedicatedManagementInterfaceType_Node{}
	this.Node = string(randStringTypes(r))
	return this
}
func NewPopulatedEthernetInterfaceType(r randyTypes, easy bool) *EthernetInterfaceType {
	this := &EthernetInterfaceType{}
	this.Device = string(randStringTypes(r))
	oneofNumber_NodeChoice := []int32{3, 4}[r.Intn(2)]
	switch oneofNumber_NodeChoice {
	case 3:
		this.NodeChoice = NewPopulatedEthernetInterfaceType_Cluster(r, easy)
	case 4:
		this.NodeChoice = NewPopulatedEthernetInterfaceType_Node(r, easy)
	}
	oneofNumber_VlanChoice := []int32{6, 7}[r.Intn(2)]
	switch oneofNumber_VlanChoice {
	case 6:
		this.VlanChoice = NewPopulatedEthernetInterfaceType_Untagged(r, easy)
	case 7:
		this.VlanChoice = NewPopulatedEthernetInterfaceType_VlanId(r, easy)
	}
	oneofNumber_AddressChoice := []int32{9, 10, 11}[r.Intn(3)]
	switch oneofNumber_AddressChoice {
	case 9:
		this.AddressChoice = NewPopulatedEthernetInterfaceType_DhcpClient(r, easy)
	case 10:
		this.AddressChoice = NewPopulatedEthernetInterfaceType_DhcpServer(r, easy)
	case 11:
		this.AddressChoice = NewPopulatedEthernetInterfaceType_StaticIp(r, easy)
	}
	oneofNumber_NetworkChoice := []int32{13, 14, 15, 21}[r.Intn(4)]
	switch oneofNumber_NetworkChoice {
	case 13:
		this.NetworkChoice = NewPopulatedEthernetInterfaceType_SiteLocalNetwork(r, easy)
	case 14:
		this.NetworkChoice = NewPopulatedEthernetInterfaceType_SiteLocalInsideNetwork(r, easy)
	case 15:
		this.NetworkChoice = NewPopulatedEthernetInterfaceType_InsideNetwork(r, easy)
	case 21:
		this.NetworkChoice = NewPopulatedEthernetInterfaceType_StorageNetwork(r, easy)
	}
	this.Mtu = uint32(r.Uint32())
	this.Priority = uint32(r.Uint32())
	oneofNumber_PrimaryChoice := []int32{19, 20}[r.Intn(2)]
	switch oneofNumber_PrimaryChoice {
	case 19:
		this.PrimaryChoice = NewPopulatedEthernetInterfaceType_NotPrimary(r, easy)
	case 20:
		this.PrimaryChoice = NewPopulatedEthernetInterfaceType_IsPrimary(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEthernetInterfaceType_Cluster(r randyTypes, easy bool) *EthernetInterfaceType_Cluster {
	this := &EthernetInterfaceType_Cluster{}
	this.Cluster = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_Node(r randyTypes, easy bool) *EthernetInterfaceType_Node {
	this := &EthernetInterfaceType_Node{}
	this.Node = string(randStringTypes(r))
	return this
}
func NewPopulatedEthernetInterfaceType_Untagged(r randyTypes, easy bool) *EthernetInterfaceType_Untagged {
	this := &EthernetInterfaceType_Untagged{}
	this.Untagged = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_VlanId(r randyTypes, easy bool) *EthernetInterfaceType_VlanId {
	this := &EthernetInterfaceType_VlanId{}
	this.VlanId = uint32(r.Uint32())
	return this
}
func NewPopulatedEthernetInterfaceType_DhcpClient(r randyTypes, easy bool) *EthernetInterfaceType_DhcpClient {
	this := &EthernetInterfaceType_DhcpClient{}
	this.DhcpClient = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_DhcpServer(r randyTypes, easy bool) *EthernetInterfaceType_DhcpServer {
	this := &EthernetInterfaceType_DhcpServer{}
	this.DhcpServer = NewPopulatedDHCPServerParametersType(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_StaticIp(r randyTypes, easy bool) *EthernetInterfaceType_StaticIp {
	this := &EthernetInterfaceType_StaticIp{}
	this.StaticIp = NewPopulatedStaticIPParametersType(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_SiteLocalNetwork(r randyTypes, easy bool) *EthernetInterfaceType_SiteLocalNetwork {
	this := &EthernetInterfaceType_SiteLocalNetwork{}
	this.SiteLocalNetwork = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_SiteLocalInsideNetwork(r randyTypes, easy bool) *EthernetInterfaceType_SiteLocalInsideNetwork {
	this := &EthernetInterfaceType_SiteLocalInsideNetwork{}
	this.SiteLocalInsideNetwork = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_InsideNetwork(r randyTypes, easy bool) *EthernetInterfaceType_InsideNetwork {
	this := &EthernetInterfaceType_InsideNetwork{}
	this.InsideNetwork = ves_io_schema_views.NewPopulatedObjectRefType(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_NotPrimary(r randyTypes, easy bool) *EthernetInterfaceType_NotPrimary {
	this := &EthernetInterfaceType_NotPrimary{}
	this.NotPrimary = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_IsPrimary(r randyTypes, easy bool) *EthernetInterfaceType_IsPrimary {
	this := &EthernetInterfaceType_IsPrimary{}
	this.IsPrimary = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedEthernetInterfaceType_StorageNetwork(r randyTypes, easy bool) *EthernetInterfaceType_StorageNetwork {
	this := &EthernetInterfaceType_StorageNetwork{}
	this.StorageNetwork = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedTunnelInterfaceType(r randyTypes, easy bool) *TunnelInterfaceType {
	this := &TunnelInterfaceType{}
	oneofNumber_NodeChoice := []int32{2, 3}[r.Intn(2)]
	switch oneofNumber_NodeChoice {
	case 2:
		this.NodeChoice = NewPopulatedTunnelInterfaceType_Cluster(r, easy)
	case 3:
		this.NodeChoice = NewPopulatedTunnelInterfaceType_Node(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Tunnel = ves_io_schema_views.NewPopulatedObjectRefType(r, easy)
	}
	if r.Intn(10) != 0 {
		this.StaticIp = NewPopulatedStaticIPParametersType(r, easy)
	}
	oneofNumber_NetworkChoice := []int32{7, 8, 9}[r.Intn(3)]
	switch oneofNumber_NetworkChoice {
	case 7:
		this.NetworkChoice = NewPopulatedTunnelInterfaceType_SiteLocalNetwork(r, easy)
	case 8:
		this.NetworkChoice = NewPopulatedTunnelInterfaceType_SiteLocalInsideNetwork(r, easy)
	case 9:
		this.NetworkChoice = NewPopulatedTunnelInterfaceType_InsideNetwork(r, easy)
	}
	this.Mtu = uint32(r.Uint32())
	this.Priority = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTunnelInterfaceType_Cluster(r randyTypes, easy bool) *TunnelInterfaceType_Cluster {
	this := &TunnelInterfaceType_Cluster{}
	this.Cluster = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedTunnelInterfaceType_Node(r randyTypes, easy bool) *TunnelInterfaceType_Node {
	this := &TunnelInterfaceType_Node{}
	this.Node = string(randStringTypes(r))
	return this
}
func NewPopulatedTunnelInterfaceType_SiteLocalNetwork(r randyTypes, easy bool) *TunnelInterfaceType_SiteLocalNetwork {
	this := &TunnelInterfaceType_SiteLocalNetwork{}
	this.SiteLocalNetwork = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedTunnelInterfaceType_SiteLocalInsideNetwork(r randyTypes, easy bool) *TunnelInterfaceType_SiteLocalInsideNetwork {
	this := &TunnelInterfaceType_SiteLocalInsideNetwork{}
	this.SiteLocalInsideNetwork = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedTunnelInterfaceType_InsideNetwork(r randyTypes, easy bool) *TunnelInterfaceType_InsideNetwork {
	this := &TunnelInterfaceType_InsideNetwork{}
	this.InsideNetwork = ves_io_schema_views.NewPopulatedObjectRefType(r, easy)
	return this
}
func NewPopulatedLegacyInterfaceType(r randyTypes, easy bool) *LegacyInterfaceType {
	this := &LegacyInterfaceType{}
	this.Type = NetworkInterfaceType([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.Mtu = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.VirtualNetwork = make([]*ves_io_schema4.ObjectRefType, v8)
		for i := 0; i < v8; i++ {
			this.VirtualNetwork[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	this.DhcpAddress = NetworkInterfaceDHCP([]int32{0, 1}[r.Intn(2)])
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.StaticAddresses = make([]*ves_io_schema3.Ipv4SubnetType, v9)
		for i := 0; i < v9; i++ {
			this.StaticAddresses[i] = ves_io_schema3.NewPopulatedIpv4SubnetType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.DefaultGateway = NewPopulatedNetworkInterfaceDFGW(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DNSServer = NewPopulatedNetworkInterfaceDNS(r, easy)
	}
	this.DHCPServer = NetworkInterfaceDHCPServer([]int32{0, 1, 2}[r.Intn(3)])
	this.VlanTagging = NetworkInterfaceVLANTagging([]int32{0, 1}[r.Intn(2)])
	this.DeviceName = string(randStringTypes(r))
	this.VlanTag = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.Tunnel = NewPopulatedNetworkInterfaceTunnel(r, easy)
	}
	this.Priority = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.AddressAllocator = make([]*ves_io_schema4.ObjectRefType, v10)
		for i := 0; i < v10; i++ {
			this.AddressAllocator[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType(r randyTypes, easy bool) *GlobalSpecType {
	this := &GlobalSpecType{}
	this.Type = NetworkInterfaceType([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.Mtu = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v11 := r.Intn(5)
		this.VirtualNetwork = make([]*ves_io_schema4.ObjectRefType, v11)
		for i := 0; i < v11; i++ {
			this.VirtualNetwork[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	this.DhcpAddress = NetworkInterfaceDHCP([]int32{0, 1}[r.Intn(2)])
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.StaticAddresses = make([]*ves_io_schema3.Ipv4SubnetType, v12)
		for i := 0; i < v12; i++ {
			this.StaticAddresses[i] = ves_io_schema3.NewPopulatedIpv4SubnetType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.DefaultGateway = NewPopulatedNetworkInterfaceDFGW(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DNSServer = NewPopulatedNetworkInterfaceDNS(r, easy)
	}
	this.DHCPServer = NetworkInterfaceDHCPServer([]int32{0, 1, 2}[r.Intn(3)])
	this.VlanTagging = NetworkInterfaceVLANTagging([]int32{0, 1}[r.Intn(2)])
	this.DeviceName = string(randStringTypes(r))
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.ParentNetworkInterface = make([]*ves_io_schema4.ObjectRefType, v13)
		for i := 0; i < v13; i++ {
			this.ParentNetworkInterface[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	this.VlanTag = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.Tunnel = NewPopulatedNetworkInterfaceTunnel(r, easy)
	}
	this.Priority = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v14 := r.Intn(5)
		this.AddressAllocator = make([]*ves_io_schema4.ObjectRefType, v14)
		for i := 0; i < v14; i++ {
			this.AddressAllocator[i] = ves_io_schema4.NewPopulatedObjectRefType(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.DhcpServerParams = NewPopulatedDHCPServerParametersType(r, easy)
	}
	this.NetworkConfig = InterfaceNetworkType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if r.Intn(10) != 0 {
		v15 := r.Intn(10)
		this.InterfaceIpMap = make(map[string]string)
		for i := 0; i < v15; i++ {
			this.InterfaceIpMap[randStringTypes(r)] = randStringTypes(r)
		}
	}
	this.IsPrimary = bool(bool(r.Intn(2) == 0))
	oneofNumber_InterfaceChoice := []int32{1001, 1002, 1003, 1004, 1005}[r.Intn(5)]
	switch oneofNumber_InterfaceChoice {
	case 1001:
		this.InterfaceChoice = NewPopulatedGlobalSpecType_DedicatedInterface(r, easy)
	case 1002:
		this.InterfaceChoice = NewPopulatedGlobalSpecType_EthernetInterface(r, easy)
	case 1003:
		this.InterfaceChoice = NewPopulatedGlobalSpecType_TunnelInterface(r, easy)
	case 1004:
		this.InterfaceChoice = NewPopulatedGlobalSpecType_Legacy(r, easy)
	case 1005:
		this.InterfaceChoice = NewPopulatedGlobalSpecType_DedicatedManagementInterface(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGlobalSpecType_DedicatedInterface(r randyTypes, easy bool) *GlobalSpecType_DedicatedInterface {
	this := &GlobalSpecType_DedicatedInterface{}
	this.DedicatedInterface = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_EthernetInterface(r randyTypes, easy bool) *GlobalSpecType_EthernetInterface {
	this := &GlobalSpecType_EthernetInterface{}
	this.EthernetInterface = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_TunnelInterface(r randyTypes, easy bool) *GlobalSpecType_TunnelInterface {
	this := &GlobalSpecType_TunnelInterface{}
	this.TunnelInterface = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_Legacy(r randyTypes, easy bool) *GlobalSpecType_Legacy {
	this := &GlobalSpecType_Legacy{}
	this.Legacy = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedGlobalSpecType_DedicatedManagementInterface(r randyTypes, easy bool) *GlobalSpecType_DedicatedManagementInterface {
	this := &GlobalSpecType_DedicatedManagementInterface{}
	this.DedicatedManagementInterface = ves_io_schema4.NewPopulatedEmpty(r, easy)
	return this
}
func NewPopulatedCreateSpecType(r randyTypes, easy bool) *CreateSpecType {
	this := &CreateSpecType{}
	oneofNumber_InterfaceChoice := []int32{18, 19, 20, 21, 22}[r.Intn(5)]
	switch oneofNumber_InterfaceChoice {
	case 18:
		this.InterfaceChoice = NewPopulatedCreateSpecType_DedicatedInterface(r, easy)
	case 19:
		this.InterfaceChoice = NewPopulatedCreateSpecType_EthernetInterface(r, easy)
	case 20:
		this.InterfaceChoice = NewPopulatedCreateSpecType_TunnelInterface(r, easy)
	case 21:
		this.InterfaceChoice = NewPopulatedCreateSpecType_LegacyInterface(r, easy)
	case 22:
		this.InterfaceChoice = NewPopulatedCreateSpecType_DedicatedManagementInterface(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCreateSpecType_DedicatedInterface(r randyTypes, easy bool) *CreateSpecType_DedicatedInterface {
	this := &CreateSpecType_DedicatedInterface{}
	this.DedicatedInterface = NewPopulatedDedicatedInterfaceType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_EthernetInterface(r randyTypes, easy bool) *CreateSpecType_EthernetInterface {
	this := &CreateSpecType_EthernetInterface{}
	this.EthernetInterface = NewPopulatedEthernetInterfaceType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_TunnelInterface(r randyTypes, easy bool) *CreateSpecType_TunnelInterface {
	this := &CreateSpecType_TunnelInterface{}
	this.TunnelInterface = NewPopulatedTunnelInterfaceType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_LegacyInterface(r randyTypes, easy bool) *CreateSpecType_LegacyInterface {
	this := &CreateSpecType_LegacyInterface{}
	this.LegacyInterface = NewPopulatedLegacyInterfaceType(r, easy)
	return this
}
func NewPopulatedCreateSpecType_DedicatedManagementInterface(r randyTypes, easy bool) *CreateSpecType_DedicatedManagementInterface {
	this := &CreateSpecType_DedicatedManagementInterface{}
	this.DedicatedManagementInterface = NewPopulatedDedicatedManagementInterfaceType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType(r randyTypes, easy bool) *ReplaceSpecType {
	this := &ReplaceSpecType{}
	oneofNumber_InterfaceChoice := []int32{18, 19, 20, 21, 22}[r.Intn(5)]
	switch oneofNumber_InterfaceChoice {
	case 18:
		this.InterfaceChoice = NewPopulatedReplaceSpecType_DedicatedInterface(r, easy)
	case 19:
		this.InterfaceChoice = NewPopulatedReplaceSpecType_EthernetInterface(r, easy)
	case 20:
		this.InterfaceChoice = NewPopulatedReplaceSpecType_TunnelInterface(r, easy)
	case 21:
		this.InterfaceChoice = NewPopulatedReplaceSpecType_LegacyInterface(r, easy)
	case 22:
		this.InterfaceChoice = NewPopulatedReplaceSpecType_DedicatedManagementInterface(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplaceSpecType_DedicatedInterface(r randyTypes, easy bool) *ReplaceSpecType_DedicatedInterface {
	this := &ReplaceSpecType_DedicatedInterface{}
	this.DedicatedInterface = NewPopulatedDedicatedInterfaceType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_EthernetInterface(r randyTypes, easy bool) *ReplaceSpecType_EthernetInterface {
	this := &ReplaceSpecType_EthernetInterface{}
	this.EthernetInterface = NewPopulatedEthernetInterfaceType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_TunnelInterface(r randyTypes, easy bool) *ReplaceSpecType_TunnelInterface {
	this := &ReplaceSpecType_TunnelInterface{}
	this.TunnelInterface = NewPopulatedTunnelInterfaceType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_LegacyInterface(r randyTypes, easy bool) *ReplaceSpecType_LegacyInterface {
	this := &ReplaceSpecType_LegacyInterface{}
	this.LegacyInterface = NewPopulatedLegacyInterfaceType(r, easy)
	return this
}
func NewPopulatedReplaceSpecType_DedicatedManagementInterface(r randyTypes, easy bool) *ReplaceSpecType_DedicatedManagementInterface {
	this := &ReplaceSpecType_DedicatedManagementInterface{}
	this.DedicatedManagementInterface = NewPopulatedDedicatedManagementInterfaceType(r, easy)
	return this
}
func NewPopulatedGetSpecType(r randyTypes, easy bool) *GetSpecType {
	this := &GetSpecType{}
	oneofNumber_InterfaceChoice := []int32{18, 19, 20, 21, 22}[r.Intn(5)]
	switch oneofNumber_InterfaceChoice {
	case 18:
		this.InterfaceChoice = NewPopulatedGetSpecType_DedicatedInterface(r, easy)
	case 19:
		this.InterfaceChoice = NewPopulatedGetSpecType_EthernetInterface(r, easy)
	case 20:
		this.InterfaceChoice = NewPopulatedGetSpecType_TunnelInterface(r, easy)
	case 21:
		this.InterfaceChoice = NewPopulatedGetSpecType_LegacyInterface(r, easy)
	case 22:
		this.InterfaceChoice = NewPopulatedGetSpecType_DedicatedManagementInterface(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetSpecType_DedicatedInterface(r randyTypes, easy bool) *GetSpecType_DedicatedInterface {
	this := &GetSpecType_DedicatedInterface{}
	this.DedicatedInterface = NewPopulatedDedicatedInterfaceType(r, easy)
	return this
}
func NewPopulatedGetSpecType_EthernetInterface(r randyTypes, easy bool) *GetSpecType_EthernetInterface {
	this := &GetSpecType_EthernetInterface{}
	this.EthernetInterface = NewPopulatedEthernetInterfaceType(r, easy)
	return this
}
func NewPopulatedGetSpecType_TunnelInterface(r randyTypes, easy bool) *GetSpecType_TunnelInterface {
	this := &GetSpecType_TunnelInterface{}
	this.TunnelInterface = NewPopulatedTunnelInterfaceType(r, easy)
	return this
}
func NewPopulatedGetSpecType_LegacyInterface(r randyTypes, easy bool) *GetSpecType_LegacyInterface {
	this := &GetSpecType_LegacyInterface{}
	this.LegacyInterface = NewPopulatedLegacyInterfaceType(r, easy)
	return this
}
func NewPopulatedGetSpecType_DedicatedManagementInterface(r randyTypes, easy bool) *GetSpecType_DedicatedManagementInterface {
	this := &GetSpecType_DedicatedManagementInterface{}
	this.DedicatedManagementInterface = NewPopulatedDedicatedManagementInterfaceType(r, easy)
	return this
}
func NewPopulatedNetworkInterfaceStatus(r randyTypes, easy bool) *NetworkInterfaceStatus {
	this := &NetworkInterfaceStatus{}
	this.UpDown = NetworkInterfaceUpDown([]int32{0, 1, 2}[r.Intn(3)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v16 := r.Intn(100)
	tmps := make([]rune, v16)
	for i := 0; i < v16; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTypes(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTypes(dAtA []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		v17 := r.Int63()
		if r.Intn(2) == 0 {
			v17 *= -1
		}
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(v17))
	case 1:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTypes(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTypes(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *NetworkInterfaceDFGW) Size() (n int) {
	var l int
	_ = l
	if m.DefaultGatewayMode != 0 {
		n += 1 + sovTypes(uint64(m.DefaultGatewayMode))
	}
	if m.DefaultGatewayAddress != nil {
		l = m.DefaultGatewayAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NetworkInterfaceDNS) Size() (n int) {
	var l int
	_ = l
	if m.DnsMode != 0 {
		n += 1 + sovTypes(uint64(m.DnsMode))
	}
	if len(m.DnsServer) > 0 {
		for _, e := range m.DnsServer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkInterfaceTunnel) Size() (n int) {
	var l int
	_ = l
	if len(m.Tunnel) > 0 {
		for _, e := range m.Tunnel {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DHCPPoolType) Size() (n int) {
	var l int
	_ = l
	l = len(m.StartIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EndIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Exclude {
		n += 2
	}
	return n
}

func (m *DHCPNetworkType) Size() (n int) {
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		n += m.NetworkPrefixChoice.Size()
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.GatewayChoice != nil {
		n += m.GatewayChoice.Size()
	}
	if m.DnsChoice != nil {
		n += m.DnsChoice.Size()
	}
	if m.PoolSettings != 0 {
		n += 1 + sovTypes(uint64(m.PoolSettings))
	}
	return n
}

func (m *DHCPNetworkType_NetworkPrefix) Size() (n int) {
	var l int
	_ = l
	l = len(m.NetworkPrefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DHCPNetworkType_NetworkPrefixAllocator) Size() (n int) {
	var l int
	_ = l
	if m.NetworkPrefixAllocator != nil {
		l = m.NetworkPrefixAllocator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPNetworkType_FirstAddress) Size() (n int) {
	var l int
	_ = l
	if m.FirstAddress != nil {
		l = m.FirstAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPNetworkType_LastAddress) Size() (n int) {
	var l int
	_ = l
	if m.LastAddress != nil {
		l = m.LastAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPNetworkType_DgwAddress) Size() (n int) {
	var l int
	_ = l
	l = len(m.DgwAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DHCPNetworkType_SameAsDgw) Size() (n int) {
	var l int
	_ = l
	if m.SameAsDgw != nil {
		l = m.SameAsDgw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPNetworkType_DnsAddress) Size() (n int) {
	var l int
	_ = l
	l = len(m.DnsAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DHCPInterfaceIPType) Size() (n int) {
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		for k, v := range m.InterfaceIpMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DHCPServerParametersType) Size() (n int) {
	var l int
	_ = l
	if len(m.DhcpNetworks) > 0 {
		for _, e := range m.DhcpNetworks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfacesAddressingChoice != nil {
		n += m.InterfacesAddressingChoice.Size()
	}
	if len(m.FixedIpMap) > 0 {
		for k, v := range m.FixedIpMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.DhcpOption82Tag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DHCPServerParametersType_AutomaticFromStart) Size() (n int) {
	var l int
	_ = l
	if m.AutomaticFromStart != nil {
		l = m.AutomaticFromStart.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPServerParametersType_AutomaticFromEnd) Size() (n int) {
	var l int
	_ = l
	if m.AutomaticFromEnd != nil {
		l = m.AutomaticFromEnd.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPServerParametersType_InterfaceIpMap) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceIpMap != nil {
		l = m.InterfaceIpMap.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StaticIpParametersNodeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultGw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DnsServer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StaticIpParametersClusterType) Size() (n int) {
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		for k, v := range m.InterfaceIpMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *StaticIpParametersFleetType) Size() (n int) {
	var l int
	_ = l
	if m.NetworkPrefixAllocator != nil {
		l = m.NetworkPrefixAllocator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultGw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DnsServer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StaticIPParametersType) Size() (n int) {
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		n += m.NetworkPrefixChoice.Size()
	}
	return n
}

func (m *StaticIPParametersType_NodeStaticIp) Size() (n int) {
	var l int
	_ = l
	if m.NodeStaticIp != nil {
		l = m.NodeStaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StaticIPParametersType_ClusterStaticIp) Size() (n int) {
	var l int
	_ = l
	if m.ClusterStaticIp != nil {
		l = m.ClusterStaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StaticIPParametersType_FleetStaticIp) Size() (n int) {
	var l int
	_ = l
	if m.FleetStaticIp != nil {
		l = m.FleetStaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedInterfaceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NodeChoice != nil {
		n += m.NodeChoice.Size()
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if m.PrimaryChoice != nil {
		n += m.PrimaryChoice.Size()
	}
	return n
}

func (m *DedicatedInterfaceType_Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedInterfaceType_Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Node)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DedicatedInterfaceType_NotPrimary) Size() (n int) {
	var l int
	_ = l
	if m.NotPrimary != nil {
		l = m.NotPrimary.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedInterfaceType_IsPrimary) Size() (n int) {
	var l int
	_ = l
	if m.IsPrimary != nil {
		l = m.IsPrimary.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedManagementInterfaceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NodeChoice != nil {
		n += m.NodeChoice.Size()
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	return n
}

func (m *DedicatedManagementInterfaceType_Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedManagementInterfaceType_Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Node)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *EthernetInterfaceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NodeChoice != nil {
		n += m.NodeChoice.Size()
	}
	if m.VlanChoice != nil {
		n += m.VlanChoice.Size()
	}
	if m.AddressChoice != nil {
		n += m.AddressChoice.Size()
	}
	if m.NetworkChoice != nil {
		n += m.NetworkChoice.Size()
	}
	if m.Mtu != 0 {
		n += 2 + sovTypes(uint64(m.Mtu))
	}
	if m.Priority != 0 {
		n += 2 + sovTypes(uint64(m.Priority))
	}
	if m.PrimaryChoice != nil {
		n += m.PrimaryChoice.Size()
	}
	return n
}

func (m *EthernetInterfaceType_Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Node)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *EthernetInterfaceType_Untagged) Size() (n int) {
	var l int
	_ = l
	if m.Untagged != nil {
		l = m.Untagged.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_VlanId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.VlanId))
	return n
}
func (m *EthernetInterfaceType_DhcpClient) Size() (n int) {
	var l int
	_ = l
	if m.DhcpClient != nil {
		l = m.DhcpClient.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_DhcpServer) Size() (n int) {
	var l int
	_ = l
	if m.DhcpServer != nil {
		l = m.DhcpServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_StaticIp) Size() (n int) {
	var l int
	_ = l
	if m.StaticIp != nil {
		l = m.StaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_SiteLocalNetwork) Size() (n int) {
	var l int
	_ = l
	if m.SiteLocalNetwork != nil {
		l = m.SiteLocalNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_SiteLocalInsideNetwork) Size() (n int) {
	var l int
	_ = l
	if m.SiteLocalInsideNetwork != nil {
		l = m.SiteLocalInsideNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_InsideNetwork) Size() (n int) {
	var l int
	_ = l
	if m.InsideNetwork != nil {
		l = m.InsideNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_NotPrimary) Size() (n int) {
	var l int
	_ = l
	if m.NotPrimary != nil {
		l = m.NotPrimary.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_IsPrimary) Size() (n int) {
	var l int
	_ = l
	if m.IsPrimary != nil {
		l = m.IsPrimary.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_StorageNetwork) Size() (n int) {
	var l int
	_ = l
	if m.StorageNetwork != nil {
		l = m.StorageNetwork.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TunnelInterfaceType) Size() (n int) {
	var l int
	_ = l
	if m.NodeChoice != nil {
		n += m.NodeChoice.Size()
	}
	if m.Tunnel != nil {
		l = m.Tunnel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StaticIp != nil {
		l = m.StaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NetworkChoice != nil {
		n += m.NetworkChoice.Size()
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	return n
}

func (m *TunnelInterfaceType_Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TunnelInterfaceType_Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Node)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *TunnelInterfaceType_SiteLocalNetwork) Size() (n int) {
	var l int
	_ = l
	if m.SiteLocalNetwork != nil {
		l = m.SiteLocalNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TunnelInterfaceType_SiteLocalInsideNetwork) Size() (n int) {
	var l int
	_ = l
	if m.SiteLocalInsideNetwork != nil {
		l = m.SiteLocalInsideNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TunnelInterfaceType_InsideNetwork) Size() (n int) {
	var l int
	_ = l
	if m.InsideNetwork != nil {
		l = m.InsideNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LegacyInterfaceType) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, e := range m.VirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DhcpAddress != 0 {
		n += 1 + sovTypes(uint64(m.DhcpAddress))
	}
	if len(m.StaticAddresses) > 0 {
		for _, e := range m.StaticAddresses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DefaultGateway != nil {
		l = m.DefaultGateway.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DNSServer != nil {
		l = m.DNSServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DHCPServer != 0 {
		n += 1 + sovTypes(uint64(m.DHCPServer))
	}
	if m.VlanTagging != 0 {
		n += 1 + sovTypes(uint64(m.VlanTagging))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VlanTag != 0 {
		n += 1 + sovTypes(uint64(m.VlanTag))
	}
	if m.Tunnel != nil {
		l = m.Tunnel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if len(m.AddressAllocator) > 0 {
		for _, e := range m.AddressAllocator {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, e := range m.VirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DhcpAddress != 0 {
		n += 1 + sovTypes(uint64(m.DhcpAddress))
	}
	if len(m.StaticAddresses) > 0 {
		for _, e := range m.StaticAddresses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DefaultGateway != nil {
		l = m.DefaultGateway.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DNSServer != nil {
		l = m.DNSServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DHCPServer != 0 {
		n += 1 + sovTypes(uint64(m.DHCPServer))
	}
	if m.VlanTagging != 0 {
		n += 1 + sovTypes(uint64(m.VlanTagging))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ParentNetworkInterface) > 0 {
		for _, e := range m.ParentNetworkInterface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.VlanTag != 0 {
		n += 1 + sovTypes(uint64(m.VlanTag))
	}
	if m.Tunnel != nil {
		l = m.Tunnel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if len(m.AddressAllocator) > 0 {
		for _, e := range m.AddressAllocator {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.DhcpServerParams != nil {
		l = m.DhcpServerParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.NetworkConfig != 0 {
		n += 2 + sovTypes(uint64(m.NetworkConfig))
	}
	if len(m.InterfaceIpMap) > 0 {
		for k, v := range m.InterfaceIpMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.IsPrimary {
		n += 3
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *GlobalSpecType_DedicatedInterface) Size() (n int) {
	var l int
	_ = l
	if m.DedicatedInterface != nil {
		l = m.DedicatedInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_EthernetInterface) Size() (n int) {
	var l int
	_ = l
	if m.EthernetInterface != nil {
		l = m.EthernetInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_TunnelInterface) Size() (n int) {
	var l int
	_ = l
	if m.TunnelInterface != nil {
		l = m.TunnelInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Legacy) Size() (n int) {
	var l int
	_ = l
	if m.Legacy != nil {
		l = m.Legacy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DedicatedManagementInterface) Size() (n int) {
	var l int
	_ = l
	if m.DedicatedManagementInterface != nil {
		l = m.DedicatedManagementInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *CreateSpecType_DedicatedInterface) Size() (n int) {
	var l int
	_ = l
	if m.DedicatedInterface != nil {
		l = m.DedicatedInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_EthernetInterface) Size() (n int) {
	var l int
	_ = l
	if m.EthernetInterface != nil {
		l = m.EthernetInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_TunnelInterface) Size() (n int) {
	var l int
	_ = l
	if m.TunnelInterface != nil {
		l = m.TunnelInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_LegacyInterface) Size() (n int) {
	var l int
	_ = l
	if m.LegacyInterface != nil {
		l = m.LegacyInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DedicatedManagementInterface) Size() (n int) {
	var l int
	_ = l
	if m.DedicatedManagementInterface != nil {
		l = m.DedicatedManagementInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_DedicatedInterface) Size() (n int) {
	var l int
	_ = l
	if m.DedicatedInterface != nil {
		l = m.DedicatedInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_EthernetInterface) Size() (n int) {
	var l int
	_ = l
	if m.EthernetInterface != nil {
		l = m.EthernetInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_TunnelInterface) Size() (n int) {
	var l int
	_ = l
	if m.TunnelInterface != nil {
		l = m.TunnelInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LegacyInterface) Size() (n int) {
	var l int
	_ = l
	if m.LegacyInterface != nil {
		l = m.LegacyInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DedicatedManagementInterface) Size() (n int) {
	var l int
	_ = l
	if m.DedicatedManagementInterface != nil {
		l = m.DedicatedManagementInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *GetSpecType_DedicatedInterface) Size() (n int) {
	var l int
	_ = l
	if m.DedicatedInterface != nil {
		l = m.DedicatedInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_EthernetInterface) Size() (n int) {
	var l int
	_ = l
	if m.EthernetInterface != nil {
		l = m.EthernetInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_TunnelInterface) Size() (n int) {
	var l int
	_ = l
	if m.TunnelInterface != nil {
		l = m.TunnelInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LegacyInterface) Size() (n int) {
	var l int
	_ = l
	if m.LegacyInterface != nil {
		l = m.LegacyInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DedicatedManagementInterface) Size() (n int) {
	var l int
	_ = l
	if m.DedicatedManagementInterface != nil {
		l = m.DedicatedManagementInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkInterfaceStatus) Size() (n int) {
	var l int
	_ = l
	if m.UpDown != 0 {
		n += 1 + sovTypes(uint64(m.UpDown))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NetworkInterfaceDFGW) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkInterfaceDFGW{`,
		`DefaultGatewayMode:` + fmt.Sprintf("%v", this.DefaultGatewayMode) + `,`,
		`DefaultGatewayAddress:` + strings.Replace(fmt.Sprintf("%v", this.DefaultGatewayAddress), "Ipv4AddressType", "ves_io_schema3.Ipv4AddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInterfaceDNS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkInterfaceDNS{`,
		`DnsMode:` + fmt.Sprintf("%v", this.DnsMode) + `,`,
		`DnsServer:` + strings.Replace(fmt.Sprintf("%v", this.DnsServer), "Ipv4AddressType", "ves_io_schema3.Ipv4AddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInterfaceTunnel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkInterfaceTunnel{`,
		`Tunnel:` + strings.Replace(fmt.Sprintf("%v", this.Tunnel), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPPoolType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPPoolType{`,
		`StartIp:` + fmt.Sprintf("%v", this.StartIp) + `,`,
		`EndIp:` + fmt.Sprintf("%v", this.EndIp) + `,`,
		`Exclude:` + fmt.Sprintf("%v", this.Exclude) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType{`,
		`NetworkPrefixChoice:` + fmt.Sprintf("%v", this.NetworkPrefixChoice) + `,`,
		`Pools:` + strings.Replace(fmt.Sprintf("%v", this.Pools), "DHCPPoolType", "DHCPPoolType", 1) + `,`,
		`GatewayChoice:` + fmt.Sprintf("%v", this.GatewayChoice) + `,`,
		`DnsChoice:` + fmt.Sprintf("%v", this.DnsChoice) + `,`,
		`PoolSettings:` + fmt.Sprintf("%v", this.PoolSettings) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_NetworkPrefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_NetworkPrefix{`,
		`NetworkPrefix:` + fmt.Sprintf("%v", this.NetworkPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_NetworkPrefixAllocator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_NetworkPrefixAllocator{`,
		`NetworkPrefixAllocator:` + strings.Replace(fmt.Sprintf("%v", this.NetworkPrefixAllocator), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_FirstAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_FirstAddress{`,
		`FirstAddress:` + strings.Replace(fmt.Sprintf("%v", this.FirstAddress), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_LastAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_LastAddress{`,
		`LastAddress:` + strings.Replace(fmt.Sprintf("%v", this.LastAddress), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_DgwAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_DgwAddress{`,
		`DgwAddress:` + fmt.Sprintf("%v", this.DgwAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_SameAsDgw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_SameAsDgw{`,
		`SameAsDgw:` + strings.Replace(fmt.Sprintf("%v", this.SameAsDgw), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_DnsAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_DnsAddress{`,
		`DnsAddress:` + fmt.Sprintf("%v", this.DnsAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPInterfaceIPType) String() string {
	if this == nil {
		return "nil"
	}
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%v: %v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	s := strings.Join([]string{`&DHCPInterfaceIPType{`,
		`InterfaceIpMap:` + mapStringForInterfaceIpMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPServerParametersType) String() string {
	if this == nil {
		return "nil"
	}
	keysForFixedIpMap := make([]string, 0, len(this.FixedIpMap))
	for k, _ := range this.FixedIpMap {
		keysForFixedIpMap = append(keysForFixedIpMap, k)
	}
	sortkeys.Strings(keysForFixedIpMap)
	mapStringForFixedIpMap := "map[string]string{"
	for _, k := range keysForFixedIpMap {
		mapStringForFixedIpMap += fmt.Sprintf("%v: %v,", k, this.FixedIpMap[k])
	}
	mapStringForFixedIpMap += "}"
	s := strings.Join([]string{`&DHCPServerParametersType{`,
		`DhcpNetworks:` + strings.Replace(fmt.Sprintf("%v", this.DhcpNetworks), "DHCPNetworkType", "DHCPNetworkType", 1) + `,`,
		`InterfacesAddressingChoice:` + fmt.Sprintf("%v", this.InterfacesAddressingChoice) + `,`,
		`FixedIpMap:` + mapStringForFixedIpMap + `,`,
		`DhcpOption82Tag:` + fmt.Sprintf("%v", this.DhcpOption82Tag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPServerParametersType_AutomaticFromStart) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPServerParametersType_AutomaticFromStart{`,
		`AutomaticFromStart:` + strings.Replace(fmt.Sprintf("%v", this.AutomaticFromStart), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPServerParametersType_AutomaticFromEnd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPServerParametersType_AutomaticFromEnd{`,
		`AutomaticFromEnd:` + strings.Replace(fmt.Sprintf("%v", this.AutomaticFromEnd), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPServerParametersType_InterfaceIpMap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPServerParametersType_InterfaceIpMap{`,
		`InterfaceIpMap:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceIpMap), "DHCPInterfaceIPType", "DHCPInterfaceIPType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIpParametersNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIpParametersNodeType{`,
		`IpAddress:` + fmt.Sprintf("%v", this.IpAddress) + `,`,
		`DefaultGw:` + fmt.Sprintf("%v", this.DefaultGw) + `,`,
		`DnsServer:` + fmt.Sprintf("%v", this.DnsServer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIpParametersClusterType) String() string {
	if this == nil {
		return "nil"
	}
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]*StaticIpParametersNodeType{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%v: %v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	s := strings.Join([]string{`&StaticIpParametersClusterType{`,
		`InterfaceIpMap:` + mapStringForInterfaceIpMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIpParametersFleetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIpParametersFleetType{`,
		`NetworkPrefixAllocator:` + strings.Replace(fmt.Sprintf("%v", this.NetworkPrefixAllocator), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`DefaultGw:` + fmt.Sprintf("%v", this.DefaultGw) + `,`,
		`DnsServer:` + fmt.Sprintf("%v", this.DnsServer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIPParametersType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIPParametersType{`,
		`NetworkPrefixChoice:` + fmt.Sprintf("%v", this.NetworkPrefixChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIPParametersType_NodeStaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIPParametersType_NodeStaticIp{`,
		`NodeStaticIp:` + strings.Replace(fmt.Sprintf("%v", this.NodeStaticIp), "StaticIpParametersNodeType", "StaticIpParametersNodeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIPParametersType_ClusterStaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIPParametersType_ClusterStaticIp{`,
		`ClusterStaticIp:` + strings.Replace(fmt.Sprintf("%v", this.ClusterStaticIp), "StaticIpParametersClusterType", "StaticIpParametersClusterType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIPParametersType_FleetStaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIPParametersType_FleetStaticIp{`,
		`FleetStaticIp:` + strings.Replace(fmt.Sprintf("%v", this.FleetStaticIp), "StaticIpParametersFleetType", "StaticIpParametersFleetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`NodeChoice:` + fmt.Sprintf("%v", this.NodeChoice) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`PrimaryChoice:` + fmt.Sprintf("%v", this.PrimaryChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_Cluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_Cluster{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_Node{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_NotPrimary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_NotPrimary{`,
		`NotPrimary:` + strings.Replace(fmt.Sprintf("%v", this.NotPrimary), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_IsPrimary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_IsPrimary{`,
		`IsPrimary:` + strings.Replace(fmt.Sprintf("%v", this.IsPrimary), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedManagementInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedManagementInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`NodeChoice:` + fmt.Sprintf("%v", this.NodeChoice) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedManagementInterfaceType_Cluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedManagementInterfaceType_Cluster{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedManagementInterfaceType_Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedManagementInterfaceType_Node{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`NodeChoice:` + fmt.Sprintf("%v", this.NodeChoice) + `,`,
		`VlanChoice:` + fmt.Sprintf("%v", this.VlanChoice) + `,`,
		`AddressChoice:` + fmt.Sprintf("%v", this.AddressChoice) + `,`,
		`NetworkChoice:` + fmt.Sprintf("%v", this.NetworkChoice) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`PrimaryChoice:` + fmt.Sprintf("%v", this.PrimaryChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_Cluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_Cluster{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_Node{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_Untagged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_Untagged{`,
		`Untagged:` + strings.Replace(fmt.Sprintf("%v", this.Untagged), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_VlanId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_VlanId{`,
		`VlanId:` + fmt.Sprintf("%v", this.VlanId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_DhcpClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_DhcpClient{`,
		`DhcpClient:` + strings.Replace(fmt.Sprintf("%v", this.DhcpClient), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_DhcpServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_DhcpServer{`,
		`DhcpServer:` + strings.Replace(fmt.Sprintf("%v", this.DhcpServer), "DHCPServerParametersType", "DHCPServerParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_StaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_StaticIp{`,
		`StaticIp:` + strings.Replace(fmt.Sprintf("%v", this.StaticIp), "StaticIPParametersType", "StaticIPParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_SiteLocalNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_SiteLocalNetwork{`,
		`SiteLocalNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalNetwork), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_SiteLocalInsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_SiteLocalInsideNetwork{`,
		`SiteLocalInsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInsideNetwork), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_InsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_InsideNetwork{`,
		`InsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.InsideNetwork), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_NotPrimary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_NotPrimary{`,
		`NotPrimary:` + strings.Replace(fmt.Sprintf("%v", this.NotPrimary), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_IsPrimary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_IsPrimary{`,
		`IsPrimary:` + strings.Replace(fmt.Sprintf("%v", this.IsPrimary), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_StorageNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_StorageNetwork{`,
		`StorageNetwork:` + strings.Replace(fmt.Sprintf("%v", this.StorageNetwork), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType{`,
		`NodeChoice:` + fmt.Sprintf("%v", this.NodeChoice) + `,`,
		`Tunnel:` + strings.Replace(fmt.Sprintf("%v", this.Tunnel), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`StaticIp:` + strings.Replace(fmt.Sprintf("%v", this.StaticIp), "StaticIPParametersType", "StaticIPParametersType", 1) + `,`,
		`NetworkChoice:` + fmt.Sprintf("%v", this.NetworkChoice) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_Cluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_Cluster{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_Node{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_SiteLocalNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_SiteLocalNetwork{`,
		`SiteLocalNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalNetwork), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_SiteLocalInsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_SiteLocalInsideNetwork{`,
		`SiteLocalInsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInsideNetwork), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_InsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_InsideNetwork{`,
		`InsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.InsideNetwork), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LegacyInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LegacyInterfaceType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`VirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.VirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`DhcpAddress:` + fmt.Sprintf("%v", this.DhcpAddress) + `,`,
		`StaticAddresses:` + strings.Replace(fmt.Sprintf("%v", this.StaticAddresses), "Ipv4SubnetType", "ves_io_schema3.Ipv4SubnetType", 1) + `,`,
		`DefaultGateway:` + strings.Replace(fmt.Sprintf("%v", this.DefaultGateway), "NetworkInterfaceDFGW", "NetworkInterfaceDFGW", 1) + `,`,
		`DNSServer:` + strings.Replace(fmt.Sprintf("%v", this.DNSServer), "NetworkInterfaceDNS", "NetworkInterfaceDNS", 1) + `,`,
		`DHCPServer:` + fmt.Sprintf("%v", this.DHCPServer) + `,`,
		`VlanTagging:` + fmt.Sprintf("%v", this.VlanTagging) + `,`,
		`DeviceName:` + fmt.Sprintf("%v", this.DeviceName) + `,`,
		`VlanTag:` + fmt.Sprintf("%v", this.VlanTag) + `,`,
		`Tunnel:` + strings.Replace(fmt.Sprintf("%v", this.Tunnel), "NetworkInterfaceTunnel", "NetworkInterfaceTunnel", 1) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`AddressAllocator:` + strings.Replace(fmt.Sprintf("%v", this.AddressAllocator), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%v: %v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`VirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.VirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`DhcpAddress:` + fmt.Sprintf("%v", this.DhcpAddress) + `,`,
		`StaticAddresses:` + strings.Replace(fmt.Sprintf("%v", this.StaticAddresses), "Ipv4SubnetType", "ves_io_schema3.Ipv4SubnetType", 1) + `,`,
		`DefaultGateway:` + strings.Replace(fmt.Sprintf("%v", this.DefaultGateway), "NetworkInterfaceDFGW", "NetworkInterfaceDFGW", 1) + `,`,
		`DNSServer:` + strings.Replace(fmt.Sprintf("%v", this.DNSServer), "NetworkInterfaceDNS", "NetworkInterfaceDNS", 1) + `,`,
		`DHCPServer:` + fmt.Sprintf("%v", this.DHCPServer) + `,`,
		`VlanTagging:` + fmt.Sprintf("%v", this.VlanTagging) + `,`,
		`DeviceName:` + fmt.Sprintf("%v", this.DeviceName) + `,`,
		`ParentNetworkInterface:` + strings.Replace(fmt.Sprintf("%v", this.ParentNetworkInterface), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`VlanTag:` + fmt.Sprintf("%v", this.VlanTag) + `,`,
		`Tunnel:` + strings.Replace(fmt.Sprintf("%v", this.Tunnel), "NetworkInterfaceTunnel", "NetworkInterfaceTunnel", 1) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`AddressAllocator:` + strings.Replace(fmt.Sprintf("%v", this.AddressAllocator), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`DhcpServerParams:` + strings.Replace(fmt.Sprintf("%v", this.DhcpServerParams), "DHCPServerParametersType", "DHCPServerParametersType", 1) + `,`,
		`NetworkConfig:` + fmt.Sprintf("%v", this.NetworkConfig) + `,`,
		`InterfaceIpMap:` + mapStringForInterfaceIpMap + `,`,
		`IsPrimary:` + fmt.Sprintf("%v", this.IsPrimary) + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DedicatedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DedicatedInterface{`,
		`DedicatedInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedInterface), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_EthernetInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_EthernetInterface{`,
		`EthernetInterface:` + strings.Replace(fmt.Sprintf("%v", this.EthernetInterface), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_TunnelInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_TunnelInterface{`,
		`TunnelInterface:` + strings.Replace(fmt.Sprintf("%v", this.TunnelInterface), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Legacy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Legacy{`,
		`Legacy:` + strings.Replace(fmt.Sprintf("%v", this.Legacy), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DedicatedManagementInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DedicatedManagementInterface{`,
		`DedicatedManagementInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedManagementInterface), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DedicatedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DedicatedInterface{`,
		`DedicatedInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedInterface), "DedicatedInterfaceType", "DedicatedInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_EthernetInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_EthernetInterface{`,
		`EthernetInterface:` + strings.Replace(fmt.Sprintf("%v", this.EthernetInterface), "EthernetInterfaceType", "EthernetInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_TunnelInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_TunnelInterface{`,
		`TunnelInterface:` + strings.Replace(fmt.Sprintf("%v", this.TunnelInterface), "TunnelInterfaceType", "TunnelInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LegacyInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LegacyInterface{`,
		`LegacyInterface:` + strings.Replace(fmt.Sprintf("%v", this.LegacyInterface), "LegacyInterfaceType", "LegacyInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DedicatedManagementInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DedicatedManagementInterface{`,
		`DedicatedManagementInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedManagementInterface), "DedicatedManagementInterfaceType", "DedicatedManagementInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DedicatedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DedicatedInterface{`,
		`DedicatedInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedInterface), "DedicatedInterfaceType", "DedicatedInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_EthernetInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_EthernetInterface{`,
		`EthernetInterface:` + strings.Replace(fmt.Sprintf("%v", this.EthernetInterface), "EthernetInterfaceType", "EthernetInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_TunnelInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_TunnelInterface{`,
		`TunnelInterface:` + strings.Replace(fmt.Sprintf("%v", this.TunnelInterface), "TunnelInterfaceType", "TunnelInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LegacyInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LegacyInterface{`,
		`LegacyInterface:` + strings.Replace(fmt.Sprintf("%v", this.LegacyInterface), "LegacyInterfaceType", "LegacyInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DedicatedManagementInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DedicatedManagementInterface{`,
		`DedicatedManagementInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedManagementInterface), "DedicatedManagementInterfaceType", "DedicatedManagementInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DedicatedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DedicatedInterface{`,
		`DedicatedInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedInterface), "DedicatedInterfaceType", "DedicatedInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_EthernetInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_EthernetInterface{`,
		`EthernetInterface:` + strings.Replace(fmt.Sprintf("%v", this.EthernetInterface), "EthernetInterfaceType", "EthernetInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_TunnelInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_TunnelInterface{`,
		`TunnelInterface:` + strings.Replace(fmt.Sprintf("%v", this.TunnelInterface), "TunnelInterfaceType", "TunnelInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LegacyInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LegacyInterface{`,
		`LegacyInterface:` + strings.Replace(fmt.Sprintf("%v", this.LegacyInterface), "LegacyInterfaceType", "LegacyInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DedicatedManagementInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DedicatedManagementInterface{`,
		`DedicatedManagementInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedManagementInterface), "DedicatedManagementInterfaceType", "DedicatedManagementInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInterfaceStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkInterfaceStatus{`,
		`UpDown:` + fmt.Sprintf("%v", this.UpDown) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NetworkInterfaceDFGW) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceDFGW: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceDFGW: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGatewayMode", wireType)
			}
			m.DefaultGatewayMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultGatewayMode |= (NetworkInterfaceGatewayMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGatewayAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultGatewayAddress == nil {
				m.DefaultGatewayAddress = &ves_io_schema3.Ipv4AddressType{}
			}
			if err := m.DefaultGatewayAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterfaceDNS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceDNS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceDNS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsMode", wireType)
			}
			m.DnsMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsMode |= (NetworkInterfaceDNSMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsServer = append(m.DnsServer, &ves_io_schema3.Ipv4AddressType{})
			if err := m.DnsServer[len(m.DnsServer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterfaceTunnel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceTunnel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceTunnel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tunnel = append(m.Tunnel, &ves_io_schema4.ObjectRefType{})
			if err := m.Tunnel[len(m.Tunnel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPPoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPPoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPPoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exclude = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPNetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPNetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPNetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPrefixChoice = &DHCPNetworkType_NetworkPrefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefixAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPrefixChoice = &DHCPNetworkType_NetworkPrefixAllocator{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &DHCPPoolType{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GatewayChoice = &DHCPNetworkType_FirstAddress{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GatewayChoice = &DHCPNetworkType_LastAddress{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DgwAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayChoice = &DHCPNetworkType_DgwAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SameAsDgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DnsChoice = &DHCPNetworkType_SameAsDgw{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsChoice = &DHCPNetworkType_DnsAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSettings", wireType)
			}
			m.PoolSettings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolSettings |= (DHCPPoolSettingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPInterfaceIPType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPInterfaceIPType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPInterfaceIPType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceIpMap == nil {
				m.InterfaceIpMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InterfaceIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPServerParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPServerParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPServerParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpNetworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpNetworks = append(m.DhcpNetworks, &DHCPNetworkType{})
			if err := m.DhcpNetworks[len(m.DhcpNetworks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticFromStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfacesAddressingChoice = &DHCPServerParametersType_AutomaticFromStart{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticFromEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfacesAddressingChoice = &DHCPServerParametersType_AutomaticFromEnd{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHCPInterfaceIPType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfacesAddressingChoice = &DHCPServerParametersType_InterfaceIpMap{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FixedIpMap == nil {
				m.FixedIpMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FixedIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpOption82Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpOption82Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticIpParametersNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticIpParametersNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticIpParametersNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultGw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticIpParametersClusterType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticIpParametersClusterType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticIpParametersClusterType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceIpMap == nil {
				m.InterfaceIpMap = make(map[string]*StaticIpParametersNodeType)
			}
			var mapkey string
			var mapvalue *StaticIpParametersNodeType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StaticIpParametersNodeType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InterfaceIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticIpParametersFleetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticIpParametersFleetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticIpParametersFleetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefixAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkPrefixAllocator == nil {
				m.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
			}
			if err := m.NetworkPrefixAllocator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultGw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticIPParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticIPParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticIPParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeStaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIpParametersNodeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPrefixChoice = &StaticIPParametersType_NodeStaticIp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterStaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIpParametersClusterType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPrefixChoice = &StaticIPParametersType_ClusterStaticIp{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetStaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIpParametersFleetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPrefixChoice = &StaticIPParametersType_FleetStaticIp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DedicatedInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DedicatedInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DedicatedInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeChoice = &DedicatedInterfaceType_Cluster{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeChoice = &DedicatedInterfaceType_Node{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotPrimary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrimaryChoice = &DedicatedInterfaceType_NotPrimary{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrimaryChoice = &DedicatedInterfaceType_IsPrimary{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DedicatedManagementInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DedicatedManagementInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DedicatedManagementInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeChoice = &DedicatedManagementInterfaceType_Cluster{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeChoice = &DedicatedManagementInterfaceType_Node{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthernetInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthernetInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthernetInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeChoice = &EthernetInterfaceType_Cluster{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeChoice = &EthernetInterfaceType_Node{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Untagged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VlanChoice = &EthernetInterfaceType_Untagged{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VlanChoice = &EthernetInterfaceType_VlanId{v}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &EthernetInterfaceType_DhcpClient{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHCPServerParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &EthernetInterfaceType_DhcpServer{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIPParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &EthernetInterfaceType_StaticIp{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_SiteLocalNetwork{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_SiteLocalInsideNetwork{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_InsideNetwork{v}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotPrimary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrimaryChoice = &EthernetInterfaceType_NotPrimary{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrimaryChoice = &EthernetInterfaceType_IsPrimary{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_StorageNetwork{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeChoice = &TunnelInterfaceType_Cluster{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeChoice = &TunnelInterfaceType_Node{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel == nil {
				m.Tunnel = &ves_io_schema_views.ObjectRefType{}
			}
			if err := m.Tunnel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StaticIp == nil {
				m.StaticIp = &StaticIPParametersType{}
			}
			if err := m.StaticIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &TunnelInterfaceType_SiteLocalNetwork{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &TunnelInterfaceType_SiteLocalInsideNetwork{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &TunnelInterfaceType_InsideNetwork{v}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LegacyInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LegacyInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LegacyInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (NetworkInterfaceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = append(m.VirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.VirtualNetwork[len(m.VirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpAddress", wireType)
			}
			m.DhcpAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DhcpAddress |= (NetworkInterfaceDHCP(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticAddresses = append(m.StaticAddresses, &ves_io_schema3.Ipv4SubnetType{})
			if err := m.StaticAddresses[len(m.StaticAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultGateway == nil {
				m.DefaultGateway = &NetworkInterfaceDFGW{}
			}
			if err := m.DefaultGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNSServer == nil {
				m.DNSServer = &NetworkInterfaceDNS{}
			}
			if err := m.DNSServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPServer", wireType)
			}
			m.DHCPServer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DHCPServer |= (NetworkInterfaceDHCPServer(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTagging", wireType)
			}
			m.VlanTagging = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTagging |= (NetworkInterfaceVLANTagging(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTag", wireType)
			}
			m.VlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel == nil {
				m.Tunnel = &NetworkInterfaceTunnel{}
			}
			if err := m.Tunnel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressAllocator = append(m.AddressAllocator, &ves_io_schema4.ObjectRefType{})
			if err := m.AddressAllocator[len(m.AddressAllocator)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (NetworkInterfaceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = append(m.VirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.VirtualNetwork[len(m.VirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpAddress", wireType)
			}
			m.DhcpAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DhcpAddress |= (NetworkInterfaceDHCP(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticAddresses = append(m.StaticAddresses, &ves_io_schema3.Ipv4SubnetType{})
			if err := m.StaticAddresses[len(m.StaticAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultGateway == nil {
				m.DefaultGateway = &NetworkInterfaceDFGW{}
			}
			if err := m.DefaultGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNSServer == nil {
				m.DNSServer = &NetworkInterfaceDNS{}
			}
			if err := m.DNSServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPServer", wireType)
			}
			m.DHCPServer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DHCPServer |= (NetworkInterfaceDHCPServer(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTagging", wireType)
			}
			m.VlanTagging = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTagging |= (NetworkInterfaceVLANTagging(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNetworkInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentNetworkInterface = append(m.ParentNetworkInterface, &ves_io_schema4.ObjectRefType{})
			if err := m.ParentNetworkInterface[len(m.ParentNetworkInterface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTag", wireType)
			}
			m.VlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel == nil {
				m.Tunnel = &NetworkInterfaceTunnel{}
			}
			if err := m.Tunnel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressAllocator = append(m.AddressAllocator, &ves_io_schema4.ObjectRefType{})
			if err := m.AddressAllocator[len(m.AddressAllocator)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpServerParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DhcpServerParams == nil {
				m.DhcpServerParams = &DHCPServerParametersType{}
			}
			if err := m.DhcpServerParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConfig", wireType)
			}
			m.NetworkConfig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkConfig |= (InterfaceNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceIpMap == nil {
				m.InterfaceIpMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InterfaceIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimary = bool(v != 0)
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_DedicatedInterface{v}
			iNdEx = postIndex
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_EthernetInterface{v}
			iNdEx = postIndex
		case 1003:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_TunnelInterface{v}
			iNdEx = postIndex
		case 1004:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Legacy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_Legacy{v}
			iNdEx = postIndex
		case 1005:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedManagementInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_DedicatedManagementInterface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_DedicatedInterface{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthernetInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_EthernetInterface{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TunnelInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_TunnelInterface{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_LegacyInterface{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedManagementInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedManagementInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_DedicatedManagementInterface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_DedicatedInterface{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthernetInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_EthernetInterface{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TunnelInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_TunnelInterface{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_LegacyInterface{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedManagementInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedManagementInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_DedicatedManagementInterface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_DedicatedInterface{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthernetInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_EthernetInterface{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TunnelInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_TunnelInterface{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_LegacyInterface{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedManagementInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedManagementInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_DedicatedManagementInterface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterfaceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpDown", wireType)
			}
			m.UpDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpDown |= (NetworkInterfaceUpDown(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/network_interface/types.proto", fileDescriptorTypes) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/network_interface/types.proto", fileDescriptorTypes)
}

var fileDescriptorTypes = []byte{
	// 4223 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0x5d, 0x6c, 0x1b, 0x57,
	0x76, 0xd6, 0x25, 0x87, 0x7f, 0x87, 0xfa, 0x19, 0x5d, 0xc9, 0x32, 0x4d, 0xdb, 0x34, 0xc3, 0x8d,
	0x13, 0xad, 0x32, 0x96, 0x45, 0x5a, 0x92, 0x65, 0xe5, 0xa7, 0x21, 0x45, 0x5a, 0xa2, 0x56, 0xa6,
	0x94, 0xa1, 0xec, 0x24, 0x45, 0xba, 0xc4, 0x98, 0x1c, 0xd1, 0x93, 0x90, 0x33, 0x04, 0x67, 0x24,
	0x45, 0x05, 0xdc, 0x6e, 0x8b, 0x3e, 0xf9, 0xa5, 0x7f, 0xe8, 0x0f, 0xf2, 0xd2, 0x97, 0xa2, 0xdb,
	0xcd, 0x5b, 0xd1, 0x02, 0x5d, 0x74, 0x8c, 0x42, 0x35, 0x1a, 0x20, 0xe8, 0x93, 0xfa, 0xd4, 0xa0,
	0x0f, 0x8b, 0x0d, 0xf7, 0x25, 0x49, 0xbb, 0x40, 0xd0, 0xa7, 0x3c, 0x75, 0x8b, 0x7b, 0xe7, 0x87,
	0x43, 0x72, 0x48, 0x51, 0x8e, 0x8b, 0xdd, 0xb4, 0x79, 0x19, 0x0e, 0x79, 0xcf, 0xcf, 0x9d, 0x73,
	0xcf, 0xf9, 0xce, 0xb9, 0xe7, 0x0e, 0xe1, 0xa5, 0x03, 0x51, 0x9d, 0x97, 0x94, 0xeb, 0x6a, 0xf9,
	0x81, 0x58, 0x17, 0xae, 0xcb, 0xa2, 0x76, 0xa8, 0x34, 0xdf, 0x2b, 0x49, 0xb2, 0x26, 0x36, 0xf7,
	0x84, 0xb2, 0x78, 0x5d, 0x3b, 0x6a, 0x88, 0xea, 0x7c, 0xa3, 0xa9, 0x68, 0x0a, 0xbe, 0x62, 0x10,
	0xcf, 0x1b, 0xc4, 0xf3, 0x3d, 0xc4, 0xd1, 0x6b, 0x55, 0x49, 0x7b, 0xb0, 0x7f, 0x7f, 0xbe, 0xac,
	0xd4, 0xaf, 0x57, 0x95, 0xaa, 0x72, 0x9d, 0xf2, 0xdd, 0xdf, 0xdf, 0xa3, 0xdf, 0xe8, 0x17, 0x7a,
	0x67, 0xc8, 0x8b, 0x5e, 0xa9, 0x2a, 0x4a, 0xb5, 0x26, 0xb6, 0xa9, 0x34, 0xa9, 0x2e, 0xaa, 0x9a,
	0x50, 0x6f, 0x98, 0x04, 0xe7, 0x7b, 0x66, 0x67, 0x0e, 0x5c, 0xec, 0x1c, 0x50, 0x1a, 0x9a, 0xa4,
	0xc8, 0xe6, 0x34, 0xa3, 0x97, 0x3b, 0x07, 0x1b, 0x07, 0x5a, 0xc9, 0xf1, 0x14, 0xd1, 0x0b, 0x9d,
	0xc3, 0xce, 0xa1, 0x4b, 0x9d, 0x43, 0x07, 0x42, 0x4d, 0xaa, 0x08, 0x9a, 0x68, 0x8e, 0xc6, 0xbb,
	0x46, 0x25, 0xf1, 0xb0, 0xd4, 0xa9, 0xf9, 0x4a, 0x2f, 0x85, 0xea, 0x54, 0x90, 0xf8, 0x09, 0x82,
	0xe9, 0x82, 0x61, 0xb6, 0xbc, 0x65, 0xb5, 0xec, 0xed, 0xf5, 0x37, 0xb1, 0x0c, 0xd3, 0x15, 0x71,
	0x4f, 0xd8, 0xaf, 0x69, 0xa5, 0xaa, 0xa0, 0x89, 0x87, 0xc2, 0x51, 0xa9, 0xae, 0x54, 0xc4, 0x08,
	0x8a, 0xa3, 0xd9, 0xf1, 0xd4, 0x2b, 0xf3, 0xa7, 0x58, 0x7e, 0xbe, 0x5b, 0xe8, 0xba, 0x21, 0xe4,
	0x8e, 0x52, 0x11, 0x79, 0x6c, 0x4a, 0x76, 0xfc, 0x86, 0xef, 0xc1, 0xf9, 0x6e, 0x7d, 0x42, 0xa5,
	0xd2, 0x14, 0x55, 0x35, 0xe2, 0x89, 0xa3, 0xd9, 0x70, 0x2a, 0xd6, 0xa5, 0x32, 0xdf, 0x38, 0x58,
	0x4c, 0x1b, 0x14, 0xbb, 0x47, 0x0d, 0x91, 0x3f, 0xd7, 0x29, 0xd4, 0x1c, 0x4a, 0xfc, 0x08, 0xc1,
	0x54, 0xcf, 0x03, 0x16, 0x8a, 0xb8, 0x08, 0xc1, 0x8a, 0xac, 0x3a, 0x9f, 0x69, 0xe5, 0xcc, 0xcf,
	0x94, 0x2d, 0x14, 0xe9, 0xf3, 0x04, 0x2a, 0xb2, 0x4a, 0x1f, 0xe2, 0x55, 0x00, 0x22, 0x54, 0x15,
	0x9b, 0x07, 0x62, 0x33, 0xe2, 0x89, 0x7b, 0x87, 0x98, 0x77, 0xa8, 0x22, 0xab, 0x45, 0xca, 0x90,
	0x90, 0x60, 0xa6, 0x5b, 0xc5, 0xee, 0xbe, 0x2c, 0x8b, 0x35, 0x9c, 0x07, 0xbf, 0x46, 0xef, 0x22,
	0x88, 0x0a, 0xbd, 0xd4, 0x25, 0x74, 0xfb, 0xfe, 0xbb, 0x62, 0x59, 0xe3, 0xc5, 0x3d, 0x22, 0x32,
	0x33, 0xf5, 0xe1, 0x43, 0x93, 0xfc, 0x1f, 0x3e, 0x3f, 0xf6, 0xfa, 0xfe, 0x08, 0x79, 0x58, 0xc4,
	0x9b, 0xbf, 0x6c, 0x32, 0x41, 0x0f, 0xeb, 0x4d, 0xfc, 0x0e, 0x82, 0xd1, 0xec, 0xc6, 0xda, 0xce,
	0x8e, 0xa2, 0xd4, 0x08, 0x0f, 0x9e, 0x85, 0xa0, 0xaa, 0x09, 0x4d, 0xad, 0x24, 0x35, 0xa8, 0x3d,
	0x42, 0x99, 0xb1, 0xaf, 0x74, 0x34, 0x42, 0x04, 0x30, 0x4d, 0xcf, 0xfb, 0x88, 0x0f, 0xd0, 0xe1,
	0x7c, 0x03, 0x3f, 0x0f, 0x7e, 0x51, 0xae, 0x10, 0x3a, 0x8f, 0x1b, 0x9d, 0x4f, 0x94, 0x2b, 0xf9,
	0x06, 0x7e, 0x0e, 0x02, 0xe2, 0xfb, 0xe5, 0xda, 0x7e, 0x45, 0x8c, 0x78, 0xe3, 0x68, 0x36, 0x98,
	0x09, 0x7c, 0xf2, 0x10, 0x7d, 0xa6, 0x23, 0xc4, 0x5b, 0xbf, 0x27, 0xfe, 0x34, 0x00, 0x13, 0x64,
	0x0e, 0xe6, 0x33, 0xd3, 0x69, 0xdc, 0x84, 0x71, 0xcb, 0xee, 0x8d, 0xa6, 0xb8, 0x27, 0xbd, 0x6f,
	0x2a, 0x19, 0xb7, 0x94, 0xf8, 0x9a, 0xde, 0xaf, 0x10, 0xda, 0x18, 0xe1, 0xc7, 0x4c, 0xba, 0x1d,
	0x4a, 0x86, 0x7f, 0x1b, 0x22, 0x9d, 0x8c, 0x25, 0xa1, 0x56, 0x53, 0xca, 0x82, 0xa6, 0x34, 0xe9,
	0x04, 0xc2, 0xa9, 0x44, 0x97, 0xcd, 0x68, 0x30, 0x74, 0x59, 0xee, 0xca, 0x87, 0x0f, 0x27, 0x4d,
	0xb7, 0x6b, 0xf3, 0x7f, 0xf2, 0x10, 0x1d, 0xeb, 0x88, 0x4e, 0x7e, 0x63, 0x84, 0x9f, 0xe9, 0xd0,
	0x9b, 0xb6, 0x88, 0xf0, 0xdb, 0xe0, 0x6b, 0x28, 0x4a, 0x4d, 0x8d, 0x30, 0x74, 0x85, 0xae, 0x9d,
	0xea, 0x4d, 0x4e, 0xf3, 0x67, 0xa6, 0xed, 0x95, 0x62, 0xad, 0xbb, 0x08, 0xe2, 0x0d, 0x89, 0xf8,
	0x65, 0x18, 0xdb, 0x93, 0x9a, 0xaa, 0x66, 0x47, 0x84, 0x9f, 0x3e, 0xd0, 0x74, 0x97, 0x8a, 0x5c,
	0xbd, 0xa1, 0x1d, 0x6d, 0x20, 0x7e, 0x94, 0x12, 0x9b, 0x3e, 0x86, 0x6f, 0xc1, 0x68, 0x4d, 0x70,
	0xf0, 0x06, 0x06, 0xf2, 0x86, 0x09, 0xad, 0xc5, 0xba, 0x00, 0xe1, 0x4a, 0xf5, 0xd0, 0xe6, 0x0c,
	0xba, 0x2c, 0xf7, 0x06, 0xe2, 0xa1, 0x52, 0x3d, 0xb4, 0x38, 0x96, 0x21, 0xac, 0x0a, 0x75, 0xb1,
	0x24, 0xa8, 0xa5, 0x4a, 0xf5, 0x30, 0x02, 0x03, 0x74, 0x79, 0xf8, 0x10, 0x21, 0x4d, 0xab, 0xd9,
	0xea, 0x21, 0xd5, 0x24, 0xab, 0xb6, 0xa6, 0xb0, 0x9b, 0x26, 0x0f, 0x4f, 0x82, 0xcb, 0xd2, 0xf4,
	0x36, 0x8c, 0x11, 0xe3, 0x94, 0x54, 0x51, 0xd3, 0x24, 0xb9, 0xaa, 0x46, 0x46, 0x69, 0x10, 0x2f,
	0x0e, 0x6d, 0xf6, 0xa2, 0xc1, 0x48, 0x63, 0x70, 0xb4, 0xd1, 0xfe, 0x41, 0x5d, 0x7d, 0xf8, 0x5f,
	0xaf, 0x45, 0x93, 0x5c, 0x8a, 0xbb, 0xc1, 0x25, 0x53, 0xdc, 0x22, 0xb7, 0xc4, 0x2d, 0x73, 0x37,
	0xb9, 0x15, 0xee, 0x16, 0x97, 0x5c, 0xe0, 0x92, 0xc9, 0x27, 0x3a, 0x7a, 0x07, 0x26, 0x8d, 0xe8,
	0x89, 0x9b, 0xae, 0x8b, 0x51, 0x12, 0xe2, 0x10, 0xa1, 0x3f, 0x11, 0xd9, 0x6a, 0x7c, 0x4d, 0x91,
	0xf7, 0xa4, 0xea, 0x7e, 0x53, 0x20, 0x68, 0x8c, 0x19, 0x22, 0x08, 0xae, 0x42, 0x2c, 0x6b, 0x60,
	0x54, 0xdc, 0x04, 0xa9, 0xb8, 0x20, 0x57, 0xe2, 0xd9, 0x42, 0x31, 0x6e, 0x00, 0x00, 0xf6, 0x2e,
	0x71, 0xb7, 0x32, 0xb3, 0x70, 0xae, 0xcb, 0x93, 0xcb, 0x0f, 0x14, 0xa9, 0x2c, 0xe2, 0x89, 0x63,
	0x1d, 0x79, 0x4e, 0x74, 0x84, 0x5a, 0x3a, 0xf2, 0xa6, 0xb8, 0x1b, 0x99, 0xef, 0xc0, 0xb8, 0x85,
	0x95, 0x26, 0xc9, 0xe4, 0xb1, 0x8e, 0xfc, 0x27, 0x3a, 0xf2, 0xb5, 0x74, 0xe4, 0xa3, 0xd3, 0xce,
	0x5c, 0x31, 0x30, 0xc9, 0x41, 0x00, 0x27, 0x3a, 0x0a, 0x11, 0x02, 0xfa, 0x3c, 0x9b, 0x4c, 0x10,
	0xb1, 0x9e, 0x4d, 0x26, 0xe8, 0x63, 0xfd, 0x9b, 0x4c, 0x30, 0xc4, 0x42, 0xe2, 0xf7, 0x18, 0x98,
	0x22, 0xcf, 0x62, 0xa3, 0x50, 0x7e, 0x87, 0x06, 0xe7, 0x8f, 0xbc, 0xc0, 0xda, 0x86, 0x2c, 0x49,
	0x8d, 0x52, 0x5d, 0x68, 0x98, 0x80, 0xb4, 0x31, 0x94, 0xdd, 0xbb, 0x04, 0xce, 0xb7, 0xbf, 0x37,
	0xee, 0x08, 0x8d, 0x9c, 0xac, 0x35, 0x8f, 0x32, 0x7f, 0xe7, 0x21, 0x4b, 0x3e, 0xfa, 0x01, 0x0a,
	0x25, 0x02, 0x4d, 0x1f, 0x8b, 0x22, 0x3f, 0x40, 0x34, 0x22, 0x3e, 0x40, 0x1e, 0xf6, 0x75, 0x72,
	0x17, 0xfa, 0x00, 0xf9, 0xe7, 0xa8, 0x4b, 0xb4, 0x7e, 0xfa, 0x91, 0x77, 0xf6, 0xd1, 0x63, 0xf4,
	0x3c, 0x4e, 0xfc, 0xbb, 0x8e, 0x62, 0x10, 0xac, 0x0b, 0xaa, 0x26, 0x36, 0xaf, 0x2d, 0xd8, 0x77,
	0x49, 0xfb, 0x2e, 0x45, 0x88, 0x73, 0x8f, 0x1e, 0xa3, 0x34, 0xfe, 0xb5, 0x2f, 0x74, 0xf4, 0x72,
	0x41, 0xa9, 0x88, 0xf1, 0x3d, 0xa5, 0x19, 0xb7, 0x67, 0x18, 0x57, 0x1b, 0x62, 0x59, 0xda, 0x93,
	0xc4, 0x4a, 0x5c, 0x50, 0xe3, 0xaa, 0xa4, 0x89, 0xab, 0xb2, 0x52, 0x11, 0x39, 0x7a, 0x1b, 0x97,
	0xd4, 0xb8, 0x91, 0x5a, 0x85, 0x1a, 0x91, 0x34, 0xfe, 0xe8, 0x31, 0x02, 0x1c, 0x6c, 0xe9, 0x88,
	0x21, 0x92, 0xc8, 0x4f, 0xf0, 0xe8, 0x31, 0xf2, 0x63, 0xe6, 0x63, 0x1d, 0x8d, 0x90, 0xaf, 0xfe,
	0x47, 0x8f, 0x91, 0x27, 0x48, 0xe7, 0xb8, 0xf2, 0xe8, 0x31, 0x5a, 0x8c, 0xa6, 0xbe, 0xd0, 0xd1,
	0x7c, 0x7e, 0xe7, 0x60, 0x31, 0x6e, 0xba, 0x39, 0x55, 0xaf, 0x3d, 0x10, 0x1d, 0x53, 0x50, 0xe4,
	0xb8, 0x10, 0xaf, 0x4a, 0x07, 0xa2, 0x1c, 0x97, 0x4d, 0xb1, 0x33, 0x8f, 0x1e, 0x23, 0x1c, 0x65,
	0x5b, 0x3a, 0x1a, 0xa5, 0xcc, 0x66, 0x00, 0xd8, 0x1a, 0xa3, 0x54, 0x23, 0x3f, 0x2e, 0x75, 0xd8,
	0x32, 0x9a, 0x86, 0x29, 0x17, 0xeb, 0x62, 0x16, 0xbc, 0xef, 0x89, 0x47, 0x06, 0xc2, 0xf3, 0xe4,
	0x16, 0x4f, 0x83, 0xef, 0x40, 0xa8, 0xed, 0x8b, 0x06, 0xd0, 0xf2, 0xc6, 0x97, 0x55, 0xcf, 0x0a,
	0x4a, 0xfc, 0x61, 0xd0, 0x70, 0x69, 0xc3, 0x39, 0x77, 0x84, 0xa6, 0x50, 0x17, 0x35, 0xb1, 0x49,
	0xd3, 0x16, 0x3e, 0x82, 0xb1, 0xca, 0x83, 0x72, 0xa3, 0x64, 0x2e, 0xb4, 0x6a, 0xfa, 0xc1, 0xc2,
	0x50, 0x7e, 0xe0, 0x40, 0xfc, 0x4c, 0x82, 0x78, 0x74, 0x3b, 0x4f, 0x59, 0x77, 0x41, 0xe4, 0xc0,
	0xc1, 0x51, 0xa2, 0xca, 0x64, 0x52, 0xf1, 0x06, 0x4c, 0x0b, 0xfb, 0x9a, 0x52, 0x17, 0x34, 0xa9,
	0x5c, 0xda, 0x6b, 0x2a, 0xf5, 0x12, 0x4d, 0x4d, 0x26, 0xcc, 0xbb, 0xa3, 0xcd, 0x08, 0x8f, 0x6d,
	0x9e, 0xdb, 0x4d, 0xa5, 0x5e, 0x24, 0x1c, 0x38, 0x0b, 0xb8, 0x4b, 0x92, 0x28, 0x57, 0x22, 0xcc,
	0x40, 0x39, 0x6c, 0x87, 0x9c, 0x9c, 0x5c, 0xc1, 0x7b, 0x2e, 0x51, 0xe1, 0xa3, 0x32, 0x16, 0x9f,
	0x26, 0x2a, 0x32, 0xcc, 0xb1, 0x91, 0x69, 0xba, 0x96, 0x14, 0xff, 0xc4, 0x03, 0xa3, 0x7b, 0xd2,
	0xfb, 0x62, 0xc5, 0x52, 0xe2, 0xa7, 0x26, 0xcf, 0x0f, 0xa5, 0xc4, 0x6d, 0x11, 0xe7, 0x6f, 0x13,
	0x69, 0x8e, 0xd8, 0xfb, 0x92, 0x1a, 0x1d, 0x3e, 0x40, 0x81, 0x84, 0xaf, 0xe9, 0xfd, 0xb1, 0xb1,
	0x2e, 0xfe, 0x0f, 0x90, 0x97, 0x35, 0x82, 0xd0, 0x35, 0xf4, 0xbe, 0xd0, 0x51, 0xec, 0x4e, 0x7a,
	0xcd, 0x72, 0xcc, 0xb8, 0xb2, 0x47, 0x9d, 0x9a, 0x82, 0x61, 0xb9, 0x26, 0x89, 0xb2, 0x46, 0x88,
	0xcf, 0x3d, 0x7a, 0x8c, 0x26, 0xf1, 0x44, 0x4b, 0x47, 0x61, 0x07, 0xf1, 0xd9, 0xe2, 0xc6, 0xd2,
	0xa0, 0x29, 0xf1, 0xfb, 0x62, 0x5c, 0x50, 0x55, 0xa9, 0x2a, 0x8b, 0x15, 0xf2, 0xd5, 0x45, 0xe1,
	0x90, 0x71, 0x03, 0x7b, 0xb6, 0x0d, 0xf0, 0xeb, 0x30, 0x49, 0x7d, 0xda, 0x08, 0xf4, 0x95, 0x54,
	0x49, 0x13, 0xaa, 0x34, 0x5f, 0x86, 0x32, 0xd3, 0x8e, 0x22, 0xc0, 0x4c, 0x49, 0x91, 0xd7, 0xf9,
	0x09, 0x42, 0xbe, 0x6d, 0x52, 0xef, 0x0a, 0xd5, 0xe8, 0xab, 0x30, 0xd1, 0x65, 0xd3, 0xb3, 0x44,
	0xdc, 0x6a, 0xf5, 0x89, 0x8e, 0xca, 0x90, 0x80, 0xcb, 0xce, 0xe4, 0xa2, 0x72, 0x46, 0x4e, 0xe1,
	0xac, 0xac, 0x41, 0xb2, 0xcd, 0x0c, 0x4c, 0xda, 0x6e, 0x63, 0x3d, 0x1a, 0x46, 0x29, 0xb8, 0x0a,
	0x71, 0x3a, 0x81, 0x78, 0x7e, 0x27, 0x9e, 0xa6, 0x06, 0xaa, 0x8b, 0xb2, 0x66, 0x40, 0xcd, 0x1a,
	0xb5, 0x8d, 0x8a, 0xd1, 0x72, 0x26, 0x09, 0x97, 0x6c, 0xf7, 0xb0, 0xd3, 0xae, 0x24, 0x57, 0x9d,
	0x69, 0xc2, 0x7b, 0xa2, 0x23, 0x0f, 0x49, 0x13, 0x37, 0x48, 0x12, 0x34, 0xeb, 0xc6, 0x1f, 0x22,
	0x88, 0x16, 0x35, 0xe2, 0xfd, 0xf9, 0x46, 0xdb, 0x99, 0x08, 0x04, 0x52, 0x54, 0xb8, 0x06, 0x20,
	0x35, 0xec, 0x34, 0x8e, 0xdc, 0x4a, 0x37, 0x3e, 0x24, 0x35, 0xac, 0x09, 0x73, 0x00, 0x76, 0xd1,
	0x7f, 0xe8, 0x5e, 0x4e, 0x86, 0xac, 0xb2, 0xfe, 0x90, 0x52, 0xb7, 0xab, 0x6b, 0xaf, 0x3b, 0xb5,
	0x5d, 0x4c, 0x7f, 0xcc, 0xc0, 0xe5, 0xde, 0x99, 0xae, 0xd5, 0xf6, 0x49, 0x3a, 0xa0, 0x93, 0xfd,
	0xab, 0xfe, 0xe9, 0x8c, 0x3f, 0x35, 0xa6, 0x06, 0x8a, 0x76, 0x4d, 0x6c, 0x3f, 0x1c, 0x94, 0xd8,
	0xbe, 0x29, 0xa9, 0xec, 0xf5, 0x47, 0x8f, 0xd1, 0x2b, 0xd1, 0xd5, 0x2f, 0x74, 0xb4, 0x6c, 0x58,
	0x80, 0x38, 0x5a, 0xc3, 0xb6, 0x81, 0x4b, 0x4a, 0x13, 0x48, 0x52, 0xeb, 0x4c, 0x69, 0xb1, 0x47,
	0x8f, 0x51, 0x34, 0x1a, 0x69, 0xe9, 0x68, 0xba, 0x2d, 0xa4, 0x6d, 0xc8, 0x9e, 0x5c, 0xf6, 0x5b,
	0xc3, 0xe6, 0xb2, 0x37, 0x9c, 0x91, 0x15, 0x4e, 0xbd, 0xfc, 0x14, 0xab, 0x68, 0xb9, 0xb2, 0x33,
	0x11, 0xfe, 0x1c, 0xc1, 0xc5, 0x5e, 0xca, 0xdb, 0x35, 0x51, 0xd4, 0xa8, 0x23, 0x35, 0x07, 0xec,
	0x3d, 0xd0, 0xd0, 0x7b, 0x8f, 0x69, 0xb7, 0xbd, 0x47, 0xdf, 0xed, 0xc6, 0xff, 0x66, 0xe8, 0xfc,
	0xb9, 0x17, 0x66, 0xcc, 0xe7, 0xdd, 0xe9, 0x4a, 0xfb, 0x65, 0x18, 0x27, 0xab, 0x48, 0x32, 0x2e,
	0xc9, 0x99, 0xe6, 0x26, 0xf0, 0xeb, 0x99, 0x7a, 0x63, 0x84, 0x1f, 0x25, 0x42, 0x2d, 0x0a, 0xdc,
	0x84, 0xc9, 0xb2, 0x11, 0x4c, 0x0e, 0x3d, 0x46, 0x76, 0x7f, 0xed, 0xeb, 0x05, 0xa6, 0x9d, 0x5b,
	0x27, 0x4c, 0x05, 0xb6, 0x4e, 0x15, 0x26, 0xf6, 0xc8, 0x82, 0x3a, 0x34, 0x1a, 0x75, 0xc0, 0x2b,
	0x4f, 0xa1, 0xd1, 0x76, 0x8d, 0x4c, 0xb8, 0x73, 0xf3, 0x38, 0x46, 0x75, 0x58, 0x0c, 0x99, 0xb9,
	0x7e, 0xa5, 0xfe, 0xa4, 0xa3, 0xd4, 0xf7, 0x91, 0x9d, 0xc8, 0xa2, 0x51, 0xa6, 0x27, 0xfe, 0x95,
	0x81, 0x99, 0xac, 0x58, 0x91, 0xca, 0x82, 0x26, 0x56, 0xda, 0x5d, 0x02, 0xb2, 0x34, 0x3c, 0xf8,
	0x2b, 0xe2, 0x81, 0x54, 0x16, 0x4d, 0xdc, 0x5d, 0x6d, 0xe9, 0xe8, 0x45, 0x60, 0x44, 0xed, 0xc1,
	0x02, 0xbd, 0x26, 0xe9, 0xf5, 0x16, 0xf8, 0xc8, 0xfd, 0x02, 0xf8, 0x0e, 0x6b, 0x82, 0x4c, 0x3e,
	0x0e, 0x05, 0x79, 0xc1, 0x72, 0x05, 0x7f, 0x93, 0x61, 0x51, 0xe4, 0x75, 0xde, 0x94, 0x84, 0x17,
	0x20, 0x60, 0x1a, 0xea, 0x94, 0xea, 0xca, 0x22, 0xc3, 0xeb, 0xc0, 0x90, 0xb5, 0xa4, 0xc6, 0x0b,
	0x65, 0x92, 0xad, 0x53, 0xc1, 0xac, 0x4b, 0xf5, 0xc6, 0x08, 0x4f, 0x05, 0xe0, 0x39, 0xf0, 0xd6,
	0xb5, 0x7d, 0xba, 0xe9, 0x1c, 0xcb, 0x44, 0x8e, 0xcd, 0xbc, 0x3b, 0x31, 0x37, 0x96, 0x09, 0x2f,
	0x70, 0x4b, 0xc9, 0xd4, 0xb5, 0xe4, 0xf2, 0x8d, 0x95, 0x45, 0x9e, 0x10, 0xe1, 0x39, 0x08, 0x36,
	0x9a, 0x92, 0xd2, 0x94, 0xb4, 0xa3, 0x48, 0x88, 0x32, 0x8c, 0x5b, 0x0c, 0xbe, 0x39, 0x6f, 0xe4,
	0x17, 0x88, 0xb7, 0xc7, 0xf1, 0x4d, 0x08, 0xcb, 0x8a, 0x56, 0x6a, 0x34, 0xa5, 0xba, 0xd0, 0x3c,
	0xa2, 0x5b, 0xcd, 0xfe, 0xdb, 0x61, 0x90, 0x15, 0x6d, 0xc7, 0xa0, 0xc4, 0x4b, 0x00, 0x92, 0x6a,
	0xf3, 0x8d, 0x0e, 0xe4, 0x0b, 0x49, 0xaa, 0xc9, 0xb6, 0xfa, 0xea, 0x13, 0x1d, 0xdd, 0x82, 0x28,
	0x4c, 0xd9, 0xcb, 0x16, 0xb7, 0xd7, 0x0d, 0x7b, 0x93, 0x5c, 0x0a, 0x2e, 0xc2, 0xf4, 0x9a, 0x52,
	0xaf, 0x2b, 0x72, 0xd7, 0xae, 0xd1, 0xbb, 0xc2, 0xdd, 0xca, 0xc4, 0xc8, 0x74, 0x2b, 0xa2, 0x73,
	0x0f, 0x68, 0x25, 0x66, 0xef, 0x0d, 0x6e, 0x91, 0xec, 0x01, 0xcd, 0x29, 0x39, 0x7d, 0x27, 0x7c,
	0xa2, 0x23, 0xa0, 0x5b, 0xbc, 0x24, 0x97, 0x4c, 0x19, 0xb9, 0xdb, 0xde, 0xe2, 0xf9, 0xd9, 0xc0,
	0x26, 0x13, 0x0c, 0xb0, 0xc1, 0x4d, 0x26, 0x08, 0x6c, 0x38, 0xf1, 0x6f, 0x1e, 0x88, 0xdb, 0x93,
	0xbb, 0x23, 0xc8, 0x42, 0x55, 0x24, 0x45, 0x43, 0xa7, 0x77, 0xdd, 0xec, 0xf2, 0xae, 0x2b, 0xa4,
	0xb0, 0x72, 0x7a, 0xd7, 0xaf, 0xae, 0x0b, 0xf9, 0x86, 0x70, 0xa1, 0xd5, 0x6b, 0x4f, 0x74, 0xf4,
	0x5d, 0x78, 0x91, 0x6c, 0xd1, 0xad, 0x65, 0x6a, 0x9b, 0xc2, 0xb1, 0x62, 0xbe, 0x24, 0x97, 0xe2,
	0x96, 0x4e, 0x5b, 0x16, 0xb3, 0x5a, 0xfa, 0x9b, 0x30, 0x9c, 0xcb, 0x69, 0x0f, 0xc4, 0xa6, 0x2c,
	0x76, 0x99, 0x53, 0xee, 0x32, 0xe7, 0xbd, 0x96, 0x8e, 0xd6, 0x7a, 0x82, 0x35, 0x45, 0xaf, 0x37,
	0xe8, 0x75, 0x91, 0x5e, 0x97, 0xe8, 0x75, 0x99, 0x5e, 0x6f, 0xd2, 0xeb, 0x4a, 0x47, 0x58, 0xff,
	0x0a, 0xae, 0x42, 0x0a, 0x82, 0xfb, 0xb2, 0x26, 0x54, 0xab, 0x62, 0xe5, 0x94, 0xc6, 0x95, 0x4d,
	0x87, 0x5f, 0x84, 0xc0, 0x41, 0x4d, 0x90, 0x4b, 0x52, 0x85, 0xd6, 0xdf, 0x63, 0x99, 0x51, 0x22,
	0x39, 0x30, 0xe7, 0x8b, 0xfc, 0xe2, 0xca, 0x2c, 0xda, 0x40, 0xbc, 0x9f, 0x0c, 0xe7, 0x2b, 0x24,
	0x9a, 0x69, 0xc9, 0x6e, 0xd4, 0xfd, 0x34, 0xf8, 0xfb, 0x37, 0x9c, 0x80, 0x90, 0x1a, 0x55, 0x30,
	0xbe, 0x6f, 0x32, 0x9a, 0x29, 0xd1, 0xe8, 0x54, 0xdd, 0x7a, 0xea, 0xad, 0x54, 0x86, 0x21, 0x68,
	0x6d, 0xe9, 0x30, 0xdb, 0x39, 0xef, 0x40, 0xa8, 0x9d, 0x4d, 0x0c, 0xa0, 0xb9, 0x39, 0x6c, 0x36,
	0xd9, 0xe9, 0x96, 0x7f, 0x6c, 0xc8, 0x0f, 0xaa, 0x56, 0xc6, 0xca, 0x02, 0x26, 0xe5, 0x5c, 0x89,
	0x54, 0x04, 0x35, 0x6b, 0x1f, 0x1e, 0x19, 0x1b, 0x60, 0x01, 0x2f, 0xcf, 0x12, 0x8e, 0x2d, 0xc2,
	0x60, 0x75, 0xae, 0xde, 0x80, 0x0b, 0x0e, 0x29, 0x92, 0xac, 0x4a, 0x15, 0xd1, 0x16, 0x36, 0x3e,
	0x50, 0xd8, 0x8c, 0x2d, 0x2c, 0x4f, 0xd9, 0x2c, 0x91, 0x7b, 0x30, 0xde, 0x25, 0x67, 0x62, 0xe8,
	0x22, 0xe8, 0xc2, 0x87, 0x0f, 0x27, 0x0e, 0xa4, 0xa6, 0xb6, 0xdf, 0x7e, 0x24, 0xb3, 0x6f, 0xbc,
	0xe1, 0xe5, 0xc7, 0xa4, 0x0e, 0x3d, 0x66, 0x78, 0xb3, 0x67, 0xcd, 0x10, 0x93, 0x67, 0xcb, 0x10,
	0x53, 0x03, 0x8c, 0xc0, 0x0c, 0xc8, 0x10, 0xd3, 0x03, 0xf9, 0xda, 0x19, 0x02, 0xe7, 0x60, 0x42,
	0xd5, 0x94, 0xa6, 0x50, 0x6d, 0x1b, 0xec, 0x5c, 0x7f, 0x5e, 0xd3, 0x13, 0xbc, 0xfc, 0xb8, 0xc9,
	0x64, 0x9a, 0x63, 0xb5, 0xf1, 0x44, 0x47, 0x35, 0xb8, 0x0c, 0xd8, 0x42, 0x1c, 0x07, 0x6a, 0x05,
	0x92, 0x5c, 0x3c, 0xc5, 0xc5, 0x97, 0xe0, 0x1c, 0xb0, 0xf9, 0x9d, 0xae, 0x3c, 0x83, 0x56, 0xe0,
	0x1c, 0x4c, 0xdc, 0x33, 0xac, 0x6e, 0xb7, 0x34, 0x3d, 0xc9, 0x14, 0x5c, 0xee, 0x93, 0x99, 0x7c,
	0xc9, 0x65, 0x2e, 0x79, 0xf3, 0xd4, 0xdc, 0x14, 0x83, 0x30, 0x8d, 0x62, 0xc7, 0xb8, 0xd5, 0x9c,
	0xf4, 0x2e, 0x73, 0x37, 0x33, 0x57, 0x61, 0xdc, 0x2a, 0x78, 0x4d, 0x92, 0xa9, 0x63, 0x1d, 0x85,
	0x4e, 0x74, 0x44, 0x76, 0x23, 0x01, 0xb3, 0xe1, 0x9a, 0xf9, 0x6e, 0xfb, 0x4c, 0xc0, 0x24, 0x3b,
	0x7f, 0xac, 0xa3, 0xb1, 0x13, 0x1d, 0x8d, 0xb6, 0x74, 0x14, 0x4e, 0xde, 0xe0, 0x92, 0x8b, 0x5c,
	0x2a, 0xc9, 0x25, 0x97, 0xfa, 0x64, 0xc3, 0xa9, 0x13, 0x1d, 0x61, 0x9a, 0x0d, 0x6f, 0x71, 0xa9,
	0x85, 0xae, 0x6c, 0x18, 0x64, 0x43, 0x9b, 0x4c, 0x70, 0x94, 0x1d, 0xdb, 0x64, 0x82, 0x98, 0x9d,
	0x4a, 0x7c, 0xe4, 0x87, 0x29, 0xe3, 0xd4, 0xa5, 0x13, 0xb1, 0x97, 0xdb, 0x08, 0xea, 0x19, 0xb4,
	0x3a, 0x66, 0xa5, 0x67, 0xe3, 0xe8, 0x9a, 0x89, 0xa3, 0x46, 0xd1, 0x7d, 0xed, 0x74, 0x1c, 0x75,
	0xc3, 0xd0, 0x9c, 0x7d, 0xfe, 0xc3, 0x0c, 0x1d, 0x4a, 0x21, 0xfb, 0x14, 0xc8, 0x3a, 0xfb, 0xc1,
	0xbb, 0x4e, 0x40, 0xf2, 0x7d, 0x2d, 0x40, 0x3a, 0x15, 0x88, 0x06, 0x9f, 0x33, 0x9c, 0x11, 0x88,
	0x82, 0x03, 0x85, 0x0d, 0x0f, 0x44, 0xa1, 0x67, 0x01, 0x44, 0xa8, 0x0f, 0x10, 0xc1, 0x59, 0x81,
	0x28, 0x3c, 0x18, 0x88, 0x56, 0xdf, 0x7d, 0xa2, 0xa3, 0x3d, 0x88, 0x00, 0x6b, 0xf8, 0xa3, 0x23,
	0x9e, 0x99, 0x24, 0x17, 0x5f, 0x74, 0x0f, 0xe6, 0x25, 0x98, 0xee, 0x0d, 0x66, 0xb4, 0x3c, 0x20,
	0x96, 0x69, 0x90, 0xf5, 0x89, 0x65, 0xe7, 0x59, 0x43, 0x57, 0x10, 0x92, 0xc8, 0x0a, 0x9c, 0xe8,
	0xc8, 0x4f, 0x22, 0x8b, 0x1e, 0x90, 0xd8, 0x47, 0x09, 0x7e, 0x36, 0x90, 0xf8, 0xe7, 0x10, 0x4c,
	0x6d, 0x89, 0x55, 0xa1, 0x7c, 0xd4, 0x19, 0x47, 0x6f, 0x01, 0xa3, 0x1d, 0x35, 0xac, 0x43, 0xd7,
	0xa5, 0x33, 0x1f, 0xba, 0xd2, 0xd5, 0x19, 0x23, 0xf6, 0x0a, 0xfe, 0x2e, 0xf2, 0x45, 0xbd, 0x23,
	0xc8, 0xcb, 0x53, 0x89, 0xd6, 0x32, 0x78, 0x87, 0x59, 0x86, 0x32, 0x74, 0xaf, 0xae, 0x79, 0x6e,
	0x37, 0xf8, 0x64, 0xf5, 0x52, 0xaf, 0x57, 0x38, 0x8e, 0x58, 0xc7, 0xcd, 0x21, 0xcb, 0xea, 0x6f,
	0x01, 0x6d, 0x5c, 0xdb, 0xfd, 0x30, 0xdf, 0x53, 0x3e, 0x32, 0x29, 0x3a, 0x78, 0x5a, 0xae, 0x58,
	0x8d, 0xb3, 0x0d, 0x60, 0xcd, 0x40, 0x36, 0x65, 0x8b, 0xaa, 0xd9, 0x0d, 0xbe, 0xec, 0x72, 0xdc,
	0x5c, 0xdc, 0xbf, 0x2f, 0x1b, 0xfb, 0x51, 0x7e, 0xc2, 0x60, 0x4b, 0x5b, 0x5c, 0xf8, 0xfb, 0x30,
	0xd1, 0x75, 0xee, 0x6e, 0x46, 0xee, 0x53, 0x4c, 0xf3, 0xf6, 0xfa, 0x9b, 0xfc, 0x78, 0xe7, 0x31,
	0x3c, 0x2e, 0x02, 0x64, 0x0b, 0x45, 0xab, 0xcc, 0x0a, 0x0e, 0xd9, 0x16, 0x77, 0x39, 0x69, 0xe7,
	0x43, 0xd9, 0x42, 0xd1, 0x2e, 0xac, 0xc2, 0xc4, 0x26, 0x96, 0xd4, 0x10, 0xb5, 0xeb, 0xcb, 0x4f,
	0x65, 0x57, 0x43, 0x22, 0x0f, 0xed, 0x7b, 0x5c, 0x82, 0x51, 0x9a, 0xb6, 0x48, 0x2d, 0x2a, 0xc9,
	0x55, 0x1a, 0xd7, 0x4f, 0xf3, 0xca, 0xc3, 0xbd, 0xad, 0x74, 0x61, 0xd7, 0x90, 0xc1, 0xd3, 0x44,
	0x68, 0x7e, 0xc1, 0x57, 0x20, 0x6c, 0x94, 0xe5, 0x25, 0x59, 0xa8, 0x8b, 0xc6, 0x69, 0x27, 0x0f,
	0xc6, 0x4f, 0x05, 0xa1, 0x2e, 0xe2, 0xab, 0x10, 0xb4, 0x66, 0x40, 0x0b, 0xba, 0xb1, 0x0c, 0x58,
	0x00, 0xf1, 0xdf, 0x57, 0xf8, 0x80, 0x29, 0x0b, 0x6f, 0xdb, 0x59, 0x61, 0x7c, 0x48, 0x2c, 0x77,
	0x7f, 0xbd, 0xc0, 0xce, 0x0f, 0x4e, 0x70, 0x9a, 0x38, 0xa5, 0x4a, 0x92, 0xa0, 0xb7, 0x5b, 0x15,
	0x61, 0x87, 0x88, 0xa1, 0x98, 0x5b, 0x9f, 0xcb, 0x11, 0x45, 0xac, 0x39, 0x68, 0xf7, 0xba, 0x56,
	0x7f, 0xf3, 0x89, 0x8e, 0x0e, 0x20, 0x06, 0xac, 0x81, 0x27, 0x0e, 0x1c, 0x84, 0x24, 0x47, 0x76,
	0xb8, 0x0b, 0x5c, 0x72, 0x11, 0xe2, 0x2e, 0x68, 0x38, 0xea, 0x38, 0xbc, 0x5d, 0x76, 0x05, 0xc6,
	0x45, 0xb8, 0xd4, 0x07, 0x18, 0x99, 0x1b, 0x5c, 0x72, 0x29, 0xf1, 0x64, 0x12, 0xc6, 0xd7, 0x6b,
	0xca, 0x7d, 0xa1, 0x56, 0x6c, 0x88, 0x65, 0x8a, 0x60, 0xf9, 0x67, 0x80, 0x60, 0x26, 0x64, 0xbd,
	0xe0, 0x84, 0xac, 0xe9, 0xff, 0xb3, 0x70, 0xf5, 0xfd, 0xa7, 0x84, 0xab, 0x3e, 0xaf, 0x45, 0x7c,
	0x0b, 0x62, 0xdf, 0x04, 0x10, 0x7b, 0x08, 0x91, 0x86, 0xd0, 0x14, 0x65, 0xad, 0xd4, 0xa3, 0x25,
	0x32, 0x3a, 0x84, 0xf3, 0x5e, 0xfd, 0xf0, 0xe1, 0x64, 0x0f, 0xa7, 0x59, 0x83, 0x39, 0xbc, 0x78,
	0xc6, 0x50, 0xd2, 0x3d, 0xef, 0x5f, 0x1a, 0x86, 0xbe, 0xd0, 0x83, 0xa1, 0xf0, 0x4b, 0xc6, 0x4f,
	0x5c, 0x05, 0xec, 0xe8, 0x75, 0x94, 0xe8, 0x71, 0x8d, 0x1a, 0xb9, 0xf4, 0x35, 0x5b, 0x1e, 0x3c,
	0xdb, 0x6e, 0x75, 0xd0, 0x11, 0x15, 0xbf, 0xe3, 0x28, 0x12, 0x29, 0x96, 0x46, 0x2e, 0x0f, 0x89,
	0x21, 0xb6, 0x35, 0x1d, 0xaf, 0x06, 0xd8, 0xaf, 0x78, 0x19, 0xb8, 0x8c, 0xff, 0x09, 0xb9, 0x9c,
	0xd7, 0xc5, 0xa8, 0xc5, 0xd6, 0x4e, 0x55, 0xd0, 0x89, 0xe1, 0xae, 0x07, 0x74, 0xfc, 0x99, 0x5e,
	0x3c, 0xe9, 0x7f, 0x46, 0x36, 0xe0, 0xb5, 0x0c, 0x7c, 0xb9, 0xa3, 0x45, 0x70, 0x25, 0x8e, 0x66,
	0x83, 0xce, 0x56, 0xc0, 0x1b, 0x30, 0x55, 0xb1, 0xfa, 0x8f, 0x8e, 0x70, 0xf9, 0x7c, 0xc0, 0x66,
	0xca, 0x7e, 0xb1, 0x6e, 0x63, 0x84, 0xc7, 0x95, 0x9e, 0xa3, 0x01, 0xbc, 0x0d, 0x58, 0x34, 0x1b,
	0x02, 0x0e, 0x89, 0x5f, 0x0c, 0x29, 0x71, 0x52, 0xec, 0x6e, 0x5f, 0xe2, 0xef, 0x01, 0x6b, 0xb8,
	0xba, 0x43, 0xdc, 0x7f, 0x0c, 0x29, 0x6e, 0x42, 0xeb, 0xdc, 0x59, 0xe3, 0x15, 0xf0, 0xd7, 0x68,
	0x52, 0x8f, 0xfc, 0xe7, 0x90, 0x22, 0x4c, 0x7a, 0xbc, 0x07, 0xb1, 0xb6, 0xa9, 0xea, 0x76, 0xab,
	0xd6, 0x31, 0xa9, 0x9f, 0x0f, 0x29, 0xf1, 0x52, 0x65, 0x40, 0xf3, 0xfb, 0x19, 0xbc, 0x48, 0x93,
	0x59, 0x72, 0xfa, 0xad, 0xb9, 0x7b, 0x7a, 0xee, 0x58, 0x47, 0x9f, 0x93, 0xed, 0xd3, 0x67, 0x81,
	0x96, 0x8e, 0xa6, 0x92, 0x0b, 0x0b, 0xa4, 0x8e, 0x59, 0x48, 0x91, 0xcb, 0x0d, 0x72, 0x59, 0xdc,
	0x64, 0x82, 0x93, 0x2c, 0x36, 0xba, 0x12, 0x9b, 0x4c, 0x70, 0x8a, 0x9d, 0xde, 0x64, 0x82, 0xd3,
	0xec, 0xb9, 0x4d, 0x26, 0x78, 0x8e, 0x9d, 0xd9, 0x64, 0x82, 0x33, 0xec, 0xf9, 0x4d, 0x26, 0x78,
	0x9e, 0x8d, 0x6c, 0x32, 0xc1, 0x08, 0x7b, 0x61, 0x93, 0x09, 0x5e, 0x60, 0xa3, 0x9b, 0x4c, 0x30,
	0xca, 0x5e, 0xdc, 0x64, 0x82, 0x17, 0xd9, 0x4b, 0x9b, 0xfe, 0xe0, 0x67, 0x01, 0xf6, 0xf3, 0x40,
	0xe2, 0x1f, 0x7d, 0x30, 0xbe, 0xd6, 0x14, 0x05, 0x4d, 0xb4, 0x8b, 0x98, 0x77, 0xdd, 0x3d, 0x0d,
	0x0f, 0x09, 0x82, 0xee, 0x67, 0x50, 0x7d, 0x5c, 0xb0, 0xee, 0xea, 0x82, 0x46, 0x5f, 0x6d, 0xf9,
	0x54, 0x55, 0xae, 0x0d, 0x74, 0xb3, 0xdf, 0xea, 0xea, 0xa0, 0xef, 0xb9, 0x38, 0xe8, 0xf4, 0x90,
	0x39, 0xdb, 0xa5, 0xf3, 0x93, 0x09, 0x92, 0x1a, 0xf8, 0xa4, 0x8f, 0x03, 0xbf, 0x07, 0xac, 0xe1,
	0x90, 0x0e, 0x65, 0xe7, 0x86, 0x54, 0xe6, 0xb2, 0x3d, 0xee, 0x54, 0x56, 0xeb, 0x24, 0xc0, 0x7f,
	0x8c, 0x4e, 0x75, 0xfa, 0x19, 0xaa, 0x3b, 0x3d, 0xfc, 0x02, 0xf6, 0x39, 0xf0, 0xe9, 0x98, 0xc8,
	0xc0, 0x08, 0x59, 0x7d, 0xe9, 0x5f, 0x5e, 0xeb, 0x2a, 0x91, 0x9f, 0xe8, 0x68, 0x06, 0xa6, 0x61,
	0xbc, 0xfd, 0x8a, 0x0a, 0xf5, 0x39, 0x4f, 0xf2, 0x66, 0x66, 0xde, 0x25, 0x16, 0xa2, 0x66, 0x8f,
	0x6e, 0xb2, 0xa5, 0xa3, 0xf1, 0xe4, 0x2d, 0x2e, 0xb9, 0xc2, 0xa5, 0x16, 0xb8, 0x54, 0x8a, 0x4b,
	0x25, 0x8d, 0x20, 0x48, 0xfc, 0xbd, 0x0f, 0x26, 0x78, 0xb1, 0x51, 0x13, 0xca, 0xff, 0x2f, 0x3c,
	0xb8, 0xfa, 0x8c, 0x3d, 0x98, 0xe9, 0xe7, 0xbd, 0xd5, 0x67, 0xec, 0xbd, 0xcc, 0xb7, 0x9e, 0xdb,
	0xe5, 0xb9, 0x7f, 0xeb, 0x83, 0xf0, 0xba, 0xa8, 0x7d, 0xeb, 0xb5, 0xdf, 0x7a, 0xed, 0x37, 0xc8,
	0x6b, 0xdf, 0xed, 0xfd, 0x27, 0x4a, 0x51, 0x13, 0xb4, 0x7d, 0x15, 0xef, 0x40, 0x60, 0xbf, 0x51,
	0xaa, 0x28, 0x87, 0xb2, 0xd9, 0xff, 0x38, 0xfb, 0x86, 0xe9, 0x6e, 0x23, 0xab, 0x1c, 0xca, 0xbc,
	0x7f, 0x9f, 0x7e, 0xce, 0x29, 0xc6, 0xcb, 0xe6, 0x5d, 0xef, 0xe4, 0xe3, 0x59, 0x78, 0x3e, 0x5f,
	0x58, 0xdb, 0xba, 0x9b, 0xcd, 0x95, 0xf2, 0x3b, 0xa5, 0x74, 0x36, 0xcb, 0xe7, 0x8a, 0xc5, 0x5c,
	0xb1, 0x74, 0x9b, 0xdf, 0xbe, 0x53, 0xa2, 0x1b, 0xe7, 0x9d, 0xed, 0xed, 0xad, 0x22, 0x3b, 0x42,
	0x28, 0x73, 0x6f, 0x0d, 0x41, 0x89, 0xa2, 0xcc, 0xb1, 0x8e, 0x46, 0xe6, 0x3e, 0x42, 0x30, 0xed,
	0xb6, 0xdf, 0xc0, 0xcf, 0xc1, 0xe5, 0x42, 0x6e, 0xf7, 0xcd, 0x6d, 0xfe, 0x7b, 0xa5, 0x7c, 0x61,
	0x37, 0xc7, 0xdf, 0x4e, 0xaf, 0xe5, 0x4a, 0xd6, 0x2f, 0x7c, 0xee, 0x36, 0x3b, 0x82, 0xe3, 0x70,
	0xa9, 0x97, 0xa4, 0x98, 0xdf, 0xcd, 0x95, 0xb6, 0xb6, 0xd7, 0xd2, 0x5b, 0x2c, 0xc2, 0x2f, 0xc2,
	0x77, 0x06, 0x51, 0x94, 0xf2, 0x85, 0x62, 0x3e, 0x9b, 0x63, 0x3d, 0xf8, 0x32, 0x5c, 0x70, 0x21,
	0xdc, 0xdd, 0xe6, 0xd3, 0xeb, 0x39, 0xd6, 0xeb, 0xae, 0xe9, 0x4e, 0xba, 0x90, 0x5e, 0xcf, 0xdd,
	0xc9, 0x15, 0x76, 0x59, 0x66, 0xee, 0x43, 0x97, 0xff, 0x6e, 0xd1, 0xe7, 0x88, 0x41, 0xb4, 0x97,
	0x35, 0xb7, 0xbb, 0x91, 0xe3, 0x0b, 0xb9, 0x5d, 0x76, 0x04, 0x3f, 0x0f, 0xf1, 0xde, 0x71, 0xb2,
	0xd1, 0x6f, 0x7f, 0x65, 0x91, 0x3b, 0xd5, 0x56, 0x7a, 0x6d, 0xc7, 0x41, 0xe5, 0xc1, 0x2f, 0x40,
	0xa2, 0x97, 0x6a, 0xf7, 0x6e, 0xa1, 0x90, 0xdb, 0x72, 0xd0, 0x79, 0xe7, 0x7e, 0xc3, 0xe5, 0x7f,
	0x66, 0x1b, 0x6b, 0x3b, 0x38, 0x01, 0xb1, 0x5e, 0x7e, 0xba, 0x68, 0xd9, 0x7c, 0x31, 0x9d, 0xd9,
	0xca, 0xb1, 0x23, 0xee, 0xeb, 0x42, 0x69, 0x72, 0x05, 0x4a, 0x82, 0xe6, 0x34, 0xb8, 0x38, 0xa0,
	0x73, 0x81, 0xe7, 0xe0, 0x85, 0x3e, 0x4f, 0xbc, 0x9b, 0x5e, 0x5f, 0xcf, 0x17, 0xd6, 0x1d, 0xda,
	0xbe, 0x0b, 0x57, 0x4f, 0xa1, 0xb5, 0xb5, 0xfe, 0x05, 0xea, 0x55, 0xeb, 0xfc, 0x53, 0xdb, 0x55,
	0x78, 0xae, 0x57, 0xd4, 0x7a, 0x7a, 0x37, 0xf7, 0x66, 0xfa, 0x6d, 0x87, 0xc6, 0x97, 0xe0, 0xc5,
	0xfe, 0x64, 0xe9, 0xbb, 0xbb, 0xdb, 0xa5, 0xf4, 0x16, 0x71, 0x9e, 0x5d, 0xb2, 0x2c, 0x1c, 0xcc,
	0xf6, 0x27, 0xbe, 0x5b, 0xcc, 0x95, 0xd6, 0xb6, 0x0b, 0xb7, 0xf3, 0xeb, 0x77, 0xf9, 0x5c, 0x96,
	0xf5, 0xcc, 0xfd, 0x3e, 0x82, 0xf3, 0x7d, 0xfe, 0xb6, 0xd6, 0xc7, 0xac, 0x85, 0xa2, 0x63, 0x66,
	0xae, 0xce, 0x4c, 0x48, 0xba, 0x67, 0x35, 0x0b, 0xcf, 0xbb, 0x13, 0xf6, 0xcc, 0xe8, 0x2f, 0x11,
	0x44, 0xfb, 0xf7, 0xb0, 0xdc, 0xad, 0x4f, 0xd7, 0xba, 0x98, 0xe3, 0xef, 0xe5, 0x78, 0xc7, 0xe4,
	0xdc, 0x75, 0x3a, 0x48, 0xad, 0x75, 0xc2, 0x49, 0xb8, 0xe6, 0x12, 0x10, 0x85, 0x8d, 0x74, 0x61,
	0x2d, 0x97, 0x75, 0x63, 0xf1, 0xcc, 0xfd, 0x09, 0xea, 0x85, 0x40, 0x03, 0xb8, 0xdc, 0x97, 0x2b,
	0x9d, 0xbd, 0x93, 0x2f, 0xe4, 0x8b, 0xbb, 0x7c, 0x7a, 0x37, 0x7f, 0x2f, 0xb7, 0xf5, 0x76, 0x29,
	0xbb, 0xfd, 0x66, 0xa1, 0x9f, 0x05, 0xb7, 0x77, 0x72, 0x84, 0x6e, 0xbb, 0x90, 0xb6, 0x08, 0x91,
	0xbb, 0xaf, 0x74, 0x10, 0xde, 0xdd, 0x61, 0x3d, 0x99, 0x3f, 0x43, 0x27, 0x9f, 0xc6, 0x46, 0x3e,
	0xf9, 0x34, 0x36, 0xf2, 0xe5, 0xa7, 0x31, 0xf4, 0xd5, 0xa7, 0x31, 0xf4, 0x83, 0x56, 0x0c, 0xfd,
	0x75, 0x2b, 0x86, 0x7e, 0xdc, 0x8a, 0xa1, 0xe3, 0x56, 0x0c, 0x7d, 0xdc, 0x8a, 0xa1, 0x93, 0x56,
	0x0c, 0x7d, 0xd2, 0x8a, 0xa1, 0x9f, 0xb6, 0x62, 0xe8, 0xb3, 0x56, 0x6c, 0xe4, 0xcb, 0x56, 0x0c,
	0xfd, 0xc1, 0xcf, 0x62, 0x23, 0xc7, 0x3f, 0x8b, 0xa1, 0x5f, 0xbf, 0x5b, 0x55, 0x1a, 0xef, 0x55,
	0xe7, 0x0f, 0x94, 0x9a, 0x26, 0x36, 0x9b, 0xc2, 0xfc, 0xbe, 0x7a, 0x9d, 0xde, 0xec, 0x29, 0xcd,
	0xfa, 0xb5, 0x46, 0x53, 0x39, 0x90, 0x2a, 0x62, 0xf3, 0x9a, 0x35, 0x7c, 0xbd, 0x71, 0xbf, 0xaa,
	0x5c, 0x17, 0xdf, 0xd7, 0xcc, 0xff, 0x90, 0xf6, 0xfb, 0x63, 0xee, 0x7d, 0x3f, 0xfd, 0x47, 0xe9,
	0x8d, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xe7, 0xd2, 0xcf, 0xd4, 0xc2, 0x3b, 0x00, 0x00,
}
